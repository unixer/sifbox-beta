diff -urN media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/common/saa716x/saa716x_budget.c media-experimental-media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/common/saa716x/saa716x_budget.c
--- media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/common/saa716x/saa716x_budget.c	2012-02-27 10:48:36.168908938 +0100
+++ media-experimental-media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/common/saa716x/saa716x_budget.c	2012-02-27 00:02:09.968915022 +0100
@@ -114,9 +114,9 @@
 	}
 
 	/* set default port mapping */
-	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x04080FA9);
-	/* enable FGPI3 and FGPI1 for TS input from Port 2 and 6 */
-	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x321);
+	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x2C688F44);
+	/* enable FGPI3 and FGPI0 for TS input from Port 3 and 6 */
+	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x894);
 
 	err = saa716x_dvb_init(saa716x);
 	if (err) {
@@ -450,7 +450,7 @@
 	.demod_mode		= STV090x_SINGLE,
 	.clk_mode		= STV090x_CLK_EXT,
 
-	.xtal			= 8000000,
+	.xtal			= 13500000,
 	.address		= 0x68,
 
 	.ts1_mode		= STV090x_TSMODE_DVBCI,
@@ -458,10 +458,6 @@
 
 	.repeater_level		= STV090x_RPTLEVEL_16,
 
-	.gpio_voltage_enable	= 2,
-	.gpio_voltage_select	= 3,
-	.gpio_voltage_boost	= 4,
-
 	.tuner_init		= NULL,
 	.tuner_sleep		= NULL,
 	.tuner_set_mode		= NULL,
@@ -477,7 +473,7 @@
 
 static struct stv6110x_config skystar2_stv6110x_config = {
 	.addr			= 0x60,
-	.refclk			= 16000000,
+	.refclk			= 27000000,
 	.clk_div		= 2,
 };
 
@@ -485,7 +481,7 @@
 					       int count)
 {
 	struct saa716x_dev *saa716x = adapter->saa716x;
-	struct saa716x_i2c *i2c = &saa716x->i2c[SAA716x_I2C_BUS_B];
+	struct saa716x_i2c *i2c = &saa716x->i2c[SAA716x_I2C_BUS_A];
 	struct stv6110x_devctl *ctl;
 
 	if (count < saa716x->config->adapters) {
@@ -494,14 +490,14 @@
 		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count,
 			saa716x->pdev->subsystem_device);
 
-		saa716x_gpio_set_output(saa716x, 26);
+		saa716x_gpio_set_output(saa716x, 20);
 
 		/* Reset the demodulator */
-		saa716x_gpio_write(saa716x, 26, 1);
+		saa716x_gpio_write(saa716x, 20, 1);
 		msleep(10);
-		saa716x_gpio_write(saa716x, 26, 0);
+		saa716x_gpio_write(saa716x, 20, 0);
 		msleep(10);
-		saa716x_gpio_write(saa716x, 26, 1);
+		saa716x_gpio_write(saa716x, 20, 1);
 		msleep(10);
 
 		adapter->fe = dvb_attach(stv090x_attach,
@@ -565,7 +561,7 @@
 	.adap_config		= {
 		{
 			/* Adapter 0 */
-			.ts_port = 1, /* using FGPI 1 */
+			.ts_port = 3, /* using FGPI 3, TODO: check */
 			.worker = demux_worker
 		}
 	}
diff -urN media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.c media-experimental-media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.c
--- media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.c	2012-02-27 10:48:36.338908938 +0100
+++ media-experimental-media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.c	2012-02-27 00:02:11.468915022 +0100
@@ -5086,7 +5086,7 @@
 	return -1;
 }
 
-static int stv0900_set_tspath(struct stv090x_state *state)
+static int stv090x_set_tspath(struct stv090x_state *state)
 {
 	u32 reg;
 
@@ -5349,122 +5349,6 @@
 	return -1;
 }
 
-static int stv0903_set_tspath(struct stv090x_state *state)
-{
-	u32 reg;
-
-	if (state->internal->dev_ver >= 0x20) {
-		switch (state->config->ts1_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-			stv090x_write_reg(state, STV090x_TSGENERAL, 0x00);
-			break;
-
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		default:
-			if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0c) < 0)
-				goto err;
-			break;
-		}
-	} else {
-		switch (state->config->ts1_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-			stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x10);
-			break;
-
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		default:
-			stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x14);
-			break;
-		}
-	}
-
-	switch (state->config->ts1_mode) {
-	case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_DVBCI:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_SERIAL_PUNCTURED:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	default:
-		break;
-	}
-
-	if (state->config->ts1_clk > 0) {
-		u32 speed;
-
-		switch (state->config->ts1_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-		default:
-			speed = state->internal->mclk /
-				(state->config->ts1_clk / 4);
-			if (speed < 0x08)
-				speed = 0x08;
-			if (speed > 0xFF)
-				speed = 0xFF;
-			break;
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			speed = state->internal->mclk /
-				(state->config->ts1_clk / 32);
-			if (speed < 0x20)
-				speed = 0x20;
-			if (speed > 0xFF)
-				speed = 0xFF;
-			break;
-		}
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
-		STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
-			goto err;
-		if (stv090x_write_reg(state, STV090x_P1_TSSPEED, speed) < 0)
-			goto err;
-	}
-
-	reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x01);
-	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-		goto err;
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x00);
-	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
 static int stv090x_init(struct dvb_frontend *fe)
 {
 	struct stv090x_state *state = fe->demodulator_priv;
@@ -5527,13 +5411,8 @@
 	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
 		goto err;
 
-	if (state->device == STV0900) {
-		if (stv0900_set_tspath(state) < 0)
-			goto err;
-	} else {
-		if (stv0903_set_tspath(state) < 0)
-			goto err;
-	}
+	if (stv090x_set_tspath(state) < 0)
+		goto err;
 
 	return 0;
 
@@ -5574,26 +5453,23 @@
 	/* Stop Demod */
 	if (stv090x_write_reg(state, STV090x_P1_DMDISTATE, 0x5c) < 0)
 		goto err;
-	if (state->device == STV0900)
-		if (stv090x_write_reg(state, STV090x_P2_DMDISTATE, 0x5c) < 0)
-			goto err;
+	if (stv090x_write_reg(state, STV090x_P2_DMDISTATE, 0x5c) < 0)
+		goto err;
 
 	msleep(5);
 
 	/* Set No Tuner Mode */
 	if (stv090x_write_reg(state, STV090x_P1_TNRCFG, 0x6c) < 0)
 		goto err;
-	if (state->device == STV0900)
-		if (stv090x_write_reg(state, STV090x_P2_TNRCFG, 0x6c) < 0)
-			goto err;
+	if (stv090x_write_reg(state, STV090x_P2_TNRCFG, 0x6c) < 0)
+		goto err;
 
 	/* I2C repeater OFF */
 	STV090x_SETFIELD_Px(reg, ENARPT_LEVEL_FIELD, config->repeater_level);
 	if (stv090x_write_reg(state, STV090x_P1_I2CRPT, reg) < 0)
 		goto err;
-	if (state->device == STV0900)
-		if (stv090x_write_reg(state, STV090x_P2_I2CRPT, reg) < 0)
-			goto err;
+	if (stv090x_write_reg(state, STV090x_P2_I2CRPT, reg) < 0)
+		goto err;
 
 	if (stv090x_write_reg(state, STV090x_NCOARSE, 0x13) < 0) /* set PLL divider */
 		goto err;
@@ -5659,100 +5535,6 @@
 	return -1;
 }
 
-static int stv090x_set_voltage(struct dvb_frontend *fe,
-			       enum fe_sec_voltage voltage)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	const struct stv090x_config *config = state->config;
-	u16 reg;
-	u8 en = 0;
-	u8 sel = 0;
-
-	switch (voltage) {
-	case SEC_VOLTAGE_OFF:
-		/* EN = 0 */
-		en = 0x00;
-		break;
-
-	case SEC_VOLTAGE_13:
-		/* EN = 1, SEL = 0 */
-		en = 0x02;
-		sel = 0x00;
-		break;
-
-	case SEC_VOLTAGE_18:
-		/* EN = 1, SEL = 1 */
-		en = 0x02;
-		sel = 0x02;
-		break;
-
-	default:
-		break;
-	}
-
-	if (config->gpio_voltage_enable) {
-
-		if (config->gpio_voltage_enable > 0)
-			reg = STV090x_GPIOxCFG(config->gpio_voltage_enable);
-		else {
-			reg = STV090x_GPIOxCFG(-config->gpio_voltage_enable);
-			en |= 0x01;
-		}
-
-		if (stv090x_write_reg(state, reg, en) < 0)
-			goto err;
-	}
-
-	if (config->gpio_voltage_select) {
-
-		if (config->gpio_voltage_select > 0)
-			reg = STV090x_GPIOxCFG(config->gpio_voltage_select);
-		else {
-			reg = STV090x_GPIOxCFG(-config->gpio_voltage_select);
-			sel |= 0x01;
-		}
-
-		if (stv090x_write_reg(state, reg, sel) < 0)
-			goto err;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_voltage_boost(struct dvb_frontend *fe, long arg)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	const struct stv090x_config *config = state->config;
-	u16 reg;
-	u8 value;
-
-	if (config->gpio_voltage_boost) {
-
-		if (arg)
-			value = 0x02;
-		else
-			value = 0x00;
-
-		if (config->gpio_voltage_boost > 0)
-			reg = STV090x_GPIOxCFG(config->gpio_voltage_boost);
-		else {
-			reg = STV090x_GPIOxCFG(-config->gpio_voltage_boost);
-			value |= 0x01;
-		}
-
-		if (stv090x_write_reg(state, reg, value) < 0)
-			goto err;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
 static struct dvb_frontend_ops stv090x_ops = {
 
 	.info = {
@@ -5780,8 +5562,6 @@
 	.diseqc_send_burst		= stv090x_send_diseqc_burst,
 	.diseqc_recv_slave_reply	= stv090x_recv_slave_reply,
 	.set_tone			= stv090x_set_tone,
-	.set_voltage			= stv090x_set_voltage,
-	.enable_high_lnb_voltage	= stv090x_voltage_boost,
 
 	.search				= stv090x_search,
 	.read_status			= stv090x_read_status,
diff -urN media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.h media-experimental-media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.h
--- media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.h	2012-02-27 10:48:36.338908938 +0100
+++ media-experimental-media_build_experimental//experimental/v4l-dvb-saa716x/linux/drivers/media/dvb/frontends/stv090x.h	2012-02-27 00:02:11.478915022 +0100
@@ -85,9 +85,6 @@
 	enum stv090x_adc_range	adc2_range; /* default: 2Vpp */
 
 	bool diseqc_envelope_mode;
-	s8 gpio_voltage_enable;
-	s8 gpio_voltage_select;
-	s8 gpio_voltage_boost;
 
 	int (*tuner_init) (struct dvb_frontend *fe);
 	int (*tuner_sleep) (struct dvb_frontend *fe);
diff -urN media_build_experimental//linux/drivers/media/common/Makefile media-experimental-media_build_experimental//linux/drivers/media/common/Makefile
--- media_build_experimental//linux/drivers/media/common/Makefile	2012-02-27 10:48:36.968908938 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/common/Makefile	2010-07-03 23:22:08.000000000 +0200
@@ -4,4 +4,3 @@
 obj-y += tuners/
 obj-$(CONFIG_VIDEO_SAA7146) += saa7146.o
 obj-$(CONFIG_VIDEO_SAA7146_VV) += saa7146_vv.o
-obj-$(CONFIG_SAA716X_CORE) += saa716x/
diff -urN media_build_experimental//linux/drivers/media/common/saa716x/saa716x_budget.c media-experimental-media_build_experimental//linux/drivers/media/common/saa716x/saa716x_budget.c
--- media_build_experimental//linux/drivers/media/common/saa716x/saa716x_budget.c	2012-02-27 10:48:36.968908938 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/common/saa716x/saa716x_budget.c	2012-02-27 00:02:31.098915018 +0100
@@ -114,9 +114,9 @@
 	}
 
 	/* set default port mapping */
-	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x04080FA9);
-	/* enable FGPI3 and FGPI1 for TS input from Port 2 and 6 */
-	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x321);
+	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x2C688F44);
+	/* enable FGPI3 and FGPI0 for TS input from Port 3 and 6 */
+	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x894);
 
 	err = saa716x_dvb_init(saa716x);
 	if (err) {
@@ -450,7 +450,7 @@
 	.demod_mode		= STV090x_SINGLE,
 	.clk_mode		= STV090x_CLK_EXT,
 
-	.xtal			= 8000000,
+	.xtal			= 13500000,
 	.address		= 0x68,
 
 	.ts1_mode		= STV090x_TSMODE_DVBCI,
@@ -458,10 +458,6 @@
 
 	.repeater_level		= STV090x_RPTLEVEL_16,
 
-	.gpio_voltage_enable	= 2,
-	.gpio_voltage_select	= 3,
-	.gpio_voltage_boost	= 4,
-
 	.tuner_init		= NULL,
 	.tuner_sleep		= NULL,
 	.tuner_set_mode		= NULL,
@@ -477,7 +473,7 @@
 
 static struct stv6110x_config skystar2_stv6110x_config = {
 	.addr			= 0x60,
-	.refclk			= 16000000,
+	.refclk			= 27000000,
 	.clk_div		= 2,
 };
 
@@ -485,7 +481,7 @@
 					       int count)
 {
 	struct saa716x_dev *saa716x = adapter->saa716x;
-	struct saa716x_i2c *i2c = &saa716x->i2c[SAA716x_I2C_BUS_B];
+	struct saa716x_i2c *i2c = &saa716x->i2c[SAA716x_I2C_BUS_A];
 	struct stv6110x_devctl *ctl;
 
 	if (count < saa716x->config->adapters) {
@@ -494,14 +490,14 @@
 		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count,
 			saa716x->pdev->subsystem_device);
 
-		saa716x_gpio_set_output(saa716x, 26);
+		saa716x_gpio_set_output(saa716x, 20);
 
 		/* Reset the demodulator */
-		saa716x_gpio_write(saa716x, 26, 1);
+		saa716x_gpio_write(saa716x, 20, 1);
 		msleep(10);
-		saa716x_gpio_write(saa716x, 26, 0);
+		saa716x_gpio_write(saa716x, 20, 0);
 		msleep(10);
-		saa716x_gpio_write(saa716x, 26, 1);
+		saa716x_gpio_write(saa716x, 20, 1);
 		msleep(10);
 
 		adapter->fe = dvb_attach(stv090x_attach,
@@ -565,7 +561,7 @@
 	.adap_config		= {
 		{
 			/* Adapter 0 */
-			.ts_port = 1, /* using FGPI 1 */
+			.ts_port = 3, /* using FGPI 3, TODO: check */
 			.worker = demux_worker
 		}
 	}
diff -urN media_build_experimental//linux/drivers/media/common/tuners/tua9001.c media-experimental-media_build_experimental//linux/drivers/media/common/tuners/tua9001.c
--- media_build_experimental//linux/drivers/media/common/tuners/tua9001.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/common/tuners/tua9001.c	2012-02-27 00:02:31.298915018 +0100
@@ -0,0 +1,286 @@
+/*
+ * Infineon TUA 9001 silicon tuner driver
+ *
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/slab.h>         /* for kzalloc/kfree */
+#include <linux/version.h>
+#include "tua9001.h"
+#include "tua9001_priv.h"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)) || ((defined V4L2_VERSION) && (V4L2_VERSION >= 197120))
+/* all DVB frontend drivers now work directly with the DVBv5
+ * structure. This warrants that all drivers will be
+ * getting/setting frontend parameters on a consistent way, in
+ * order to avoid copying data from/to the DVBv3 structs
+ * without need.
+ */
+#define V4L2_ONLY_DVB_V5
+#endif
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "debug");
+
+/* write register */
+static int tua9001_writereg(struct tua9001_priv *priv, u8 reg, u16 val)
+{
+	u8 buf[3] = {reg, val >> 8, val & 0xff};
+	struct i2c_msg msg = { .addr = priv->cfg->i2c_address,
+		.flags = 0, .buf = buf, .len = 3 };
+
+	if (i2c_transfer(priv->i2c, &msg, 1) != 1) {
+		err("I2C write failed, reg:%02x", reg);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int tua9001_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int tua9001_init(struct dvb_frontend *fe)
+{
+	struct tua9001_priv *priv = fe->tuner_priv;
+	int ret = 0;
+	u8 i;
+	struct regdesc data[] = {
+		{0x1e, 0x6512},
+		{0x25, 0xb888},
+		{0x39, 0x5460},
+		{0x3b, 0x00c0},
+		{0x3a, 0xf000},
+		{0x08, 0x0000},
+		{0x32, 0x0030},
+		{0x41, 0x703a},
+		{0x40, 0x1c78},
+		{0x2c, 0x1c00},
+		{0x36, 0xc013},
+		{0x37, 0x6f18},
+		{0x27, 0x0008},
+		{0x2a, 0x0001},
+		{0x34, 0x0a40},
+	};
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open i2c-gate */
+
+	for (i = 0; i < ARRAY_SIZE(data); i++) {
+		ret = tua9001_writereg(priv, data[i].reg, data[i].val);
+		if (ret)
+			break;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close i2c-gate */
+
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+#ifdef V4L2_ONLY_DVB_V5
+static int tua9001_set_params(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *params = &fe->dtv_property_cache;
+	struct tua9001_priv *priv = fe->tuner_priv;
+	int ret;
+	u16 val;
+	u32 freq;
+	u8 i;
+	struct regdesc data[2];
+
+	switch (params->bandwidth_hz) {
+#if 0
+	case 5000000:
+		val  = 0x3000;
+		break;
+#endif
+	case 6000000:
+		val  = 0x2000;
+		break;
+	case 7000000:
+		val  = 0x1000;
+		break;
+	case 8000000:
+	default:
+		val  = 0x0000;
+		break;
+	}
+
+	data[0].reg = 0x04;
+	data[0].val = val;
+
+freq = params->frequency;
+
+#define OFFSET 150000000
+freq = freq - OFFSET;
+freq  = freq/1000;
+freq  = 48 * freq;
+freq  = freq/1000;
+
+val = freq;
+
+	data[1].reg = 0x1f;
+	data[1].val = val;
+
+
+	deb_info("%s: freq:%d bw:%d freq tuner:%d val:%d\n", __func__,
+		params->frequency, params->bandwidth_hz, priv->frequency,
+		val);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open i2c-gate */
+
+	for (i = 0; i < ARRAY_SIZE(data); i++) {
+		ret = tua9001_writereg(priv, data[i].reg, data[i].val);
+		if (ret)
+			break;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close i2c-gate */
+
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+#else
+static int tua9001_set_params(struct dvb_frontend *fe,
+	struct dvb_frontend_parameters *params)
+{
+	struct tua9001_priv *priv = fe->tuner_priv;
+	int ret;
+	u16 val;
+	u32 freq;
+	u8 i;
+	struct regdesc data[2];
+
+	switch (params->u.ofdm.bandwidth) {
+#if 0
+	case BANDWIDTH_5_MHZ:
+		val  = 0x3000;
+		break;
+#endif
+	case BANDWIDTH_6_MHZ:
+		val  = 0x2000;
+		break;
+	case BANDWIDTH_7_MHZ:
+		val  = 0x1000;
+		break;
+	case BANDWIDTH_8_MHZ:
+	default:
+		val  = 0x0000;
+		break;
+	}
+
+	data[0].reg = 0x04;
+	data[0].val = val;
+
+freq = params->frequency;
+
+#define OFFSET 150000000
+freq = freq - OFFSET;
+freq  = freq/1000;
+freq  = 48 * freq;
+freq  = freq/1000;
+
+val = freq;
+
+	data[1].reg = 0x1f;
+	data[1].val = val;
+
+
+	deb_info("%s: freq:%d bw:%d freq tuner:%d val:%d\n", __func__,
+		params->frequency, params->u.ofdm.bandwidth, priv->frequency,
+		val);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open i2c-gate */
+
+	for (i = 0; i < ARRAY_SIZE(data); i++) {
+		ret = tua9001_writereg(priv, data[i].reg, data[i].val);
+		if (ret)
+			break;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close i2c-gate */
+
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+#endif
+
+static int tua9001_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct tua9001_priv *priv = fe->tuner_priv;
+	*frequency = priv->frequency;
+	return 0;
+}
+
+static const struct dvb_tuner_ops tua9001_tuner_ops = {
+	.info = {
+		.name           = "Infineon TUA 9001",
+
+		.frequency_min  = 170000000,
+		.frequency_max  = 860000000,
+		.frequency_step = 0,
+	},
+
+	.release       = tua9001_release,
+	.init          = tua9001_init,
+
+	.set_params    = tua9001_set_params,
+
+	.get_frequency = tua9001_get_frequency,
+};
+
+struct dvb_frontend * tua9001_attach(struct dvb_frontend *fe,
+	struct i2c_adapter *i2c, struct tua9001_config *cfg)
+{
+	struct tua9001_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct tua9001_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+
+	priv->cfg = cfg;
+	priv->i2c = i2c;
+
+	info("Infineon TUA 9001 successfully attached.");
+
+	memcpy(&fe->ops.tuner_ops, &tua9001_tuner_ops,
+		sizeof(struct dvb_tuner_ops));
+
+	fe->tuner_priv = priv;
+	return fe;
+}
+EXPORT_SYMBOL(tua9001_attach);
+
+MODULE_DESCRIPTION("Infineon TUA 9001 silicon tuner driver");
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/common/tuners/tua9001.h media-experimental-media_build_experimental//linux/drivers/media/common/tuners/tua9001.h
--- media_build_experimental//linux/drivers/media/common/tuners/tua9001.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/common/tuners/tua9001.h	2012-02-27 00:02:31.298915018 +0100
@@ -0,0 +1,46 @@
+/*
+ * Infineon TUA 9001 silicon tuner driver
+ *
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef TUA9001_H
+#define TUA9001_H
+
+#include "dvb_frontend.h"
+
+struct tua9001_config {
+	u8 i2c_address;
+};
+
+#if defined(DETACHED_TERRATEC_MODULES) || \
+    defined(CONFIG_MEDIA_TUNER_TUA9001) || \
+	(defined(CONFIG_MEDIA_TUNER_TUA9001_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tua9001_attach(struct dvb_frontend *fe,
+					struct i2c_adapter *i2c,
+					struct tua9001_config *cfg);
+#else
+static inline struct dvb_frontend *tua9001_attach(struct dvb_frontend *fe,
+						struct i2c_adapter *i2c,
+						struct tua9001_config *cfg)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif
diff -urN media_build_experimental//linux/drivers/media/common/tuners/tua9001_priv.h media-experimental-media_build_experimental//linux/drivers/media/common/tuners/tua9001_priv.h
--- media_build_experimental//linux/drivers/media/common/tuners/tua9001_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/common/tuners/tua9001_priv.h	2012-02-27 00:02:31.308915018 +0100
@@ -0,0 +1,53 @@
+/*
+ * Infineon TUA 9001 silicon tuner driver
+ *
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef TUA9001_PRIV_H
+#define TUA9001_PRIV_H
+
+#define LOG_PREFIX "tua9001"
+
+#define dprintk(var, level, args...) \
+	do { \
+		if ((var & level)) \
+			printk(args); \
+	} while (0)
+
+#define deb_info(args...) dprintk(debug, 0x01, args)
+
+#undef err
+#define err(f, arg...)  printk(KERN_ERR     LOG_PREFIX": " f "\n" , ## arg)
+#undef info
+#define info(f, arg...) printk(KERN_INFO    LOG_PREFIX": " f "\n" , ## arg)
+#undef warn
+#define warn(f, arg...) printk(KERN_WARNING LOG_PREFIX": " f "\n" , ## arg)
+
+struct regdesc {
+	u8 reg;
+	u16 val;
+};
+
+struct tua9001_priv {
+	struct tua9001_config *cfg;
+	struct i2c_adapter *i2c;
+
+	u32 frequency;
+};
+
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-core.c media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-core.c
--- media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-core.c	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-core.c	2012-01-22 02:53:17.000000000 +0100
@@ -36,6 +36,7 @@
 #include <linux/swab.h>
 #include <linux/vmalloc.h>
 #include "ddbridge.h"
+
 #include "ddbridge-regs.h"
 
 #include "tda18271c2dd.h"
@@ -43,60 +44,14 @@
 #include "stv090x.h"
 #include "lnbh24.h"
 #include "drxk.h"
-#if 0
-#include "stv0367.h"
-#else
-#include "stv0367dd.h"
-#endif
-#if 0
-#include "tda18212.h"
-#else
-#include "tda18212dd.h"
-#endif
-
-static int adapter_alloc;
-module_param(adapter_alloc, int, 0444);
-MODULE_PARM_DESC(adapter_alloc, "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
-
-static int ts_loop = -1;
-module_param(ts_loop, int, 0444);
-MODULE_PARM_DESC(ts_loop, "TS in/out on port ts_loop");
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
-static struct ddb *ddbs[32];
-
 /* MSI had problems with lost interrupts, fixed but needs testing */
-/* #undef CONFIG_PCI_MSI */
-
-/******************************************************************************/
-
-static inline void ddbwritel(struct ddb *dev, u32 val, u32 adr)
-{
-	writel(val, (char *) (dev->regs+(adr)));
-}
-
-static inline u32 ddbreadl(struct ddb *dev, u32 adr)
-{
-	return readl((char *) (dev->regs+(adr)));
-}
-
-#define ddbcpyto(_dev, _adr, _src, _count)   memcpy_toio((char *) \
-					(_dev->regs + (_adr)), (_src), (_count))
-
-#define ddbcpyfrom(_dev, _dst, _adr, _count) memcpy_fromio((_dst), (char *) \
-					(_dev->regs + (_adr)), (_count))
-
+#undef CONFIG_PCI_MSI
 
 /******************************************************************************/
 
-static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
-{
-	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len};
-
-	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
-}
-
 static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
 {
 	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
@@ -104,31 +59,10 @@
 	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
 }
 
-static int i2c_read_regs(struct i2c_adapter *adapter,
-			 u8 adr, u8 reg, u8 *val, u8 len)
-{
-	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
-				   .buf  = &reg, .len   = 1},
-				  {.addr = adr,  .flags = I2C_M_RD,
-				   .buf  = val,  .len   = len } };
-	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
-}
-
-static int i2c_read_regs16(struct i2c_adapter *adapter,
-			   u8 adr, u16 reg, u8 *val, u8 len)
-{
-	u8 reg16[2] = { reg >> 8, reg };
-	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
-				   .buf  = (u8 *)&reg16, .len   = 2},
-				  {.addr = adr,  .flags = I2C_M_RD,
-				   .buf  = val,  .len   = len } };
-	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
-}
-
 static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)
 {
 	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
-				   .buf  = &reg, .len   = 1},
+				   .buf  = &reg, .len   = 1 },
 				  {.addr = adr,  .flags = I2C_M_RD,
 				   .buf  = val,  .len   = 1 } };
 	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
@@ -137,22 +71,14 @@
 static int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,
 			  u16 reg, u8 *val)
 {
-	u8 msg[2] = {reg >> 8, reg & 0xff};
+	u8 msg[2] = {reg>>8, reg&0xff};
 	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
 				   .buf  = msg, .len   = 2},
 				  {.addr = adr, .flags = I2C_M_RD,
-				   .buf  = val, .len   = 1 } };
+				   .buf  = val, .len   = 1} };
 	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
 }
 
-static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr,
-			   u16 reg, u8 val)
-{
-	u8 msg[3] = {reg >> 8, reg & 0xff, val};
-
-	return i2c_write(adap, adr, msg, 3);
-}
-
 static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
 {
 	struct ddb *dev = i2c->dev;
@@ -160,18 +86,18 @@
 	u32 val;
 
 	i2c->done = 0;
-	ddbwritel(dev, (adr << 9) | cmd, i2c->regs + I2C_COMMAND);
+	ddbwritel((adr << 9) | cmd, i2c->regs + I2C_COMMAND);
 	stat = wait_event_timeout(i2c->wq, i2c->done == 1, HZ);
 	if (stat <= 0) {
 		printk(KERN_ERR "I2C timeout\n");
 		{ /* MSI debugging*/
-			u32 istat = ddbreadl(dev, INTERRUPT_STATUS);
+			u32 istat = ddbreadl(INTERRUPT_STATUS);
 			printk(KERN_ERR "IRS %08x\n", istat);
-			ddbwritel(dev, istat, INTERRUPT_ACK);
+			ddbwritel(istat, INTERRUPT_ACK);
 		}
 		return -EIO;
 	}
-	val = ddbreadl(dev, i2c->regs+I2C_COMMAND);
+	val = ddbreadl(i2c->regs+I2C_COMMAND);
 	if (val & 0x70000)
 		return -EIO;
 	return 0;
@@ -180,7 +106,7 @@
 static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
 			       struct i2c_msg msg[], int num)
 {
-	struct ddb_i2c *i2c = (struct ddb_i2c *) i2c_get_adapdata(adapter);
+	struct ddb_i2c *i2c = (struct ddb_i2c *)i2c_get_adapdata(adapter);
 	struct ddb *dev = i2c->dev;
 	u8 addr = 0;
 
@@ -191,8 +117,8 @@
 	    !(msg[0].flags & I2C_M_RD)) {
 		memcpy_toio(dev->regs + I2C_TASKMEM_BASE + i2c->wbuf,
 			    msg[0].buf, msg[0].len);
-		ddbwritel(dev, msg[0].len|(msg[1].len << 16),
-			  i2c->regs + I2C_TASKLENGTH);
+		ddbwritel(msg[0].len|(msg[1].len << 16),
+			  i2c->regs+I2C_TASKLENGTH);
 		if (!ddb_i2c_cmd(i2c, addr, 1)) {
 			memcpy_fromio(msg[1].buf,
 				      dev->regs + I2C_TASKMEM_BASE + i2c->rbuf,
@@ -200,16 +126,17 @@
 			return num;
 		}
 	}
+
 	if (num == 1 && !(msg[0].flags & I2C_M_RD)) {
-		ddbcpyto(dev, I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
-		ddbwritel(dev, msg[0].len, i2c->regs + I2C_TASKLENGTH);
+		ddbcpyto(I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
+		ddbwritel(msg[0].len, i2c->regs + I2C_TASKLENGTH);
 		if (!ddb_i2c_cmd(i2c, addr, 2))
 			return num;
 	}
 	if (num == 1 && (msg[0].flags & I2C_M_RD)) {
-		ddbwritel(dev, msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
+		ddbwritel(msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
 		if (!ddb_i2c_cmd(i2c, addr, 3)) {
-			ddbcpyfrom(dev, msg[0].buf,
+			ddbcpyfrom(msg[0].buf,
 				   I2C_TASKMEM_BASE + i2c->rbuf, msg[0].len);
 			return num;
 		}
@@ -234,7 +161,7 @@
 	struct ddb_i2c *i2c;
 	struct i2c_adapter *adap;
 
-	for (i = 0; i < dev->info->i2c_num; i++) {
+	for (i = 0; i < dev->info->port_num; i++) {
 		i2c = &dev->i2c[i];
 		adap = &i2c->adap;
 		i2c_del_adapter(adap);
@@ -247,15 +174,15 @@
 	struct ddb_i2c *i2c;
 	struct i2c_adapter *adap;
 
-	for (i = 0; i < dev->info->i2c_num; i++) {
+	for (i = 0; i < dev->info->port_num; i++) {
 		i2c = &dev->i2c[i];
 		i2c->dev = dev;
 		i2c->nr = i;
 		i2c->wbuf = i * (I2C_TASKMEM_SIZE / 4);
 		i2c->rbuf = i2c->wbuf + (I2C_TASKMEM_SIZE / 8);
 		i2c->regs = 0x80 + i * 0x20;
-		ddbwritel(dev, I2C_SPEED_100, i2c->regs + I2C_TIMING);
-		ddbwritel(dev, (i2c->rbuf << 16) | i2c->wbuf,
+		ddbwritel(I2C_SPEED_100, i2c->regs + I2C_TIMING);
+		ddbwritel((i2c->rbuf << 16) | i2c->wbuf,
 			  i2c->regs + I2C_TASKADDRESS);
 		init_waitqueue_head(&i2c->wq);
 
@@ -290,94 +217,69 @@
 /******************************************************************************/
 /******************************************************************************/
 
-static void ddb_set_dma_table(struct ddb *dev, struct ddb_dma *dma)
+#if 0
+static void set_table(struct ddb *dev, u32 off,
+		      dma_addr_t *pbuf, u32 num)
 {
 	u32 i, base;
 	u64 mem;
 
-	if (!dma)
-		return;
-	base = DMA_BASE_ADDRESS_TABLE + dma->nr * 0x100;
-	for (i = 0; i < dma->num; i++) {
-		mem = dma->pbuf[i];
-		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
-		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
+	base = DMA_BASE_ADDRESS_TABLE + off;
+	for (i = 0; i < num; i++) {
+		mem = pbuf[i];
+		ddbwritel(mem & 0xffffffff, base + i * 8);
+		ddbwritel(mem >> 32, base + i * 8 + 4);
 	}
-	dma->bufreg = (dma->div << 16) |
-		((dma->num & 0x1f) << 11) |
-		((dma->size >> 7) & 0x7ff);
-}
-
-static void ddb_set_dma_tables(struct ddb *dev)
-{
-	u32 i;
-
-	for (i = 0; i < dev->info->port_num * 2; i++)
-		ddb_set_dma_table(dev, dev->input[i].dma);
-	for (i = 0; i < dev->info->port_num; i++)
-		ddb_set_dma_table(dev, dev->output[i].dma);
 }
+#endif
 
-static void dma_free(struct pci_dev *pdev, struct ddb_dma *dma)
+static void ddb_address_table(struct ddb *dev)
 {
-	int i;
+	u32 i, j, base;
+	u64 mem;
+	dma_addr_t *pbuf;
 
-	if (!dma)
-		return;
-	for (i = 0; i < dma->num; i++) {
-		if (dma->vbuf[i]) {
-			pci_free_consistent(pdev, dma->size,
-					    dma->vbuf[i], dma->pbuf[i]);
-			dma->vbuf[i] = 0;
+	for (i = 0; i < dev->info->port_num * 2; i++) {
+		base = DMA_BASE_ADDRESS_TABLE + i * 0x100;
+		pbuf = dev->input[i].pbuf;
+		for (j = 0; j < dev->input[i].dma_buf_num; j++) {
+			mem = pbuf[j];
+			ddbwritel(mem & 0xffffffff, base + j * 8);
+			ddbwritel(mem >> 32, base + j * 8 + 4);
 		}
 	}
-}
-
-static void ddb_redirect_dma(struct ddb *dev,
-			     struct ddb_dma *sdma,
-			     struct ddb_dma *ddma)
-{
-	u32 i, base;
-	u64 mem;
-
-	sdma->bufreg = ddma->bufreg;
-	base = DMA_BASE_ADDRESS_TABLE + sdma->nr * 0x100;
-	for (i = 0; i < ddma->num; i++) {
-		mem = ddma->pbuf[i];
-		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
-		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
+	for (i = 0; i < dev->info->port_num; i++) {
+		base = DMA_BASE_ADDRESS_TABLE + 0x800 + i * 0x100;
+		pbuf = dev->output[i].pbuf;
+		for (j = 0; j < dev->output[i].dma_buf_num; j++) {
+			mem = pbuf[j];
+			ddbwritel(mem & 0xffffffff, base + j * 8);
+			ddbwritel(mem >> 32, base + j * 8 + 4);
+		}
 	}
 }
 
-static void ddb_unredirect(struct ddb_port *port)
+static void io_free(struct pci_dev *pdev, u8 **vbuf,
+		    dma_addr_t *pbuf, u32 size, int num)
 {
-	struct ddb_input *ored, *ired;
-
-	ored = port->output->redirect;
-	ired = port->input[0]->redirect;
+	int i;
 
-	if (!ored || !ired)
-		return;
-	if (ired->port->output->redirect == port->input[0]) {
-		ired->port->output->redirect = ored;
-		ddb_set_dma_table(port->dev, port->input[0]->dma);
-		ddb_redirect_dma(ored->port->dev, ored->dma, ired->port->output->dma);
-	} else
-		ddb_set_dma_table(ored->port->dev, ored->dma);
-	ored->redirect = ired;
-	port->input[0]->redirect = 0;
-	port->output->redirect = 0;
+	for (i = 0; i < num; i++) {
+		if (vbuf[i]) {
+			pci_free_consistent(pdev, size, vbuf[i], pbuf[i]);
+			vbuf[i] = 0;
+		}
+	}
 }
 
-static int dma_alloc(struct pci_dev *pdev, struct ddb_dma *dma)
+static int io_alloc(struct pci_dev *pdev, u8 **vbuf,
+		    dma_addr_t *pbuf, u32 size, int num)
 {
 	int i;
 
-	if (!dma)
-		return 0;
-	for (i = 0; i < dma->num; i++) {
-		dma->vbuf[i] = pci_alloc_consistent(pdev, dma->size, &dma->pbuf[i]);
-		if (!dma->vbuf[i])
+	for (i = 0; i < num; i++) {
+		vbuf[i] = pci_alloc_consistent(pdev, size, &pbuf[i]);
+		if (!vbuf[i])
 			return -ENOMEM;
 	}
 	return 0;
@@ -392,23 +294,34 @@
 		port = &dev->port[i];
 		switch (port->class) {
 		case DDB_PORT_TUNER:
-			if (dma_alloc(dev->pdev, port->input[0]->dma) < 0)
+			if (io_alloc(dev->pdev, port->input[0]->vbuf,
+				     port->input[0]->pbuf,
+				     port->input[0]->dma_buf_size,
+				     port->input[0]->dma_buf_num) < 0)
 				return -1;
-			if (dma_alloc(dev->pdev, port->input[1]->dma) < 0)
+			if (io_alloc(dev->pdev, port->input[1]->vbuf,
+				     port->input[1]->pbuf,
+				     port->input[1]->dma_buf_size,
+				     port->input[1]->dma_buf_num) < 0)
 				return -1;
 			break;
 		case DDB_PORT_CI:
-		case DDB_PORT_LOOP:
-			if (dma_alloc(dev->pdev, port->input[0]->dma) < 0)
+			if (io_alloc(dev->pdev, port->input[0]->vbuf,
+				     port->input[0]->pbuf,
+				     port->input[0]->dma_buf_size,
+				     port->input[0]->dma_buf_num) < 0)
 				return -1;
-			if (dma_alloc(dev->pdev, port->output->dma) < 0)
+			if (io_alloc(dev->pdev, port->output->vbuf,
+				     port->output->pbuf,
+				     port->output->dma_buf_size,
+				     port->output->dma_buf_num) < 0)
 				return -1;
 			break;
 		default:
 			break;
 		}
 	}
-	ddb_set_dma_tables(dev);
+	ddb_address_table(dev);
 	return 0;
 }
 
@@ -419,11 +332,18 @@
 
 	for (i = 0; i < dev->info->port_num; i++) {
 		port = &dev->port[i];
-
-		ddb_unredirect(port);
-		dma_free(dev->pdev, port->input[0]->dma);
-		dma_free(dev->pdev, port->input[1]->dma);
-		dma_free(dev->pdev, port->output->dma);
+		io_free(dev->pdev, port->input[0]->vbuf,
+			port->input[0]->pbuf,
+			port->input[0]->dma_buf_size,
+			port->input[0]->dma_buf_num);
+		io_free(dev->pdev, port->input[1]->vbuf,
+			port->input[1]->pbuf,
+			port->input[1]->dma_buf_size,
+			port->input[1]->dma_buf_num);
+		io_free(dev->pdev, port->output->vbuf,
+			port->output->pbuf,
+			port->output->dma_buf_size,
+			port->output->dma_buf_num);
 	}
 }
 
@@ -431,116 +351,90 @@
 {
 	struct ddb *dev = input->port->dev;
 
-	spin_lock_irq(&input->dma->lock);
-	input->dma->cbuf = 0;
-	input->dma->coff = 0;
+	spin_lock_irq(&input->lock);
+	input->cbuf = 0;
+	input->coff = 0;
 
 	/* reset */
-	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(dev, 2, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
-
-	ddbwritel(dev, input->dma->bufreg, DMA_BUFFER_SIZE(input->dma->nr));
-	ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
-
-	ddbwritel(dev, 1, DMA_BASE_WRITE);
-	ddbwritel(dev, 3, DMA_BUFFER_CONTROL(input->dma->nr));
-	ddbwritel(dev, 9, TS_INPUT_CONTROL(input->nr));
-	input->dma->running = 1;
-	spin_unlock_irq(&input->dma->lock);
-	/* printk(KERN_INFO "input_start %d\n", input->nr); */
+	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
+	ddbwritel(2, TS_INPUT_CONTROL(input->nr));
+	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
+
+	ddbwritel((1 << 16) |
+		  (input->dma_buf_num << 11) |
+		  (input->dma_buf_size >> 7),
+		  DMA_BUFFER_SIZE(input->nr));
+	ddbwritel(0, DMA_BUFFER_ACK(input->nr));
+
+	ddbwritel(1, DMA_BASE_WRITE);
+	ddbwritel(3, DMA_BUFFER_CONTROL(input->nr));
+	ddbwritel(9, TS_INPUT_CONTROL(input->nr));
+	input->running = 1;
+	spin_unlock_irq(&input->lock);
 }
 
 static void ddb_input_stop(struct ddb_input *input)
 {
 	struct ddb *dev = input->port->dev;
 
-	spin_lock_irq(&input->dma->lock);
-	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma->nr));
-	input->dma->running = 0;
-	spin_unlock_irq(&input->dma->lock);
+	spin_lock_irq(&input->lock);
+	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
+	ddbwritel(0, DMA_BUFFER_CONTROL(input->nr));
+	input->running = 0;
+	spin_unlock_irq(&input->lock);
 }
 
 static void ddb_output_start(struct ddb_output *output)
 {
 	struct ddb *dev = output->port->dev;
 
-	spin_lock_irq(&output->dma->lock);
-	output->dma->cbuf = 0;
-	output->dma->coff = 0;
-	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(dev, 2, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(dev, 0x3c, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(dev, output->dma->bufreg, DMA_BUFFER_SIZE(output->dma->nr));
-	ddbwritel(dev, 0, DMA_BUFFER_ACK(output->dma->nr));
-
-	ddbwritel(dev, 1, DMA_BASE_READ);
-	ddbwritel(dev, 3, DMA_BUFFER_CONTROL(output->dma->nr));
-	if (output->port->input[0]->port->class == DDB_PORT_LOOP)
-		ddbwritel(dev, 0x05, TS_OUTPUT_CONTROL(output->nr));
-	else
-		ddbwritel(dev, 0x1d, TS_OUTPUT_CONTROL(output->nr));
-	output->dma->running = 1;
-	spin_unlock_irq(&output->dma->lock);
-	/* printk(KERN_INFO "output_start %d\n", output->nr); */
-}
-
-#if 0
-static void ddb_input_start_all(struct ddb_input *input)
-{
-	struct ddb_input *next;
-
-	ddb_input_start(input);
-	while ((next = input->redirect) &&
-	       next != input) {
-		ddb_input_start(next);
-		ddb_output_start(next->port->output);
-	}
+	spin_lock_irq(&output->lock);
+	output->cbuf = 0;
+	output->coff = 0;
+	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(2, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(0x3c, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel((1 << 16) |
+		  (output->dma_buf_num << 11) |
+		  (output->dma_buf_size >> 7),
+		  DMA_BUFFER_SIZE(output->nr + 8));
+	ddbwritel(0, DMA_BUFFER_ACK(output->nr + 8));
+
+	ddbwritel(1, DMA_BASE_READ);
+	ddbwritel(3, DMA_BUFFER_CONTROL(output->nr + 8));
+	/* ddbwritel(0xbd, TS_OUTPUT_CONTROL(output->nr)); */
+	ddbwritel(0x1d, TS_OUTPUT_CONTROL(output->nr));
+	output->running = 1;
+	spin_unlock_irq(&output->lock);
 }
-#endif
 
 static void ddb_output_stop(struct ddb_output *output)
 {
 	struct ddb *dev = output->port->dev;
 
-	spin_lock_irq(&output->dma->lock);
-	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma->nr));
-	output->dma->running = 0;
-	spin_unlock_irq(&output->dma->lock);
-}
-
-#if 0
-static void ddb_input_stop_all(struct ddb_input *input)
-{
-	struct ddb_input *next;
-
-	ddb_input_stop(input);
-	while ((next = input->redirect) &&
-	       next != input) {
-		ddb_input_stop(next);
-		ddb_output_stop(next->port->output);
-	}
+	spin_lock_irq(&output->lock);
+	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(0, DMA_BUFFER_CONTROL(output->nr + 8));
+	output->running = 0;
+	spin_unlock_irq(&output->lock);
 }
-#endif
 
 static u32 ddb_output_free(struct ddb_output *output)
 {
-	u32 idx, off, stat = output->dma->stat;
+	u32 idx, off, stat = output->stat;
 	s32 diff;
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
-	if (output->dma->cbuf != idx) {
-		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
-		    (output->dma->size - output->dma->coff <= 188))
+	if (output->cbuf != idx) {
+		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
+		    (output->dma_buf_size - output->coff <= 188))
 			return 0;
 		return 188;
 	}
-	diff = off - output->dma->coff;
+	diff = off - output->coff;
 	if (diff <= 0 || diff > 188)
 		return 188;
 	return 0;
@@ -550,24 +444,24 @@
 				const u8 *buf, size_t count)
 {
 	struct ddb *dev = output->port->dev;
-	u32 idx, off, stat = output->dma->stat;
+	u32 idx, off, stat = output->stat;
 	u32 left = count, len;
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
 	while (left) {
-		len = output->dma->size - output->dma->coff;
-		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
+		len = output->dma_buf_size - output->coff;
+		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
 		    (off == 0)) {
 			if (len <= 188)
 				break;
 			len -= 188;
 		}
-		if (output->dma->cbuf == idx) {
-			if (off > output->dma->coff) {
+		if (output->cbuf == idx) {
+			if (off > output->coff) {
 #if 1
-				len = off - output->dma->coff;
+				len = off - output->coff;
 				len -= (len % 188);
 				if (len <= 188)
 
@@ -578,146 +472,68 @@
 		}
 		if (len > left)
 			len = left;
-		if (copy_from_user(output->dma->vbuf[output->dma->cbuf] +
-				   output->dma->coff,
+		if (copy_from_user(output->vbuf[output->cbuf] + output->coff,
 				   buf, len))
 			return -EIO;
-		/* printk("cfu %d  %d %d\n", len, output->cbuf, output->coff); */
 		left -= len;
 		buf += len;
-		output->dma->coff += len;
-		if (output->dma->coff == output->dma->size) {
-			output->dma->coff = 0;
-			output->dma->cbuf = ((output->dma->cbuf + 1) %
-					     output->dma->num);
+		output->coff += len;
+		if (output->coff == output->dma_buf_size) {
+			output->coff = 0;
+			output->cbuf = ((output->cbuf + 1) % output->dma_buf_num);
 		}
-		ddbwritel(dev, (output->dma->cbuf << 11) | (output->dma->coff >> 7),
-			  DMA_BUFFER_ACK(output->dma->nr));
+		ddbwritel((output->cbuf << 11) | (output->coff >> 7),
+			  DMA_BUFFER_ACK(output->nr + 8));
 	}
 	return count - left;
 }
 
-#if 0
-static u32 ddb_input_free_bytes(struct ddb_input *input)
-{
-	struct ddb *dev = input->port->dev;
-	u32 idx, off, stat = input->dma->stat;
-	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
-
-	idx = (stat >> 11) & 0x1f;
-	off = (stat & 0x7ff) << 7;
-
-	if (ctrl & 4)
-		return 0;
-	if (input->dma->cbuf != idx)
-		return 1;
-	return 0;
-}
-
-static s32 ddb_output_used_bufs(struct ddb_output *output)
-{
-	u32 idx, off, stat, ctrl;
-	s32 diff;
-
-	spin_lock_irq(&output->dma->lock);
-	stat = output->dma->stat;
-	ctrl = output->dma->ctrl;
-	spin_unlock_irq(&output->dma->lock);
-
-	idx = (stat >> 11) & 0x1f;
-	off = (stat & 0x7ff) << 7;
-
-	if (ctrl & 4)
-		return 0;
-	diff = output->dma->cbuf - idx;
-	if (diff == 0 && off < output->dma->coff)
-		return 0;
-	if (diff <= 0)
-		diff += output->dma->num;
-	return diff;
-}
-
-static s32 ddb_input_free_bufs(struct ddb_input *input)
-{
-	u32 idx, off, stat, ctrl;
-	s32 free;
-
-	spin_lock_irq(&input->dma->lock);
-	ctrl = input->dma->ctrl;
-	stat = input->dma->stat;
-	spin_unlock_irq(&input->dma->lock);
-	if (ctrl & 4)
-		return 0;
-	idx = (stat >> 11) & 0x1f;
-	off = (stat & 0x7ff) << 7;
-	free = input->dma->cbuf - idx;
-	if (free == 0 && off < input->dma->coff)
-		return 0;
-	if (free <= 0)
-		free += input->dma->num;
-	return free - 1;
-}
-
-static u32 ddb_output_ok(struct ddb_output *output)
-{
-	struct ddb_input *input = output->port->input[0];
-	s32 diff;
-
-	diff = ddb_input_free_bufs(input) - ddb_output_used_bufs(output);
-	if (diff > 0)
-		return 1;
-	return 0;
-}
-#endif
-
 static u32 ddb_input_avail(struct ddb_input *input)
 {
 	struct ddb *dev = input->port->dev;
-	u32 idx, off, stat = input->dma->stat;
-	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
+	u32 idx, off, stat = input->stat;
+	u32 ctrl = ddbreadl(DMA_BUFFER_CONTROL(input->nr));
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
 	if (ctrl & 4) {
 		printk(KERN_ERR "IA %d %d %08x\n", idx, off, ctrl);
-		ddbwritel(dev, stat, DMA_BUFFER_ACK(input->dma->nr));
+		ddbwritel(input->stat, DMA_BUFFER_ACK(input->nr));
 		return 0;
 	}
-	if (input->dma->cbuf != idx || off < input->dma->coff)
+	if (input->cbuf != idx)
 		return 188;
 	return 0;
 }
 
-static size_t ddb_input_read(struct ddb_input *input, u8 *buf, size_t count)
+static ssize_t ddb_input_read(struct ddb_input *input, u8 *buf, size_t count)
 {
 	struct ddb *dev = input->port->dev;
 	u32 left = count;
-	u32 idx, off, free, stat = input->dma->stat;
+	u32 idx, free, stat = input->stat;
 	int ret;
 
 	idx = (stat >> 11) & 0x1f;
-	off = (stat & 0x7ff) << 7;
 
 	while (left) {
-		if (input->dma->cbuf == idx)
+		if (input->cbuf == idx)
 			return count - left;
-		free = input->dma->size - input->dma->coff;
+		free = input->dma_buf_size - input->coff;
 		if (free > left)
 			free = left;
-		ret = copy_to_user(buf, input->dma->vbuf[input->dma->cbuf] +
-				   input->dma->coff, free);
+		ret = copy_to_user(buf, input->vbuf[input->cbuf] +
+				   input->coff, free);
 		if (ret)
 			return -EFAULT;
-		input->dma->coff += free;
-		if (input->dma->coff == input->dma->size) {
-			input->dma->coff = 0;
-			input->dma->cbuf = (input->dma->cbuf+1) %
-				input->dma->num;
+		input->coff += free;
+		if (input->coff == input->dma_buf_size) {
+			input->coff = 0;
+			input->cbuf = (input->cbuf+1) % input->dma_buf_num;
 		}
 		left -= free;
-		ddbwritel(dev, (input->dma->cbuf << 11) | (input->dma->coff >> 7),
-			  DMA_BUFFER_ACK(input->dma->nr));
+		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
+			  DMA_BUFFER_ACK(input->nr));
 	}
 	return count;
 }
@@ -739,7 +555,7 @@
 }
 #endif
 
-static int locked_gate_ctrl(struct dvb_frontend *fe, int enable)
+static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	struct ddb_input *input = fe->sec_priv;
 	struct ddb_port *port = input->port;
@@ -747,9 +563,9 @@
 
 	if (enable) {
 		mutex_lock(&port->i2c_gate_lock);
-		status = input->dvb.gate_ctrl(fe, 1);
+		status = input->gate_ctrl(fe, 1);
 	} else {
-		status = input->dvb.gate_ctrl(fe, 0);
+		status = input->gate_ctrl(fe, 0);
 		mutex_unlock(&port->i2c_gate_lock);
 	}
 	return status;
@@ -762,88 +578,17 @@
 	struct drxk_config config;
 
 	memset(&config, 0, sizeof(config));
-	config.adr = 0x29 + (input->nr & 1);
 	config.microcode_name = "drxk_a3.mc";
+	config.adr = 0x29 + (input->nr & 1);
 
-#ifdef USE_API3
-	fe = input->dvb.fe = dvb_attach(drxk_attach, &config, i2c, &input->dvb.fe2);
-#else
-	fe = input->dvb.fe = dvb_attach(drxk_attach, &config, i2c);
-#endif
-	if (!input->dvb.fe) {
+	fe = input->fe = dvb_attach(drxk_attach, &config, i2c);
+	if (!input->fe) {
 		printk(KERN_ERR "No DRXK found!\n");
 		return -ENODEV;
 	}
 	fe->sec_priv = input;
-	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
-	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
-	return 0;
-}
-
-#if 0
-struct stv0367_config stv0367_0 = {
-	.demod_address = 0x1f,
-	.xtal = 27000000,
-	.if_khz = 5000,
-	.if_iq_mode = FE_TER_NORMAL_IF_TUNER,
-	.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,
-	.clk_pol = STV0367_RISINGEDGE_CLOCK,
-};
-
-struct stv0367_config stv0367_1 = {
-	.demod_address = 0x1e,
-	.xtal = 27000000,
-	.if_khz = 5000,
-	.if_iq_mode = FE_TER_NORMAL_IF_TUNER,
-	.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,
-	.clk_pol = STV0367_RISINGEDGE_CLOCK,
-};
-
-
-static int demod_attach_stv0367(struct ddb_input *input)
-{
-	struct i2c_adapter *i2c = &input->port->i2c->adap;
-	struct dvb_frontend *fe;
-
-	fe = input->dvb.fe = dvb_attach(stv0367ter_attach,
-				    (input->nr & 1) ? &stv0367_1 : &stv0367_0,
-				    i2c);
-	if (!input->dvb.fe) {
-		printk(KERN_ERR "No stv0367 found!\n");
-		return -ENODEV;
-	}
-	fe->sec_priv = input;
-	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
-	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
-	return 0;
-}
-#endif
-
-struct stv0367_cfg stv0367dd_0 = {
-	.adr = 0x1f,
-	.xtal = 27000000,
-};
-
-struct stv0367_cfg stv0367dd_1 = {
-	.adr = 0x1e,
-	.xtal = 27000000,
-};
-
-static int demod_attach_stv0367dd(struct ddb_input *input)
-{
-	struct i2c_adapter *i2c = &input->port->i2c->adap;
-	struct dvb_frontend *fe;
-
-	fe = input->dvb.fe = dvb_attach(stv0367_attach, i2c,
-				    (input->nr & 1) ? &stv0367dd_1 : &stv0367dd_0,
-				    &input->dvb.fe2);
-	if (!input->dvb.fe) {
-		printk(KERN_ERR "No stv0367 found!\n");
-		return -ENODEV;
-	}
-	fe->sec_priv = input;
-	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
-	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+	input->gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;
 	return 0;
 }
 
@@ -852,57 +597,18 @@
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
 	struct dvb_frontend *fe;
 
-	if (input->dvb.fe->ops.i2c_gate_ctrl)
-		input->dvb.fe->ops.i2c_gate_ctrl(input->dvb.fe, 1);
-	fe = dvb_attach(tda18271c2dd_attach, input->dvb.fe, i2c, 0x60);
-	if (input->dvb.fe->ops.i2c_gate_ctrl)
-		input->dvb.fe->ops.i2c_gate_ctrl(input->dvb.fe, 0);
+	if (input->fe->ops.i2c_gate_ctrl)
+		input->fe->ops.i2c_gate_ctrl(input->fe, 1);
+	fe = dvb_attach(tda18271c2dd_attach, input->fe, i2c, 0x60);
 	if (!fe) {
 		printk(KERN_ERR "No TDA18271 found!\n");
 		return -ENODEV;
 	}
+	if (input->fe->ops.i2c_gate_ctrl)
+		input->fe->ops.i2c_gate_ctrl(input->fe, 0);
 	return 0;
 }
 
-static int tuner_attach_tda18212dd(struct ddb_input *input)
-{
-	struct i2c_adapter *i2c = &input->port->i2c->adap;
-	struct dvb_frontend *fe;
-
-	fe = dvb_attach(tda18212dd_attach, input->dvb.fe, i2c,
-			(input->nr & 1) ? 0x63 : 0x60);
-	if (!fe) {
-		printk(KERN_ERR "No TDA18212 found!\n");
-		return -ENODEV;
-	}
-	return 0;
-}
-
-#if 0
-struct tda18212_config tda18212_0 = {
-	.i2c_address = 0x60,
-};
-
-struct tda18212_config tda18212_1 = {
-	.i2c_address = 0x63,
-};
-
-static int tuner_attach_tda18212(struct ddb_input *input)
-{
-	struct i2c_adapter *i2c = &input->port->i2c->adap;
-	struct dvb_frontend *fe;
-	struct tda18212_config *cfg;
-
-	cfg = (input->nr & 1) ? &tda18212_1 : &tda18212_0;
-	fe = dvb_attach(tda18212_attach, input->dvb.fe, i2c, cfg);
-	if (!fe) {
-		printk(KERN_ERR "No TDA18212 found!\n");
-		return -ENODEV;
-	}
-	return 0;
-}
-#endif
-
 /******************************************************************************/
 /******************************************************************************/
 /******************************************************************************/
@@ -962,14 +668,14 @@
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
 	struct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;
 
-	input->dvb.fe = dvb_attach(stv090x_attach, feconf, i2c,
+	input->fe = dvb_attach(stv090x_attach, feconf, i2c,
 			       (input->nr & 1) ? STV090x_DEMODULATOR_1
 			       : STV090x_DEMODULATOR_0);
-	if (!input->dvb.fe) {
+	if (!input->fe) {
 		printk(KERN_ERR "No STV0900 found!\n");
 		return -ENODEV;
 	}
-	if (!dvb_attach(lnbh24_attach, input->dvb.fe, i2c, 0,
+	if (!dvb_attach(lnbh24_attach, input->fe, i2c, 0,
 			0, (input->nr & 1) ?
 			(0x09 - type) : (0x0b - type))) {
 		printk(KERN_ERR "No LNBH24 found!\n");
@@ -986,7 +692,7 @@
 		&stv6110b : &stv6110a;
 	struct stv6110x_devctl *ctl;
 
-	ctl = dvb_attach(stv6110x_attach, input->dvb.fe, tunerconf, i2c);
+	ctl = dvb_attach(stv6110x_attach, input->fe, tunerconf, i2c);
 	if (!ctl) {
 		printk(KERN_ERR "No STV6110X found!\n");
 		return -ENODEV;
@@ -1054,10 +760,10 @@
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ddb_input *input = dvbdmx->priv;
 
-	if (!input->dvb.users)
+	if (!input->users)
 		ddb_input_start(input);
 
-	return ++input->dvb.users;
+	return ++input->users;
 }
 
 static int stop_feed(struct dvb_demux_feed *dvbdmxfeed)
@@ -1065,8 +771,8 @@
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ddb_input *input = dvbdmx->priv;
 
-	if (--input->dvb.users)
-		return input->dvb.users;
+	if (--input->users)
+		return input->users;
 
 	ddb_input_stop(input);
 	return 0;
@@ -1075,200 +781,116 @@
 
 static void dvb_input_detach(struct ddb_input *input)
 {
-	struct dvb_demux *dvbdemux = &input->dvb.demux;
+	struct dvb_adapter *adap = &input->adap;
+	struct dvb_demux *dvbdemux = &input->demux;
 
-	switch (input->dvb.attached) {
-	case 6:
-		if (input->dvb.fe2)
-			dvb_unregister_frontend(input->dvb.fe2);
-		if (input->dvb.fe)
-			dvb_unregister_frontend(input->dvb.fe);
+	switch (input->attached) {
 	case 5:
-		dvb_frontend_detach(input->dvb.fe);
-		input->dvb.fe = NULL;
+		if (input->fe2)
+			dvb_unregister_frontend(input->fe2);
+		if (input->fe) {
+			dvb_unregister_frontend(input->fe);
+			dvb_frontend_detach(input->fe);
+			input->fe = NULL;
+		}
 	case 4:
-		dvb_net_release(&input->dvb.dvbnet);
+		dvb_net_release(&input->dvbnet);
+
 	case 3:
 		dvbdemux->dmx.close(&dvbdemux->dmx);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
-					      &input->dvb.hw_frontend);
+					      &input->hw_frontend);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
-					      &input->dvb.mem_frontend);
-		dvb_dmxdev_release(&input->dvb.dmxdev);
-	case 2:
-		dvb_dmx_release(&input->dvb.demux);
-	case 1:
-		break;
-	}
-	input->dvb.attached = 0;
-}
-
-static int dvb_register_adapters(struct ddb *dev)
-{
-	int i, ret = 0;
-	struct ddb_port *port;
-	struct dvb_adapter *adap;
-
-	if (adapter_alloc == 3) {
-		port = &dev->port[0];
-		adap = port->input[0]->dvb.adap;
-		ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-					   &port->dev->pdev->dev,
-					   adapter_nr);
-		if (ret < 0)
-			return ret;
-		port->input[0]->dvb.adap_registered = 1;
-		for (i = 0; i < dev->info->port_num; i++) {
-			port = &dev->port[i];
-			port->input[0]->dvb.adap = adap;
-			port->input[1]->dvb.adap = adap;
-		}
-		return 0;
-	}
-
-	for (i = 0; i < dev->info->port_num; i++) {
-		port = &dev->port[i];
-		switch (port->class) {
-		case DDB_PORT_TUNER:
-			adap = port->input[0]->dvb.adap;
-			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-						   &port->dev->pdev->dev,
-						   adapter_nr);
-			if (ret < 0)
-				return ret;
-			port->input[0]->dvb.adap_registered = 1;
-
-			if (adapter_alloc > 0) {
-				port->input[1]->dvb.adap = port->input[0]->dvb.adap;
-				break;
-			}
-			adap = port->input[1]->dvb.adap;
-			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-						   &port->dev->pdev->dev,
-						   adapter_nr);
-			if (ret < 0)
-				return ret;
-			port->input[1]->dvb.adap_registered = 1;
-			break;
-
-		case DDB_PORT_CI:
-		case DDB_PORT_LOOP:
-			adap = port->input[0]->dvb.adap;
-			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-						   &port->dev->pdev->dev,
-						   adapter_nr);
-			if (ret < 0)
-				return ret;
-			port->input[0]->dvb.adap_registered = 1;
-			break;
-		default:
-			if (adapter_alloc < 2)
-				break;
-			adap = port->input[0]->dvb.adap;
-			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-						   &port->dev->pdev->dev,
-						   adapter_nr);
-			if (ret < 0)
-				return ret;
-			port->input[0]->dvb.adap_registered = 1;
-			break;
-		}
-	}
-	return ret;
-}
-
-static void dvb_unregister_adapters(struct ddb *dev)
-{
-	int i;
-	struct ddb_port *port;
-	struct ddb_input *input;
+					      &input->mem_frontend);
+		dvb_dmxdev_release(&input->dmxdev);
 
-	for (i = 0; i < dev->info->port_num; i++) {
-		port = &dev->port[i];
+	case 2:
+		dvb_dmx_release(&input->demux);
 
-		input = port->input[0];
-		if (input->dvb.adap_registered)
-			dvb_unregister_adapter(input->dvb.adap);
-		input->dvb.adap_registered = 0;
-
-		input = port->input[1];
-		if (input->dvb.adap_registered)
-			dvb_unregister_adapter(input->dvb.adap);
-		input->dvb.adap_registered = 0;
+	case 1:
+		dvb_unregister_adapter(adap);
 	}
+	input->attached = 0;
 }
 
-
 static int dvb_input_attach(struct ddb_input *input)
 {
-	int ret = 0;
+	int ret;
 	struct ddb_port *port = input->port;
-	struct dvb_adapter *adap = input->dvb.adap;
-	struct dvb_demux *dvbdemux = &input->dvb.demux;
+	struct dvb_adapter *adap = &input->adap;
+	struct dvb_demux *dvbdemux = &input->demux;
 
-	input->dvb.attached = 1;
+	ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+				   &input->port->dev->pdev->dev,
+				   adapter_nr);
+	if (ret < 0) {
+		printk(KERN_ERR "ddbridge: Could not register adapter."
+		       "Check if you enabled enough adapters in dvb-core!\n");
+		return ret;
+	}
+	input->attached = 1;
 
 	ret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",
 				      start_feed,
 				      stop_feed, input);
 	if (ret < 0)
 		return ret;
-	input->dvb.attached = 2;
+	input->attached = 2;
 
-	ret = my_dvb_dmxdev_ts_card_init(&input->dvb.dmxdev,
-					 &input->dvb.demux,
-					 &input->dvb.hw_frontend,
-					 &input->dvb.mem_frontend, adap);
+	ret = my_dvb_dmxdev_ts_card_init(&input->dmxdev, &input->demux,
+					 &input->hw_frontend,
+					 &input->mem_frontend, adap);
 	if (ret < 0)
 		return ret;
-	input->dvb.attached = 3;
+	input->attached = 3;
 
-	ret = dvb_net_init(adap, &input->dvb.dvbnet, input->dvb.dmxdev.demux);
+	ret = dvb_net_init(adap, &input->dvbnet, input->dmxdev.demux);
 	if (ret < 0)
 		return ret;
-	input->dvb.attached = 4;
+	input->attached = 4;
 
-	input->dvb.fe = 0;
+	input->fe = 0;
 	switch (port->type) {
 	case DDB_TUNER_DVBS_ST:
 		if (demod_attach_stv0900(input, 0) < 0)
 			return -ENODEV;
 		if (tuner_attach_stv6110(input, 0) < 0)
 			return -ENODEV;
+		if (input->fe) {
+			if (dvb_register_frontend(adap, input->fe) < 0)
+				return -ENODEV;
+		}
 		break;
 	case DDB_TUNER_DVBS_ST_AA:
 		if (demod_attach_stv0900(input, 1) < 0)
 			return -ENODEV;
 		if (tuner_attach_stv6110(input, 1) < 0)
 			return -ENODEV;
+		if (input->fe) {
+			if (dvb_register_frontend(adap, input->fe) < 0)
+				return -ENODEV;
+		}
 		break;
 	case DDB_TUNER_DVBCT_TR:
 		if (demod_attach_drxk(input) < 0)
 			return -ENODEV;
 		if (tuner_attach_tda18271(input) < 0)
 			return -ENODEV;
+		if (input->fe) {
+			if (dvb_register_frontend(adap, input->fe) < 0)
+				return -ENODEV;
+		}
+		if (input->fe2) {
+			if (dvb_register_frontend(adap, input->fe2) < 0)
+				return -ENODEV;
+			input->fe2->tuner_priv = input->fe->tuner_priv;
+			memcpy(&input->fe2->ops.tuner_ops,
+			       &input->fe->ops.tuner_ops,
+			       sizeof(struct dvb_tuner_ops));
+		}
 		break;
-	case DDB_TUNER_DVBCT_ST:
-		if (demod_attach_stv0367dd(input) < 0)
-			return -ENODEV;
-		if (tuner_attach_tda18212dd(input) < 0)
-			return -ENODEV;
-		break;
-	}
-	input->dvb.attached = 5;
-	if (input->dvb.fe) {
-		if (dvb_register_frontend(adap, input->dvb.fe) < 0)
-			return -ENODEV;
-	}
-	if (input->dvb.fe2) {
-		if (dvb_register_frontend(adap, input->dvb.fe2) < 0)
-			return -ENODEV;
-		input->dvb.fe2->tuner_priv = input->dvb.fe->tuner_priv;
-		memcpy(&input->dvb.fe2->ops.tuner_ops,
-		       &input->dvb.fe->ops.tuner_ops,
-		       sizeof(struct dvb_tuner_ops));
 	}
-	input->dvb.attached = 6;
+	input->attached = 5;
 	return 0;
 }
 
@@ -1288,8 +910,7 @@
 			if (file->f_flags & O_NONBLOCK)
 				break;
 			if (wait_event_interruptible(
-				    output->dma->wq,
-				    ddb_output_free(output) >= 188) < 0)
+				    output->wq, ddb_output_free(output) >= 188) < 0)
 				break;
 		}
 		stat = ddb_output_write(output, buf, left);
@@ -1316,7 +937,7 @@
 			if (file->f_flags & O_NONBLOCK)
 				break;
 			if (wait_event_interruptible(
-				    input->dma->wq, ddb_input_avail(input) >= 188) < 0)
+				    input->wq, ddb_input_avail(input) >= 188) < 0)
 				break;
 		}
 		read = ddb_input_read(input, buf, left);
@@ -1349,38 +970,6 @@
 	return mask;
 }
 
-#if 0
-static int ts_release(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ddb_output *output = dvbdev->priv;
-	struct ddb_input *input = output->port->input[0];
-
-
-	return dvb_generic_release(inode, file);
-}
-
-static unsigned int ts_open(struct inode *inode, struct file *file)
-{
-	int err;
-	struct dvb_device *dvbdev = file->private_data;
-	struct ddb_output *output = dvbdev->priv;
-	struct ddb_input *input = output->port->input[0];
-
-	err = dvb_generic_open(inode, file);
-	if (err < 0)
-		return err;
-
-#if 0
-	if ((file->f_flags & O_ACCMODE) == O_RDONLY)
-		ddb_input_start(input);
-	else
-		ddb_output_start(output);
-#endif
-	return err;
-}
-#endif
-
 static const struct file_operations ci_fops = {
 	.owner   = THIS_MODULE,
 	.read    = ts_read,
@@ -1393,9 +982,9 @@
 
 static struct dvb_device dvbdev_ci = {
 	.priv    = 0,
-	.readers = 1,
-	.writers = 1,
-	.users   = 2,
+	.readers = -1,
+	.writers = -1,
+	.users   = -1,
 	.fops    = &ci_fops,
 };
 
@@ -1403,297 +992,53 @@
 /****************************************************************************/
 /****************************************************************************/
 
-static int set_redirect(u32 i, u32 p)
-{
-	struct ddb *idev = ddbs[(i >> 4) & 0x1f];
-	struct ddb_input *input;
-	struct ddb *pdev = ddbs[(p >> 4) & 0x1f];
-	struct ddb_port *port;
-
-	if (!idev || !pdev)
-		return -EINVAL;
-
-	port = &pdev->port[p & 3];
-	if (port->class != DDB_PORT_CI && port->class != DDB_PORT_LOOP)
-		return -EINVAL;
-
-	ddb_unredirect(port);
-	if (i == 8)
-		return 0;
-	input = &idev->input[i & 7];
-	if (input->port->class != DDB_PORT_TUNER)
-		port->input[0]->redirect = input->redirect;
-	else
-		port->input[0]->redirect = input;
-	input->redirect = port->input[0];
-	port->output->redirect = input;
-
-	ddb_redirect_dma(input->port->dev, input->dma, port->output->dma);
-	return 0;
-}
-
-static void input_write_output(struct ddb_input *input,
-			       struct ddb_output *output)
-{
-	ddbwritel(output->port->dev,
-		  input->dma->stat, DMA_BUFFER_ACK(output->dma->nr));
-}
-
-static void output_ack_input(struct ddb_output *output,
-			     struct ddb_input *input)
-{
-	ddbwritel(input->port->dev,
-		  output->dma->stat, DMA_BUFFER_ACK(input->dma->nr));
-}
-
-static void input_write_dvb(struct ddb_input *input, struct ddb_dvb *dvb)
-{
-	struct ddb_dma *dma = input->dma;
-	struct ddb *dev = input->port->dev;
-
-	if (4 & ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr)))
-		printk(KERN_ERR "Overflow dma %d\n", dma->nr);
-	while (dma->cbuf != ((dma->stat >> 11) & 0x1f)
-	       || (4 & ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr)))) {
-		dvb_dmx_swfilter_packets(&dvb->demux,
-					 dma->vbuf[dma->cbuf],
-					 dma->size / 188);
-		dma->cbuf = (dma->cbuf + 1) % dma->num;
-		ddbwritel(dev, (dma->cbuf << 11),  DMA_BUFFER_ACK(dma->nr));
-		dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
-	}
-}
-
 static void input_tasklet(unsigned long data)
 {
 	struct ddb_input *input = (struct ddb_input *) data;
-	struct ddb_dma *dma = input->dma;
 	struct ddb *dev = input->port->dev;
 
-	spin_lock(&dma->lock);
-	if (!dma->running) {
-		spin_unlock(&dma->lock);
+	spin_lock(&input->lock);
+	if (!input->running) {
+		spin_unlock(&input->lock);
 		return;
 	}
-	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+	input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
 
 	if (input->port->class == DDB_PORT_TUNER) {
-		if (input->redirect)
-			input_write_output(input,
-					   input->redirect->port->output);
-		else
-			input_write_dvb(input, &input->dvb);
-	}
-	if (input->port->class == DDB_PORT_CI ||
-	    input->port->class == DDB_PORT_LOOP) {
-		if (input->redirect) {
-			if (input->redirect->port->class == DDB_PORT_TUNER)
-				input_write_dvb(input, &input->redirect->dvb);
-			else
-				input_write_output(input,
-						   input->redirect->port->output);
-		} else
-			wake_up(&dma->wq);
-	}
-	spin_unlock(&dma->lock);
+		if (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))
+			printk(KERN_ERR "Overflow input %d\n", input->nr);
+		while (input->cbuf != ((input->stat >> 11) & 0x1f)
+		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
+			dvb_dmx_swfilter_packets(&input->demux,
+						 input->vbuf[input->cbuf],
+						 input->dma_buf_size / 188);
+
+			input->cbuf = (input->cbuf + 1) % input->dma_buf_num;
+			ddbwritel((input->cbuf << 11),
+				  DMA_BUFFER_ACK(input->nr));
+			input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
+		       }
+	}
+	if (input->port->class == DDB_PORT_CI)
+		wake_up(&input->wq);
+	spin_unlock(&input->lock);
 }
 
 static void output_tasklet(unsigned long data)
 {
 	struct ddb_output *output = (struct ddb_output *) data;
-	struct ddb_dma *dma = output->dma;
 	struct ddb *dev = output->port->dev;
 
-	spin_lock(&dma->lock);
-	if (!dma->running) {
-		spin_unlock(&dma->lock);
+	spin_lock(&output->lock);
+	if (!output->running) {
+		spin_unlock(&output->lock);
 		return;
 	}
-	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
-	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
-	if (output->redirect)
-		output_ack_input(output, output->redirect);
-	wake_up(&dma->wq);
-	spin_unlock(&dma->lock);
-}
-
-#if 0
-static void io_tasklet(unsigned long data)
-{
-	struct ddb_dma *dma = (struct ddb_dma *) data;
-
-	spin_lock(&dma->lock);
-	if (!dma->running) {
-		spin_unlock(&dma->lock);
-		return;
-	}
-	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
-	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
-	if (dma->nr & 8)
-		handle_output((struct ddb_output *) dma->io);
-	else
-		handle_input((struct ddb_input *) dma->io);
-	wake_up(&dma->wq);
-	spin_unlock(&dma->lock);
-}
-#endif
-
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
-
-static int wait_ci_ready(struct ddb_ci *ci)
-{
-	u32 count = 100;
-
-	do {
-		if (ddbreadl(ci->port->dev,
-			     CI_CONTROL(ci->nr)) & CI_READY)
-			break;
-		msleep(1);
-		if ((--count) == 0)
-			return -1;
-	} while (1);
-	return 0;
-}
-
-static int read_attribute_mem(struct dvb_ca_en50221 *ca,
-			      int slot, int address)
-{
-	struct ddb_ci *ci = ca->data;
-	u32 val, off = (address >> 1) & (CI_BUFFER_SIZE-1);
-
-	if (address > CI_BUFFER_SIZE)
-		return -1;
-	ddbwritel(ci->port->dev, CI_READ_CMD | (1 << 16) | address,
-		  CI_DO_READ_ATTRIBUTES(ci->nr));
-	wait_ci_ready(ci);
-	val = 0xff & ddbreadl(ci->port->dev, CI_BUFFER(ci->nr) + off);
-	/* printk("%04x: %02x\n", address, val); */
-	return val;
-}
-
-static int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,
-			       int address, u8 value)
-{
-	struct ddb_ci *ci = ca->data;
-
-	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
-		  CI_DO_ATTRIBUTE_RW(ci->nr));
-	wait_ci_ready(ci);
-	return 0;
-}
-
-static int read_cam_control(struct dvb_ca_en50221 *ca,
-			    int slot, u8 address)
-{
-	u32 count = 100;
-	struct ddb_ci *ci = ca->data;
-	u32 res;
-
-	ddbwritel(ci->port->dev, CI_READ_CMD | address,
-		  CI_DO_IO_RW(ci->nr));
-	do {
-		res = ddbreadl(ci->port->dev, CI_READDATA(ci->nr));
-		if (res & CI_READY)
-			break;
-		msleep(1);
-		if ((--count) == 0)
-			return -1;
-	} while (1);
-	return 0xff & res;
-}
-
-static int write_cam_control(struct dvb_ca_en50221 *ca, int slot,
-			     u8 address, u8 value)
-{
-	struct ddb_ci *ci = ca->data;
-
-	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
-		  CI_DO_IO_RW(ci->nr));
-	wait_ci_ready(ci);
-	return 0;
-}
-
-static int slot_reset(struct dvb_ca_en50221 *ca, int slot)
-{
-	struct ddb_ci *ci = ca->data;
-
-	printk(KERN_INFO "slot reset %d\n", ci->nr);
-	ddbwritel(ci->port->dev, CI_POWER_ON,
-		  CI_CONTROL(ci->nr));
-	msleep(300);
-	ddbwritel(ci->port->dev, CI_POWER_ON | CI_RESET_CAM,
-		  CI_CONTROL(ci->nr));
-	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON | CI_RESET_CAM,
-		  CI_CONTROL(ci->nr));
-	udelay(20);
-	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON,
-		  CI_CONTROL(ci->nr));
-	return 0;
-}
-
-static int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
-{
-	struct ddb_ci *ci = ca->data;
-
-	printk(KERN_INFO "slot shutdown\n");
-	ddbwritel(ci->port->dev, 0, CI_CONTROL(ci->nr));
-	return 0;
-}
-
-static int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
-{
-	struct ddb_ci *ci = ca->data;
-	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
-
-	ddbwritel(ci->port->dev, val | CI_BYPASS_DISABLE,
-		  CI_CONTROL(ci->nr));
-	return 0;
+	output->stat = ddbreadl(DMA_BUFFER_CURRENT(output->nr + 8));
+	wake_up(&output->wq);
+	spin_unlock(&output->lock);
 }
 
-static int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)
-{
-	struct ddb_ci *ci = ca->data;
-	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
-	int stat = 0;
-
-	if (val & CI_CAM_DETECT)
-		stat |= DVB_CA_EN50221_POLL_CAM_PRESENT;
-	if (val & CI_CAM_READY)
-		stat |= DVB_CA_EN50221_POLL_CAM_READY;
-	return stat;
-}
-
-static struct dvb_ca_en50221 en_templ = {
-	.read_attribute_mem  = read_attribute_mem,
-	.write_attribute_mem = write_attribute_mem,
-	.read_cam_control    = read_cam_control,
-	.write_cam_control   = write_cam_control,
-	.slot_reset          = slot_reset,
-	.slot_shutdown       = slot_shutdown,
-	.slot_ts_enable      = slot_ts_enable,
-	.poll_slot_status    = poll_slot_status,
-};
-
-static void ci_attach(struct ddb_port *port)
-{
-	struct ddb_ci *ci = 0;
-
-	ci = kzalloc(sizeof(*ci), GFP_KERNEL);
-	if (!ci)
-		return;
-	memcpy(&ci->en, &en_templ, sizeof(en_templ));
-	ci->en.data = ci;
-	port->en = &ci->en;
-	ci->port = port;
-	ci->nr = port->nr - 2;
-}
-
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
-
 
 struct cxd2099_cfg cxd_cfg = {
 	.bitrate =  62000,
@@ -1704,22 +1049,28 @@
 
 static int ddb_ci_attach(struct ddb_port *port)
 {
-	if (port->type == DDB_CI_EXTERNAL_SONY) {
-		port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
-		if (!port->en)
-			return -ENODEV;
-		dvb_ca_en50221_init(port->input[0]->dvb.adap,
-				    port->en, 0, 1);
-	}
-#if 1
-	if (port->type == DDB_CI_INTERNAL) {
-		ci_attach(port);
-		if (!port->en)
-			return -ENODEV;
-		dvb_ca_en50221_init(port->input[0]->dvb.adap, port->en, 0, 1);
+	int ret;
+
+	ret = dvb_register_adapter(&port->output->adap,
+				   "DDBridge",
+				   THIS_MODULE,
+				   &port->dev->pdev->dev,
+				   adapter_nr);
+	if (ret < 0)
+		return ret;
+	port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
+	if (!port->en) {
+		dvb_unregister_adapter(&port->output->adap);
+		return -ENODEV;
 	}
-#endif
-	return 0;
+	ddb_input_start(port->input[0]);
+	ddb_output_start(port->output);
+	dvb_ca_en50221_init(&port->output->adap,
+			    port->en, 0, 1);
+	ret = dvb_register_device(&port->output->adap, &port->output->dev,
+				  &dvbdev_ci, (void *) port->output,
+				  DVB_DEVICE_SEC);
+	return ret;
 }
 
 static int ddb_port_attach(struct ddb_port *port)
@@ -1735,15 +1086,6 @@
 		break;
 	case DDB_PORT_CI:
 		ret = ddb_ci_attach(port);
-		if (ret < 0)
-			break;
-	case DDB_PORT_LOOP:
-		ddb_input_start(port->input[0]);
-		ddb_output_start(port->output);
-		ret = dvb_register_device(port->input[0]->dvb.adap,
-					  &port->input[0]->dvb.dev,
-					  &dvbdev_ci, (void *) port->output,
-					  DVB_DEVICE_SEC);
 		break;
 	default:
 		break;
@@ -1758,10 +1100,6 @@
 	int i, ret = 0;
 	struct ddb_port *port;
 
-	ret = dvb_register_adapters(dev);
-	if (ret < 0)
-		return ret;
-
 	for (i = 0; i < dev->info->port_num; i++) {
 		port = &dev->port[i];
 		ret = ddb_port_attach(port);
@@ -1784,26 +1122,25 @@
 			dvb_input_detach(port->input[1]);
 			break;
 		case DDB_PORT_CI:
-		case DDB_PORT_LOOP:
-			if (port->input[0]->dvb.dev)
-				dvb_unregister_device(port->input[0]->dvb.dev);
-			ddb_input_stop(port->input[0]);
-			ddb_output_stop(port->output);
+			if (port->output->dev)
+				dvb_unregister_device(port->output->dev);
 			if (port->en) {
+				ddb_input_stop(port->input[0]);
+				ddb_output_stop(port->output);
 				dvb_ca_en50221_release(port->en);
 				kfree(port->en);
 				port->en = 0;
+				dvb_unregister_adapter(&port->output->adap);
 			}
 			break;
 		}
 	}
-	dvb_unregister_adapters(dev);
 }
 
 /****************************************************************************/
 /****************************************************************************/
 
-static int port_has_cxd(struct ddb_port *port)
+static int port_has_ci(struct ddb_port *port)
 {
 	u8 val;
 	return i2c_read_reg(&port->i2c->adap, 0x40, 0, &val) ? 0 : 1;
@@ -1835,21 +1172,6 @@
 	return 1;
 }
 
-static int port_has_stv0367(struct ddb_port *port)
-{
-	u8 val;
-
-	if (i2c_read_reg16(&port->i2c->adap, 0x1e, 0xf000, &val) < 0)
-		return 0;
-	if (val != 0x60)
-		return 0;
-	if (i2c_read_reg16(&port->i2c->adap, 0x1f, 0xf000, &val) < 0)
-		return 0;
-	if (val != 0x60)
-		return 0;
-	return 1;
-}
-
 static void ddb_port_probe(struct ddb_port *port)
 {
 	struct ddb *dev = port->dev;
@@ -1857,92 +1179,62 @@
 
 	port->class = DDB_PORT_NONE;
 
-	if (port->nr > 1 && dev->info->type == DDB_OCTOPUS_CI) {
-		modname = "CI internal";
-		port->class = DDB_PORT_CI;
-		port->type = DDB_CI_INTERNAL;
-	} else if (port_has_cxd(port)) {
+	if (port_has_ci(port)) {
 		modname = "CI";
 		port->class = DDB_PORT_CI;
-		port->type = DDB_CI_EXTERNAL_SONY;
-		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
 	} else if (port_has_stv0900(port)) {
 		modname = "DUAL DVB-S2";
 		port->class = DDB_PORT_TUNER;
 		port->type = DDB_TUNER_DVBS_ST;
-		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
 	} else if (port_has_stv0900_aa(port)) {
 		modname = "DUAL DVB-S2";
 		port->class = DDB_PORT_TUNER;
 		port->type = DDB_TUNER_DVBS_ST_AA;
-		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
 	} else if (port_has_drxks(port)) {
 		modname = "DUAL DVB-C/T";
 		port->class = DDB_PORT_TUNER;
 		port->type = DDB_TUNER_DVBCT_TR;
-		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
-	} else if (port_has_stv0367(port)) {
-		modname = "DUAL DVB-C/T";
-		port->class = DDB_PORT_TUNER;
-		port->type = DDB_TUNER_DVBCT_ST;
-		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
-	} else if (port->nr == ts_loop) {
-		modname = "TS LOOP";
-		port->class = DDB_PORT_LOOP;
-	}
-	printk(KERN_INFO "Port %d (TAB %d): %s\n", port->nr, port->nr+1, modname);
-}
-
-static void ddb_dma_init(struct ddb_dma *dma, int nr, void *io)
-{
-	unsigned long priv = (unsigned long) io;
-
-	dma->io = io;
-	dma->nr = nr;
-	spin_lock_init(&dma->lock);
-	init_waitqueue_head(&dma->wq);
-	if (nr & 8) {
-		tasklet_init(&dma->tasklet, output_tasklet, priv);
-		dma->num = OUTPUT_DMA_BUFS;
-		dma->size = OUTPUT_DMA_SIZE;
-		dma->div = OUTPUT_DMA_IRQ_DIV;
-	} else {
-		tasklet_init(&dma->tasklet, input_tasklet, priv);
-		dma->num = INPUT_DMA_BUFS;
-		dma->size = INPUT_DMA_SIZE;
-		dma->div = INPUT_DMA_IRQ_DIV;
+		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
 	}
+	printk(KERN_INFO "Port %d (TAB %d): %s\n",
+			 port->nr, port->nr+1, modname);
 }
 
-static void ddb_input_init(struct ddb_port *port, int nr, int pnr)
+static void ddb_input_init(struct ddb_port *port, int nr)
 {
 	struct ddb *dev = port->dev;
 	struct ddb_input *input = &dev->input[nr];
 
-	port->input[pnr] = input;
 	input->nr = nr;
 	input->port = port;
-	input->dma = &dev->dma[nr];
-	ddb_dma_init(input->dma, nr, (void *) input);
-	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
-	ddbwritel(dev, 2, TS_INPUT_CONTROL(nr));
-	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
-	ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
-	input->dvb.adap = &dev->adap[input->nr];
+	input->dma_buf_num = INPUT_DMA_BUFS;
+	input->dma_buf_size = INPUT_DMA_SIZE;
+	ddbwritel(0, TS_INPUT_CONTROL(nr));
+	ddbwritel(2, TS_INPUT_CONTROL(nr));
+	ddbwritel(0, TS_INPUT_CONTROL(nr));
+	ddbwritel(0, DMA_BUFFER_ACK(nr));
+	tasklet_init(&input->tasklet, input_tasklet, (unsigned long) input);
+	spin_lock_init(&input->lock);
+	init_waitqueue_head(&input->wq);
 }
 
 static void ddb_output_init(struct ddb_port *port, int nr)
 {
 	struct ddb *dev = port->dev;
 	struct ddb_output *output = &dev->output[nr];
-	port->output = output;
 	output->nr = nr;
 	output->port = port;
-	output->dma = &dev->dma[nr + 8];
-	ddb_dma_init(output->dma, nr + 8, (void *) output);
-	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
-	ddbwritel(dev, 2, TS_OUTPUT_CONTROL(nr));
-	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
+	output->dma_buf_num = OUTPUT_DMA_BUFS;
+	output->dma_buf_size = OUTPUT_DMA_SIZE;
+
+	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
+	ddbwritel(2, TS_OUTPUT_CONTROL(nr));
+	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
+	tasklet_init(&output->tasklet, output_tasklet, (unsigned long) output);
+	init_waitqueue_head(&output->wq);
 }
 
 static void ddb_ports_init(struct ddb *dev)
@@ -1955,16 +1247,14 @@
 		port->dev = dev;
 		port->nr = i;
 		port->i2c = &dev->i2c[i];
+		port->input[0] = &dev->input[2 * i];
+		port->input[1] = &dev->input[2 * i + 1];
+		port->output = &dev->output[i];
 
 		mutex_init(&port->i2c_gate_lock);
 		ddb_port_probe(port);
-		if (i >= 2 && dev->info->type == DDB_OCTOPUS_CI) {
-			ddb_input_init(port, 2 + i, 0);
-			ddb_input_init(port, 4 + i, 1);
-		} else {
-			ddb_input_init(port, 2 * i, 0);
-			ddb_input_init(port, 2 * i + 1, 1);
-		}
+		ddb_input_init(port, 2 * i);
+		ddb_input_init(port, 2 * i + 1);
 		ddb_output_init(port, i);
 	}
 }
@@ -1977,12 +1267,9 @@
 	for (i = 0; i < dev->info->port_num; i++) {
 		port = &dev->port[i];
 		port->dev = dev;
-		if (port->input[0])
-			tasklet_kill(&port->input[0]->dma->tasklet);
-		if (port->input[1])
-			tasklet_kill(&port->input[1]->dma->tasklet);
-		if (port->output)
-			tasklet_kill(&port->output->dma->tasklet);
+		tasklet_kill(&port->input[0]->tasklet);
+		tasklet_kill(&port->input[1]->tasklet);
+		tasklet_kill(&port->output->tasklet);
 	}
 }
 
@@ -2001,18 +1288,13 @@
 static irqreturn_t irq_handler(int irq, void *dev_id)
 {
 	struct ddb *dev = (struct ddb *) dev_id;
-	u32 s = ddbreadl(dev, INTERRUPT_STATUS);
+	u32 s = ddbreadl(INTERRUPT_STATUS);
 
 	if (!s)
 		return IRQ_NONE;
 
 	do {
-		ddbwritel(dev, s, INTERRUPT_ACK);
-
-		if (s & 0x0000000f)
-			dev->i2c_irq++;
-		if (s & 0x000fff00)
-			dev->ts_irq++;
+		ddbwritel(s, INTERRUPT_ACK);
 
 		if (s & 0x00000001)
 			irq_handle_i2c(dev, 0);
@@ -2024,32 +1306,33 @@
 			irq_handle_i2c(dev, 3);
 
 		if (s & 0x00000100)
-			tasklet_schedule(&dev->dma[0].tasklet);
+			tasklet_schedule(&dev->input[0].tasklet);
 		if (s & 0x00000200)
-			tasklet_schedule(&dev->dma[1].tasklet);
+			tasklet_schedule(&dev->input[1].tasklet);
 		if (s & 0x00000400)
-			tasklet_schedule(&dev->dma[2].tasklet);
+			tasklet_schedule(&dev->input[2].tasklet);
 		if (s & 0x00000800)
-			tasklet_schedule(&dev->dma[3].tasklet);
+			tasklet_schedule(&dev->input[3].tasklet);
 		if (s & 0x00001000)
-			tasklet_schedule(&dev->dma[4].tasklet);
+			tasklet_schedule(&dev->input[4].tasklet);
 		if (s & 0x00002000)
-			tasklet_schedule(&dev->dma[5].tasklet);
+			tasklet_schedule(&dev->input[5].tasklet);
 		if (s & 0x00004000)
-			tasklet_schedule(&dev->dma[6].tasklet);
+			tasklet_schedule(&dev->input[6].tasklet);
 		if (s & 0x00008000)
-			tasklet_schedule(&dev->dma[7].tasklet);
+			tasklet_schedule(&dev->input[7].tasklet);
+
 		if (s & 0x00010000)
-			tasklet_schedule(&dev->dma[8].tasklet);
+			tasklet_schedule(&dev->output[0].tasklet);
 		if (s & 0x00020000)
-			tasklet_schedule(&dev->dma[9].tasklet);
+			tasklet_schedule(&dev->output[1].tasklet);
 		if (s & 0x00040000)
-			tasklet_schedule(&dev->dma[10].tasklet);
+			tasklet_schedule(&dev->output[2].tasklet);
 		if (s & 0x00080000)
-			tasklet_schedule(&dev->dma[11].tasklet);
+			tasklet_schedule(&dev->output[3].tasklet);
 
-		/* if (s & 0x000f0000)	printk("%08x\n", istat); */
-	} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));
+		/* if (s & 0x000f0000)	printk(KERN_DEBUG "%08x\n", istat); */
+	} while ((s = ddbreadl(INTERRUPT_STATUS)));
 
 	return IRQ_HANDLED;
 }
@@ -2063,21 +1346,21 @@
 	u32 data, shift;
 
 	if (wlen > 4)
-		ddbwritel(dev, 1, SPI_CONTROL);
+		ddbwritel(1, SPI_CONTROL);
 	while (wlen > 4) {
 		/* FIXME: check for big-endian */
 		data = swab32(*(u32 *)wbuf);
 		wbuf += 4;
 		wlen -= 4;
-		ddbwritel(dev, data, SPI_DATA);
-		while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+		ddbwritel(data, SPI_DATA);
+		while (ddbreadl(SPI_CONTROL) & 0x0004)
 			;
 	}
 
 	if (rlen)
-		ddbwritel(dev, 0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+		ddbwritel(0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
 	else
-		ddbwritel(dev, 0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+		ddbwritel(0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
 
 	data = 0;
 	shift = ((4 - wlen) * 8);
@@ -2089,33 +1372,33 @@
 	}
 	if (shift)
 		data <<= shift;
-	ddbwritel(dev, data, SPI_DATA);
-	while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+	ddbwritel(data, SPI_DATA);
+	while (ddbreadl(SPI_CONTROL) & 0x0004)
 		;
 
 	if (!rlen) {
-		ddbwritel(dev, 0, SPI_CONTROL);
+		ddbwritel(0, SPI_CONTROL);
 		return 0;
 	}
 	if (rlen > 4)
-		ddbwritel(dev, 1, SPI_CONTROL);
+		ddbwritel(1, SPI_CONTROL);
 
 	while (rlen > 4) {
-		ddbwritel(dev, 0xffffffff, SPI_DATA);
-		while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+		ddbwritel(0xffffffff, SPI_DATA);
+		while (ddbreadl(SPI_CONTROL) & 0x0004)
 			;
-		data = ddbreadl(dev, SPI_DATA);
+		data = ddbreadl(SPI_DATA);
 		*(u32 *) rbuf = swab32(data);
 		rbuf += 4;
 		rlen -= 4;
 	}
-	ddbwritel(dev, 0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
-	ddbwritel(dev, 0xffffffff, SPI_DATA);
-	while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+	ddbwritel(0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
+	ddbwritel(0xffffffff, SPI_DATA);
+	while (ddbreadl(SPI_CONTROL) & 0x0004)
 		;
 
-	data = ddbreadl(dev, SPI_DATA);
-	ddbwritel(dev, 0, SPI_CONTROL);
+	data = ddbreadl(SPI_DATA);
+	ddbwritel(0, SPI_CONTROL);
 
 	if (rlen < 4)
 		data <<= ((4 - rlen) * 8);
@@ -2138,21 +1421,14 @@
 	__u32 read_len;
 };
 
-struct ddb_gpio {
-	__u32 mask;
-	__u32 data;
-};
-
-
 #define IOCTL_DDB_FLASHIO  _IOWR(DDB_MAGIC, 0x00, struct ddb_flashio)
-#define IOCTL_DDB_GPIO_IN  _IOWR(DDB_MAGIC, 0x01, struct ddb_gpio)
-#define IOCTL_DDB_GPIO_OUT _IOWR(DDB_MAGIC, 0x02, struct ddb_gpio)
 
 #define DDB_NAME "ddbridge"
 
 static u32 ddb_num;
+static struct ddb *ddbs[32];
+static struct class *ddb_class;
 static int ddb_major;
-static DEFINE_MUTEX(ddb_mutex);
 
 static int ddb_open(struct inode *inode, struct file *file)
 {
@@ -2194,16 +1470,6 @@
 			return -EFAULT;
 		break;
 	}
-	case IOCTL_DDB_GPIO_OUT:
-	{
-		struct ddb_gpio gpio;
-		if (copy_from_user(&gpio, parg, sizeof(gpio)))
-			break;
-		ddbwritel(dev, gpio.mask, GPIO_DIRECTION);
-		ddbwritel(dev, gpio.data, GPIO_OUTPUT);
-		res = 0;
-		break;
-	}
 	default:
 		return -ENOTTY;
 	}
@@ -2215,248 +1481,41 @@
 	.open           = ddb_open,
 };
 
-static char *ddb_devnode(struct device *device, mode_t *mode)
+static char *ddb_devnode(struct device *device, umode_t *mode)
 {
 	struct ddb *dev = dev_get_drvdata(device);
 
 	return kasprintf(GFP_KERNEL, "ddbridge/card%d", dev->nr);
 }
 
-static ssize_t ports_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-
-	return sprintf(buf, "%d\n", dev->info->port_num);
-}
-
-static ssize_t ts_irq_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-
-	return sprintf(buf, "%d\n", dev->ts_irq);
-}
-
-static ssize_t i2c_irq_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-
-	return sprintf(buf, "%d\n", dev->i2c_irq);
-}
-
-static char *class_name[] = {
-	"NONE", "CI", "TUNER", "LOOP"
-};
-
-static char *type_name[] = {
-	"NONE", "DVBS_ST", "DVBS_ST_AA", "DVBCT_TR", "DVBCT_ST", "INTERNAL", "CXD2099",
-};
-
-static ssize_t fan_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	u32 val;
-
-	val = ddbreadl(dev, GPIO_OUTPUT) & 1;
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t fan_store(struct device *device, struct device_attribute *d,
-			 const char *buf, size_t count)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	unsigned val;
-
-	if (sscanf(buf, "%u\n", &val) != 1)
-		return -EINVAL;
-	ddbwritel(dev, 1, GPIO_DIRECTION);
-	ddbwritel(dev, val & 1, GPIO_OUTPUT);
-	return count;
-}
-
-static ssize_t temp_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	int temp;
-	u8 tmp[2];
-
-	if (!dev->info->temp_num)
-		return sprintf(buf, "no sensor\n");
-	if (i2c_read_regs(&dev->i2c[0].adap, 0x48, 0, tmp, 2) < 0)
-		return sprintf(buf, "read_error\n");
-	temp = (tmp[0] << 3) | (tmp[1] >> 5);
-	temp *= 125;
-	return sprintf(buf, "%d\n", temp);
-}
-
-static ssize_t mod_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	int num = attr->attr.name[3] - 0x30;
-
-	return sprintf(buf, "%s:%s\n",
-		       class_name[dev->port[num].class],
-		       type_name[dev->port[num].type]);
-}
-
-static ssize_t led_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	int num = attr->attr.name[3] - 0x30;
-
-	return sprintf(buf, "%d\n", dev->leds & (1 << num) ? 1 : 0);
-}
-
-
-static void ddb_set_led(struct ddb *dev, int num, int val)
-{
-	if (!dev->info->led_num)
-		return;
-	switch (dev->port[num].class) {
-	case DDB_PORT_TUNER:
-		switch (dev->port[num].type) {
-		case DDB_TUNER_DVBS_ST:
-			printk(KERN_INFO "LED %d %d\n", num, val);
-			i2c_write_reg16(&dev->i2c[num].adap,
-					0x69, 0xf14c, val ? 2 : 0);
-			break;
-		case DDB_TUNER_DVBCT_ST:
-			printk(KERN_INFO "LED %d %d\n", num, val);
-			i2c_write_reg16(&dev->i2c[num].adap,
-					0x1f, 0xf00e, 0);
-			i2c_write_reg16(&dev->i2c[num].adap,
-					0x1f, 0xf00f, val ? 1 : 0);
-			break;
-		}
-		break;
-	default:
-		break;
-	}
-}
-
-static ssize_t led_store(struct device *device, struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	int num = attr->attr.name[3] - 0x30;
-	unsigned val;
-
-	if (sscanf(buf, "%u\n", &val) != 1)
-		return -EINVAL;
-	if (val)
-		dev->leds |= (1 << num);
-	else
-		dev->leds &= ~(1 << num);
-	ddb_set_led(dev, num, val);
-	return count;
-}
-
-static ssize_t snr_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	char snr[32];
-	int num = attr->attr.name[3] - 0x30;
-
-	/* serial number at 0x100-0x11f */
-	if (i2c_read_regs16(&dev->i2c[num].adap, 0x57, 0x100, snr, 32) < 0)
-		return sprintf(buf, "NO SNR\n");
-	snr[31] = 0; /* in case it is not terminated on EEPROM */
-	return sprintf(buf, "%s\n", snr);
-}
-
-
-static ssize_t snr_store(struct device *device, struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	struct ddb *dev = dev_get_drvdata(device);
-	int num = attr->attr.name[3] - 0x30;
-	u8 snr[34] = { 0x01, 0x00 };
-
-	if (count > 31)
-		return -EINVAL;
-	memcpy(snr + 2, buf, count);
-	i2c_write(&dev->i2c[num].adap, 0x57, snr, 34);
-	return count;
-}
-
-static ssize_t redirect_show(struct device *device, struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static ssize_t redirect_store(struct device *device, struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	unsigned int i, p;
-	int res;
-
-	if (sscanf(buf, "%x %x\n", &i, &p) != 2)
-		return -EINVAL;
-	printk(KERN_INFO "redirect: %02x, %02x\n", i, p);
-	res = set_redirect(i, p);
-	if (res < 0)
-		return res;
-	return count;
-}
-
-#define __ATTR_MRO(_name, _show) {				\
-	.attr	= { .name = __stringify(_name), .mode = 0444 },	\
-	.show	= _show,					\
-}
-
-struct device_attribute ddb_attrs[] = {
-	__ATTR_RO(ports),
-	__ATTR_RO(ts_irq),
-	__ATTR_RO(i2c_irq),
-	__ATTR_MRO(mod0, mod_show),
-	__ATTR_MRO(mod1, mod_show),
-	__ATTR_MRO(mod2, mod_show),
-	__ATTR_MRO(mod3, mod_show),
-	__ATTR_RO(temp),
-	__ATTR(fan, 0666, fan_show, fan_store),
-	__ATTR(led0, 0666, led_show, led_store),
-	__ATTR(led1, 0666, led_show, led_store),
-	__ATTR(led2, 0666, led_show, led_store),
-	__ATTR(led3, 0666, led_show, led_store),
-	__ATTR(snr0, 0666, snr_show, snr_store),
-	__ATTR(snr1, 0666, snr_show, snr_store),
-	__ATTR(snr2, 0666, snr_show, snr_store),
-	__ATTR(snr3, 0666, snr_show, snr_store),
-	__ATTR(redirect, 0666, redirect_show, redirect_store),
-	__ATTR_NULL
-};
-
-static struct class ddb_class = {
-	.name		= "ddbridge",
-	.owner          = THIS_MODULE,
-	.dev_attrs	= ddb_attrs,
-	.devnode        = ddb_devnode,
-};
-
 static int ddb_class_create(void)
 {
 	ddb_major = register_chrdev(0, DDB_NAME, &ddb_fops);
 	if (ddb_major < 0)
 		return ddb_major;
-	if (class_register(&ddb_class) < 0)
+
+	ddb_class = class_create(THIS_MODULE, DDB_NAME);
+	if (IS_ERR(ddb_class)) {
+		unregister_chrdev(ddb_major, DDB_NAME);
 		return -1;
+	}
+	ddb_class->devnode = ddb_devnode;
 	return 0;
 }
 
 static void ddb_class_destroy(void)
 {
-	class_unregister(&ddb_class);
+	class_destroy(ddb_class);
 	unregister_chrdev(ddb_major, DDB_NAME);
 }
 
 static int ddb_device_create(struct ddb *dev)
 {
-	mutex_lock(&ddb_mutex);
 	dev->nr = ddb_num++;
-	ddbs[dev->nr] = dev;
-	mutex_unlock(&ddb_mutex);
-	dev->ddb_dev = device_create(&ddb_class, &dev->pdev->dev,
+	dev->ddb_dev = device_create(ddb_class, NULL,
 				     MKDEV(ddb_major, dev->nr),
 				     dev, "ddbridge%d", dev->nr);
+	ddbs[dev->nr] = dev;
 	if (IS_ERR(dev->ddb_dev))
 		return -1;
 	return 0;
@@ -2464,9 +1523,10 @@
 
 static void ddb_device_destroy(struct ddb *dev)
 {
+	ddb_num--;
 	if (IS_ERR(dev->ddb_dev))
 		return;
-	device_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));
+	device_destroy(ddb_class, MKDEV(ddb_major, 0));
 }
 
 
@@ -2489,7 +1549,7 @@
 	ddb_ports_detach(dev);
 	ddb_i2c_release(dev);
 
-	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+	ddbwritel(0, INTERRUPT_ENABLE);
 	free_irq(dev->pdev->irq, dev);
 #ifdef CONFIG_PCI_MSI
 	if (dev->msi)
@@ -2504,6 +1564,7 @@
 	pci_disable_device(pdev);
 }
 
+
 static int __devinit ddb_probe(struct pci_dev *pdev,
 			       const struct pci_device_id *id)
 {
@@ -2514,9 +1575,10 @@
 	if (pci_enable_device(pdev) < 0)
 		return -ENODEV;
 
-	dev = vzalloc(sizeof(struct ddb));
+	dev = vmalloc(sizeof(struct ddb));
 	if (dev == NULL)
 		return -ENOMEM;
+	memset(dev, 0, sizeof(struct ddb));
 
 	dev->pdev = pdev;
 	pci_set_drvdata(pdev, dev);
@@ -2529,8 +1591,7 @@
 		stat = -ENOMEM;
 		goto fail;
 	}
-	printk(KERN_INFO "HW %08x REG %08x\n",
-	       ddbreadl(dev, 0), ddbreadl(dev, 4));
+	printk(KERN_INFO "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));
 
 #ifdef CONFIG_PCI_MSI
 	if (pci_msi_enabled())
@@ -2546,11 +1607,11 @@
 			   irq_flag, "DDBridge", (void *) dev);
 	if (stat < 0)
 		goto fail1;
-	ddbwritel(dev, 0, DMA_BASE_WRITE);
-	ddbwritel(dev, 0, DMA_BASE_READ);
-	ddbwritel(dev, 0xffffffff, INTERRUPT_ACK);
-	ddbwritel(dev, 0x000fff0f, INTERRUPT_ENABLE);
-	ddbwritel(dev, 0, MSI1_ENABLE);
+	ddbwritel(0, DMA_BASE_WRITE);
+	ddbwritel(0, DMA_BASE_READ);
+	ddbwritel(0xffffffff, INTERRUPT_ACK);
+	ddbwritel(0xfff0f, INTERRUPT_ENABLE);
+	ddbwritel(0, MSI1_ENABLE);
 
 	if (ddb_i2c_init(dev) < 0)
 		goto fail1;
@@ -2561,13 +1622,7 @@
 	}
 	if (ddb_ports_attach(dev) < 0)
 		goto fail3;
-
 	ddb_device_create(dev);
-
-	if (dev->info->fan_num)	{
-		ddbwritel(dev, 1, GPIO_DIRECTION);
-		ddbwritel(dev, 1, GPIO_OUTPUT);
-	}
 	return 0;
 
 fail3:
@@ -2577,7 +1632,6 @@
 fail2:
 	printk(KERN_ERR "fail2\n");
 	ddb_buffers_free(dev);
-	ddb_i2c_release(dev);
 fail1:
 	printk(KERN_ERR "fail1\n");
 	if (dev->msi)
@@ -2604,65 +1658,23 @@
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus DVB adapter",
 	.port_num = 4,
-	.i2c_num  = 4,
 };
 
 static struct ddb_info ddb_octopus_le = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus LE DVB adapter",
 	.port_num = 2,
-	.i2c_num  = 2,
-};
-
-static struct ddb_info ddb_octopus_oem = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus OEM",
-	.port_num = 4,
-	.i2c_num  = 4,
-	.led_num  = 1,
-	.fan_num  = 1,
-	.temp_num = 1,
-};
-
-static struct ddb_info ddb_octopus_mini = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus Mini",
-	.port_num = 4,
-	.i2c_num  = 4,
 };
 
 static struct ddb_info ddb_v6 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine S2 V6 DVB adapter",
 	.port_num = 3,
-	.i2c_num  = 3,
-};
-
-static struct ddb_info ddb_dvbct = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
-	.port_num = 3,
-	.i2c_num  = 3,
-};
-
-static struct ddb_info ddb_satixS2v3 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
-	.port_num = 3,
-	.i2c_num  = 3,
 };
 
-static struct ddb_info ddb_ci = {
-	.type     = DDB_OCTOPUS_CI,
-	.name     = "Digital Devices Octopus CI",
-	.port_num = 4,
-	.i2c_num  = 2,
-};
-
-
 #define DDVID 0xdd01 /* Digital Devices Vendor ID */
 
-#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) { \
+#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) {	\
 	.vendor      = _vend,    .device    = _dev, \
 	.subvendor   = _subvend, .subdevice = _subdev, \
 	.driver_data = (unsigned long)&_driverdata }
@@ -2671,12 +1683,8 @@
 	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
 	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
 	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0003, ddb_octopus_oem),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus),
 	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
-	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
-	DDB_ID(DDVID, 0x0011, DDVID, 0x0040, ddb_ci),
 	/* in case sub-ids got deleted in flash */
 	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
 	{0}
@@ -2693,16 +1701,11 @@
 
 static __init int module_init_ddbridge(void)
 {
-	int stat;
-
 	printk(KERN_INFO "Digital Devices PCIE bridge driver, "
 	       "Copyright (C) 2010-11 Digital Devices GmbH\n");
 	if (ddb_class_create())
 		return -1;
-	stat = pci_register_driver(&ddb_pci_driver);
-	if (stat < 0)
-		ddb_class_destroy();
-	return stat;
+	return pci_register_driver(&ddb_pci_driver);
 }
 
 static __exit void module_exit_ddbridge(void)
@@ -2717,4 +1720,4 @@
 MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
 MODULE_AUTHOR("Ralph Metzler");
 MODULE_LICENSE("GPL");
-MODULE_VERSION("0.8");
+MODULE_VERSION("0.5");
diff -urN media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge.h media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge.h
--- media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge.h	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge.h	2012-02-15 05:45:37.000000000 +0100
@@ -32,10 +32,7 @@
 #include <asm/dma.h>
 #include <linux/dvb/frontend.h>
 #include <linux/dvb/ca.h>
-#include <linux/dvb/video.h>
-#include <linux/dvb/audio.h>
 #include <linux/socket.h>
-#include <linux/device.h>
 
 #include "dmxdev.h"
 #include "dvbdev.h"
@@ -55,53 +52,43 @@
 	int   type;
 #define DDB_NONE         0
 #define DDB_OCTOPUS      1
-#define DDB_OCTOPUS_CI   2
 	char *name;
 	int   port_num;
-	int   i2c_num;
-	int   led_num;
-	int   fan_num;
-	int   temp_num;
+	u32   port_type[DDB_MAX_PORT];
 };
 
 /* DMA_SIZE MUST be divisible by 188 and 128 !!! */
 
-#define DMA_MAX_BUFS 32      /* hardware table limit */
-
+#define INPUT_DMA_MAX_BUFS 32      /* hardware table limit */
 #define INPUT_DMA_BUFS 8
 #define INPUT_DMA_SIZE (128*47*21)
-#define INPUT_DMA_IRQ_DIV 1
 
+#define OUTPUT_DMA_MAX_BUFS 32
 #define OUTPUT_DMA_BUFS 8
 #define OUTPUT_DMA_SIZE (128*47*21)
-#define OUTPUT_DMA_IRQ_DIV 1
 
 struct ddb;
 struct ddb_port;
 
-struct ddb_dma {
-	void                  *io;
+struct ddb_input {
+	struct ddb_port       *port;
 	u32                    nr;
-	dma_addr_t             pbuf[DMA_MAX_BUFS];
-	u8                    *vbuf[DMA_MAX_BUFS];
-	u32                    num;
-	u32                    size;
-	u32                    div;
-	u32                    bufreg;
+	int                    attached;
+
+	dma_addr_t             pbuf[INPUT_DMA_MAX_BUFS];
+	u8                    *vbuf[INPUT_DMA_MAX_BUFS];
+	u32                    dma_buf_num;
+	u32                    dma_buf_size;
 
 	struct tasklet_struct  tasklet;
 	spinlock_t             lock;
 	wait_queue_head_t      wq;
 	int                    running;
 	u32                    stat;
-	u32                    ctrl;
 	u32                    cbuf;
 	u32                    coff;
-};
 
-struct ddb_dvb {
-	struct dvb_adapter    *adap;
-	int                    adap_registered;
+	struct dvb_adapter     adap;
 	struct dvb_device     *dev;
 	struct dvb_frontend   *fe;
 	struct dvb_frontend   *fe2;
@@ -112,36 +99,32 @@
 	struct dmx_frontend    mem_frontend;
 	int                    users;
 	int (*gate_ctrl)(struct dvb_frontend *, int);
-	int                    attached;
-};
-
-struct ddb_ci {
-	struct dvb_ca_en50221  en;
-	struct ddb_port       *port;
-	u32                    nr;
-};
-
-
-struct ddb_input {
-	struct ddb_port       *port;
-	u32                    nr;
-	struct ddb_dma        *dma;
-	struct ddb_input      *redirect;
-
-	struct ddb_dvb         dvb;
 };
 
 struct ddb_output {
 	struct ddb_port       *port;
 	u32                    nr;
-	struct ddb_dma        *dma;
-	struct ddb_input      *redirect;
+	dma_addr_t             pbuf[OUTPUT_DMA_MAX_BUFS];
+	u8                    *vbuf[OUTPUT_DMA_MAX_BUFS];
+	u32                    dma_buf_num;
+	u32                    dma_buf_size;
+	struct tasklet_struct  tasklet;
+	spinlock_t             lock;
+	wait_queue_head_t      wq;
+	int                    running;
+	u32                    stat;
+	u32                    cbuf;
+	u32                    coff;
+
+	struct dvb_adapter     adap;
+	struct dvb_device     *dev;
 };
 
 struct ddb_i2c {
 	struct ddb            *dev;
 	u32                    nr;
 	struct i2c_adapter     adap;
+	struct i2c_adapter     adap2;
 	u32                    regs;
 	u32                    rbuf;
 	u32                    wbuf;
@@ -158,15 +141,12 @@
 #define DDB_PORT_NONE           0
 #define DDB_PORT_CI             1
 #define DDB_PORT_TUNER          2
-#define DDB_PORT_LOOP           3
 	u32                    type;
 #define DDB_TUNER_NONE          0
 #define DDB_TUNER_DVBS_ST       1
 #define DDB_TUNER_DVBS_ST_AA    2
-#define DDB_TUNER_DVBCT_TR      3
-#define DDB_TUNER_DVBCT_ST      4
-#define DDB_CI_INTERNAL         5
-#define DDB_CI_EXTERNAL_SONY    6
+#define DDB_TUNER_DVBCT_TR     16
+#define DDB_TUNER_DVBCT_ST     17
 	u32                    adr;
 
 	struct ddb_input      *input[2];
@@ -181,20 +161,25 @@
 	struct ddb_i2c         i2c[DDB_MAX_I2C];
 	struct ddb_input       input[DDB_MAX_INPUT];
 	struct ddb_output      output[DDB_MAX_OUTPUT];
-	struct dvb_adapter     adap[DDB_MAX_INPUT];
-	struct ddb_dma         dma[DDB_MAX_INPUT + DDB_MAX_OUTPUT];
 
 	struct device         *ddb_dev;
-	u32                    nr;
+	int                    nr;
 	u8                     iobuf[1028];
 
 	struct ddb_info       *info;
 	int                    msi;
+};
 
-	u8                     leds;
+/****************************************************************************/
 
-	u32                    ts_irq;
-	u32                    i2c_irq;
-};
+#define ddbwritel(_val, _adr)        writel((_val), \
+				     (char *) (dev->regs+(_adr)))
+#define ddbreadl(_adr)               readl((char *) (dev->regs+(_adr)))
+#define ddbcpyto(_adr, _src, _count) memcpy_toio((char *)	\
+				     (dev->regs+(_adr)), (_src), (_count))
+#define ddbcpyfrom(_dst, _adr, _count) memcpy_fromio((_dst), (char *) \
+				       (dev->regs+(_adr)), (_count))
+
+/****************************************************************************/
 
 #endif
diff -urN media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-regs.h media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-regs.h
--- media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-regs.h	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/ddbridge-regs.h	2011-07-11 20:09:53.000000000 +0200
@@ -21,12 +21,11 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  */
 
-/* DD-DVBBridgeV1.h 388 2011-07-13 20:47:08Z manfred */
+/* DD-DVBBridgeV1.h 273 2010-09-17 05:03:16Z manfred */
 
 /* Register Definitions */
 
-#define CUR_REGISTERMAP_VERSION     0x10003
-#define CUR_REGISTERMAP_VERSION_CI  0x10000
+#define CUR_REGISTERMAP_VERSION 0x10000
 
 #define HARDWARE_VERSION       0x00
 #define REGISTERMAP_VERSION    0x04
@@ -37,14 +36,8 @@
 #define SPI_CONTROL     0x10
 #define SPI_DATA        0x14
 
-/* -------------------------------------------------------------------------- */
-/* GPIO */
-
-#define GPIO_OUTPUT      0x20
-#define GPIO_INPUT       0x24
-#define GPIO_DIRECTION   0x28
+/* ------------------------------------------------------------------------- */
 
-/* -------------------------------------------------------------------------- */
 /* Interrupt controller                                     */
 /* How many MSI's are available depends on HW (Min 2 max 8) */
 /* How many are usable also depends on Host platform        */
@@ -156,46 +149,3 @@
 #define DMA_BASE_ADDRESS_TABLE  (0x2000)
 #define DMA_BASE_ADDRESS_TABLE_ENTRIES (512)
 
-/* -------------------------------------------------------------------------- */
-/* CI Interface (only CI-Bridge) */
-
-#define CI_BASE                     (0x400)
-#define CI_CONTROL(i)               (CI_BASE + (i) * 32 + 0x00)
-
-#define CI_DO_ATTRIBUTE_RW(i)       (CI_BASE + (i) * 32 + 0x04)
-#define CI_DO_IO_RW(i)              (CI_BASE + (i) * 32 + 0x08)
-#define CI_READDATA(i)              (CI_BASE + (i) * 32 + 0x0c)
-#define CI_DO_READ_ATTRIBUTES(i)    (CI_BASE + (i) * 32 + 0x10)
-
-#define CI_RESET_CAM                    (0x00000001)
-#define CI_POWER_ON                     (0x00000002)
-#define CI_ENABLE                       (0x00000004)
-#define CI_BLOCKIO_ENABLE               (0x00000008)
-#define CI_BYPASS_DISABLE               (0x00000010)
-#define CI_DISABLE_AUTO_OFF             (0x00000020)
-
-#define CI_CAM_READY                    (0x00010000)
-#define CI_CAM_DETECT                   (0x00020000)
-#define CI_READY                        (0x80000000)
-#define CI_BLOCKIO_ACTIVE               (0x40000000)
-#define CI_BLOCKIO_RCVDATA              (0x20000000)
-#define CI_BLOCKIO_SEND_PENDING         (0x10000000)
-#define CI_BLOCKIO_SEND_COMPLETE        (0x08000000)
-
-#define CI_READ_CMD                     (0x40000000)
-#define CI_WRITE_CMD                    (0x80000000)
-
-#define CI_BLOCKIO_SEND(i)              (CI_BASE + (i) * 32 + 0x14)
-#define CI_BLOCKIO_RECEIVE(i)           (CI_BASE + (i) * 32 + 0x18)
-
-#define CI_BLOCKIO_SEND_COMMAND         (0x80000000)
-#define CI_BLOCKIO_SEND_COMPLETE_ACK    (0x40000000)
-#define CI_BLOCKIO_RCVDATA_ACK          (0x40000000)
-
-#define CI_BUFFER_BASE                  (0x3000)
-#define CI_BUFFER_SIZE                  (0x0800)
-#define CI_BLOCKIO_BUFFER_SIZE          (CI_BUFFER_SIZE/2)
-
-#define CI_BUFFER(i)                    (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
-#define CI_BLOCKIO_RECEIVE_BUFFER(i)    (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
-#define CI_BLOCKIO_SEND_BUFFER(i)       (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE + CI_BLOCKIO_BUFFER_SIZE)
diff -urN media_build_experimental//linux/drivers/media/dvb/ddbridge/Kconfig media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/Kconfig
--- media_build_experimental//linux/drivers/media/dvb/ddbridge/Kconfig	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/Kconfig	2011-07-11 20:09:53.000000000 +0200
@@ -6,8 +6,6 @@
 	select DVB_STV090x if !DVB_FE_CUSTOMISE
 	select DVB_DRXK if !DVB_FE_CUSTOMISE
 	select DVB_TDA18271C2DD if !DVB_FE_CUSTOMISE
-	select DVB_STV0367DD if !DVB_FE_CUSTOMISE
-	select DVB_TDA18212DD if !DVB_FE_CUSTOMISE
 	---help---
 	  Support for cards with the Digital Devices PCI express bridge:
 	  - Octopus PCIe Bridge
@@ -16,6 +14,5 @@
 	  - DuoFlex S2 Octopus
 	  - DuoFlex CT Octopus
 	  - cineS2(v6)
-	  - cineCT(v6)
 
 	  Say Y if you own such a card and want to use it.
diff -urN media_build_experimental//linux/drivers/media/dvb/ddbridge/Makefile media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/Makefile
--- media_build_experimental//linux/drivers/media/dvb/ddbridge/Makefile	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ddbridge/Makefile	2011-11-02 05:45:17.000000000 +0100
@@ -11,4 +11,4 @@
 ccflags-y += -Idrivers/media/common/tuners/
 
 # For the staging CI driver cxd2099
-ccflags-y += -Idrivers/staging/cxd2099/
+ccflags-y += -Idrivers/staging/media/cxd2099/
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-core/dvbdev.c~ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-core/dvbdev.c~
--- media_build_experimental//linux/drivers/media/dvb/dvb-core/dvbdev.c~	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-core/dvbdev.c~	2012-02-27 00:02:37.098915017 +0100
@@ -0,0 +1,506 @@
+/*
+ * dvbdev.c
+ *
+ * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include "dvbdev.h"
+
+static DEFINE_MUTEX(dvbdev_mutex);
+static int dvbdev_debug;
+
+module_param(dvbdev_debug, int, 0644);
+MODULE_PARM_DESC(dvbdev_debug, "Turn on/off device debugging (default:off).");
+
+#define dprintk if (dvbdev_debug) printk
+
+static LIST_HEAD(dvb_adapter_list);
+static DEFINE_MUTEX(dvbdev_register_lock);
+
+static const char * const dnames[] = {
+	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
+	"net", "osd"
+};
+
+#ifdef CONFIG_DVB_DYNAMIC_MINORS
+#define MAX_DVB_MINORS		256
+#define DVB_MAX_IDS		MAX_DVB_MINORS
+#else
+#define DVB_MAX_IDS		4
+#define nums2minor(num,type,id)	((num << 6) | (id << 4) | type)
+#define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
+#endif
+
+static struct class *dvb_class;
+
+static struct dvb_device *dvb_minors[MAX_DVB_MINORS];
+static DECLARE_RWSEM(minor_rwsem);
+
+static int dvb_device_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev;
+
+	mutex_lock(&dvbdev_mutex);
+	down_read(&minor_rwsem);
+	dvbdev = dvb_minors[iminor(inode)];
+
+	if (dvbdev && dvbdev->fops) {
+		int err = 0;
+		const struct file_operations *old_fops;
+
+		file->private_data = dvbdev;
+		old_fops = file->f_op;
+		file->f_op = fops_get(dvbdev->fops);
+		if (file->f_op == NULL) {
+			file->f_op = old_fops;
+			goto fail;
+		}
+		if(file->f_op->open)
+			err = file->f_op->open(inode,file);
+		if (err) {
+			fops_put(file->f_op);
+			file->f_op = fops_get(old_fops);
+		}
+		fops_put(old_fops);
+		up_read(&minor_rwsem);
+		mutex_unlock(&dvbdev_mutex);
+		return err;
+	}
+fail:
+	up_read(&minor_rwsem);
+	mutex_unlock(&dvbdev_mutex);
+	return -ENODEV;
+}
+
+
+static const struct file_operations dvb_device_fops =
+{
+	.owner =	THIS_MODULE,
+	.open =		dvb_device_open,
+	.llseek =	noop_llseek,
+};
+
+static struct cdev dvb_device_cdev;
+
+int dvb_generic_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if (!dvbdev->users)
+		return -EBUSY;
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+		if (!dvbdev->readers)
+			return -EBUSY;
+		dvbdev->readers--;
+	} else {
+		if (!dvbdev->writers)
+			return -EBUSY;
+		dvbdev->writers--;
+	}
+
+	dvbdev->users--;
+	return 0;
+}
+EXPORT_SYMBOL(dvb_generic_open);
+
+
+int dvb_generic_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+		dvbdev->readers++;
+	} else {
+		dvbdev->writers++;
+	}
+
+	dvbdev->users++;
+	return 0;
+}
+EXPORT_SYMBOL(dvb_generic_release);
+
+
+long dvb_generic_ioctl(struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if (!dvbdev->kernel_ioctl)
+		return -EINVAL;
+
+	return dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);
+}
+EXPORT_SYMBOL(dvb_generic_ioctl);
+
+
+static int dvbdev_get_free_id (struct dvb_adapter *adap, int type)
+{
+	u32 id = 0;
+
+	while (id < DVB_MAX_IDS) {
+		struct dvb_device *dev;
+		list_for_each_entry(dev, &adap->device_list, list_head)
+			if (dev->type == type && dev->id == id)
+				goto skip;
+		return id;
+skip:
+		id++;
+	}
+	return -ENFILE;
+}
+
+
+int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
+			const struct dvb_device *template, void *priv, int type)
+{
+	struct dvb_device *dvbdev;
+	struct file_operations *dvbdevfops;
+	struct device *clsdev;
+	int minor;
+	int id;
+
+	mutex_lock(&dvbdev_register_lock);
+
+	if ((id = dvbdev_get_free_id (adap, type)) < 0){
+		mutex_unlock(&dvbdev_register_lock);
+		*pdvbdev = NULL;
+		printk(KERN_ERR "%s: couldn't find free device id\n", __func__);
+		return -ENFILE;
+	}
+
+	*pdvbdev = dvbdev = kmalloc(sizeof(struct dvb_device), GFP_KERNEL);
+
+	if (!dvbdev){
+		mutex_unlock(&dvbdev_register_lock);
+		return -ENOMEM;
+	}
+
+	dvbdevfops = kzalloc(sizeof(struct file_operations), GFP_KERNEL);
+
+	if (!dvbdevfops){
+		kfree (dvbdev);
+		mutex_unlock(&dvbdev_register_lock);
+		return -ENOMEM;
+	}
+
+	memcpy(dvbdev, template, sizeof(struct dvb_device));
+	dvbdev->type = type;
+	dvbdev->id = id;
+	dvbdev->adapter = adap;
+	dvbdev->priv = priv;
+	dvbdev->fops = dvbdevfops;
+	init_waitqueue_head (&dvbdev->wait_queue);
+
+	memcpy(dvbdevfops, template->fops, sizeof(struct file_operations));
+	dvbdevfops->owner = adap->module;
+
+	list_add_tail (&dvbdev->list_head, &adap->device_list);
+
+	down_write(&minor_rwsem);
+#ifdef CONFIG_DVB_DYNAMIC_MINORS
+	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
+		if (dvb_minors[minor] == NULL)
+			break;
+
+	if (minor == MAX_DVB_MINORS) {
+		kfree(dvbdevfops);
+		kfree(dvbdev);
+		mutex_unlock(&dvbdev_register_lock);
+		return -EINVAL;
+	}
+#else
+	minor = nums2minor(adap->num, type, id);
+#endif
+
+	dvbdev->minor = minor;
+	dvb_minors[minor] = dvbdev;
+	up_write(&minor_rwsem);
+
+	mutex_unlock(&dvbdev_register_lock);
+
+	clsdev = device_create(dvb_class, adap->device,
+			       MKDEV(DVB_MAJOR, minor),
+			       dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);
+	if (IS_ERR(clsdev)) {
+		printk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",
+		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
+		return PTR_ERR(clsdev);
+	}
+
+	dprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
+		adap->num, dnames[type], id, minor, minor);
+
+	return 0;
+}
+EXPORT_SYMBOL(dvb_register_device);
+
+
+void dvb_unregister_device(struct dvb_device *dvbdev)
+{
+	if (!dvbdev)
+		return;
+
+	down_write(&minor_rwsem);
+	dvb_minors[dvbdev->minor] = NULL;
+	up_write(&minor_rwsem);
+
+	device_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));
+
+	list_del (&dvbdev->list_head);
+	kfree (dvbdev->fops);
+	kfree (dvbdev);
+}
+EXPORT_SYMBOL(dvb_unregister_device);
+
+static int dvbdev_check_free_adapter_num(int num)
+{
+	struct list_head *entry;
+	list_for_each(entry, &dvb_adapter_list) {
+		struct dvb_adapter *adap;
+		adap = list_entry(entry, struct dvb_adapter, list_head);
+		if (adap->num == num)
+			return 0;
+	}
+	return 1;
+}
+
+static int dvbdev_get_free_adapter_num (void)
+{
+	int num = 0;
+
+	while (num < DVB_MAX_ADAPTERS) {
+		if (dvbdev_check_free_adapter_num(num))
+			return num;
+		num++;
+	}
+
+	return -ENFILE;
+}
+
+
+int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
+			 struct module *module, struct device *device,
+			 short *adapter_nums)
+{
+	int i, num;
+
+	mutex_lock(&dvbdev_register_lock);
+
+	for (i = 0; i < DVB_MAX_ADAPTERS; ++i) {
+		num = adapter_nums[i];
+		if (num >= 0  &&  num < DVB_MAX_ADAPTERS) {
+		/* use the one the driver asked for */
+			if (dvbdev_check_free_adapter_num(num))
+				break;
+		} else {
+			num = dvbdev_get_free_adapter_num();
+			break;
+		}
+		num = -1;
+	}
+
+	if (num < 0) {
+		mutex_unlock(&dvbdev_register_lock);
+		return -ENFILE;
+	}
+
+	memset (adap, 0, sizeof(struct dvb_adapter));
+	INIT_LIST_HEAD (&adap->device_list);
+
+	printk(KERN_INFO "DVB: registering new adapter (%s)\n", name);
+
+	adap->num = num;
+	adap->name = name;
+	adap->module = module;
+	adap->device = device;
+	adap->mfe_shared = 0;
+	adap->mfe_dvbdev = NULL;
+	mutex_init (&adap->mfe_lock);
+
+	list_add_tail (&adap->list_head, &dvb_adapter_list);
+
+	mutex_unlock(&dvbdev_register_lock);
+
+	return num;
+}
+EXPORT_SYMBOL(dvb_register_adapter);
+
+
+int dvb_unregister_adapter(struct dvb_adapter *adap)
+{
+	mutex_lock(&dvbdev_register_lock);
+	list_del (&adap->list_head);
+	mutex_unlock(&dvbdev_register_lock);
+	return 0;
+}
+EXPORT_SYMBOL(dvb_unregister_adapter);
+
+/* if the miracle happens and "generic_usercopy()" is included into
+   the kernel, then this can vanish. please don't make the mistake and
+   define this as video_usercopy(). this will introduce a dependecy
+   to the v4l "videodev.o" module, which is unnecessary for some
+   cards (ie. the budget dvb-cards don't need the v4l module...) */
+int dvb_usercopy(struct file *file,
+		     unsigned int cmd, unsigned long arg,
+		     int (*func)(struct file *file,
+		     unsigned int cmd, void *arg))
+{
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *) arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
+	}
+
+	/* call driver */
+	mutex_lock(&dvbdev_mutex);
+	if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
+		err = -EINVAL;
+	mutex_unlock(&dvbdev_mutex);
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
+	{
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
+	}
+
+out:
+	kfree(mbuf);
+	return err;
+}
+
+static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+
+	add_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);
+	add_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);
+	add_uevent_var(env, "DVB_DEVICE_NUM=%d", dvbdev->id);
+	return 0;
+}
+
+static char *dvb_devnode(struct device *dev, umode_t *mode)
+{
+	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+
+	return kasprintf(GFP_KERNEL, "dvb/adapter%d/%s%d",
+		dvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);
+}
+
+
+static int __init init_dvbdev(void)
+{
+	int retval;
+	dev_t dev = MKDEV(DVB_MAJOR, 0);
+
+	if ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {
+		printk(KERN_ERR "dvb-core: unable to get major %d\n", DVB_MAJOR);
+		return retval;
+	}
+
+	cdev_init(&dvb_device_cdev, &dvb_device_fops);
+	if ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {
+		printk(KERN_ERR "dvb-core: unable register character device\n");
+		goto error;
+	}
+
+	dvb_class = class_create(THIS_MODULE, "dvb");
+	if (IS_ERR(dvb_class)) {
+		retval = PTR_ERR(dvb_class);
+		goto error;
+	}
+	dvb_class->dev_uevent = dvb_uevent;
+	dvb_class->devnode = dvb_devnode;
+	return 0;
+
+error:
+	cdev_del(&dvb_device_cdev);
+	unregister_chrdev_region(dev, MAX_DVB_MINORS);
+	return retval;
+}
+
+
+static void __exit exit_dvbdev(void)
+{
+	class_destroy(dvb_class);
+	cdev_del(&dvb_device_cdev);
+	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
+}
+
+subsys_initcall(init_dvbdev);
+module_exit(exit_dvbdev);
+
+MODULE_DESCRIPTION("DVB Core Driver");
+MODULE_AUTHOR("Marcus Metzler, Ralph Metzler, Holger Waechtler");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-core.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-core.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-core.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-core.c	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,253 @@
+#include "a867_af903x.h"
+#include "a867_aver_version.h"
+
+DEVICE_CONTEXT DC;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25)
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+#endif
+
+static int map_gpio_by_id(const struct usb_device_id *id, PDEVICE_CONTEXT pdc)
+{
+	if( id->idProduct == 0xa333 ) {
+		pdc->Map.I2C_SLAVE_ADDR = 0x3A;
+		pdc->Map.RF_SW_HOST = 0; //chip0
+		pdc->Map.GPIO_UHF_en = p_reg_top_gpioh2_en;
+		pdc->Map.GPIO_UHF_on = p_reg_top_gpioh2_on;
+		pdc->Map.GPIO_UHF_o  = p_reg_top_gpioh2_o;
+		pdc->Map.GPIO_VHF_en = p_reg_top_gpioh3_en;
+		pdc->Map.GPIO_VHF_on = p_reg_top_gpioh3_on;
+		pdc->Map.GPIO_VHF_o  = p_reg_top_gpioh3_o;
+		pdc->Map.GPIO_WP_en	= p_reg_top_gpioh7_en;
+		pdc->Map.GPIO_WP_on	= p_reg_top_gpioh7_on;
+		pdc->Map.GPIO_WP_o   = p_reg_top_gpioh7_o;
+		pdc->Map.GPIO_OSC_en = p_reg_top_gpioh6_en;
+		pdc->Map.GPIO_OSC_on = p_reg_top_gpioh6_on;
+		pdc->Map.GPIO_OSC_o  = p_reg_top_gpioh6_o;
+		pdc->Map.GPIO_TUR1_en = p_reg_top_gpioh11_en;
+		pdc->Map.GPIO_TUR1_on = p_reg_top_gpioh11_on;
+		pdc->Map.GPIO_TUR1_o  = p_reg_top_gpioh11_o;
+		pdc->Map.GPIO_TUR2_en = p_reg_top_gpioh12_en;
+		pdc->Map.GPIO_TUR2_on = p_reg_top_gpioh12_on;
+		pdc->Map.GPIO_TUR2_o  = p_reg_top_gpioh12_o;
+		pdc->Map.GPIO_DPWR_en = 0xF000;
+		pdc->Map.GPIO_DPWR_on = 0xF000;
+		pdc->Map.GPIO_DPWR_o	 = 0xF000;
+		pdc->Map.GPIO_DRST_en = 0xF000;
+		pdc->Map.GPIO_DRST_on = 0xF000;
+		pdc->Map.GPIO_DRST_o  = 0xF000;
+		pdc->Map.GPIO_STR_en  = p_reg_top_gpioh8_en;
+		pdc->Map.GPIO_STR_on  = p_reg_top_gpioh8_on;
+		pdc->Map.GPIO_STR_o   = p_reg_top_gpioh8_o;
+		pdc->Map.GPIO_STR_i   = r_reg_top_gpioh8_i;
+	}
+	else if( id->idProduct == 0xa825 ) {
+		pdc->Map.I2C_SLAVE_ADDR = 0x3E;
+		//pdc->Map.RF_SW_HOST = 1; //chip1
+		pdc->Map.RF_SW_HOST = 0; //chip0
+		pdc->Map.GPIO_UHF_en = p_reg_top_gpioh3_en;
+		pdc->Map.GPIO_UHF_on = p_reg_top_gpioh3_on;
+		pdc->Map.GPIO_UHF_o  = p_reg_top_gpioh3_o;
+		pdc->Map.GPIO_VHF_en = p_reg_top_gpioh2_en;	//When UHF, this pin low
+		pdc->Map.GPIO_VHF_on = p_reg_top_gpioh2_on;
+		pdc->Map.GPIO_VHF_o  = p_reg_top_gpioh2_o;
+		pdc->Map.GPIO_WP_en	= p_reg_top_gpioh7_en;
+		pdc->Map.GPIO_WP_on	= p_reg_top_gpioh7_on;
+		pdc->Map.GPIO_WP_o   = p_reg_top_gpioh7_o;
+		pdc->Map.GPIO_OSC_en = p_reg_top_gpioh6_en;	//Use GPIO6 for HW test
+		pdc->Map.GPIO_OSC_on = p_reg_top_gpioh6_on;	//GPIO8 can't use.
+		pdc->Map.GPIO_OSC_o  = p_reg_top_gpioh6_o;
+		pdc->Map.GPIO_TUR1_en = p_reg_top_gpioh11_en;	//Use GPIO11,12 will cause hostB fail.
+		pdc->Map.GPIO_TUR1_on = p_reg_top_gpioh11_on;
+		pdc->Map.GPIO_TUR1_o  = p_reg_top_gpioh11_o;
+		pdc->Map.GPIO_TUR2_en = p_reg_top_gpioh12_en;
+		pdc->Map.GPIO_TUR2_on = p_reg_top_gpioh12_on;
+		pdc->Map.GPIO_TUR2_o  = p_reg_top_gpioh12_o;
+		pdc->Map.GPIO_DPWR_en = p_reg_top_gpioh2_en;
+		pdc->Map.GPIO_DPWR_on = p_reg_top_gpioh2_on;
+		pdc->Map.GPIO_DPWR_o	 = p_reg_top_gpioh2_o;
+		pdc->Map.GPIO_DRST_en = p_reg_top_gpioh5_en;
+		pdc->Map.GPIO_DRST_on = p_reg_top_gpioh5_on;
+		pdc->Map.GPIO_DRST_o  = p_reg_top_gpioh5_o;
+		pdc->Map.GPIO_STR_en  = 0xF000;
+		pdc->Map.GPIO_STR_on  = 0xF000;
+		pdc->Map.GPIO_STR_o   = 0xF000;
+		pdc->Map.GPIO_STR_i   = 0xF000;
+	}
+	else if(id->idProduct == 0xa337 
+		|| id->idProduct == 0xF337
+		|| id->idProduct == 0x0337 
+		|| id->idProduct == 0xa867 
+		|| id->idProduct == 0x0867 
+		|| id->idProduct == 0x1867) {
+		deb_data("GPIO Mapping : A867\n");
+		pdc->Map.I2C_SLAVE_ADDR = 0x3A;
+		pdc->Map.RF_SW_HOST = 0; //chip1
+		pdc->Map.GPIO_UHF_en = 0xF000;
+		pdc->Map.GPIO_UHF_on = 0xF000;
+		pdc->Map.GPIO_UHF_o  = 0xF000;
+		pdc->Map.GPIO_VHF_en = 0xF000;
+		pdc->Map.GPIO_VHF_on = 0xF000;
+		pdc->Map.GPIO_VHF_o  = 0xF000;
+		pdc->Map.GPIO_WP_en	= p_reg_top_gpioh7_en;
+		pdc->Map.GPIO_WP_on	= p_reg_top_gpioh7_on;
+		pdc->Map.GPIO_WP_o   = p_reg_top_gpioh7_o;
+		pdc->Map.GPIO_OSC_en = 0xF000;
+		pdc->Map.GPIO_OSC_on = 0xF000;
+		pdc->Map.GPIO_OSC_o  = 0xF000;
+		pdc->Map.GPIO_TUR1_en = p_reg_top_gpioh6_en;	//Use GPIO11,12 will cause hostB fail.
+		pdc->Map.GPIO_TUR1_on = p_reg_top_gpioh6_on;
+		pdc->Map.GPIO_TUR1_o  = p_reg_top_gpioh6_o;
+		pdc->Map.GPIO_TUR2_en = p_reg_top_gpioh11_en;
+		pdc->Map.GPIO_TUR2_on = p_reg_top_gpioh11_on;
+		pdc->Map.GPIO_TUR2_o  = p_reg_top_gpioh11_o;
+		pdc->Map.GPIO_DPWR_en = 0xF000;
+		pdc->Map.GPIO_DPWR_on = 0xF000;
+		pdc->Map.GPIO_DPWR_o	= 0xF000;
+		pdc->Map.GPIO_DRST_en = 0xF000;
+		pdc->Map.GPIO_DRST_on = 0xF000;
+		pdc->Map.GPIO_DRST_o  = 0xF000;
+		pdc->Map.GPIO_STR_en  = 0xF000;
+		pdc->Map.GPIO_STR_on  = 0xF000;
+		pdc->Map.GPIO_STR_o   = 0xF000;
+		pdc->Map.GPIO_STR_i   = 0xF000;
+		pdc->Map.GPIO_LED_en = p_reg_top_gpioh3_en;	
+		pdc->Map.GPIO_LED_on = p_reg_top_gpioh3_on;
+		pdc->Map.GPIO_LED_o  = p_reg_top_gpioh3_o;
+	}
+	else {
+		pdc->Map.I2C_SLAVE_ADDR = 0x3E;
+		pdc->Map.RF_SW_HOST = 1; //chip1
+		pdc->Map.GPIO_UHF_en = p_reg_top_gpioh3_en;
+		pdc->Map.GPIO_UHF_on = p_reg_top_gpioh3_on;
+		pdc->Map.GPIO_UHF_o  = p_reg_top_gpioh3_o;
+		pdc->Map.GPIO_VHF_en = p_reg_top_gpioh2_en;	//When UHF, this pin low
+		pdc->Map.GPIO_VHF_on = p_reg_top_gpioh2_on;
+		pdc->Map.GPIO_VHF_o  = p_reg_top_gpioh2_o;
+		pdc->Map.GPIO_WP_en	= p_reg_top_gpioh7_en;
+		pdc->Map.GPIO_WP_on	= p_reg_top_gpioh7_on;
+		pdc->Map.GPIO_WP_o   = p_reg_top_gpioh7_o;
+		pdc->Map.GPIO_OSC_en = p_reg_top_gpioh6_en;	//Use GPIO6 for HW test
+		pdc->Map.GPIO_OSC_on = p_reg_top_gpioh6_on;	//GPIO8 can't use.
+		pdc->Map.GPIO_OSC_o  = p_reg_top_gpioh6_o;
+		pdc->Map.GPIO_TUR1_en = p_reg_top_gpioh11_en;	//Use GPIO11,12 will cause hostB fail.
+		pdc->Map.GPIO_TUR1_on = p_reg_top_gpioh11_on;
+		pdc->Map.GPIO_TUR1_o  = p_reg_top_gpioh11_o;
+		pdc->Map.GPIO_TUR2_en = p_reg_top_gpioh12_en;
+		pdc->Map.GPIO_TUR2_on = p_reg_top_gpioh12_on;
+		pdc->Map.GPIO_TUR2_o  = p_reg_top_gpioh12_o;
+		pdc->Map.GPIO_DPWR_en = p_reg_top_gpioh2_en;
+		pdc->Map.GPIO_DPWR_on = p_reg_top_gpioh2_on;
+		pdc->Map.GPIO_DPWR_o	 = p_reg_top_gpioh2_o;
+		pdc->Map.GPIO_DRST_en = p_reg_top_gpioh5_en;
+		pdc->Map.GPIO_DRST_on = p_reg_top_gpioh5_on;
+		pdc->Map.GPIO_DRST_o  = p_reg_top_gpioh5_o;
+		pdc->Map.GPIO_STR_en  = 0xF000;
+		pdc->Map.GPIO_STR_on  = 0xF000;
+		pdc->Map.GPIO_STR_o   = 0xF000;
+		pdc->Map.GPIO_STR_i   = 0xF000;
+	}
+	return 0;
+}
+
+static int af903x_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	int retval = -ENOMEM;
+	int i;
+
+	// init GPIO mappings based on device
+	map_gpio_by_id(id, &DC);
+
+	deb_data("===af903x usb device pluged in!! ===\n");
+	retval = Device_init(interface_to_usbdev(intf),intf,&DC, true);
+	if (retval){
+                if(retval) deb_data("Device_init Fail: 0x%08x\n", retval);
+        }
+	
+	for (i = 0; i < af903x_device_count; i++) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25)
+		if (dvb_usb_device_init(intf, &af903x_properties[i], THIS_MODULE, NULL, adapter_nr) == 0)
+#else
+		if (dvb_usb_device_init(intf, &af903x_properties[i], THIS_MODULE, NULL) == 0)
+#endif
+			{deb_data("dvb_usb_device_init success!!\n");return 0;}
+	}
+
+	return -ENOMEM;
+}
+
+static int af903x_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	int error;
+	deb_data("Enter %s Function, message=0x%ux\n",__FUNCTION__, message.event);
+	error = DL_ApCtrl(0);
+	if (error) deb_data("DL_ApCtrl error : 0x%x\n", error);
+
+// If selective suspend is not supported, this must be a S3/S4 suspend,
+// in which case we choose to reboot AF903x so it can work after resuming on EeePC.
+#if !defined(CONFIG_USB_SUSPEND)
+	DL_Reboot();	
+#endif
+
+	return 0;
+}
+
+static int af903x_resume(struct usb_interface *intf)
+{
+	int retval = -ENOMEM;
+	deb_data("Enter %s Function\n",__FUNCTION__);
+	
+	retval = DL_ApCtrl(1);
+	if (retval) deb_data("DL_ApCtrl error : 0x%x\n", retval);
+
+	retval = Device_init(interface_to_usbdev(intf),intf,&DC, false);
+        if (retval){
+                if(retval) deb_data("Device_init Fail: 0x%08x\n", retval);
+        }
+
+        return 0;
+}
+
+static struct usb_driver af903x_driver = {
+#if LINUX_VERSION_CODE <=  KERNEL_VERSION(2,6,15)
+	.owner = THIS_MODULE,
+#endif
+	.name       = "dvb-usb-a867",
+	.probe      = af903x_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table   = af903x_usb_id_table,
+	.suspend    = af903x_suspend,
+	.resume     = af903x_resume,
+#if LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,22)
+	.reset_resume = af903x_resume,
+#endif
+	.supports_autosuspend = 1,
+};
+
+static int __init af903x_module_init(void)
+{
+	int result;
+
+	printk("AVerMedia A867 driver module V%s loaded.\n", DRIVER_VER);
+
+	if ((result = usb_register(&af903x_driver))) {
+		err("usb_register failed. Error number %d",result);
+		return result;
+	}
+	return 0;
+}
+
+static void __exit af903x_module_exit(void)
+{
+	usb_deregister(&af903x_driver);
+	printk("AVerMedia A867 driver module V%s unloaded.\n", DRIVER_VER);
+}
+
+module_init (af903x_module_init);
+module_exit (af903x_module_exit);
+
+MODULE_AUTHOR("MPD Linux Team");
+MODULE_DESCRIPTION("AVerMedia A867");
+MODULE_VERSION(DRIVER_VER);
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-devices.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-devices.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-devices.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-devices.c	2012-02-27 00:02:36.328915017 +0100
@@ -0,0 +1,278 @@
+#include "a867_af903x.h"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)) || ((defined V4L2_VERSION) && (V4L2_VERSION >= 196608))
+#define V4L2_REFACTORED_MFE_CODE
+#endif
+
+int dvb_usb_af903x_hwpid = 1; // enable hw pid filter 
+module_param_named(hwpid,dvb_usb_af903x_hwpid, int, 0644); 
+MODULE_PARM_DESC(debug, "set hw pid filter.(disable=0, enable=1)" DVB_USB_DEBUG_STATUS);
+
+//static u16 gSWPIDTable[32];
+static int gTblUsed = 0;
+
+static int af903x_download_firmware(struct usb_device *udev, const struct firmware *fw)
+{
+	int ret=0;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	
+	return ret;
+}
+
+static int af903x_powerctrl(struct dvb_usb_device *d, int onoff)
+{
+
+	int ret;
+	deb_data("- Enter %s Function - %s\n",__FUNCTION__,onoff?"ON":"OFF");
+
+	// resume device before DL_ApCtrl(on)
+	if( onoff ) {
+		ret = usb_autopm_get_interface(uintfs);
+		if(ret) {
+			deb_data("%s calling usb_autopm_get_interface failed with %d\n", __FUNCTION__, ret);
+			gTblUsed = 0;
+
+			return ret;
+		}
+	}
+
+	ret = DL_ApCtrl(onoff);
+	if(ret) deb_data("	af903x_powerctrl Fail: 0x%04X\n", ret);
+
+	//suspend device after DL_ApCtrl(off)
+	if( !onoff ) {
+		usb_autopm_put_interface(uintfs);	
+	}
+
+	deb_data("- Exit %s Function - %s, ret=%d\n",__FUNCTION__,onoff?"ON":"OFF", ret);
+	return ret;
+}
+
+static int af903x_identify_state(struct usb_device *udev, struct dvb_usb_device_properties *props,
+			struct dvb_usb_device_description **desc, int *cold)
+{
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	*cold = 0;
+
+	return 0;
+}
+
+static int af903x_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+#ifdef V4L2_REFACTORED_MFE_CODE
+	adap->fe_adap[0].fe = af903x_attach(1);
+
+	return adap->fe_adap[0].fe == NULL ? -ENODEV : 0;
+#else
+	adap->fe = af903x_attach(1);
+
+	return adap->fe == NULL ? -ENODEV : 0;
+#endif
+}
+
+static int af903x_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+#ifdef V4L2_REFACTORED_MFE_CODE
+	tuner_attach(adap->fe_adap[0].fe);
+#else
+	tuner_attach(adap->fe);
+#endif
+	return  0;
+}
+
+static int af903x_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)
+{
+	deb_data("- Enter %s Function - (%d) streaming state for %d\n",__FUNCTION__,onoff, adap->id);
+	
+
+	return 0;
+}
+
+static int af903x_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)
+{
+    int ret =0;
+    deb_data("%s: onoff:%d\n", __func__, onoff);
+
+    if (!onoff){
+        deb_data("  Reset PID Table\n");
+        DL_ResetPID();
+        PDC->fc[adap->id].ulcPIDs = 0;
+        memset(PDC->fc[adap->id].aulPIDs, 0, sizeof(FILTER_INFO));
+    }
+    PDC->fc[adap->id].bEnPID =  onoff;
+    ret = DL_PIDOnOff(PDC->fc[adap->id].bEnPID);
+
+    deb_data("  set pid onoff ok\n");
+    return ret;
+}
+
+
+static int af903x_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pidnum,
+    int onoff)
+{
+//    if (down_interruptible (&my_sem))
+//            return -ERESTARTSYS;
+
+    int ret = 0;
+    Pid pid;
+    deb_data("- %s: set pid filter, index %d, pid %d, onoff %d.\n",
+    __func__, index, pidnum, onoff);
+
+
+    if (onoff) { //add filter to table
+        PDC->fc[adap->id].aulPIDs[index].filternum = pidnum;
+        if (!PDC->fc[adap->id].aulPIDs[index].onoff ){
+            PDC->fc[adap->id].aulPIDs[index].onoff = true;
+            PDC->fc[adap->id].ulcPIDs ++;
+        }
+    }
+    else{   //del filter from table
+        PDC->fc[adap->id].aulPIDs[index].filternum = 0;
+        if (PDC->fc[adap->id].aulPIDs[index].onoff ){
+            PDC->fc[adap->id].aulPIDs[index].onoff = false;
+            PDC->fc[adap->id].ulcPIDs --;
+        }
+    }
+
+    if (onoff) {
+        /* cannot use it as pid_filter_ctrl since it has to be done
+ *            before setting the first pid */
+        if (adap->feedcount == 1) {
+            deb_data("  first pid set, enable pid table\n");
+
+            pid.sectionType = SectionType_TABLE;
+            pid.table = 0x00;
+            pid.duration = 0xFF;
+
+            ret = af903x_pid_filter_ctrl(adap, onoff);
+            if (ret)
+                return ret;
+        }
+        pid.value = (Word)pidnum;
+        ret = DL_AddPID(index, pid);
+        if (ret)
+            return ret;
+
+    }
+    else{
+
+        pid.value = (Word)pidnum;
+        ret = DL_RemovePID(index, pid);
+        if (ret)
+            return ret;
+
+        if (adap->feedcount == 0) {
+            deb_data("  last pid unset, disable pid table\n");
+            ret = af903x_pid_filter_ctrl(adap, onoff);
+            if (ret)
+                return ret;
+        }
+
+    }
+
+    deb_data("  set pid ok, total pid num :%d\n", PDC->fc[adap->id].ulcPIDs);
+
+	msleep(100);
+	
+//    up(&my_sem);
+    return 0;
+}
+
+
+struct usb_device_id af903x_usb_id_table[] = {
+		{ USB_DEVICE(0x07ca,0xa333) },
+		{ USB_DEVICE(0x07ca,0xb867) },
+		{ USB_DEVICE(0x07ca,0x1867) },
+		{ USB_DEVICE(0x07ca,0x0337) },
+		{ USB_DEVICE(0x07ca,0xa867) },
+		{ USB_DEVICE(0x07ca,0x0867) },
+		{ USB_DEVICE(0x07ca,0xF337) },
+		{ USB_DEVICE(0x07ca,0x3867) },
+#if SUPPORT_AF903X_EVB 
+		{ USB_DEVICE(0x15A4,0x1000) },
+		{ USB_DEVICE(0x15A4,0x1001) },
+		{ USB_DEVICE(0x15A4,0x1002) },
+		{ USB_DEVICE(0x15A4,0x1003) },
+		{ USB_DEVICE(0x15A4,0x9035) },
+#endif //SUPPORT_AF903X_EVB
+		{ 0 }		/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, af903x_usb_id_table);
+
+struct dvb_usb_device_properties af903x_properties[] = {
+	{
+		.usb_ctrl          = DEVICE_SPECIFIC,
+		.download_firmware = af903x_download_firmware,
+		.no_reconnect      = 1,
+		.power_ctrl		   = af903x_powerctrl,
+		.identify_state    = af903x_identify_state,
+		
+		.num_adapters = 1,
+		.adapter = {
+			{
+#ifdef V4L2_REFACTORED_MFE_CODE
+				.num_frontends = 1,
+				.fe = {{
+#endif
+#if ENABLE_HW_PID
+					.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_NEED_PID_FILTERING,
+#else
+					.caps = DVB_USB_ADAP_HAS_PID_FILTER,
+#endif
+					.pid_filter_count = 32,
+					.frontend_attach  = af903x_frontend_attach,
+					.tuner_attach     = af903x_tuner_attach,
+					.streaming_ctrl   = af903x_streaming_ctrl,
+					.pid_filter_ctrl  = af903x_pid_filter_ctrl,
+					.pid_filter		  = af903x_pid_filter,
+
+					.stream = { 
+					.type = USB_BULK,
+					.count = 10,
+					.endpoint = 0x84,
+					.u = {
+						.bulk = {
+							.buffersize = (188 * TS_PACKET_COUNT),
+							}
+						}
+					}
+#ifdef V4L2_REFACTORED_MFE_CODE
+		    }},
+#endif
+			},
+		},
+#if 0
+		.num_device_descs = 1,
+#else
+		.num_device_descs = 2,
+#endif
+		.devices = {
+			{   "AVerMedia A333 DVB-T Recevier",
+				{ &af903x_usb_id_table[0]
+				 ,&af903x_usb_id_table[1]
+#if SUPPORT_AF903X_EVB 
+				 ,&af903x_usb_id_table[7]
+				 ,&af903x_usb_id_table[8]
+#endif //SUPPORT_AF903X_EVB
+				},
+
+				{ NULL },
+			},
+			{   "AVerMedia A867 DVB-T Recevier",  
+				{ &af903x_usb_id_table[2]
+				 ,&af903x_usb_id_table[3]
+				 ,&af903x_usb_id_table[4]
+				 ,&af903x_usb_id_table[5]
+				 ,&af903x_usb_id_table[6]
+				 ,&af903x_usb_id_table[7]
+				},
+
+				{ NULL },
+			}
+		}
+	}
+};
+
+int af903x_device_count = ARRAY_SIZE(af903x_properties);
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-drv.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-drv.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-drv.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-drv.c	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,1238 @@
+#include "a867_af903x.h"
+//#include "a867_firmware.h"
+#include "a867_ofdm.h"
+
+#define true 1
+#define false 0
+
+#define FW_VER         0x08060000
+int dvb_usb_af903x_debug = 0; // disable all level by default
+module_param_named(debug,dvb_usb_af903x_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (info=1, deb_fw=2, deb_fwdata=4, deb_data=8 (or-able)), default=0");
+
+int dvb_usb_af903x_snrdb = 0; // output SNR 16bit format
+module_param_named(snrdb,dvb_usb_af903x_snrdb, int, 0644);
+MODULE_PARM_DESC(snrdb, "set SNR format (16bit=0, dB decibel=1), default=0");
+
+struct usb_device *udevs = NULL;
+struct usb_interface *uintfs = NULL;
+PDEVICE_CONTEXT PDC;
+
+  
+//************** DRV_ *************//
+
+static DWORD DRV_ResetPID(
+    IN	void*	handle,
+    IN	BYTE	ucSlaveDemod)
+{
+	DWORD dwError = Error_NO_ERROR;
+    PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+          
+    //Clear pidTable
+    dwError = Demodulator_resetPid ((Demodulator*) &pdc->Demodulator, ucSlaveDemod);
+
+	return dwError;
+}
+
+static DWORD DRV_PIDOnOff(
+	void	*handle, 
+	BYTE	ucSlaveDemod,
+	DWORD	dwOnOff)
+{
+	DWORD dwError = Error_NO_ERROR;
+	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+	if(dwOnOff)
+	{
+        dwError = Demodulator_controlPidFilter ((Demodulator*) &pdc->Demodulator, ucSlaveDemod, 1);
+	}
+	else
+	{
+        dwError = Demodulator_controlPidFilter ((Demodulator*) &pdc->Demodulator, ucSlaveDemod, 0);
+	}
+
+	return dwError;
+}
+
+static DWORD DRV_AddPID(
+	void	*handle,
+	BYTE	ucSlaveDemod,
+	DWORD	index,
+	Pid		pid)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+    PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+          
+    dwError = Demodulator_addPidToFilter ((Demodulator*) &pdc->Demodulator, ucSlaveDemod,index, pid);
+
+	return dwError;
+}
+
+DWORD DRV_RemovePID(
+    IN  void*   handle,
+    IN  BYTE    ucSlaveDemod,
+    IN  Byte    index,
+    IN  Pid     pid
+)
+{
+//    deb_data("- Enter %s Function - , index:%d, pid:%x \n",__FUNCTION__, index, pid.value);
+
+    DWORD   dwError = Error_NO_ERROR;
+
+    PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+    dwError = Demodulator_removePidAt ((Demodulator*) &pdc->Demodulator, ucSlaveDemod,index, pid);
+
+    return(dwError);
+
+}
+
+
+
+static DWORD DRV_IrTblDownload(IN      void * handle)
+{
+        DWORD dwError = Error_NO_ERROR;
+        PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+        struct file *filp;
+        unsigned char b_buf[512] ;
+        int i, fileSize;
+        mm_segment_t oldfs;
+
+        deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+        oldfs=get_fs();
+        set_fs(KERNEL_DS);
+
+        filp=filp_open("/lib/firmware/af35irtbl.bin", O_RDWR,0644);
+        if ( IS_ERR(filp) ) {
+                deb_data("      LoadIrTable : Can't open file\n");goto exit;}
+
+        if ( (filp->f_op) == NULL ) {
+                deb_data("      LoadIrTable : File Operation Method Error!!\n");goto exit;}
+
+        filp->f_pos=0x00;
+        fileSize = filp->f_op->read(filp,b_buf,sizeof(b_buf),&filp->f_pos);
+
+        for(i=0; i<fileSize; i++)
+        {
+              //deb_data("\n Data %d",i); //
+              //deb_data("0x%x",b_buf[i]);//
+              // dwError = Af901xWriteReg(ucDemod2WireAddr, 0, MERC_IR_TABLE_BASE_ADDR + i, b_buf[i]);
+              //if (dwError) goto exit;
+        }
+
+        dwError = Demodulator_loadIrTable((Demodulator*) &pdc->Demodulator, (Word)fileSize, b_buf);
+        if (dwError) {deb_data("Demodulator_loadIrTable fail"); goto exit;}
+
+        filp_close(filp, NULL);
+        set_fs(oldfs);
+
+        return (dwError);
+exit:
+        deb_data("LoadIrTable fail!\n");
+	return dwError;
+
+}
+
+static DWORD  DRV_GetEEPROMConfig2(
+        void *      handle,
+        BYTE       ucSlaveDemod)
+{
+
+	DWORD dwError = Error_NO_ERROR;
+    	tWORD    shift = 0;
+    	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+	BYTE btmp = 0;
+
+	deb_data("- Enter %s Function -",__FUNCTION__);
+	
+    	if(ucSlaveDemod) shift = EEPROM_SHIFT;
+    
+    	dwError = Demodulator_readRegisters((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, EEPROM_TUNERID+shift, 1, &btmp);
+    	if (dwError) goto exit;
+    	deb_data("EEPROM_TUNERID%d  = 0x%02X\n", ucSlaveDemod, btmp);		
+    	PTI.TunerId = btmp;  
+
+exit:
+    
+    return(dwError);     
+}  
+
+static DWORD DRV_SetFreqBw(
+    	void*	handle,      
+     	BYTE 	ucSlaveDemod,
+      	DWORD   dwFreq,      
+      	WORD	ucBw
+)
+{
+	DWORD dwError = Error_NO_ERROR;
+    
+	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+	//Bool bLock = true;
+
+	deb_data("- Enter %s Function -\n ",__FUNCTION__);
+	deb_data("       ucSlaveDemod = %d, Freq= %d, BW=%d\n", ucSlaveDemod, dwFreq, ucBw);
+
+    if (pdc->fc[ucSlaveDemod].bEnPID)
+    {
+		deb_data("		Reset HW PID table\n ");
+        //Disable PID filter
+		Demodulator_writeRegisterBits ((Demodulator*) &pdc->Demodulator, ucSlaveDemod, Processor_OFDM, p_mp2if_pid_en, mp2if_pid_en_pos, mp2if_pid_en_len, 0);
+		
+    }
+	
+    down(&PDC->tunerLock);
+
+    PDC->fc[0].AVerFlags &= ~(0x08);
+    PDC->fc[0].AVerFlags |= 0x04;
+    PTI.bSettingFreq = true; //before acquireChannel, it is ture;  otherwise, it is false
+
+    if(dwFreq) {
+        pdc->fc[ucSlaveDemod].ulDesiredFrequency = dwFreq;
+    }
+    else {
+        dwFreq = pdc->fc[ucSlaveDemod].ulDesiredFrequency;
+    }
+
+    if(ucBw) {
+        pdc->fc[ucSlaveDemod].ucDesiredBandWidth = ucBw*1000;
+	}
+    else {
+        ucBw = pdc->fc[ucSlaveDemod].ucDesiredBandWidth;
+    	}
+
+    deb_data("Real Freq= %d, BW=%d\n", pdc->fc[ucSlaveDemod].ulDesiredFrequency, pdc->fc[ucSlaveDemod].ucDesiredBandWidth);
+           
+
+    if(!PTI.bTunerInited){
+        deb_data("    Skip SetFreq - Tuner is still off!\n");
+        goto exit;
+    }
+	
+    PTI.bTunerOK = false;        
+
+    if (pdc->fc[ucSlaveDemod].ulDesiredFrequency!=0 && pdc->fc[ucSlaveDemod].ucDesiredBandWidth!=0)	
+    {
+	deb_data("AcquireChannel : Real Freq= %d, BW=%d\n", pdc->fc[ucSlaveDemod].ulDesiredFrequency, pdc->fc[ucSlaveDemod].ucDesiredBandWidth);
+	dwError = Demodulator_acquireChannel ((Demodulator*) &pdc->Demodulator, ucSlaveDemod, pdc->fc[ucSlaveDemod].ucDesiredBandWidth, pdc->fc[ucSlaveDemod].ulDesiredFrequency);  
+	//PTI.bSettingFreq = false;
+    	if (dwError) 
+    	{
+        	deb_data("Demod_acquireChannel fail! 0x%08x\n", dwError);
+        	goto exit;
+    	}	
+	else //when success acquireChannel, record currentFreq/currentBW.
+	{
+		pdc->fc[ucSlaveDemod].ulCurrentFrequency = pdc->fc[ucSlaveDemod].ulDesiredFrequency;	
+		pdc->fc[ucSlaveDemod].ucCurrentBandWidth = pdc->fc[ucSlaveDemod].ucDesiredBandWidth;  
+	}
+    }
+    else {
+       	deb_data("Demod_acquireChannel skipped\n");
+    }
+
+    if(pdc->StreamType == StreamType_DVBT_DATAGRAM) {
+        PDC->fc[ucSlaveDemod].OvrFlwChk = CHECK_LOCK_LOOPS ;
+        PDC->fc[ucSlaveDemod].UnLockCount = 0;
+    }
+
+    PTI.bTunerOK = true;
+
+exit:
+
+    PTI.bSettingFreq = false;
+    up(&PDC->tunerLock);
+
+    return(dwError);  
+}
+
+static DWORD DRV_getFirmwareVersionFromFile( 
+	 	Processor	processor, 
+		DWORD* 		version
+)
+{
+    DWORD OFDM_VER1 = DVB_OFDM_VERSION1;
+    DWORD OFDM_VER2 = DVB_OFDM_VERSION2;
+    DWORD OFDM_VER3 = DVB_OFDM_VERSION3;
+    DWORD OFDM_VER4 = DVB_OFDM_VERSION4;
+
+    DWORD LINK_VER1 = DVB_LL_VERSION1;
+    DWORD LINK_VER2 = DVB_LL_VERSION2;
+    DWORD LINK_VER3 = DVB_LL_VERSION3;    
+    DWORD LINK_VER4 = DVB_LL_VERSION4;    
+
+    if(processor == Processor_OFDM) {
+        *version = (DWORD)( (OFDM_VER1 << 24) + (OFDM_VER2 << 16) + (OFDM_VER3 << 8) + OFDM_VER4);
+    }
+    else { //LINK
+        *version = (DWORD)( (LINK_VER1 << 24) + (LINK_VER2 << 16) + (LINK_VER3 << 8) + LINK_VER4);    
+    }
+    
+    return *version;
+}
+
+static DWORD  DRV_Initialize(
+	    void *      handle
+)
+{
+	DWORD error = Error_NO_ERROR;
+	 
+	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+	DWORD fileVersion, cmdVersion = 0; 
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+	if(pdc->Demodulator.booted) //from Standard_setBusTuner() > Standard_getFirmwareVersion()
+    	{
+        	//use "#define version" to get fw version (from firmware.h title)
+        	error = DRV_getFirmwareVersionFromFile(Processor_OFDM, &fileVersion);
+
+        	//use "Command_QUERYINFO" to get fw version 
+        	error = Demodulator_getFirmwareVersion((Demodulator*) &pdc->Demodulator, Processor_OFDM, &cmdVersion);
+        	if(error) deb_data("DRV_Initialize : Demodulator_getFirmwareVersion : error = 0x%08x\n", error);
+
+        	if(cmdVersion != fileVersion)
+        	{
+            		deb_data("Reboot: Outside Fw = 0x%X, Inside Fw = 0x%X", fileVersion, cmdVersion);               
+            		error = Demodulator_reboot((Demodulator*) &pdc->Demodulator);
+            		pdc->bBootCode = true;
+            		if(error) 
+            		{
+                		deb_data("Demodulator_reboot : error = 0x%08x\n", error);
+                		return error;
+            		}
+            		else {
+                		return Error_NOT_READY;
+            		}
+        	}
+        	else
+        	{
+            		deb_data("	Fw version is the same!\n");
+  	      		error = Error_NO_ERROR;
+        	}
+	}//pdc->Demodulator.booted
+	
+ReInit:  //Patch for NIM fail or disappear, Maggie   
+    error = Demodulator_initialize ((Demodulator*) &pdc->Demodulator, pdc->Demodulator.chipNumber , 8000, pdc->StreamType, pdc->architecture);    
+    if (error) 
+    { 
+        deb_data("Device initialize fail : 0x%08x\n", error);
+        if( ((error&Error_FIRMWARE_STATUS) && (error&0x10)) && (pdc->Demodulator.chipNumber>1) )
+        {
+            pdc->Demodulator.cmdDescription->sendCommand ((Demodulator*) &pdc->Demodulator, Command_FW_DOWNLOAD_END, 0, Processor_LINK, 0, NULL, 0, NULL);
+
+            deb_data("	Retry to download FW with Single TS\n");
+            pdc->Demodulator.chipNumber = 1;
+            pdc->bDualTs = false;
+            error = Demodulator_writeRegister ((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, 0x417F, 0);
+            goto ReInit;
+       }
+    }
+    else {
+        deb_data("    Device initialize Ok!!\n");
+    }
+
+	error = Demodulator_writeRegisterBits ((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, 
+											p_reg_usb_min_len, reg_usb_min_len_pos, reg_usb_min_len_len, 1);
+
+    Demodulator_getFirmwareVersion ((Demodulator*) &pdc->Demodulator, Processor_OFDM, &cmdVersion);
+    deb_data("    FwVer OFDM = 0x%X, ", cmdVersion);
+    Demodulator_getFirmwareVersion ((Demodulator*) &pdc->Demodulator, Processor_LINK, &cmdVersion);
+    deb_data("FwVer LINK = 0x%X\n", cmdVersion);
+    
+    return error;
+	
+}
+
+static DWORD DRV_InitDevInfo(
+    	void *      handle,
+    	BYTE        ucSlaveDemod
+)
+{
+    DWORD dwError = Error_NO_ERROR;    
+ 
+    PDC->fc[ucSlaveDemod].ulCurrentFrequency = 0;  
+    PDC->fc[ucSlaveDemod].ucCurrentBandWidth = 0;
+
+    PDC->fc[ucSlaveDemod].ulDesiredFrequency = 0;	
+    PDC->fc[ucSlaveDemod].ucDesiredBandWidth = 6000;	
+
+    //For PID Filter Setting
+    //PDC->fc[ucSlaveDemod].ulcPIDs = 0;    
+    PDC->fc[ucSlaveDemod].bEnPID = true;
+    PDC->fc[ucSlaveDemod].bApOn = false;
+    PDC->fc[ucSlaveDemod].bResetTs = false;
+
+    PTI.bTunerOK = false;
+    PTI.bSettingFreq = false;
+
+    return dwError;
+}	
+
+static DWORD DRV_GetEEPROMConfig(    
+	void *      handle)
+{
+	DWORD dwError = Error_NO_ERROR;
+	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+    	BYTE ucSlaveDemod = 0;
+	BYTE btmp = 0;
+
+	deb_data("- Enter %s Function -",__FUNCTION__);	
+   
+	//bIrTblDownload option
+	dwError =   Demodulator_readRegisters((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, EEPROM_IRMODE, 1, &btmp);
+	if (dwError) return(dwError);
+	PDC->bIrTblDownload = btmp ? true:false;
+	deb_data(	"EEPROM_IRMODE = 0x%02X, ", btmp);
+        deb_data("bIrTblDownload %s\n", PDC->bIrTblDownload?"ON":"OFF");
+ 
+    	PDC->bDualTs = false;
+    	PDC->architecture = Architecture_DCA;
+    	PDC->Demodulator.chipNumber = 1;    
+    	PDC->bDCAPIP = false;
+
+
+        dwError = DRV_GetEEPROMConfig2(pdc, ucSlaveDemod);
+	 if (dwError) return(dwError);  
+        dwError = DRV_InitDevInfo(pdc, ucSlaveDemod);
+    
+   	 return(dwError);     
+}   
+
+static DWORD DRV_SetBusTuner(
+	 void * handle, 
+	 Word busId, 
+	 Word tunerId
+)
+{
+	DWORD dwError = Error_NO_ERROR;
+	DWORD 	 version = 0;
+
+	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+	deb_data("- Enter %s Function -",__FUNCTION__);
+	deb_data("busId = 0x%x, tunerId =0x%x\n", busId, tunerId);
+
+	if ((pdc->UsbMode==0x0110) && (busId==Bus_USB)) {
+        busId=Bus_USB11;    
+    }
+    
+    	dwError = Demodulator_setBusTuner ((Demodulator*) &pdc->Demodulator, busId, tunerId);
+	if (dwError) {deb_data("Demodulator_setBusTuner error\n");return dwError;}
+	dwError = Demodulator_getFirmwareVersion ((Demodulator*) &pdc->Demodulator, Processor_LINK, &version);
+    	if (version != 0) {
+        	pdc->Demodulator.booted = True;
+    	} 
+    	else {
+        	pdc->Demodulator.booted = False;
+    	}
+    	return(dwError); 
+}
+
+
+DWORD A333TunerPowerControl(
+	PDEVICE_CONTEXT pdc,	
+	BYTE    ucSlaveDemod,
+	bool        bPowerOn
+)
+{
+
+	DWORD dwError = Error_NO_ERROR;
+
+	if(bPowerOn)
+       	PTI.bTunerInited = true;
+	else
+		PTI.bTunerInited = false;    
+
+    //control oscilator	
+   	dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_OSC_en, 1);
+    dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_OSC_on, 1);
+   	dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_OSC_o, 1); 
+
+    dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR1_en, 1);
+   	dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR1_on, 1);
+    dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR1_o, 1); 
+   	dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR2_en, 1);
+    dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR2_on, 1);
+   	dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR2_o, 1);
+
+    if(bPowerOn) 
+	{
+   		dwError=Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_OSC_o, 1); 
+       	dwError=Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR1_o, 1);
+       	dwError=Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR2_o, 1);
+        if(pdc->bTunerPowerOff == true) 
+   	    {
+       	    dwError = Demodulator_initialize ((Demodulator*) &pdc->Demodulator, pdc->Demodulator.chipNumber, 
+											pdc->Demodulator.bandwidth[0], pdc->StreamType, pdc->architecture);  
+			pdc->bTunerPowerOff = false;
+		}              	        
+		
+    }
+	else 
+	{ // power off
+	
+		if(pdc->architecture == Architecture_PIP)
+		{
+			if(pdc->fc[0].tunerinfo.bTunerInited == 0 && pdc->fc[1].tunerinfo.bTunerInited == 0) 
+           	{                                
+               	if(pdc->bTunerPowerOff == false) 
+               	{
+                   	dwError = Demodulator_finalize((Demodulator*) &pdc->Demodulator);
+					pdc->bTunerPowerOff = true;
+				}
+       	        dwError = Demodulator_writeRegister((Demodulator*)&PDC->Demodulator,0,Processor_LINK,PDC->Map.GPIO_TUR1_o, 0);
+           	    dwError = Demodulator_writeRegister((Demodulator*)&PDC->Demodulator,0,Processor_LINK,PDC->Map.GPIO_TUR2_o, 0);
+   	        	dwError = Demodulator_writeRegister((Demodulator*)&PDC->Demodulator,0,Processor_LINK,PDC->Map.GPIO_OSC_o, 0);
+            }
+        }
+		else 
+		{
+			if(pdc->bTunerPowerOff == false) 
+            {                
+               	dwError = Demodulator_finalize((Demodulator*) &pdc->Demodulator);
+	        	pdc->bTunerPowerOff = true;
+			}      
+
+			dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR1_o, 0);
+			dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_TUR2_o, 0);
+			dwError = Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_OSC_o, 0);
+		}        	
+	}
+
+	return dwError;
+}
+
+DWORD A337TunerPowerControl(
+	PDEVICE_CONTEXT pdc,	
+	BYTE    ucSlaveDemod,
+	bool        bPowerOn
+)
+{
+
+	DWORD dwError = Error_NO_ERROR;
+
+	if(bPowerOn)
+		PTI.bTunerInited = true;
+	else
+		PTI.bTunerInited = false;    
+
+	if(bPowerOn) //tuner on
+	{
+		if(pdc->bTunerPowerOff == true) 
+		{
+			//use variable to control gpio
+
+			// enable tuner power
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR1_en, 1);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR1_on, 1);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR2_en, 1);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR2_on, 1);
+
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR1_o, 1); 
+			mdelay(100);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR2_o, 1);
+			mdelay(100);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_en, 1);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_on, 1);
+
+				
+			// reset tuner
+			deb_data("A337 reset");
+			mdelay(10);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_o, 0); 
+			mdelay(30);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_o, 1);
+
+			mdelay(300);
+			deb_data("pdc->bTunerPowerOff == true\n");
+			dwError = Demodulator_initialize ((Demodulator*) &pdc->Demodulator, pdc->Demodulator.chipNumber , pdc->Demodulator.bandwidth[0], pdc->StreamType, pdc->architecture);  
+			pdc->bTunerPowerOff = false;
+		}              	        
+	}
+	else //tuner off
+	{
+		// Bugfix: wrong level of tuner i2c whiling plugging in device.
+		dwError = Demodulator_finalize((Demodulator*) &pdc->Demodulator);
+		if(pdc->bTunerPowerOff == false) 
+		{                
+			pdc->bTunerPowerOff = true;
+
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_o, 0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_en, 0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, p_reg_top_gpioh12_on, 0);
+			mdelay(10);
+
+			// disable tuner power
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR1_o, 0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR2_o, 0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR1_en,0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR1_on,0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR2_en,0);
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_LINK, pdc->Map.GPIO_TUR2_on,0);
+		}      
+	}
+
+	return dwError;
+}
+
+
+static DWORD DRV_TunerPowerCtrl(
+    	void *	handle, 
+     	BYTE	ucSlaveDemod,
+     	bool		bPowerOn
+)
+{ 
+    DWORD dwError = Error_NO_ERROR;	
+
+    PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+    deb_data("- Enter %s Function , bPowerOn=%d -\n",__FUNCTION__, bPowerOn);
+
+	deb_data("Detected tuner ID: 0x%x\n", pdc->fc[0].tunerinfo.TunerId);
+
+	switch(PDC->idProduct)
+	{
+	case 0xa337:	//A337
+	case 0x0337:	//A867
+	case 0xa867:	//A867
+    case 0x0867:
+    case 0x1867:
+	case 0xF337:
+		dwError = A337TunerPowerControl(pdc, ucSlaveDemod, bPowerOn);
+		break;
+	case 0xa333:	//A337 & EVB
+	default:	
+		dwError = A333TunerPowerControl(pdc, ucSlaveDemod, bPowerOn);
+	}
+
+	return dwError;
+}
+
+static DWORD DRV_ApCtrl (
+      void *      handle,
+      Byte        ucSlaveDemod,
+      Bool        bOn
+)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+        PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+
+	deb_data("enter DRV_ApCtrl: ucSlaveDemod = %d, bOn = %s\n", ucSlaveDemod, bOn?"ON":"OFF"); 
+
+      //deb_data("enter DRV_ApCtrl: Demod[%d].GraphBuilt = %d", ucSlaveDemod, pdc->fc[ucSlaveDemod].GraphBuilt); 
+	
+   	Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_LED_en, 1); 
+   	Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_LED_on, 1); 
+   	Demodulator_writeRegister((Demodulator*) &PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_LED_o, bOn?1:0); 
+
+
+	dwError = DRV_TunerPowerCtrl(handle, ucSlaveDemod, bOn);
+       	if(dwError) deb_data("DRV_TunerPowerCtrl Fail: 0x%08x\n", dwError); 
+
+	
+    	dwError = Demodulator_controlPowerSaving((Demodulator*) &pdc->Demodulator, ucSlaveDemod, bOn);   
+    	if(dwError) deb_data("DRV_ApCtrl: Demodulator_controlPowerSaving error = 0x%08x\n", dwError);
+	
+    return(dwError);
+}
+
+
+static DWORD DRV_TunerWakeup(
+      void *     handle
+)
+{   
+    	DWORD dwError = Error_NO_ERROR;
+
+    	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT) handle;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+	//tuner power on
+	dwError = Demodulator_writeRegisterBits((Demodulator*) &pdc->Demodulator, 0, Processor_LINK,  p_reg_top_gpioh7_o, reg_top_gpioh7_o_pos, reg_top_gpioh7_o_len, 1);	 
+
+    return(dwError);
+
+}
+
+static DWORD DRV_Reboot(
+	void * handle
+)
+{
+    	DWORD dwError = Error_NO_ERROR;
+
+    	PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT) handle;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+	dwError = Demodulator_reboot((Demodulator*) &pdc->Demodulator);
+
+	return(dwError);
+}
+//s021+e
+
+static DWORD DRV_IsPsbOverflow(
+	void *	handle,
+	Byte	ucSlaveDemod,
+	Bool	*bPsbOverflow
+)
+{
+	DWORD dwError = Error_NO_ERROR;
+	Byte ucValue;
+        PDEVICE_CONTEXT pdc = (PDEVICE_CONTEXT)handle;
+	Bool PsbOverflow;
+
+	deb_data("enter %s: - \n", __FUNCTION__); 
+
+	if( ucSlaveDemod ) { //13
+		dwError = Demodulator_readRegister((Demodulator*) &pdc->Demodulator, 0, Processor_OFDM, p_reg_sys_buf_overflow, &ucValue);
+		if( dwError ) goto exit;
+
+		PsbOverflow = (ucValue&0x01)? 1:0;
+		if( PsbOverflow ) {
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_OFDM, p_reg_sys_buf_overflow, ucValue&(~0x01));
+			if( dwError ) goto exit;
+		}
+	}
+	else { //15
+		dwError = Demodulator_readRegister((Demodulator*) &pdc->Demodulator, 0, Processor_OFDM, p_mp2if_psb_overflow, &ucValue);
+		if( dwError ) goto exit;
+
+		PsbOverflow = (ucValue&0x01)? 1:0;
+		if( PsbOverflow ) {
+			dwError = Demodulator_writeRegister((Demodulator*) &pdc->Demodulator, 0, Processor_OFDM, p_mp2if_psb_overflow, ucValue&(~0x01));
+			if( dwError ) goto exit;
+		}
+	}
+
+	if( bPsbOverflow ) *bPsbOverflow = PsbOverflow;
+exit:
+	return dwError;
+}
+
+//************** DL_ *************//
+//
+DWORD DL_ResetPID(void)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+    dwError = DRV_ResetPID(PDC, 0);
+
+	return dwError;
+}
+
+DWORD DL_AddPID(BYTE index, Pid pid)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+	dwError = DRV_AddPID(PDC, 0, index, pid);
+	
+	return dwError;
+}
+
+DWORD DL_PIDOnOff(DWORD OnOff)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+	dwError = DRV_PIDOnOff(PDC, 0, OnOff);
+
+	return dwError;
+}
+
+DWORD DL_RemovePID(
+    IN  Byte    index,
+    IN  Pid     pid
+)
+{
+
+    DWORD dwError = Error_NO_ERROR;
+	
+	dwError = DRV_RemovePID(PDC, 0, index, pid);
+
+    return(dwError);
+}
+
+
+DWORD DL_IsPsbOverflow(
+	void *	handle,
+	Byte	ucSlaveDemod,
+	Bool *	bPsbOverflow
+)
+{
+	DWORD dwError = DRV_IsPsbOverflow(handle, ucSlaveDemod, bPsbOverflow);
+	return dwError;
+}
+
+
+DWORD DL_MonitorReception(Bool *lock)
+{
+	DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	Bool bLock = False;
+	ChannelStatistic stat;
+
+	deb_data("- Enter %s Function , OvrFlwChk=%d, UnLockCount=%d-\n",__FUNCTION__,
+			PDC->fc[ucSlaveDemod].OvrFlwChk,
+			PDC->fc[ucSlaveDemod].UnLockCount);
+
+	down(&PDC->tunerLock);
+
+	if( PDC->fc[ucSlaveDemod].ulDesiredFrequency==0 || PDC->fc[ucSlaveDemod].ucDesiredBandWidth==0 ) {
+		if( lock ) *lock = False;
+		deb_data("- %s Function skipping\n",__FUNCTION__);
+		goto exit;
+	}
+
+	// check lock status
+	dwError= Demodulator_isLocked((Demodulator*) &PDC->Demodulator, ucSlaveDemod, &bLock);
+	if( dwError!=Error_NO_ERROR ) {
+		goto exit;
+	}
+
+	// consider as unlock if UBC is not zero
+	dwError = Demodulator_getChannelStatistic((Demodulator*) &PDC->Demodulator, ucSlaveDemod, &stat);
+	if( dwError!=Error_NO_ERROR ) {
+		goto exit;
+	}
+
+//uncomment this because this causes instability in channel scan.
+
+
+	// report lock status
+	if( lock ) *lock = bLock;
+	deb_data("- %s Function, LOCK = %d\n", __FUNCTION__, bLock);
+
+	// stop monitoring
+	if(PDC->fc[ucSlaveDemod].OvrFlwChk<1) {
+		deb_data("- %s Function end of monitor cycle -\n",__FUNCTION__);
+
+		// if lock is lost for a while, try to reacquire channel
+		if( PDC->fc[ucSlaveDemod].UnLockCount >= CHECK_LOCK_LOOPS*2/3) {
+			WORD bw = PDC->fc[ucSlaveDemod].ucDesiredBandWidth;
+			DWORD freq = PDC->fc[ucSlaveDemod].ulDesiredFrequency;
+	
+
+			deb_data("- %s Function need to reacquire channel, freq=%d, bw=%d-\n",__FUNCTION__,
+					freq, bw);
+
+			// reacquire channel
+			// first power off, then power on
+			DRV_ApCtrl (PDC, 0, 0);
+			User_delay(0, 500);
+			DRV_ApCtrl (PDC, 0, 1);
+			User_delay(0, 500);
+
+			// switch to another frequency, say 500MHz
+			deb_data("- %s Function switch to 500MHz first -\n",__FUNCTION__);
+			Demodulator_acquireChannel ((Demodulator*) &PDC->Demodulator, ucSlaveDemod,
+							bw, 500000);
+			User_delay(0, 500);
+			// now change to original frequency
+			deb_data("- %s Function switch to %d KHz later -\n",__FUNCTION__, freq);
+			Demodulator_acquireChannel ((Demodulator*) &PDC->Demodulator, ucSlaveDemod,
+							bw, freq);
+		}	
+
+		// restart monitor cycle
+		PDC->fc[ucSlaveDemod].OvrFlwChk = CHECK_LOCK_LOOPS;
+		PDC->fc[ucSlaveDemod].UnLockCount = 0;
+
+		dwError = Error_NO_ERROR;
+		goto exit;
+	}
+	
+	PDC->fc[ucSlaveDemod].OvrFlwChk--;
+
+	// maintain lock count
+	if( !bLock ) PDC->fc[ucSlaveDemod].UnLockCount ++;
+
+	deb_data("- Exit %s Function -\n",__FUNCTION__);
+
+	// avoid race with setfreq
+exit:
+	up(&PDC->tunerLock);
+	return dwError;
+}
+
+
+DWORD DL_GetLocked(Bool *bLock)
+{
+	DWORD dwError;
+	BYTE    ucSlaveDemod=0;
+
+	down(&PDC->tunerLock);
+
+	if( bLock ) {
+		dwError= Demodulator_isLocked((Demodulator*) &PDC->Demodulator, ucSlaveDemod, bLock);
+	}
+	else {
+		dwError = Error_NULL_PTR;
+	}
+
+	up(&PDC->tunerLock);
+	return dwError;
+}
+
+
+DWORD DL_GetSignalStrength(u16 *strength)
+{
+	DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	Byte 	str;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	 	
+
+	dwError = Demodulator_getSignalStrength((Demodulator*) &PDC->Demodulator, ucSlaveDemod, &str);
+
+	if( strength ) *strength = str;
+
+	return dwError;
+}
+
+DWORD DL_GetSignalQuality(u16 *squality)
+{
+	DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	Byte 	str;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	 	
+
+	dwError = Demodulator_getSignalQuality((Demodulator*) &PDC->Demodulator, ucSlaveDemod, &str);
+
+	if( squality ) *squality = str;
+
+	return dwError;
+}
+
+
+DWORD DL_GetChannelStat(u32 *ber, u32 *berbits, u32 *ubc)
+{
+	DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	ChannelStatistic stat;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	 	
+
+	dwError = Demodulator_getChannelStatistic((Demodulator*) &PDC->Demodulator, ucSlaveDemod, &stat);
+	// ignore error because saved value is returned in stat
+	if( ber ) *ber = stat.postVitErrorCount;
+	if( berbits ) *berbits = stat.postVitBitCount;
+	if( ubc ) *ubc = stat.abortCount;
+
+	return(dwError);
+}
+
+
+static DWORD DL_Initialize(
+	    void *      handle
+)
+{
+    	DWORD dwError = Error_NO_ERROR;  
+    
+     	dwError = DRV_Initialize(handle);   
+
+	return (dwError); 
+    
+}
+
+static DWORD DL_SetBusTuner(
+	 void * handle, 
+	 Word busId, 
+	 Word tunerId
+)
+{
+
+	DWORD dwError = Error_NO_ERROR;
+	
+    	dwError = DRV_SetBusTuner(handle, busId, tunerId);
+
+	return (dwError);
+
+}
+
+static DWORD  DL_GetEEPROMConfig(
+	 void *      handle
+)
+{   
+    DWORD dwError = Error_NO_ERROR;
+
+    dwError = DRV_GetEEPROMConfig(handle);
+
+    return(dwError);
+} 
+
+static DWORD DL_TunerWakeup(
+      void *     handle
+)
+{    
+	DWORD dwError = Error_NO_ERROR;
+
+	 dwError = DRV_TunerWakeup(handle);
+   
+    	return(dwError);
+}
+static DWORD  DL_IrTblDownload(
+      void *     handle
+)
+{
+        DWORD dwError = Error_NO_ERROR;
+
+	dwError = DRV_IrTblDownload(handle);
+
+        return(dwError);
+}
+
+
+DWORD DL_TunerPowerCtrl(u8 bPowerOn)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+	deb_data("enter DL_TunerPowerCtrl:  bOn = %s\n", bPowerOn?"ON":"OFF");
+
+    	dwError = DRV_TunerPowerCtrl(PDC, 0, bPowerOn);
+
+    	return (dwError);
+}
+//EXPORT_SYMBOL(DL_TunerPowerCtrl);
+
+
+DWORD DL_ApCtrl (
+      Bool        bOn
+)
+{
+        DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	//Bool bLock;
+
+	down(&PDC->powerLock);
+
+	deb_data("Enter DL_ApCtrl:  bOn = %s, use_cnt=%d\n", bOn?"ON":"OFF", PDC->power_use_count);
+
+	// implement power management based on reference counting
+	if( bOn ) PDC->power_use_count++;
+	else PDC->power_use_count--;
+	if( PDC->power_use_count < 0 ) PDC->power_use_count = 0;
+
+	if( bOn && PDC->power_use_count==1 ) {
+
+		deb_data("DL_ApCtrl: call DRV_ApCtrl(ON)\n");
+	    	dwError = DRV_ApCtrl (PDC, 0, 1);
+	}
+	else if( !bOn && PDC->power_use_count==0 ) {
+		deb_data("DL_ApCtrl: call DRV_ApCtrl(OFF)\n");
+
+	    	dwError = DRV_ApCtrl (PDC, 0, 0);
+		PDC->fc[ucSlaveDemod].ulDesiredFrequency = 0;
+		PDC->fc[ucSlaveDemod].ucDesiredBandWidth = 0;
+		PDC->fc[ucSlaveDemod].OvrFlwChk = 0;
+	}
+
+	up(&PDC->powerLock);
+
+	deb_data("Exit DL_ApCtrl:  bOn = %s, dwError = %d\n", bOn?"ON":"OFF", dwError);
+    	return(dwError);
+}
+
+// return 1 if the difference between freq1 & freq2 is smaller or equal than t.
+static inline int Is_Within_Tolerance(u32 freq1, u32 freq2, u32 t)
+{
+	u32 diff = (freq1>freq2)? (freq1-freq2) : (freq2-freq1);
+	if( diff<=t ) return 1;
+	else return 0;
+}
+
+
+DWORD DL_Tuner_SetFreq(u32 dwFreq,u8 ucBw)
+{
+
+	DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	if ( (PDC->fc[ucSlaveDemod].ulDesiredFrequency!=dwFreq 
+		&& !Is_Within_Tolerance(PDC->fc[ucSlaveDemod].ulDesiredFrequency, dwFreq, 125) )
+			|| PDC->fc[ucSlaveDemod].ucDesiredBandWidth!=ucBw*1000) 
+	 	dwError = DRV_SetFreqBw(PDC, ucSlaveDemod, dwFreq, ucBw);
+	else
+		deb_data("     the same Frequency & BandWidth\n");
+	 
+    	return(dwError);	
+}
+
+DWORD DL_Tuner_SetBW(u8 ucBw)
+{
+	DWORD dwError = Error_NO_ERROR;
+	BYTE    ucSlaveDemod=0;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	 	
+	if (PDC->fc[ucSlaveDemod].ucDesiredBandWidth!=ucBw*1000)
+	 	dwError =  DRV_SetFreqBw(PDC, ucSlaveDemod, 0, ucBw);
+	else
+		deb_data("     the same BandWidth\n");
+
+	return(dwError);
+}
+
+DWORD DL_ReSetInterval(void)
+{
+         DWORD dwError = Error_NO_ERROR;
+
+
+         return(dwError);
+}
+
+DWORD DL_Reboot(void)
+{
+	DWORD dwError = Error_NO_ERROR;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	 	
+
+	dwError = DRV_Reboot(PDC);
+
+	return(dwError);
+}
+
+
+DWORD Device_init(struct usb_device *udev,struct usb_interface *uintf, PDEVICE_CONTEXT PDCs, Bool bBoot)
+{
+	 DWORD error = Error_NO_ERROR;
+	 BYTE filterIdx=0;
+	 udevs=udev;
+	 uintfs=uintf;
+	 PDC=PDCs;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+	//************* Set Device init Info *************//
+	PDC->bEnterSuspend = false;
+    	PDC->bSurpriseRemoval = false;
+    	PDC->bDevNotResp = false;
+    	PDC->bSelectiveSuspend = false; 
+	PDC->bTunerPowerOff = false;
+
+	if (bBoot)
+	{
+		PDC->bSupportSelSuspend = false;
+		PDC->Demodulator.userData = (Handle)PDC;
+		PDC->Demodulator.chipNumber =1;
+		PDC->architecture=Architecture_DCA;
+		PDC->Demodulator.frequency[0] = 666000;
+		PDC->Demodulator.bandwidth[0] = 8000;
+		PDC->bIrTblDownload = false;
+		PDC->fc[0].tunerinfo.TunerId = 0;
+		PDC->fc[1].tunerinfo.TunerId = 0;
+		PDC->bDualTs=false;	
+        	PDC->FilterCnt = 0;
+		PDC->StreamType = StreamType_DVBT_DATAGRAM;
+		PDC->UsbCtrlTimeOut = 1;
+
+		//init_MUTEX(&PDC->powerLock);
+		//init_MUTEX(&PDC->tunerLock);
+		sema_init(&PDC->powerLock, 1);
+		sema_init(&PDC->tunerLock, 1);
+		
+		PDC->power_use_count = 0;
+
+		PDC->idVendor = udev->descriptor.idVendor;
+		PDC->idProduct = udev->descriptor.idProduct;
+
+		PDC->Demodulator.GPIO8Value[0] = 2;
+		PDC->Demodulator.GPIO8Value[1] = 2;
+
+		PDC->fc[0].AVerFlags = 0x00;
+		PDC->fc[1].AVerFlags = 0x00;
+		
+		//init_MUTEX(&PDC->regLock);
+		sema_init(&PDC->regLock, 1);
+	}
+	else {
+        	PDC->UsbCtrlTimeOut = 5;
+    	}//bBoot
+
+#ifdef AFA_USB_DEVICE 	
+	if (bBoot) {
+		//************* Set USB Info *************//
+		PDC->MaxPacketSize = 0x0200; //default USB2.0
+		PDC->UsbMode = (PDC->MaxPacketSize == 0x200)?0x0200:0x0110;  
+		deb_data("USB mode= 0x%x\n", PDC->UsbMode);
+
+		PDC->TsPacketCount = (PDC->UsbMode == 0x200)?TS_PACKET_COUNT_HI:TS_PACKET_COUNT_FU;
+		PDC->TsFrames = (PDC->UsbMode == 0x200)?TS_FRAMES_HI:TS_FRAMES_FU;
+		PDC->TsFrameSize = TS_PACKET_SIZE*PDC->TsPacketCount;
+		PDC->TsFrameSizeDw = PDC->TsFrameSize/4;
+	}
+	PDC->bEP12Error = false;
+    	PDC->bEP45Error = false; 
+    	PDC->ForceWrite = false;    
+    	PDC->ulActiveFilter = 0;
+#else
+    	PDC->bSupportSuspend = false; 
+#endif//AFA_USB_DEVICE
+	
+#ifdef AFA_USB_DEVICE
+	if(bBoot)
+    	{
+		//patch for eeepc
+        	error = DL_SetBusTuner (PDC, Bus_USB, Tuner_Afatech_AF9007);
+        	PDC->UsbCtrlTimeOut = 5;
+        
+        	error = DL_SetBusTuner (PDC, Bus_USB, Tuner_Afatech_AF9007);
+        	if (error)
+        	{
+            		deb_data("First DL_SetBusTuner fail : 0x%08x\n",error );
+            		goto Exit;
+        	}
+
+        	error =DL_GetEEPROMConfig(PDC);
+        	if (error)
+        	{
+            		deb_data("DL_GetEEPROMConfig fail : 0x%08x\n", error);
+            		goto Exit;
+        	}
+	}//bBoot
+	
+	error = DL_SetBusTuner(PDC, Bus_USB, PDC->fc[0].tunerinfo.TunerId);
+    	if (error)
+    	{
+        	deb_data("DL_SetBusTuner fail!\n");
+        	goto Exit;
+    	}
+
+	if(PDC->Demodulator.chipNumber == 1 && PDC->Demodulator.booted) //warm-boot/(S1)
+	{
+		error = DL_TunerWakeup(PDC);
+	}
+	if(error) deb_data("DL_NIMReset or DL_NIMSuspend or DL_TunerWakeup fail!\n"); 
+
+	error = DL_Initialize(PDC);
+    	if (error) 
+    	{
+        	deb_data("DL_Initialize fail! 0x%08x\n", error);
+        	goto Exit;
+    	}
+	
+	if (PDC->bIrTblDownload) 
+    	{
+        	error = DL_IrTblDownload(PDC);
+       	 	if (error) deb_data("DL_IrTblDownload fail");
+    	}
+
+    	//for (filterIdx=0; filterIdx< pdc->Demodulator.chipNumber; filterIdx++) 
+    	//{  
+		
+
+        	if (bBoot)
+        	{
+			//Bool bLock;
+            		error = DRV_ApCtrl(PDC, filterIdx, false);
+            		if (error) deb_data("%d: DRV_ApCtrl Fail!\n", filterIdx);
+        	} 
+
+	deb_data("        %s success!! \n",__FUNCTION__);
+
+Exit:
+#endif //AFA_USB_DEVICE
+
+	return (error);
+}
+//EXPORT_SYMBOL(Device_init);
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-fe.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-fe.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-fe.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-fe.c	2012-02-27 00:02:36.818915017 +0100
@@ -0,0 +1,936 @@
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include "a867_af903x.h"
+#include "dvb_frontend.h"
+#include "a867_standard.h"
+
+#define A333_FREQ_MIN	44250000
+#define A333_FREQ_MAX	867250000
+
+DEFINE_MUTEX(mutex);
+
+static int alwayslock; // default to 0
+module_param(alwayslock, int, 0644);
+MODULE_PARM_DESC(alwayslock, "Whether to always report channel as locked (default:no).");
+
+
+struct af903xm_state {
+	struct dvb_frontend demod;
+#ifdef V4L2_ONLY_DVB_V5
+	uint32_t current_bandwidth_hz;
+#else
+	fe_bandwidth_t current_bandwidth;
+#endif
+	uint32_t current_frequency;
+
+	struct completion thread_exit;
+	int thread_should_stop;
+	atomic_t thread_created;
+
+	u32 ucblocks;
+	u32 ber;
+	u16 strength;
+	
+	int locked;
+};
+
+int test_map_snr(u32 snr_data, u16 *snr, u16 *maxsnr)
+{
+	Dword error = 0;
+	Dword snr_value = 0;
+	Byte constellation = 0;
+	Byte transmission_mode = 0;
+
+	*maxsnr = 0;
+	*snr = 0;
+
+    /** Get constellation type */
+    error = Standard_readRegisterBits ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, 
+										Processor_OFDM, g_reg_tpsd_const, reg_tpsd_const_pos, reg_tpsd_const_len, &constellation);
+    if (error) goto exit;
+
+    /** Get FFT mode */
+    error = Standard_readRegisterBits ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, 
+										Processor_OFDM, g_reg_tpsd_txmod, reg_tpsd_txmod_pos, reg_tpsd_txmod_len, &transmission_mode);
+    if (error) goto exit;
+
+	// Adjust snr data by transmission mode
+	if (transmission_mode == 0)
+		snr_value = snr_data * 4;
+	else if (transmission_mode == 2)	
+		snr_value = snr_data * 2;
+	else
+		snr_value = snr_data;
+
+   if( constellation == 0) //Constellation_QPSK
+   {
+           if(snr_value < 0xB4771)    *snr = 0;
+           else if(snr_value < 0xC1AED)   *snr = 1;
+           else if(snr_value < 0xD0D27)   *snr = 2;
+           else if(snr_value < 0xE4D19)   *snr = 3;
+           else if(snr_value < 0xE5DA8)   *snr = 4;
+           else if(snr_value < 0x107097)   *snr = 5;
+           else if(snr_value < 0x116975)   *snr = 6;
+           else if(snr_value < 0x1252D9)   *snr = 7;
+           else if(snr_value < 0x131FA4)   *snr = 8;
+           else if(snr_value < 0x13D5E1)   *snr = 9;
+           else if(snr_value < 0x148E53)   *snr = 10;
+           else if(snr_value < 0x15358B)   *snr = 11;
+           else if(snr_value < 0x15DD29)   *snr = 12;
+           else if(snr_value < 0x168112)   *snr = 13;
+           else if(snr_value < 0x170B61)   *snr = 14;
+           else if(snr_value < 0x17A532)   *snr = 15;
+           else if(snr_value < 0x180F94)   *snr = 16;
+           else if(snr_value < 0x186ED2)   *snr = 17;
+           else if(snr_value < 0x18B271)   *snr = 18;
+           else if(snr_value < 0x18E118)   *snr = 19;
+           else if(snr_value < 0x18FF4B)   *snr = 20;
+           else if(snr_value < 0x190AF1)   *snr = 21;
+           else if(snr_value < 0x191451)   *snr = 22;
+           else   *snr = 23;
+	   *maxsnr = 23;
+    }
+    else if ( constellation == 1) //Constellation_16QAM
+    {
+        if(snr_value < 0x4F0D5)    *snr = 0;
+           else if(snr_value < 0x5387A)   *snr = 1;
+           else if(snr_value < 0x573A4)   *snr = 2;
+           else if(snr_value < 0x5A99E)   *snr = 3;
+           else if(snr_value < 0x5CC80)   *snr = 4;
+           else if(snr_value < 0x5EB62)   *snr = 5;
+           else if(snr_value < 0x5FECF)   *snr = 6;
+           else if(snr_value < 0x60B80)   *snr = 7;
+           else if(snr_value < 0x62501)   *snr = 8;
+           else if(snr_value < 0x64865)   *snr = 9;
+           else if(snr_value < 0x69604)   *snr = 10;
+           else if(snr_value < 0x6F356)   *snr = 11;
+           else if(snr_value < 0x7706A)   *snr = 12;
+           else if(snr_value < 0x804D3)   *snr = 13;
+           else if(snr_value < 0x89D1A)   *snr = 14;
+           else if(snr_value < 0x93E3D)   *snr = 15;
+           else if(snr_value < 0x9E35D)   *snr = 16;
+           else if(snr_value < 0xA7C3C)   *snr = 17;
+           else if(snr_value < 0xAFAF8)   *snr = 18;
+           else if(snr_value < 0xB719D)   *snr = 19;
+           else if(snr_value < 0xBDA6A)   *snr = 20;
+           else if(snr_value < 0xC0C75)   *snr = 21;
+           else if(snr_value < 0xC3F7D)   *snr = 22;
+           else if(snr_value < 0xC5E62)   *snr = 23;
+           else if(snr_value < 0xC6C31)   *snr = 24;
+           else if(snr_value < 0xC7925)   *snr = 25;
+           else    *snr = 26;
+	   *maxsnr = 26;
+    }
+    else if ( constellation == 2) //Constellation_64QAM
+    {
+        if(snr_value < 0x256D0)    *snr = 0;
+           else if(snr_value < 0x27A65)   *snr = 1;
+           else if(snr_value < 0x29873)   *snr = 2;
+           else if(snr_value < 0x2B7FE)   *snr = 3;
+           else if(snr_value < 0x2CF1E)   *snr = 4;
+           else if(snr_value < 0x2E234)   *snr = 5;
+           else if(snr_value < 0x2F409)   *snr = 6;
+           else if(snr_value < 0x30046)   *snr = 7;
+           else if(snr_value < 0x30844)   *snr = 8;
+           else if(snr_value < 0x30A02)   *snr = 9;
+           else if(snr_value < 0x30CDE)   *snr = 10;
+           else if(snr_value < 0x31031)   *snr = 11;
+           else if(snr_value < 0x3144C)   *snr = 12;
+           else if(snr_value < 0x315DD)   *snr = 13;
+           else if(snr_value < 0x31920)   *snr = 14;
+           else if(snr_value < 0x322D0)   *snr = 15;
+           else if(snr_value < 0x339FC)   *snr = 16;
+           else if(snr_value < 0x364A1)   *snr = 17;
+           else if(snr_value < 0x38BCC)   *snr = 18;
+           else if(snr_value < 0x3C7D3)   *snr = 19;
+           else if(snr_value < 0x408CC)   *snr = 20;
+           else if(snr_value < 0x43BED)   *snr = 21;
+           else if(snr_value < 0x48061)   *snr = 22;
+           else if(snr_value < 0x4BE95)   *snr = 23;
+           else if(snr_value < 0x4FA7D)   *snr = 24;
+           else if(snr_value < 0x52405)   *snr = 25;
+           else if(snr_value < 0x5570D)   *snr = 26;
+           else if(snr_value < 0x59FEB)   *snr = 27;
+           else if(snr_value < 0x5BF38)   *snr = 28;
+           else    *snr = 29;
+	   *maxsnr = 29;
+    }
+	
+	
+exit:
+	
+	deb_data(" %s Function, SNR = %d -\n",__FUNCTION__, *snr);
+	return error;
+}
+
+int test_read_strength_dbm(struct dvb_frontend *demod, u32 *str)
+{
+	
+	Dword dwError = 0;
+	Byte str_dbm = 0;
+
+   // Read StrengthDBM
+    dwError = Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, est_rf_level_dbm, &str_dbm);
+    if(dwError) {
+	    deb_data("%s error, ret=0x%x\n", __FUNCTION__, dwError);
+		*str = 0;	
+		goto exit;
+    }
+ 
+	deb_data(" %s Function, StrengthDbm = %d -\n",__FUNCTION__, str_dbm);
+
+exit:
+	return dwError;
+}
+
+
+int test_read_snr(struct dvb_frontend *demod, u32 *snr_data)
+{
+	Byte check1 = 0x0, check2 = 0x0;
+	Byte base1  = 0x0, base2  = 0x0;
+	Byte snr1   = 0x0, snr2   = 0x0, snr3=0x0;			
+	u16 baseAddr = 0x0;
+
+	*snr_data = 0x000000;
+
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, 0xf21b, &check1);
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, 0xf999, &check2);
+
+	deb_data(" %s Function, check1=0x%x -\n",__FUNCTION__, check1);
+
+	if(check1 != 0x0c || check2 != 0x01)	return 1;
+	
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, 0x418b, &base1);
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, 0x418c, &base2);
+
+	baseAddr = (base1<<8) + base2 + 0x2C;
+
+	deb_data(" %s Function, base1 = 0x%x -\n",__FUNCTION__, base1);
+	deb_data(" %s Function, base2 = 0x%x -\n",__FUNCTION__, base2);
+	deb_data(" %s Function, (base1<<8) + base2 + 0x2c = baseAddr = 0x%x -\n",__FUNCTION__, baseAddr);
+	
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, baseAddr,   &snr1);
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, baseAddr+1, &snr2);
+    Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, baseAddr+2, &snr3);
+
+	*snr_data = (snr3<<16)+(snr2<<8)+(snr1);
+
+	deb_data(" %s Function, snr data = 0x%x -\n",__FUNCTION__, *snr_data);
+
+	return 0;
+
+}
+
+
+
+/* unused
+static int af903x_set_bandwidth(struct dvb_frontend *demod, u8 bw_idx)
+{
+	struct af903xm_state *state = demod->demodulator_priv;
+
+	deb_data("- Enter %s Function - bandwidth= %d \n",__FUNCTION__,bw_idx);
+
+//	state->current_bandwidth = bw_idx;
+
+	DL_Tuner_SetBW(bw_idx);
+
+	return 0;
+}
+*/
+
+static void af903x_set_channel(struct af903x_ofdm_channel *ch)
+{
+	deb_data("- Enter %s Function - RF=%d, BW=%d\n",__FUNCTION__,ch->RF_kHz,ch->Bw);
+
+	DL_Tuner_SetFreq(ch->RF_kHz,ch->Bw);
+
+}
+
+static int af903x_tune(struct dvb_frontend *demod, struct af903x_ofdm_channel *ch)
+{
+	if (ch != NULL)
+		af903x_set_channel(ch);
+
+	return 0;
+}
+
+static int af903x_init(struct dvb_frontend *demod)
+{
+	int ret = 0;
+	struct af903xm_state *state = demod->demodulator_priv;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+ 
+	ret = usb_autopm_get_interface(uintfs);
+	if(ret) {
+		deb_data("%s calling usb_autopm_get_interface failed with %d\n", __FUNCTION__, ret);
+		return ret;
+	}
+
+	ret = DL_ApCtrl(1);
+	if(ret) {
+		deb_data("af903x_init Fail: 0x%04X", ret);
+		return -EIO;
+	}
+
+	// reset statistics
+	state->ber = 0;
+	state->ucblocks = 0;
+	state->strength = 0;
+	state->locked = 1; 
+	
+	// reset values
+	state->current_frequency = 0;
+#ifdef V4L2_ONLY_DVB_V5
+	state->current_bandwidth_hz = 0;
+#else
+	state->current_bandwidth = 0;
+#endif
+
+	af903x_start_monitor_thread(demod);
+
+	deb_data("- Exit %s Function -\n",__FUNCTION__);
+	return 0;
+}
+
+static int af903x_sleep(struct dvb_frontend *demod)
+{
+	int error;
+        deb_data("Enter %s Function\n",__FUNCTION__);
+
+	af903x_stop_monitor_thread(demod);
+
+        error = DL_ApCtrl(0);
+        if (error) {
+		deb_data("%s calling DL_ApCtrl error : 0x%x\n", __FUNCTION__, error);
+		return -EIO;
+	}
+
+	usb_autopm_put_interface(uintfs);	
+
+	deb_data("- Exit %s Function -\n",__FUNCTION__);
+	return 0;
+}
+static int af903x_identify(struct af903xm_state *state)
+{
+	return 0;
+}
+
+#ifdef V4L2_ONLY_DVB_V5
+static int af903x_get_frontend(struct dvb_frontend* fe)
+{
+	struct dtv_frontend_properties *fep = &fe->dtv_property_cache;
+	struct af903xm_state *state = fe->demodulator_priv;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+	fep->frequency = state->current_frequency;
+	fep->inversion = INVERSION_AUTO;
+	fep->bandwidth_hz = state->current_bandwidth_hz;
+
+	return 0;
+}
+
+static int af903x_set_frontend(struct dvb_frontend* fe)
+{
+	struct dtv_frontend_properties *fep = &fe->dtv_property_cache;
+	struct af903xm_state *state = fe->demodulator_priv;
+	struct af903x_ofdm_channel ch;
+	u16 bw=0;
+	int ret=0;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+
+	if( fep->frequency < A333_FREQ_MIN || fep->frequency > A333_FREQ_MAX ) {
+		deb_data("- %s freq=%d Hz out of range(%d~%d)-\n",__FUNCTION__, fep->frequency, 
+				A333_FREQ_MIN, A333_FREQ_MAX);
+		// set to zero so we can report unlock to AP, because return -EINVAL apparently 
+		// does not stop AP from continuing tuning.
+		state->current_frequency = 0;
+		return -EINVAL;
+	}
+
+	switch(fep->bandwidth_hz) {
+	case 8000000: bw=8; break;
+	case 7000000: bw=7; break;
+	case 6000000: bw=6; break;
+	default:
+		deb_data("- %s unknown bw value: %d -\n",__FUNCTION__, fep->bandwidth_hz);
+		return -EINVAL;
+	}
+
+
+	ch.RF_kHz           = fep->frequency / 1000;
+	ch.Bw               = bw;
+	deb_data("- %s freq=%d KHz, bw=%d MHz -\n",__FUNCTION__, ch.RF_kHz,  ch.Bw);
+
+	state->current_bandwidth_hz = fep->bandwidth_hz;
+	state->current_frequency = fep->frequency;
+
+	ret = af903x_tune(fe, &ch);
+
+	// start monitor thread if not yet.
+	af903x_start_monitor_thread(fe);
+	
+	return ret;
+}
+#else
+static int af903x_get_frontend(struct dvb_frontend* fe,
+				struct dvb_frontend_parameters *fep)
+{
+	struct af903xm_state *state = fe->demodulator_priv;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	memset(fep, 0, sizeof(*fep));
+	fep->frequency = state->current_frequency;
+	fep->inversion = INVERSION_AUTO;
+	fep->u.ofdm.bandwidth = state->current_bandwidth;
+	return 0;
+}
+
+static int af903x_set_frontend(struct dvb_frontend* fe,
+				struct dvb_frontend_parameters *fep)
+{
+	struct af903xm_state *state = fe->demodulator_priv;
+	struct af903x_ofdm_channel ch;
+	u16 bw=0;
+	int ret=0;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+
+	if( fep->frequency < A333_FREQ_MIN || fep->frequency > A333_FREQ_MAX ) {
+		deb_data("- %s freq=%d Hz out of range(%d~%d)-\n",__FUNCTION__, fep->frequency, 
+				A333_FREQ_MIN, A333_FREQ_MAX);
+		// set to zero so we can report unlock to AP, because return -EINVAL apparently 
+		// does not stop AP from continuing tuning.
+		state->current_frequency = 0;
+		return -EINVAL;
+	}
+
+	switch(fep->u.ofdm.bandwidth) {
+	case BANDWIDTH_8_MHZ: bw=8; break;
+	case BANDWIDTH_7_MHZ: bw=7; break;
+	case BANDWIDTH_6_MHZ: bw=6; break;
+
+	case 6: 
+	//case 7:
+	//case 8:
+		bw = fep->u.ofdm.bandwidth;
+		deb_data("- %s wrong bw value: %d -\n",__FUNCTION__, fep->u.ofdm.bandwidth);
+		break;
+	default:
+
+		deb_data("- %s unknown bw value: %d -\n",__FUNCTION__, fep->u.ofdm.bandwidth);
+		return -EINVAL;
+	}
+
+
+	ch.RF_kHz           = fep->frequency / 1000;
+	ch.Bw               = bw;
+	deb_data("- %s freq=%d KHz, bw=%d MHz -\n",__FUNCTION__, ch.RF_kHz,  ch.Bw);
+
+	state->current_bandwidth = fep->u.ofdm.bandwidth;
+	state->current_frequency = fep->frequency;
+
+	ret = af903x_tune(fe, &ch);
+
+	// start monitor thread if not yet.
+	af903x_start_monitor_thread(fe);
+	
+	return ret;
+}
+#endif
+
+static int af903x_read_status(struct dvb_frontend *fe, fe_status_t *stat)
+{
+	//DWORD dwError;
+	Bool bLock;
+	struct af903xm_state *state = fe->demodulator_priv;
+	//u32	snr_data;
+	//u32 str_dbm_data;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	*stat = 0;
+
+#if !USE_MONITOR_TH	
+	{	
+	unsigned long j = (HZ*500)/1000;
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(j);
+	}
+	dwError = DL_GetLocked(&bLock);
+	if( dwError ) {
+		deb_data("- Function %s error=0x%x\n",__FUNCTION__, dwError);	
+		return -EIO;
+	}
+#else
+	if( alwayslock ) {
+		bLock = True;
+	}
+	else {
+		bLock = state->locked;
+	}
+#endif
+	if( bLock ) {
+		*stat |= FE_HAS_SIGNAL;
+		*stat |= FE_HAS_CARRIER;
+		*stat |= FE_HAS_LOCK;
+		*stat |= FE_HAS_VITERBI;
+		*stat |= FE_HAS_SYNC;
+	}
+
+
+	// report unlock if frequency is out of bound
+	if( 0==state->current_frequency ) {
+		*stat = 0;
+	}
+	
+#if ENABLE_TEST_FUNCTION
+	test_read_snr(fe, &snr_data);
+	test_map_snr(snr_data, &snr);
+	test_read_strength_dbm(fe, &str_dbm_data);
+#endif
+
+	deb_data("- Exit %s Function, status=0x%x -\n",__FUNCTION__, *stat);
+	return 0;
+}
+
+static int af903x_read_ubc(struct dvb_frontend *fe, u32* ucblocks)
+{
+	struct af903xm_state *state = fe->demodulator_priv;
+	//DWORD dwError;
+	//Bool bLock;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	
+
+#if !USE_MONITOR_TH
+	DL_GetChannelStat(NULL, NULL, ucblocks);
+
+	dwError = DL_GetLocked(&bLock);
+	// if signal is not locked, fill with 65535 to indicate loss of signal
+	if( dwError || !bLock ) {
+		deb_data("- Function %s lost lock , error=0x%x, bLock=%d -\n",__FUNCTION__, dwError, bLock);	
+		if( ucblocks ) *ucblocks = 65535;
+		return 0;
+	}
+#else
+	if( ucblocks ) *ucblocks = state->ucblocks;
+#endif
+
+	deb_data("- Exit %s Function, ubc=%d -\n",__FUNCTION__, ucblocks? *ucblocks:-1);
+	return 0;
+}
+
+
+static int af903x_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct af903xm_state *state = fe->demodulator_priv;
+	//DWORD dwError;
+	//u32 berbits;
+	//Bool bLock;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	
+
+#if !USE_MONITOR_TH
+	DL_GetChannelStat(ber, &berbits, NULL);
+
+	// if signal is not locked, fill BER with BER total bits
+	dwError = DL_GetLocked(&bLock);
+	if( dwError || !bLock ) {
+		deb_data("- Function %s lost lock , error=0x%x, bLock=%d -\n",__FUNCTION__, dwError, bLock);	
+		if( ber ) *ber = berbits;
+		return 0;
+	}
+#else
+	if( ber ) *ber = state->ber;
+#endif
+	//
+	deb_data("- Exit %s Function , ber=%d-\n",__FUNCTION__, ber? *ber:(-1));
+	return 0;
+}
+
+
+static int af903x_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	DWORD dwError;
+	Bool bLock;
+	Byte value;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	
+
+	dwError = Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, signal_strength, &value);
+	//dwError = DL_GetSignalStrength(strength);
+	if( dwError ) {
+		deb_data("- Function %s error reading signal strength -\n",__FUNCTION__);	
+		*strength = 0;
+		return 1;
+	}
+
+	dwError = DL_GetLocked(&bLock);
+	if( dwError ) {
+		deb_data("- Function %s error reading signal quality : lost lock -\n",__FUNCTION__);	
+		*strength = 0;
+		return 1;
+	}
+	
+	deb_data("- Exit %s Function, signal strength (0-100)=%d -\n",__FUNCTION__, value);	
+
+	// 16 bit output
+	*strength = value * (0xffff / 100);
+
+	return 0;
+}
+
+/*
+static int af903x_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct af903xm_state *state = fe->demodulator_priv;
+	//DWORD dwError;
+	// Bool bLock;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	
+
+#if !USE_MONITOR_TH
+	DL_GetSignalStrength(strength);
+
+	dwError = DL_GetLocked(&bLock);
+	if( dwError || !bLock ) {
+		deb_data("- Function %s lost lock , error=0x%x, bLock=%d -\n",__FUNCTION__, dwError, bLock);	
+		if( strength ) *strength = 0;
+		return 0;
+	}
+#else
+	if( strength ) *strength = state->strength;
+#endif
+	
+	deb_data("- Exit %s Function, strength=%d -\n",__FUNCTION__, strength? *strength:-1);	
+	return 0;
+}
+*/
+
+static int af903x_read_snr(struct dvb_frontend* fe, u16 *snr)
+{
+	Byte value_7_0 = 0;
+	Byte value_15_8 = 0;
+	Byte value_23_16 = 0;
+	//Dword addr = 0;
+	Dword dwError = 0;
+	u32 snr_val=0;
+	u16 snr_max=0;
+	u16 snr_16bit = 0;
+
+	*snr = 0;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+
+	dwError = Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, qnt_vbc_err_7_0, &value_7_0);
+	if(dwError)	{
+		deb_data("- Function %s  qnt_vbc_err_7_0 register read fail ! -\n",__FUNCTION__);
+		return 1;
+	}
+
+	dwError = Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, qnt_vbc_err_15_8, &value_15_8);
+	if(dwError)	{
+		deb_data("- Function %s  qnt_vbc_err_15_8 register read fail ! -\n",__FUNCTION__);
+		return 1;
+	}
+
+	dwError = Standard_readRegister ((Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, Processor_OFDM, qnt_vbc_err_23_16, &value_23_16);
+	if(dwError)	{
+		deb_data("- Function %s  qnt_vbc_err_23_16 register read fail ! -\n",__FUNCTION__);
+		return 1;
+	}
+
+	snr_val = (value_23_16 << 16) + (value_15_8 << 8) + value_7_0;
+	deb_data("- Function %s SNR row val 0x%x -\n",__FUNCTION__,snr_val);
+
+	dwError = test_map_snr(snr_val, snr, &snr_max);
+	if(dwError)	{
+		deb_data("- Function %s  map_snr fail ! -\n",__FUNCTION__);
+		*snr = 0;
+		return 1;
+	}
+	snr_16bit = (0xffff / snr_max) * *snr;
+	deb_data("- Exit %s SNR %d dB , %d 16bit -\n",__FUNCTION__,*snr,snr_16bit);
+
+	if (dvb_usb_af903x_snrdb == 0)
+		*snr = snr_16bit;
+
+	return 0;
+
+}
+
+
+
+static void af903x_release(struct dvb_frontend *demod)
+{
+	struct af903xm_state *st = demod->demodulator_priv;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	af903x_stop_monitor_thread(demod);
+	kfree(st);
+}
+
+static struct dvb_frontend_ops af903x_ops = {
+#ifdef V4L2_ONLY_DVB_V5
+	.delsys = { SYS_DVBT },
+#endif
+	.info = {
+		.name = "A867 USB DVB-T",
+#ifndef V4L2_ONLY_DVB_V5
+		.type = FE_OFDM,
+#endif
+		.frequency_min      = A333_FREQ_MIN,
+		.frequency_max      = A333_FREQ_MAX,
+		.frequency_stepsize = 62500,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_HIERARCHY_AUTO,
+	},
+
+	.release              = af903x_release,
+
+	.init                 = af903x_init,
+	.sleep                = af903x_sleep,
+
+	.set_frontend         = af903x_set_frontend,
+	.get_frontend         = af903x_get_frontend,
+
+	.read_status          = af903x_read_status,
+	.read_ber             = af903x_read_ber,
+	.read_signal_strength = af903x_read_signal_strength,
+	.read_snr             = af903x_read_snr,
+//	.read_snr             = af903x_read_signal_quality,
+	.read_ucblocks	      = af903x_read_ubc,
+};
+
+static struct dvb_frontend_ops af903x_ops;
+struct dvb_frontend * af903x_attach(u8 tmp)
+{
+	struct dvb_frontend *demod;
+	struct af903xm_state *st;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);	
+	st = kzalloc(sizeof(struct af903xm_state), GFP_KERNEL);
+	if (st == NULL)
+		return NULL;
+
+	demod                   = &st->demod;
+	demod->demodulator_priv = st;
+	memcpy(&st->demod.ops, &af903x_ops, sizeof(struct dvb_frontend_ops));
+	atomic_set(&st->thread_created, 0);
+
+	af903x_identify(st); 
+
+	return demod;
+}
+
+
+static Dword Monitor_GPIO8(void)
+{
+    Dword error = Error_NO_ERROR;
+    Byte PinValue;
+
+    if ( PDC->idProduct!=0xa333 ) {
+	goto exit;
+    }
+
+    if( PDC->fc[0].AVerFlags&0x04 ) {
+	deb_data("%s, skip read GPIO8\n", __FUNCTION__);
+	PDC->fc[0].AVerFlags &= ~(0x04);
+	goto exit;
+    }
+
+    // read GPIO8
+    error = Standard_readRegister ((Demodulator *)&PDC->Demodulator, 
+			PDC->Map.RF_SW_HOST, 
+			Processor_LINK, 
+			PDC->Map.GPIO_STR_i, 
+			&PinValue);
+    if( error ) goto exit;
+
+    if( PDC->Demodulator.GPIO8Value[0] != PinValue ) {
+
+        if( PinValue == 1 ) {
+	    error = Standard_writeRegister ( (Demodulator *)&PDC->Demodulator, 
+			PDC->Map.RF_SW_HOST, 
+			Processor_LINK, 
+			PDC->Map.GPIO_UHF_o, 
+			1);
+	    error = Standard_writeRegister ( (Demodulator *)&PDC->Demodulator, 
+			PDC->Map.RF_SW_HOST, 
+			Processor_LINK, 
+			PDC->Map.GPIO_VHF_o, 
+			1);
+        }
+        else if (PDC->fc[0].ulDesiredFrequency > 300000)
+        {
+	     //UHF
+	    error = Standard_writeRegister ( (Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, 
+					Processor_LINK, PDC->Map.GPIO_UHF_o, 1);
+	    error = Standard_writeRegister ( (Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, 
+					Processor_LINK, PDC->Map.GPIO_VHF_o, 0);
+        }
+        else
+        {
+	    //VHF
+	    error = Standard_writeRegister ( (Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, 
+					Processor_LINK, PDC->Map.GPIO_UHF_o, 0);
+	    error = Standard_writeRegister ( (Demodulator *)&PDC->Demodulator, PDC->Map.RF_SW_HOST, 
+					Processor_LINK, PDC->Map.GPIO_VHF_o, 1);
+        }
+	 PDC->Demodulator.GPIO8Value[0] = PinValue;
+    }
+    else if( PinValue == 0 ) { // pin value remains 0
+	if( PDC->Demodulator.channelStatistic[0].abortCount > 2500  &&
+		(PDC->fc[0].AVerFlags&0x08)==0 ) {
+		// pull high GPIO8
+		PDC->fc[0].AVerFlags |= 0x08; // pull H flag bit 3
+		Demodulator_writeRegister( (Demodulator *)&PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_STR_en, 1);
+		Demodulator_writeRegister( (Demodulator *)&PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_STR_on, 1);
+		Demodulator_writeRegister( (Demodulator *)&PDC->Demodulator, 0, Processor_LINK, PDC->Map.GPIO_STR_o, 1);
+	}
+    }
+    else if( PinValue == 1 ) { // pin value remains 1
+	if( PDC->Demodulator.channelStatistic[0].abortCount < 2500 &&
+		(PDC->fc[0].AVerFlags&0x08)!=0 ) {
+		// after manual tune and result is good
+		PDC->fc[0].AVerFlags &= ~(0x08);
+	}
+    }
+
+exit:
+    return error;
+}
+
+static int af903x_monitor_thread_func(void *data)
+{
+	struct dvb_frontend *demod = data;
+	struct af903xm_state *state = demod? demod->demodulator_priv:NULL;
+	const char *thread_name = "A867_monitor_thread";
+	unsigned long loopcount = 0;
+	Bool bLock = True;
+
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	if( !state ) return -1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+	lock_kernel();
+#else
+	mutex_lock(&mutex);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,61)
+	daemonize();
+	sigfillset(&current->blocked);
+	sprintf(current->comm, "%s", thread_name);
+#else
+	daemonize("%s", thread_name);
+	allow_signal(SIGTERM);
+#endif
+	siginitsetinv(&current->blocked, sigmask(SIGKILL)|sigmask(SIGINT)|\
+			sigmask(SIGTERM));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+	unlock_kernel();
+#else
+	mutex_unlock(&mutex);
+#endif
+	while(!state->thread_should_stop && !signal_pending(current)) {
+	
+		//DWORD dwError;
+		u32 ber, berbits, ucblocks;
+		u16 strength;
+
+		loopcount++;
+
+		// sleep for 500 mili seconds
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout((HZ*500)/1000);
+
+		// monitor lock and return lock status
+		// reacquire channel if lock is lost for quiet a while
+		#if 1
+			DL_MonitorReception(&bLock);
+			state->locked = bLock? 1:0;
+		#endif //0
+		// obtain statistics
+		// do this every 2 loops, which is 1 second
+		if( loopcount%2 == 1  ) {
+			// do not do this if bLock is false, because 
+			//    1. this is not necessary
+			//    2. frequency is not yet set
+			if( bLock ) {
+				DL_GetChannelStat(&ber, &berbits, &ucblocks);
+				DL_GetSignalStrength(&strength);
+
+				// sometimes strength can drop to zero while demod
+				// is still pumping out stream. In which case we
+				// maintain strength to a locked level because 
+				// some AP(kaffeine) seem to rely on strength
+				// for signs of signal lock.
+				//if( strength==0 ) strength = 10;
+				
+				strength = (strength*65535/100);
+			}
+			else {
+				DL_GetChannelStat(NULL, &berbits, NULL);
+				ber = berbits;
+				ucblocks = 65535;
+				strength = 0;
+			}
+
+			state->ber = ber;
+			state->ucblocks = ucblocks;
+			state->strength = strength;
+		}
+		// monitor GPIO8
+	        Monitor_GPIO8();
+	}
+
+	//Firstly, clear thread_created flag so monitor thead can be restored later.
+	atomic_set(&state->thread_created, 0);
+	//Secondly, clear current frequency so we can depent on later set_frequency to restore
+	//this thread.
+	state->current_frequency = 0;
+
+	deb_data("- Exit %s Function -\n",__FUNCTION__);
+	complete_and_exit(&state->thread_exit, 0);
+}
+
+void af903x_start_monitor_thread(struct dvb_frontend *demod)
+{
+	struct af903xm_state *st = demod? demod->demodulator_priv:NULL;
+	if( !st ) return;
+
+#if USE_MONITOR_TH
+	// if st->thread_created is already 1, then skip thread creation
+	if( atomic_add_unless(&st->thread_created, 1, 1) ) {
+		st->thread_should_stop = 0;
+		init_completion(&st->thread_exit); 
+		kernel_thread(af903x_monitor_thread_func, st, 0);
+	}
+#endif //USE_MONITOR_TH
+
+}
+
+void af903x_stop_monitor_thread(struct dvb_frontend *demod)
+{
+	struct af903xm_state *st = demod? demod->demodulator_priv:NULL;
+	deb_data("- Enter %s Function -\n",__FUNCTION__);
+	if( !st ) return;
+
+#if USE_MONITOR_TH
+	// if st->thread_created is alread 0, then skip thread destruction
+	if( atomic_add_unless(&st->thread_created, -1, 0) ) {
+		st->thread_should_stop = 1;
+		wait_for_completion(&st->thread_exit);
+	}
+#endif //USE_MONITOR_TH
+	deb_data("- Exit %s Function -\n",__FUNCTION__);
+}
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x.h	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,311 @@
+ 
+#ifndef _AF903X_H_
+#define _AF903X_H_
+
+#define DVB_USB_LOG_PREFIX "AF903X"
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+#include <linux/smp_lock.h>
+#else
+#include <linux/mutex.h>
+#endif
+#include <linux/usb.h>
+#include <asm/uaccess.h>
+#include "dvb-usb.h"
+#include "a867_af903x-ioctl.h"
+#include "a867_demodulator.h"
+#include "a867_userdef.h"
+//#include "a867_firmware.h"
+#include "a867_type.h"
+#include "a867_Common.h"
+#include "a867_debug.h"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)) || ((defined V4L2_VERSION) && (V4L2_VERSION >= 197120))
+/* all DVB frontend drivers now work directly with the DVBv5
+ * structure. This warrants that all drivers will be
+ * getting/setting frontend parameters on a consistent way, in
+ * order to avoid copying data from/to the DVBv3 structs
+ * without need.
+ */
+#define V4L2_ONLY_DVB_V5
+#endif
+
+#define ENABLE_TEST_FUNCTION 0
+#define ENABLE_HW_PID 0
+
+
+//enable snr reading register , default = 0
+#define ENABLE_READ_REG 1
+
+
+#define SUPPORT_AF903X_EVB	0
+
+//***************** from device.h *****************//
+#define AFA_USB_DEVICE
+
+#define SLAVE_DEMOD_2WIREADDR  0x3A
+
+#define TS_PACKET_SIZE              	188
+#define TS_PACKET_COUNT_HI       348
+#define TS_PACKET_COUNT_FU       21
+
+//***************** from driver.h *****************//
+#define TS_FRAMES_HI 16
+#define TS_FRAMES_FU 128
+#define MAX_USB20_IRP_NUM  5
+#define MAX_USB11_IRP_NUM  2
+
+//***************** from afdrv.h *****************//
+#define GANY_ONLY 0x42F5
+#define EEPROM_FLB_OFS  8
+
+#define EEPROM_IRMODE      (GANY_ONLY+EEPROM_FLB_OFS+0x10)   //00:disabled, 01:HID
+#define EEPROM_SELSUSPEND  (GANY_ONLY+EEPROM_FLB_OFS+0x28)   //Selective Suspend Mode
+#define EEPROM_TSMODE      (GANY_ONLY+EEPROM_FLB_OFS+0x28+1) //0:one ts, 1:dual ts
+#define EEPROM_2WIREADDR   (GANY_ONLY+EEPROM_FLB_OFS+0x28+2) //MPEG2 2WireAddr
+#define EEPROM_SUSPEND     (GANY_ONLY+EEPROM_FLB_OFS+0x28+3) //Suspend Mode
+#define EEPROM_IRTYPE      (GANY_ONLY+EEPROM_FLB_OFS+0x28+4) //0:NEC, 1:RC6
+#define EEPROM_SAWBW1      (GANY_ONLY+EEPROM_FLB_OFS+0x28+5)
+#define EEPROM_XTAL1       (GANY_ONLY+EEPROM_FLB_OFS+0x28+6) //0:28800, 1:20480
+#define EEPROM_SPECINV1    (GANY_ONLY+EEPROM_FLB_OFS+0x28+7)
+#define EEPROM_TUNERID     (GANY_ONLY+EEPROM_FLB_OFS+0x30+4) //
+#define EEPROM_IFFREQL     (GANY_ONLY+EEPROM_FLB_OFS+0x30) 
+#define EEPROM_IFFREQH     (GANY_ONLY+EEPROM_FLB_OFS+0x30+1)   
+#define EEPROM_IF1L        (GANY_ONLY+EEPROM_FLB_OFS+0x30+2)   
+#define EEPROM_IF1H        (GANY_ONLY+EEPROM_FLB_OFS+0x30+3)
+#define EEPROM_SHIFT       (0x10)                 //EEPROM Addr Shift for slave front end
+
+#define CHECK_LOCK_LOOPS	(20)
+#define USE_MONITOR_TH		1
+
+
+extern int dvb_usb_af903x_debug;
+extern int dvb_usb_af903x_snrdb;
+/*
+#if CONFIG_DVB_USB_DEBUG
+#define avprintk(dbg, lvl, fmt, args...) \
+		do { \
+			printk(fmt, ## args); \
+		} while(0)
+#else
+#define avprintk(dbg, lvl, fmt, args...) do {} while(0)
+#endif //CONFIG_DVB_USB_DEBUG
+
+#define deb_info(fmt, args...)   avprintk(dvb_usb_af903x_debug,0x01,fmt, ## args)
+#define deb_fw(fmt, args...)     avprintk(dvb_usb_af903x_debug,0x02,fmt, ## args)
+#define deb_fwdata(fmt, args...) avprintk(dvb_usb_af903x_debug,0x04,fmt, ## args)
+#define deb_data(fmt, args...)   avprintk(dvb_usb_af903x_debug,0x08,fmt, ## args)
+*/
+//#define deb_data(args...)   printk(KERN_NOTICE args)
+
+#define deb_force(args...) printk(KERN_DEBUG args);
+#define deb_info(args...) if (dvb_usb_af903x_debug & 1) printk(KERN_DEBUG args);
+#define deb_fw(args...) if (dvb_usb_af903x_debug & 2) printk(KERN_DEBUG args);
+#define deb_fwdata(args...)   if (dvb_usb_af903x_debug & 4) printk(KERN_DEBUG args);
+#define deb_data(args...)   if (dvb_usb_af903x_debug & 8) printk(KERN_DEBUG args);
+
+typedef struct _GPIO_MAPPINGS {
+	unsigned short  I2C_SLAVE_ADDR;
+	unsigned short  RF_SW_HOST;
+	int GPIO_UHF_en;
+	int GPIO_UHF_on;
+	int GPIO_UHF_o;
+	int GPIO_VHF_en;
+	int GPIO_VHF_on;
+	int GPIO_VHF_o;
+	int GPIO_WP_en;
+	int GPIO_WP_on;
+	int GPIO_WP_o;
+	int GPIO_OSC_en;
+	int GPIO_OSC_on;
+	int GPIO_OSC_o;
+	int GPIO_TUR1_en;
+	int GPIO_TUR1_on;
+	int GPIO_TUR1_o;
+	int GPIO_TUR2_en;
+	int GPIO_TUR2_on;
+	int GPIO_TUR2_o;
+	int GPIO_DPWR_en;
+	int GPIO_DPWR_on;
+	int GPIO_DPWR_o;
+	int GPIO_DRST_en;
+	int GPIO_DRST_on;
+	int GPIO_DRST_o;
+	int GPIO_STR_en;
+	int GPIO_STR_on;
+	int GPIO_STR_o;
+	int GPIO_STR_i;
+	int GPIO_LED_en;
+	int GPIO_LED_on;
+	int GPIO_LED_o;
+} GPIO_MAPPINGS, *PGPIO_MAPPINGS;
+
+//***************** from device.h *****************//
+typedef struct _TUNER_INFO {
+
+    Bool bTunerInited;
+    Bool bSettingFreq;
+    BYTE TunerId;
+    Bool bTunerOK;
+    Tuner_struct MXL5005_Info;
+
+} TUNER_INFO, *PTUNER_INFO;
+
+
+typedef struct  _FILTER_INFO{
+    int filternum;
+    Bool onoff;
+}  FILTER_INFO;
+
+
+typedef struct _FILTER_CONTEXT_HW {
+    DWORD ulCurrentFrequency;
+    WORD  ucCurrentBandWidth;  
+    DWORD ulDesiredFrequency;
+    WORD  ucDesiredBandWidth;   
+    //ULONG ulBandWidth;   
+    Bool bTimerOn;
+   // PKSFILTER filter;
+    Byte GraphBuilt;
+    TUNER_INFO tunerinfo; 
+    //SIGNAL_STATISTICS ss;
+    //SIGNAL_RETRAIN sr;  
+    //DWORD   gdwOrigFCW;     //move from AF901x.cpp [global variable]
+    //BYTE    gucOrigUnplugTh; //move from AF901x.cpp [global variable]
+    //BYTE    gucPreShiftIdx;    //move from AF901x.cpp [global variable]    
+   // PKSFILTERFACTORY  pFilterFactory;
+    int  bEnPID;
+    int ulcPIDs;
+    FILTER_INFO aulPIDs[32];
+    Bool bApOn;
+    int bResetTs;
+    Byte OvrFlwChk;
+    Byte UnLockCount;
+
+    BYTE AVerFlags;
+} FILTER_CONTEXT_HW, *PFILTER_CONTEXT_HW;  
+
+typedef struct _DEVICE_CONTEXT {
+    FILTER_CONTEXT_HW fc[2];
+    Byte DeviceNo;
+    Bool bBootCode;
+    Bool bEP12Error;
+    Bool bEP45Error;
+    //bool bDebugMsg;
+    //bool bDevExist;
+    Bool bDualTs;
+    Bool bIrTblDownload;
+    Byte BulkOutData[256];
+    u32 WriteLength;
+    Bool bSurpriseRemoval;
+    Bool bDevNotResp;
+    Bool bEnterSuspend;
+    Bool bSupportSuspend;
+    Bool bSupportSelSuspend;
+    u16 regIdx; 
+    Byte eepromIdx;
+    u16 UsbMode;
+    u16 MaxPacketSize;
+    u32 MaxIrpSize;
+    u32 TsFrames;
+    u32 TsFrameSize;
+    u32 TsFrameSizeDw;
+    u32 TsPacketCount;
+    //BYTE  ucDemod2WireAddr;
+    //USB_IDLE_CALLBACK_INFO cbinfo;          // callback info for selective suspend          // our selective suspend IRP    
+
+    Bool    bSelectiveSuspend;
+    u32   ulActiveFilter;
+    //BYTE    ucSerialNo; 
+    Architecture architecture;
+    //BYTE Tuner_Id;
+    StreamType StreamType;
+    Bool bDCAPIP;
+    Bool bSwapFilter;
+    Byte FilterCnt;
+    Bool  bTunerPowerOff;
+    //PKSPIN PinSave;
+    Byte UsbCtrlTimeOut;
+	
+   Ganymede Demodulator;
+   
+    Bool ForceWrite;
+
+    GPIO_MAPPINGS Map;
+
+    struct semaphore powerLock;
+    int power_use_count;
+    struct semaphore tunerLock;
+
+    unsigned short idVendor;
+    unsigned short idProduct;
+
+    struct semaphore regLock;
+	
+} DEVICE_CONTEXT, *PDEVICE_CONTEXT;
+
+#define PTI             (PDC->fc[ucSlaveDemod].tunerinfo)   //TunerInfo pointer
+
+
+
+struct af903x_ofdm_channel {
+	u32 RF_kHz;
+	u8  Bw;
+	s16 nfft;
+	s16 guard;
+	s16 nqam;
+	s16 vit_hrch;
+	s16 vit_select_hp;
+	s16 vit_alpha;
+	s16 vit_code_rate_hp;
+	s16 vit_code_rate_lp;
+	u8  intlv_native;
+};
+
+struct tuner_priv {
+        struct tuner_config *cfg;
+        struct i2c_adapter   *i2c;
+
+        u32 frequency;
+        u32 bandwidth;
+        u16 if1_freq;
+        u8  fmfreq;
+};
+
+extern struct dvb_frontend * tuner_attach(struct dvb_frontend *fe);
+extern struct dvb_frontend * af903x_attach(u8 TMP);
+extern struct dvb_usb_device_properties af903x_properties[];
+extern struct usb_device_id af903x_usb_id_table[];
+extern struct usb_device *udevs;
+extern struct usb_interface *uintfs;
+extern PDEVICE_CONTEXT PDC;
+extern int af903x_device_count;
+
+extern void af903x_start_monitor_thread(struct dvb_frontend *demod);
+extern void af903x_stop_monitor_thread(struct dvb_frontend *demod);
+
+extern DWORD Device_init(struct usb_device *udev, struct usb_interface *uintf, PDEVICE_CONTEXT PDCs, Bool bBoot);
+extern DWORD DL_ApCtrl (Bool bOn);
+extern DWORD DL_Tuner_SetBW(u8 ucBw);
+extern DWORD DL_Tuner_SetFreq(u32 ucFreq,u8 ucBw);
+extern DWORD DL_ReSetInterval(void);
+extern DWORD DL_GetChannelStat(u32 *ber, u32 *berbits, u32 *ubc);
+extern DWORD DL_GetSignalStrength(u16 *strength);
+extern DWORD DL_GetSignalQuality(u16 *strength);
+extern DWORD DL_GetLocked(Bool *bLock);
+extern DWORD DL_MonitorReception(Bool *bLock);
+extern DWORD DL_IsPsbOverflow(void *handle, Byte ucSlaveDemod, Bool *bPsvOverflow);
+extern DWORD DL_Reboot(void);
+extern DWORD DL_ResetPID(void);
+extern DWORD DL_AddPID(BYTE index, Pid pid);
+extern DWORD DL_PIDOnOff(DWORD OnOff);
+extern DWORD DL_RemovePID(BYTE index, Pid pid);
+
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-ioctl.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-ioctl.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-ioctl.h	2012-02-27 00:02:36.928915017 +0100
@@ -0,0 +1,29 @@
+#ifndef _AF903X_IOCTL_H_
+#define _AF903X_IOCTL_H_
+
+#include <linux/ioctl.h> /* needed for the _IOW etc stuff used later */
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'k' as magic number */
+#define AFA_IOC_MAGIC  'k'
+/* Please use a different 8-bit number in your code */
+
+//#define AFA_IOCRESETINTERVAL    _IO(AFA_IOC_MAGIC, 0)
+
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": switch G and S atomically
+ * H means "sHift": switch T and Q atomically
+ */
+
+
+/* ... more to come */
+
+#define AFA_IOC_MAXNR 14
+#endif /* _AF903X-IOCTL_H_ */
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-tuner.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-tuner.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-tuner.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_af903x-tuner.c	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,122 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/dvb/frontend.h>
+
+#include "dvb_frontend.h"
+#include "a867_af903x.h"
+
+#define IF2  36150       // IF2 frequency = 36.150 MHz
+#define FREF 16000       // Quartz oscillator 16 MHz
+
+#ifdef V4L2_ONLY_DVB_V5
+static int tuner_set_params(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *params = &fe->dtv_property_cache;
+	struct tuner_priv *priv=NULL;
+	DWORD dwError = Error_NO_ERROR;
+	DWORD freq = params->frequency ;// 1000; // Hz -> kHz
+
+	switch (params->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+	case SYS_ISDBT:
+	case SYS_DMBTH:
+		priv->bandwidth = params->bandwidth_hz;
+		break;
+	default:
+		priv->bandwidth = 0;
+		break;
+	}
+
+	deb_data("%s - freq : %d , bandwidth : %dn",__FUNCTION__, freq, priv->bandwidth);
+
+	/* here, frequency is expressed in KHz and bandwidth in MHz */
+	dwError =DL_Tuner_SetFreq(freq/1000, priv->bandwidth/1000000);
+	if (dwError) deb_data("tuner_set_params Fail !\n");
+	
+	return 0;
+}
+#else
+static int tuner_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)
+{
+	struct tuner_priv *priv=NULL;
+	DWORD dwError = Error_NO_ERROR;
+	DWORD freq = params->frequency ;// 1000; // Hz -> kHz
+	
+	priv->bandwidth = (fe->ops.info.type == FE_OFDM) ? params->u.ofdm.bandwidth : 0;
+
+       deb_data("%s - freq : %d , bandwidth : %dn",__FUNCTION__, freq,priv->bandwidth);
+	   
+	dwError =DL_Tuner_SetFreq(freq,priv->bandwidth);
+	if (dwError) deb_data("tuner_set_params Fail !\n");
+	
+	return 0;
+}
+#endif
+static int tuner_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct tuner_priv *priv = fe->tuner_priv;
+	*frequency = priv->frequency;
+	return 0;
+}
+
+static int tuner_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct tuner_priv *priv = fe->tuner_priv;
+	*bandwidth = priv->bandwidth;
+	return 0;
+}
+
+static int tuner_init(struct dvb_frontend *fe)
+{
+
+	return 0;
+}
+
+static int tuner_sleep(struct dvb_frontend *fe)
+{
+	return 0;
+}
+
+static int tuner_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static const struct dvb_tuner_ops tuner_tuner_ops = {
+	.info = {
+		.name           = "dvb_usb_tuner",
+		.frequency_min  =  48000000,
+		.frequency_max  = 860000000,
+		.frequency_step =     50000,
+	},
+
+	.release       = tuner_release,
+
+	.init          = tuner_init,
+	.sleep         = tuner_sleep,
+
+	.set_params    = tuner_set_params,
+	.get_frequency = tuner_get_frequency,
+	.get_bandwidth = tuner_get_bandwidth
+};
+
+/* This functions tries to identify a MT2060 tuner by reading the PART/REV register. This is hasty. */
+struct dvb_frontend * tuner_attach(struct dvb_frontend *fe)
+{
+	struct tuner_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct tuner_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+
+	memcpy(&fe->ops.tuner_ops, &tuner_tuner_ops, sizeof(struct dvb_tuner_ops));
+
+	fe->tuner_priv = priv;
+	
+	return fe;
+}
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.c	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,50 @@
+/*
+ * @(#)Afatech_AF9007_EXT.cpp
+ *
+ * Copyright 2005 Afatech, Inc. All rights reserved.
+ */
+
+//#include <stdio.h>
+#include "a867_type.h"
+#include "a867_error.h"
+#include "a867_user.h"
+#include "a867_register.h"
+#include "a867_standard.h"
+#include "a867_Afa_AF9007_Script.h"
+
+
+Dword AF9007_open (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+) {
+	return (Error_NO_ERROR);
+}
+
+Dword AF9007_close (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+) {
+	return (Error_NO_ERROR);
+}
+
+Dword AF9007_set (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Word			bandwidth,
+	IN  Dword			frequency
+) {
+	return (Error_NO_ERROR);
+}
+
+TunerDescription tuner_AF9007 = {
+    AF9007_open,
+    AF9007_close,
+    AF9007_set,
+    AF9007_scripts,
+    AF9007_scriptSets,
+    0,                              /** tuner i2c address */
+    0,                              /** length of tuner register address */
+    36167000,                       /** tuner if */
+    True,                           /** spectrum inverse */
+    0xFF                            /** tuner id */
+};
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007.h	2012-02-27 00:02:36.878915017 +0100
@@ -0,0 +1,39 @@
+/**
+ * @(#)Afatech_AF9007_EXT.h
+ *
+ * Copyright 2005 Afatech, Inc. All rights reserved.
+ */
+#ifndef __Afatech_AF9007_EXT_H__
+#define __Afatech_AF9007_EXT_H__
+
+
+extern TunerDescription tuner_AF9007;
+
+
+/**
+ *
+ */
+Dword AF9007_open (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+/**
+ *
+ */
+Dword AF9007_close (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+/**
+ *
+ */
+Dword AF9007_set (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    IN  Word			bandwidth,
+    IN  Dword			frequency
+);
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007_Script.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007_Script.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007_Script.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Afa_AF9007_Script.h	2012-02-27 00:02:36.098915017 +0100
@@ -0,0 +1,93 @@
+/** script version */
+
+#define AF9007_ADDRESS 0xC0
+#define AF9007_SCRIPTSETLENGTH	0x00000001
+
+
+Word AF9007_scriptSets[] = {
+	0x50
+};
+
+ValueSet AF9007_scripts[] = {
+ {0xF600, 0x5},
+ {0xF601, 0x8},
+ {0xF602, 0xb},
+ {0xF603, 0x0e},
+ {0xF604, 0x11},
+ {0xF605, 0x14},
+ {0xF606, 0x17},
+ {0xF607, 0x1f},
+ {0xF1E6, 0x01},
+ {0xF001, 0x00},
+ {0xF005, 0x01},
+ {0xF004, 0x00},
+ {0xF00A, 0x1B},
+ {0xF00B, 0x1C},
+ {0xF00C, 0x1B},
+ {0xF00D, 0x1C},
+ {0xF016, 0x10},
+ {0xF017, 0x04},
+ {0xF018, 0x05},
+ {0xF019, 0x04},
+ {0xF01A, 0x05},
+ {0xF021, 0x03},
+ {0xF022, 0x0A},
+ {0xF023, 0x0A},
+ {0xF000, 0x01},
+ {0xF047, 0x00},
+ {0xF007, 0x00},
+ {0xF12F, 0x00},
+ {0xF077, 0x00},
+ {0xF00A, 0x1A},
+ {0xF00B, 0x1B},
+ {0xF00C, 0x1A},
+ {0xF00D, 0x1B},
+ {0xF01F, 0x50},
+ {0xF020, 0x00},
+ {0xF029, 0x46},
+ {0xF02A, 0x00},
+ {0xF010, 0xDF},
+ {0xF011, 0x02},
+ {0xF00E, 0x44},
+ {0xF00F, 0x01},
+ {0xF014, 0xEB},
+ {0xF015, 0x02},
+ {0xF012, 0xF4},
+ {0xF013, 0x01},
+ {0x0066, 0x52},
+ {0xF01B, 0x26},
+ {0xF01C, 0x01},
+ {0xF01D, 0x12},
+ {0xF01E, 0x03},
+ {0xF025, 0xE8},
+ {0xF026, 0x00},
+ {0xF027, 0x5F},
+ {0xF028, 0x03},
+ {0x0044, 0xFF},
+ {0x0045, 0x03},
+ {0x0046, 0xFF},
+ {0x0047, 0x03},
+ {0x0048, 0xFF},
+ {0x0049, 0x03},
+ {0x004a, 0xFF},
+ {0x004b, 0x03},
+ {0x004c, 0xEB},
+ {0x004d, 0x02},
+ {0x0053, 0x68},
+ {0x0054, 0x03},
+ {0x0059, 0x12},
+ {0x005a, 0x03},
+ {0xF02B, 0x00},
+ {0xF02C, 0x01},
+ {0xF03B, 0x9A},
+ {0xF03C, 0x01},
+ {0xF03D, 0x5A},
+ {0xF03E, 0x01},
+ {0xF03F, 0x96},
+ {0xF040, 0x46},
+ {0xF031, 0x0},
+ {0x006b, 0x0A},
+ {0x006c, 0x14},
+ {0x006d, 0x08},
+};
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_aver_version.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_aver_version.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_aver_version.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_aver_version.h	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1 @@
+#define DRIVER_VER "1.0.27"
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.c	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,1005 @@
+#include "a867_cmd.h"
+
+
+Byte Cmd_sequence = 0;
+
+
+Dword Bus_addChecksum (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          bufferLength,
+    OUT Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+    Dword loop = (*bufferLength - 1) / 2;
+    Dword remain = (*bufferLength - 1) % 2;
+    Dword i;
+    Word checksum = 0;
+
+    for (i = 0; i < loop; i++)
+        checksum += (Word) (buffer[2 * i + 1] << 8) + (Word) (buffer[2 * i + 2]);
+    if (remain)
+        checksum += (Word) (buffer[*bufferLength - 1] << 8);
+    checksum = ~checksum;
+    buffer[*bufferLength] = (Byte) ((checksum & 0xFF00) >> 8);
+    buffer[*bufferLength + 1] = (Byte) (checksum & 0x00FF);
+    buffer[0] = (Byte) (*bufferLength + 1);
+    *bufferLength += 2;
+
+    return (error);
+}
+
+
+Dword Bus_removeChecksum (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          bufferLength,
+    OUT Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+    Dword loop = (*bufferLength - 3) / 2;
+    Dword remain = (*bufferLength - 3) % 2;
+    Dword i;
+    Word checksum = 0;
+
+    for (i = 0; i < loop; i++)
+        checksum += (Word) (buffer[2 * i + 1] << 8) + (Word) (buffer[2 * i + 2]);
+    if (remain)
+        checksum += (Word) (buffer[*bufferLength - 3] << 8);
+    checksum = ~checksum;
+    if (((Word) (buffer[*bufferLength - 2] << 8) + (Word) (buffer[*bufferLength - 1])) != checksum) {
+        error = Error_WRONG_CHECKSUM;
+        goto exit;
+    }
+    if (buffer[2])
+        error = Error_FIRMWARE_STATUS | buffer[2];
+    buffer[0] = (Byte) (*bufferLength - 3);
+    *bufferLength -= 2;
+
+exit :
+    return (error);
+}
+
+
+Dword Cmd_writeRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (writeBufferLength == 0) goto exit;
+    if (registerAddressLength > 4) {
+        error  = Error_PROTOCOL_FORMAT_INVALID;
+        goto exit;
+    }
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    i = 0;
+    while (i < writeBufferLength) {
+
+        j = (writeBufferLength - i) > (maxPktSize - 12) ? (maxPktSize - 12) : (writeBufferLength - i);
+        command = Bus_buildCommand (Command_REG_DEMOD_WRITE, processor, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) j;
+        buffer[5] = (Byte) registerAddressLength;
+        buffer[6] = (Byte) ((registerAddress + i) >> 24); /** Get first byte of reg. address  */
+        buffer[7] = (Byte) ((registerAddress + i) >> 16); /** Get second byte of reg. address */
+        buffer[8] = (Byte) ((registerAddress + i) >> 8);  /** Get third byte of reg. address  */
+        buffer[9] = (Byte) (registerAddress + i);         /** Get fourth byte of reg. address */
+
+        for (k = 0; k < j; k++)
+            buffer[10 + k] = writeBuffer[i + k];
+
+        bufferLength = j + 10;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength = 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        i += j;
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_writeScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsAddressLength,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (valueSetsLength == 0) goto exit;
+    if (valueSetsAddressLength > 4) {
+        error  = Error_PROTOCOL_FORMAT_INVALID;
+        goto exit;
+    }
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    i = 0;
+    while (i < valueSetsLength) {
+        j = (valueSetsLength - i) > ((maxPktSize - 10) / 3) ? ((maxPktSize - 10) / 3) : (valueSetsLength - i);
+        command = Bus_buildCommand (Command_SCATTER_WRITE, processor, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) 2;                       /** Type 2 */
+        if (processor == Processor_LINK)
+            buffer[5] = (Byte) 0;
+        else
+            buffer[5] = (Byte) 1;
+        buffer[6] = (Byte) 0;
+        buffer[7] = (Byte) j;
+
+        for (k = 0; k < j; k++) {
+            buffer[8 + k * 2] = (Byte) (valueSets[k].address >> 8);
+            buffer[9 + k * 2] = (Byte) valueSets[k].address;
+            buffer[8 + j * 2 + k] = (Byte) valueSets[k].value;
+        }
+
+        bufferLength = 8 + j * 3;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength =  5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        i += j;
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_writeTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            tunerAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            writeBufferLength,
+    IN  Byte*           writeBuffer
+) {
+
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+	if (writeBufferLength == 0)
+	{
+        command = Bus_buildCommand (Command_REG_TUNER_WRITE, Processor_LINK, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) 0;
+        buffer[5] = (Byte) tunerAddress;
+        buffer[6] = (Byte) registerAddressLength;
+        buffer[7] = (Byte) ((registerAddress) >> 8);  /** Get high byte of reg. address */
+        buffer[8] = (Byte) (registerAddress);         /** Get low byte of reg. address  */
+
+        bufferLength = 9;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength = 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+		goto exit;
+	}
+
+    i = 0;
+    while (i < writeBufferLength) {
+        j = (writeBufferLength - i) > (maxPktSize - 11) ? (maxPktSize - 11) : (writeBufferLength - i);
+        command = Bus_buildCommand (Command_REG_TUNER_WRITE, Processor_LINK, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) j;
+        buffer[5] = (Byte) tunerAddress;
+        buffer[6] = (Byte) registerAddressLength;
+        buffer[7] = (Byte) ((registerAddress + i) >> 8);  /** Get high byte of reg. address */
+        buffer[8] = (Byte) (registerAddress + i);         /** Get low byte of reg. address  */
+
+        for (k = 0; k < j; k++)
+            buffer[9 + k] = writeBuffer[ i + k];
+
+        bufferLength = j + 9;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength = 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        i += j;
+    }
+
+
+exit :    
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_writeEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            eepromAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            writeBufferLength,
+    IN  Byte*           writeBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Byte i;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (writeBufferLength == 0) goto exit;
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    command = Bus_buildCommand (Command_REG_EEPROM_WRITE, Processor_LINK, chip);
+    buffer[1] = (Byte) (command >> 8);
+    buffer[2] = (Byte) command;
+    buffer[3] = (Byte) Cmd_sequence++;
+    buffer[4] = (Byte) writeBufferLength;
+    buffer[5] = (Byte) eepromAddress;
+    buffer[6] = (Byte) registerAddressLength;
+    buffer[7] = (Byte) (registerAddress >> 8);  /** Get high byte of reg. address */
+    buffer[8] = (Byte) registerAddress;         /** Get low byte of reg. address  */
+
+    for (i = 0; i < writeBufferLength; i++)
+        buffer[9 + i] = writeBuffer[i];
+
+    bufferLength = writeBufferLength + 9;
+    error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    bufferLength = 5;
+
+    error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_readRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (readBufferLength == 0) goto exit;
+    if (registerAddressLength > 4) {
+        error  = Error_PROTOCOL_FORMAT_INVALID;
+        goto exit;
+    }
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    i = 0;
+    while (i < readBufferLength) {
+
+        j = (readBufferLength - i) > (maxPktSize - 5) ? (maxPktSize - 5) : (readBufferLength - i);
+        command = Bus_buildCommand (Command_REG_DEMOD_READ, processor, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) j;
+        buffer[5] = (Byte) registerAddressLength;
+        buffer[6] = (Byte) ((registerAddress + i) >> 24); /** Get first byte of reg. address  */
+        buffer[7] = (Byte) ((registerAddress + i) >> 16); /** Get second byte of reg. address */
+        buffer[8] = (Byte) ((registerAddress + i) >> 8);  /** Get third byte of reg. address  */
+        buffer[9] = (Byte) (registerAddress + i);         /** Get fourth byte of reg. address */
+
+        bufferLength = 10;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength = j + 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+        for (k = 0; k < j; k++) {
+            readBuffer[i + k] = buffer[k + 3];
+        }
+
+        i += j;
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_readScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsAddressLength,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (valueSetsLength == 0) goto exit;
+    if (valueSetsAddressLength > 4) {
+        error  = Error_PROTOCOL_FORMAT_INVALID;
+        goto exit;
+    }
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    i = 0;
+    while (i < valueSetsLength) {
+        j = (valueSetsLength - i) > ((maxPktSize - 10) / 2) ? ((maxPktSize - 10) / 2) : (valueSetsLength - i);
+        command = Bus_buildCommand (Command_SCATTER_READ, processor, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) 2;                       /** Type 2 */
+        if (processor == Processor_LINK)
+            buffer[5] = (Byte) 0;
+        else
+            buffer[5] = (Byte) 1;
+        buffer[6] = (Byte) 0;
+        buffer[7] = (Byte) j;
+
+        for (k = 0; k < j; k++) {
+            buffer[8 + k * 2] = (Byte) (valueSets[k].address >> 8);
+            buffer[9 + k * 2] = (Byte) valueSets[k].address;
+        }
+
+        bufferLength = 8 + j * 2;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength = j + 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+        for (k = 0; k < j; k++) {
+            //(Byte) valueSets[i + k].value = buffer[k + 3];
+	      valueSets[i + k].value = (Byte) buffer[k + 3];
+        }
+
+        i += j;
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_readTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            tunerAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            readBufferLength,
+    IN  Byte*           readBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (readBufferLength == 0) goto exit;
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    i = 0;
+    while (i < readBufferLength) {
+        j = (readBufferLength - i) > (maxPktSize - 5) ? (maxPktSize - 5) : (readBufferLength - i);
+        command = Bus_buildCommand (Command_REG_TUNER_READ, Processor_LINK, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        buffer[4] = (Byte) j;
+        buffer[5] = (Byte) tunerAddress;
+        buffer[6] = (Byte) registerAddressLength;
+        buffer[7] = (Byte) ((registerAddress + i) >> 8);  /** Get high byte of reg. address */
+        buffer[8] = (Byte) (registerAddress + i);         /** Get low byte of reg. address  */
+
+        bufferLength = 9;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        bufferLength = j + 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+        for (k = 0; k < j; k++) {
+            readBuffer[i + k] = buffer[k + 3];
+        }
+
+        i += j;
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_readEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            eepromAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            readBufferLength,
+    OUT Byte*           readBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Byte i;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (readBufferLength == 0) goto exit;
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    command = Bus_buildCommand (Command_REG_EEPROM_READ, Processor_LINK, chip);
+    buffer[1] = (Byte) (command >> 8);
+    buffer[2] = (Byte) command;
+    buffer[3] = (Byte) Cmd_sequence++;
+    buffer[4] = (Byte) readBufferLength;
+    buffer[5] = (Byte) eepromAddress;
+    buffer[6] = (Byte) registerAddressLength;
+    buffer[7] = (Byte) (registerAddress >> 8);  /** Get high byte of reg. address */
+    buffer[8] = (Byte) registerAddress;         /** Get low byte of reg. address  */
+
+    bufferLength = 9;
+    error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    bufferLength = readBufferLength + 5;
+    error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+    for (i = 0; i < readBufferLength; i++) {
+        readBuffer[i] = buffer[i + 3];
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_modifyRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Byte temp;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    if (registerAddressLength > 4) {
+        error  = Error_PROTOCOL_FORMAT_INVALID;
+        goto exit;
+    }
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    command = Bus_buildCommand (Command_REG_DEMOD_READ, processor, chip);
+    buffer[1] = (Byte) (command >> 8);
+    buffer[2] = (Byte) command;
+    buffer[3] = (Byte) Cmd_sequence++;
+    buffer[4] = (Byte) 1;
+    buffer[5] = (Byte) registerAddressLength;
+    buffer[6] = (Byte) (registerAddress >> 24); /** Get first byte of reg. address  */
+    buffer[7] = (Byte) (registerAddress >> 16); /** Get second byte of reg. address */
+    buffer[8] = (Byte) (registerAddress >> 8);  /** Get third byte of reg. address  */
+    buffer[9] = (Byte) registerAddress;         /** Get fourth byte of reg. address */
+
+    bufferLength = 10;
+    error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    bufferLength = 6;
+
+    error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+    temp = buffer[3];
+    temp = REG_CREATE (value, temp, position, length);
+
+    command = Bus_buildCommand (Command_REG_DEMOD_WRITE, processor, chip);
+    buffer[1] = (Byte) (command >> 8);
+    buffer[2] = (Byte) command;
+    buffer[3] = (Byte) Cmd_sequence++;
+    buffer[4] = (Byte) 1;
+    buffer[5] = (Byte) registerAddressLength;
+    buffer[6] = (Byte) (registerAddress >> 24); /** Get first byte of reg. address  */
+    buffer[7] = (Byte) (registerAddress >> 16); /** Get second byte of reg. address */
+    buffer[8] = (Byte) (registerAddress >> 8);  /** Get third byte of reg. address  */
+    buffer[9] = (Byte) registerAddress;         /** Get fourth byte of reg. address */
+    buffer[10] = temp;
+
+    bufferLength = 11;
+    error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    bufferLength = 5;
+
+    error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_loadFirmware (
+    IN  Demodulator*    demodulator,
+    IN  Dword           length,
+    IN  Byte*           firmware
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Dword loop;
+    Dword remain;
+    Dword i, j, k;
+    Byte buffer[256];
+    Dword bufferLength;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    loop = length / (maxPktSize - 6);
+    remain = length % (maxPktSize - 6);
+    k = 0;
+    command = Bus_buildCommand (Command_FW_DOWNLOAD, Processor_LINK, 0);
+    for (i = 0; i < loop; i++) {
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        for (j = 0; j < (maxPktSize - 6); j++)
+            buffer[4 + j] = firmware[k++];
+        bufferLength = (maxPktSize - 2);
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+    }
+    if (remain) {
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        for (j = 0; j < remain; j++)
+            buffer[4 + j] = firmware[k++];
+        bufferLength = (Word) (4 + remain);
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_reboot (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    User_enterCriticalSection (demodulator);
+
+    command = Bus_buildCommand (Command_REBOOT, Processor_LINK, chip);
+    buffer[1] = (Byte) (command >> 8);
+    buffer[2] = (Byte) command;
+    buffer[3] = (Byte) Cmd_sequence++;
+    bufferLength = 4;
+    error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_sendCommand (
+    IN  Demodulator*    demodulator,
+    IN  Word            command,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Byte buffer[256];
+    Dword bufferLength;
+    Dword i, j, k;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    User_enterCriticalSection (demodulator);
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    if (writeBufferLength == 0) {
+        command = Bus_buildCommand (command, processor, chip);
+        buffer[1] = (Byte) (command >> 8);
+        buffer[2] = (Byte) command;
+        buffer[3] = (Byte) Cmd_sequence++;
+        bufferLength = 4;
+        error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+
+        error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+    } else {
+        i = 0;
+        while (i < writeBufferLength) {
+            j = (writeBufferLength - i) > (maxPktSize - 6) ? (maxPktSize - 6) : (writeBufferLength - i);
+            command = Bus_buildCommand (command, processor, chip);
+            buffer[1] = (Byte) (command >> 8);
+            buffer[2] = (Byte) command;
+            buffer[3] = (Byte) Cmd_sequence++;
+            for (k = 0; k < j; k++)
+                buffer[k + 4] = writeBuffer[i + k];
+
+            bufferLength = j + 4;
+            error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+            if (error) goto exit;
+
+            error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+            if (error) goto exit;
+
+            i += j;
+        }
+    }
+
+    if (readBufferLength == 0) {
+        bufferLength = 5;
+
+        error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+        if (error) goto exit;
+
+        error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+        if (error) goto exit;
+    } else {
+        i = 0;
+        while (i < readBufferLength) {
+            j = (readBufferLength - i) > (maxPktSize - 5) ? (maxPktSize - 5) : (readBufferLength - i);
+
+            bufferLength = j + 5;
+
+            error = pbusDesc->busRx (demodulator, bufferLength, buffer);
+            if (error) goto exit;
+
+            error = Bus_removeChecksum (demodulator, &bufferLength, buffer);
+            if (error) goto exit;
+            for (k = 0; k < j; k++)
+                readBuffer[i + k] = buffer[k + 3];
+
+            i += j;
+        }
+    }
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Dword Cmd_receiveData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           registerAddress,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+) {
+    Dword error = Error_NO_ERROR;
+    Word command;
+    Byte buffer[256];
+    Dword bufferLength;
+    Ganymede* ganymede;
+    CmdDescription*     pcmdDesc;
+    BusDescription*     pbusDesc;
+    Dword maxPktSize;
+
+    if (readBufferLength == 0) goto exit;
+
+    ganymede = (Ganymede*) demodulator;
+    pcmdDesc = ganymede->cmdDescription;
+    pbusDesc = pcmdDesc->busDescription;
+    maxPktSize = pcmdDesc->mailBoxSize;
+
+    User_enterCriticalSection (demodulator);
+
+    command = Bus_buildCommand (Command_DATA_READ, Processor_LINK, 0);
+    buffer[1] = (Byte) (command >> 8);
+    buffer[2] = (Byte) command;
+    buffer[3] = (Byte) Cmd_sequence++;
+    buffer[4] = (Byte) ((readBufferLength >> 16)  & 0xFF);
+    buffer[5] = (Byte) ((readBufferLength >> 8)  & 0xFF);
+    buffer[6] = (Byte) (readBufferLength  & 0xFF);
+    buffer[7] = (Byte) ((registerAddress >> 16)  & 0xFF);
+    buffer[8] = (Byte) ((registerAddress >> 8)  & 0xFF);
+    buffer[9] = (Byte) (registerAddress  & 0xFF);
+
+    bufferLength = 10;
+    error = Bus_addChecksum (demodulator, &bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busTx (demodulator, bufferLength, buffer);
+    if (error) goto exit;
+
+    error = pbusDesc->busRxData (demodulator, readBufferLength, readBuffer);
+
+exit :
+    User_leaveCriticalSection (demodulator);
+    return (error);
+}
+
+
+Word Cmd_busId = Bus_USB;
+CmdDescription Cmd_busDescription = {
+    0,
+    NULL,
+    Cmd_writeRegisters,
+    Cmd_writeScatterRegisters,
+    Cmd_writeTunerRegisters,
+    Cmd_writeEepromValues,
+    Cmd_readRegisters,
+    Cmd_readScatterRegisters,
+    Cmd_readTunerRegisters,
+    Cmd_readEepromValues,
+    Cmd_modifyRegister,
+    Cmd_loadFirmware,
+    Cmd_reboot,
+    Cmd_sendCommand,
+    Cmd_receiveData
+};
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_cmd.h	2012-02-27 00:02:36.328915017 +0100
@@ -0,0 +1,246 @@
+#ifndef __CMD_H__
+#define __CMD_H__
+
+
+#include "a867_type.h"
+#include "a867_user.h"
+#include "a867_error.h"
+
+/**
+ * Bus types
+ */
+#define Bus_I2C             1
+#define Bus_USB             2
+#define Bus_SPI             3
+#define Bus_SDIO            4
+#define Bus_USB11           5
+#define Bus_I2M             6  /** I2C bus for Mercury      */
+#define Bus_I2U             7  /** I2C bus for Mercury USB  */
+
+
+/**
+ * Define commands
+ */
+#define Command_REG_DEMOD_READ          0x0000
+#define Command_REG_DEMOD_WRITE         0x0001
+#define Command_REG_TUNER_READ          0x0002
+#define Command_REG_TUNER_WRITE         0x0003
+#define Command_REG_EEPROM_READ         0x0004
+#define Command_REG_EEPROM_WRITE        0x0005
+#define Command_VAR_READ                0x0008
+#define Command_VAR_WRITE               0x0009
+
+#define Command_DATA_READ               0x0006
+
+#define Command_PLATFORM_GET            0x000A
+#define Command_PLATFORM_SET            0x000B
+#define Command_IP_CACHE                0x000D
+#define Command_IP_ADD                  0x000E
+#define Command_IP_REMOVE               0x000F
+#define Command_PID_ADD                 0x0010
+#define Command_PID_REMOVE              0x0011
+#define Command_SIPSI_GET               0x0012  /** Get SI/PSI table for specific PID "once". */
+#define Command_SIPSI_MPE_RESET         0x0013
+#define Command_H_PID_ADD               0x0015
+#define Command_H_PID_REMOVE            0x0016
+#define Command_ABORT                   0x0017
+#define Command_IR_GET                  0x0018
+#define Command_IR_SET                  0x0019
+#define Command_FW_DOWNLOAD_BEGIN       0x0024
+#define Command_FW_DOWNLOAD             0x0021
+#define Command_FW_DOWNLOAD_END         0x0025
+#define Command_QUERYINFO               0x0022
+#define Command_BOOT                    0x0023
+#define Command_REBOOT                  0x0023
+#define Command_RUN_CODE                0x0026
+#define Command_SCATTER_READ            0x0028
+#define Command_SCATTER_WRITE           0x0029
+#define Command_GENERIC_READ            0x002A
+#define Command_GENERIC_WRITE           0x002B
+
+#define Command_SERVICES_GET            0x0083
+#define Command_COMPONENT_ADD           0x0086
+#define Command_COMPONENT_REMOVE        0x0087
+#define Command_FIG_ADD                 0x0088
+#define Command_FIG_REMOVE              0x0089
+
+
+#define Bus_MAX_WRITE_SIZE              254
+#define Bus_MAX_READ_SIZE               254
+
+
+#define Bus_buildCommand(command, processor, chip)  (command + (Word) (processor << 12) + (Word) (chip << 12))
+
+
+/**
+ *
+ */
+Dword Cmd_writeRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer
+);
+
+
+/**
+ *
+ */
+Dword Cmd_writeScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsAddressLength,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+);
+
+
+/**
+ *
+ */
+Dword Cmd_writeTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            tunerAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            writeBufferLength,
+    IN  Byte*           writeBuffer
+);
+
+
+
+/**
+ *
+ */
+Dword Cmd_writeEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            eepromAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            writeBufferLength,
+    IN  Byte*           writeBuffer
+);
+
+
+/**
+ *
+ */
+Dword Cmd_readRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ *
+ */
+Dword Cmd_readScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsAddressLength,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+);
+
+
+/**
+ *
+ */
+Dword Cmd_readTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            tunerAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            readBufferLength,
+    IN  Byte*           readBuffer
+);
+
+
+/**
+ *
+ */
+Dword Cmd_readEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            eepromAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ *
+ */
+Dword Cmd_modifyRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+);
+
+
+/**
+ *
+ */
+Dword Cmd_loadFirmware (
+    IN  Demodulator*    demodulator,
+    IN  Dword           length,
+    IN  Byte*           firmware
+);
+
+
+/**
+ *
+ */
+Dword Cmd_reboot (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+);
+
+
+/**
+ *
+ */
+Dword Cmd_sendCommand (
+    IN  Demodulator*    demodulator,
+    IN  Word            command,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+Dword Cmd_receiveData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           registerAddress,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+extern Word Cmd_busId;
+extern CmdDescription Cmd_busDescription;
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Common.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Common.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Common.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Common.h	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,259 @@
+#pragma once
+
+typedef unsigned char		BYTE;						/** At least 1 Byte				*/
+typedef unsigned short		WORD;						/** At least 2 Bytes				*/
+typedef unsigned int		DWORD;						/** At least 4 Bytes				*/
+typedef void *				HANDLE;						/** Pointer to memory location	*/
+
+#define TUNER_REGS_NUM		104
+#define INITCTRL_NUM		38
+#ifdef _MXL_PRODUCTION
+#define CHCTRL_NUM			39
+#else
+#define CHCTRL_NUM			36
+#endif
+
+#define MXLCTRL_NUM			189
+
+#define MASTER_CONTROL_ADDR		9
+
+/** Enumeration of AGC Mode */
+typedef enum
+{
+	MXL_DUAL_AGC = 0 ,
+	MXL_SINGLE_AGC
+} AGC_Mode ;
+
+/**
+ * Enumeration of Master Control Register State
+ */
+typedef enum
+{
+	MC_LOAD_START = 1 ,
+	MC_POWER_DOWN ,
+	MC_SYNTH_RESET ,
+	MC_SEQ_OFF
+} Master_Control_State ;
+
+/**
+ * Enumeration of MXL5005 Tuner Mode
+ */
+typedef enum
+{
+	MXL_ANALOG_MODE = 0 ,
+	MXL_DIGITAL_MODE
+
+} Tuner_Mode ;
+
+/**
+ * Enumeration of MXL5005 Tuner IF Mode
+ */
+typedef enum
+{
+	MXL_ZERO_IF = 0 ,
+	MXL_LOW_IF
+
+} Tuner_IF_Mode ;
+
+/**
+ * Enumeration of MXL5005 Tuner Clock Out Mode
+ */
+typedef enum
+{
+	MXL_CLOCK_OUT_DISABLE = 0 ,
+	MXL_CLOCK_OUT_ENABLE
+} Tuner_Clock_Out ;
+
+/**
+ * Enumeration of MXL5005 Tuner Div Out Mode
+ */
+typedef enum
+{
+	MXL_DIV_OUT_1 = 0 ,
+	MXL_DIV_OUT_4
+
+} Tuner_Div_Out ;
+
+/**
+ * Enumeration of MXL5005 Tuner Pull-up Cap Select Mode
+ */
+typedef enum
+{
+	MXL_CAP_SEL_DISABLE = 0 ,
+	MXL_CAP_SEL_ENABLE
+
+} Tuner_Cap_Select ;
+
+/**
+ * Enumeration of MXL5005 Tuner RSSI Mode
+ */
+typedef enum
+{
+	MXL_RSSI_DISABLE = 0 ,
+	MXL_RSSI_ENABLE
+
+} Tuner_RSSI ;
+
+/**
+ * Enumeration of MXL5005 Tuner Modulation Type
+ */
+typedef enum
+{
+	MXL_DEFAULT_MODULATION = 0 ,
+	MXL_DVBT,
+	MXL_ATSC,
+	MXL_QAM
+
+} Tuner_Modu_Type ;
+
+/**
+ * MXL5005 Tuner Register Struct
+ */
+typedef struct _TunerReg_struct
+{
+	WORD 	Reg_Num ;							/** Tuner Register Address */
+	WORD	Reg_Val ;							/** Current sofware programmed value waiting to be writen */
+} TunerReg_struct ;
+
+/** 
+ * MXL5005 Tuner Control Struct
+ */
+typedef struct _TunerControl_struct {
+/*	char 	Name[40] ; */						/** Control Name */
+	WORD	Ctrl_Num ;							/** Control Number */
+	WORD	size ;								/** Number of bits to represent Value */
+	WORD 	addr[25] ;							/** Array of Tuner Register Address for each bit position */
+	WORD 	bit[25] ;							/** Array of bit position in Register Address for each bit position */
+	WORD 	val[25] ;							/** Binary representation of Value */
+} TunerControl_struct ;
+
+/**
+ * MXL5005 Tuner Struct
+ */
+typedef struct _Tuner_struct
+{
+	BYTE			Mode ;				/** 0: Analog Mode ; 1: Digital Mode */
+	BYTE			IF_Mode ;			/** for Analog Mode, 0: zero IF; 1: low IF */
+	DWORD			Chan_Bandwidth ;	/** filter  channel bandwidth (6, 7, 8) */
+	DWORD			IF_OUT ;			/** Desired IF Out Frequency */
+	WORD			IF_OUT_LOAD ;		/** IF Out Load Resistor (200/300 Ohms) */
+	DWORD			RF_IN ;				/** RF Input Frequency */
+	DWORD			Fxtal ;				/** XTAL Frequency */
+	BYTE			AGC_Mode ;			/** AGC Mode 0: Dual AGC; 1: Single AGC */
+	WORD			TOP ;				/** Value: take over point */
+	BYTE			CLOCK_OUT ;			/** 0: turn off clock out; 1: turn on clock out */
+	BYTE			DIV_OUT ;			/** 4MHz or 16MHz */
+	BYTE			CAPSELECT ;			/** 0: disable On-Chip pulling cap; 1: enable */
+	BYTE			EN_RSSI ;			/** 0: disable RSSI; 1: enable RSSI */
+	BYTE			Mod_Type ;			/** Modulation Type; */
+										/** 0 - Default;		1 - DVB-T */
+
+	/** Calculated Settings */
+	DWORD			RF_LO ;				/** Synth RF LO Frequency */
+	DWORD			IF_LO ;				/** Synth IF LO Frequency */
+	DWORD			TG_LO ;				/** Synth TG_LO Frequency */
+
+	/** Pointers to ControlName Arrays */
+	WORD					Init_Ctrl_Num ;					/** Number of INIT Control Names */
+	TunerControl_struct		Init_Ctrl[INITCTRL_NUM] ;		/** INIT Control Names Array Pointer */
+	WORD					CH_Ctrl_Num ;					/** Number of CH Control Names */
+	TunerControl_struct		CH_Ctrl[CHCTRL_NUM] ;			/** CH Control Name Array Pointer */
+	WORD					MXL_Ctrl_Num ;					/** Number of MXL Control Names */
+	TunerControl_struct		MXL_Ctrl[MXLCTRL_NUM] ;			/** MXL Control Name Array Pointer */
+
+	/** Pointer to Tuner Register Array */
+	WORD					TunerRegs_Num ;		/** Number of Tuner Registers */
+	TunerReg_struct			TunerRegs[TUNER_REGS_NUM] ;			/** Tuner Register Array Pointer */
+} Tuner_struct ;
+
+
+
+typedef enum
+{
+	/**
+	 * Initialization Control Names
+	 */
+	DN_IQTN_AMP_CUT = 1 ,       /** 1  */
+	BB_MODE ,                   /** 2  */
+	BB_BUF ,                    /** 3  */
+	BB_BUF_OA ,	                /** 4  */
+	BB_ALPF_BANDSELECT ,        /** 5  */
+	BB_IQSWAP ,                 /** 6  */
+	BB_DLPF_BANDSEL ,           /** 7  */
+	RFSYN_CHP_GAIN ,            /** 8  */
+	RFSYN_EN_CHP_HIGAIN ,       /** 9  */
+	AGC_IF ,                    /** 10 */
+	AGC_RF ,                    /** 11 */
+	IF_DIVVAL ,                 /** 12 */
+	IF_VCO_BIAS ,               /** 13 */
+	CHCAL_INT_MOD_IF ,          /** 14 */
+	CHCAL_FRAC_MOD_IF ,         /** 15 */
+	DRV_RES_SEL ,               /** 16 */
+	I_DRIVER ,                  /** 17 */
+	EN_AAF ,                    /** 18 */
+	EN_3P ,                     /** 19 */
+	EN_AUX_3P ,                 /** 20 */
+	SEL_AAF_BAND ,              /** 21 */
+	SEQ_ENCLK16_CLK_OUT ,       /** 22 */
+	SEQ_SEL4_16B ,              /** 23 */
+	XTAL_CAPSELECT ,            /** 24 */
+	IF_SEL_DBL ,                /** 25 */
+	RFSYN_R_DIV ,               /** 26 */
+	SEQ_EXTSYNTHCALIF ,         /** 27 */
+	SEQ_EXTDCCAL ,              /** 28 */
+	AGC_EN_RSSI ,               /** 29 */
+	RFA_ENCLKRFAGC ,            /** 30 */
+	RFA_RSSI_REFH ,             /** 31 */
+	RFA_RSSI_REF ,              /** 32 */
+	RFA_RSSI_REFL ,             /** 33 */
+	RFA_FLR ,                   /** 34 */
+	RFA_CEIL ,                  /** 35 */
+	SEQ_EXTIQFSMPULSE ,         /** 36 */
+	OVERRIDE_1 ,                /** 37 */
+	BB_INITSTATE_DLPF_TUNE,     /** 38 */
+	/**
+	 * Channel Change Control Names
+	 */
+	DN_POLY = 51 ,              /** 51 */
+	DN_RFGAIN ,                 /** 52 */
+	DN_CAP_RFLPF ,              /** 53 */
+	DN_EN_VHFUHFBAR ,           /** 54 */
+	DN_GAIN_ADJUST ,            /** 55 */
+	DN_IQTNBUF_AMP ,            /** 56 */
+	DN_IQTNGNBFBIAS_BST ,       /** 57 */
+	RFSYN_EN_OUTMUX ,           /** 58 */
+	RFSYN_SEL_VCO_OUT ,         /** 59 */
+	RFSYN_SEL_VCO_HI ,          /** 60 */
+	RFSYN_SEL_DIVM ,            /** 61 */
+	RFSYN_RF_DIV_BIAS ,         /** 62 */
+	DN_SEL_FREQ ,               /** 63 */
+	RFSYN_VCO_BIAS ,            /** 64 */
+	CHCAL_INT_MOD_RF ,          /** 65 */
+	CHCAL_FRAC_MOD_RF ,         /** 66 */
+	RFSYN_LPF_R ,               /** 67 */
+	CHCAL_EN_INT_RF ,           /** 68 */
+	TG_LO_DIVVAL ,              /** 69 */
+	TG_LO_SELVAL ,              /** 70 */
+	TG_DIV_VAL ,                /** 71 */
+	TG_VCO_BIAS ,               /** 72 */
+	SEQ_EXTPOWERUP ,            /** 73 */
+	OVERRIDE_2 ,                /** 74 */
+	OVERRIDE_3 ,                /** 75 */
+	OVERRIDE_4 ,                /** 76 */
+	SEQ_FSM_PULSE ,             /** 77 */
+	GPIO_4B,                    /** 78 */
+	GPIO_3B,                    /** 79 */
+	GPIO_4,                     /** 80 */
+	GPIO_3,                     /** 81 */
+	GPIO_1B,                    /** 82 */
+	DAC_A_ENABLE ,              /** 83 */
+	DAC_B_ENABLE ,              /** 84 */
+	DAC_DIN_A ,	                /** 85 */
+	DAC_DIN_B ,                 /** 86 */
+#ifdef _MXL_PRODUCTION
+	RFSYN_EN_DIV,				/** 87 */
+	RFSYN_DIVM,					/** 88 */
+	DN_BYPASS_AGC_I2C			/** 89 */
+#endif
+
+} MXL5005_ControlName ;
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_compat.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_compat.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_compat.h	2012-02-27 00:02:36.328915017 +0100
@@ -0,0 +1,503 @@
+/*
+ * $Id: compat.h,v 1.1.1.1 2008/07/09 07:30:49 stylon Exp $
+ */
+
+#ifndef _COMPAT_H
+#define _COMPAT_H
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+#define	KERN_CONT	""
+#endif
+
+/* To allow I2C compatibility code to work */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+#include <linux/i2c-dev.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+# define set_freezable()
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+# define minor(x) MINOR(x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+# define DEVICE_ATTR(a,b,c,d) CLASS_DEVICE_ATTR(a,b,c,d)
+# define device_create_file(a,b) class_device_create_file(a,b)
+# define device_remove_file(a,b) class_device_remove_file(a,b)
+# define device_register(a) class_device_register(a)
+# define device_unregister(a) class_device_unregister(a)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+# include <linux/moduleparam.h>
+# include <linux/delay.h>
+# define need_resched() (current->need_resched)
+# define work_struct tq_struct
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+# define BUG_ON(condition) do { if ((condition)!=0) BUG(); } while(0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23)
+# define irqreturn_t void
+# define IRQ_RETVAL(foobar)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,71)
+# define strlcpy(dest,src,len) strncpy(dest,src,(len)-1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+# define iminor(inode) minor(inode->i_rdev)
+#endif
+
+#if defined(I2C_ADAP_CLASS_TV_ANALOG) && !defined(I2C_CLASS_TV_ANALOG)
+# define  I2C_CLASS_TV_ANALOG  I2C_ADAP_CLASS_TV_ANALOG
+# define  I2C_CLASS_TV_DIGITAL I2C_ADAP_CLASS_TV_DIGITAL
+#endif
+
+#ifndef __pure
+#  define __pure __attribute__((pure))
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+# define __user
+# define __kernel
+# define __iomem
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+# define pm_message_t                      u32
+# define pci_choose_state(pci_dev, state)  (state)
+# define PCI_D0                            (0)
+# define assert_spin_locked(foobar)
+#endif
+
+/* Since v4l-dvb now includes it's own copy of linux/i2c-id.h these
+   are no longer necessary */
+/*
+#if !defined(I2C_ALGO_SAA7134)
+#define I2C_ALGO_SAA7134 I2C_HW_B_BT848
+#endif
+#if !defined(I2C_HW_B_CX2388x)
+# define I2C_HW_B_CX2388x I2C_HW_B_BT848
+#endif
+#if !defined(I2C_HW_SAA7134)
+# define I2C_HW_SAA7134 I2C_ALGO_SAA7134
+#endif
+#if !defined(I2C_HW_SAA7146)
+# define I2C_HW_SAA7146 I2C_ALGO_SAA7146
+#endif
+#if !defined(I2C_HW_B_EM2820)
+#define I2C_HW_B_EM2820 0x99
+#endif
+*/
+
+#ifndef I2C_M_IGNORE_NAK
+# define I2C_M_IGNORE_NAK 0x1000
+#endif
+
+/* v4l-dvb uses an out of kernel copy of i2c-id.h, which does not have
+   some stuff that previous versions of i2c-id.h defined. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) && defined(LINUX_I2C_ID_H)
+# define I2C_ALGO_BIT 0x010000
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+#define __le32 __u32
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7))
+static inline unsigned long msecs_to_jiffies(const unsigned int m)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+	return (m + (1000 / HZ) - 1) / (1000 / HZ);
+#else
+#if HZ > 1000 && !(HZ % 1000)
+	return m * (HZ / 1000);
+#else
+	return (m * HZ + 999) / 1000;
+#endif
+#endif
+}
+static inline unsigned int jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+	return (1000 / HZ) * j;
+#else
+#if HZ > 1000 && !(HZ % 1000)
+	return (j + (HZ / 1000) - 1)/(HZ / 1000);
+#else
+	return (j * 1000) / HZ;
+#endif
+#endif
+}
+static inline void msleep(unsigned int msecs)
+{
+	unsigned long timeout = msecs_to_jiffies(msecs);
+	while (timeout) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		timeout = schedule_timeout(timeout);
+	}
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+static inline unsigned long msleep_interruptible(unsigned int msecs)
+{
+	unsigned long timeout = msecs_to_jiffies(msecs);
+
+	while (timeout) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		timeout = schedule_timeout(timeout);
+	}
+	return jiffies_to_msecs(timeout);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/* some keys from 2.6.x which are not (yet?) in 2.4.x */
+# define KEY_PLAY                207
+# define KEY_PRINT		 210
+# define KEY_EMAIL         215
+# define KEY_SEARCH              217
+# define KEY_SELECT 		 0x161
+# define KEY_GOTO                0x162
+# define KEY_INFO                0x166
+# define KEY_CHANNEL             0x16b
+# define KEY_LANGUAGE            0x170
+# define KEY_SUBTITLE		 0x172
+# define KEY_ZOOM                0x174
+# define KEY_MODE		 0x175
+# define KEY_TV                  0x179
+# define KEY_CD                  0x17f
+# define KEY_TUNER               0x182
+# define KEY_TEXT                0x184
+# define KEY_DVD		 0x185
+# define KEY_AUDIO               0x188
+# define KEY_VIDEO               0x189
+# define KEY_RED                 0x18e
+# define KEY_GREEN               0x18f
+# define KEY_YELLOW              0x190
+# define KEY_BLUE                0x191
+# define KEY_CHANNELUP           0x192
+# define KEY_CHANNELDOWN         0x193
+# define KEY_RESTART		 0x198
+# define KEY_SHUFFLE     	 0x19a
+# define KEY_NEXT                0x197
+# define KEY_RADIO               0x181
+# define KEY_PREVIOUS            0x19c
+# define KEY_MHP                 0x16f
+# define KEY_EPG                 0x16d
+# define KEY_FASTFORWARD         208
+# define KEY_LIST                0x18b
+# define KEY_LAST                0x195
+# define KEY_CLEAR               0x163
+# define KEY_AUX                 0x186
+# define KEY_SCREEN              0x177
+# define KEY_PC                  0x178
+# define KEY_MEDIA               226
+# define KEY_SLOW                0x199
+# define KEY_OK                  0x160
+# define KEY_DIGITS              0x19d
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+# define KEY_SEND		231
+# define KEY_REPLY		232
+# define KEY_FORWARDMAIL	233
+# define KEY_SAVE		234
+# define KEY_DOCUMENTS		235
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define container_of(ptr, type, member) ({                      \
+	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+#include <linux/mm.h>
+static inline unsigned long vmalloc_to_pfn(void * vmalloc_addr)
+{
+    return page_to_pfn(vmalloc_to_page(vmalloc_addr));
+}
+
+static unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long kva, ret;
+
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
+	ret = __pa(kva);
+	return ret;
+}
+
+#ifndef wait_event_timeout
+#define wait_event_timeout(wq, condition, timeout)                   	     \
+({                                                                           \
+     long __ret = timeout;                                                   \
+     if (!(condition))                                                       \
+     do {                                                                    \
+	     DEFINE_WAIT(__wait);                                            \
+	     for (;;) {                                                      \
+		     prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);    \
+		     if (condition)                                          \
+			 break;                                              \
+		     __ret = schedule_timeout(__ret);                        \
+		     if (!__ret)                                             \
+			 break;                                              \
+	     }                                                               \
+	     finish_wait(&wq, &__wait);                                      \
+     } while (0);							     \
+     __ret;                                                                  \
+})
+#endif
+
+#define remap_pfn_range remap_page_range
+
+#endif
+
+/* vm_insert_page() was added in 2.6.15 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15) && defined(_LINUX_MM_H)
+static inline int vm_insert_page(struct vm_area_struct *vma,
+	unsigned long addr, struct page *page)
+{
+	return remap_pfn_range(vma, addr, page_to_pfn(page), PAGE_SIZE,
+			       vma->vm_page_prot);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+#ifndef kcalloc
+#define kcalloc(n,size,flags)			\
+({						\
+  void * __ret = NULL;				\
+  __ret = kmalloc(n * size, flags);		\
+  if (__ret)					\
+	 memset(__ret, 0, n * size);		\
+  __ret;					\
+})
+#endif
+#endif
+
+/* try_to_freeze() lost its argument.  Must appear after linux/sched.h */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) && defined(_LINUX_SCHED_H)
+# if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#  define try_to_freeze() try_to_freeze(PF_FREEZE)
+# else
+#  define try_to_freeze() (0)
+# endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#ifndef kzalloc
+#define kzalloc(size, flags)				\
+({							\
+	void *__ret = kmalloc(size, flags);		\
+	if (__ret)					\
+		memset(__ret, 0, size);			\
+	__ret;						\
+})
+#endif
+#endif
+
+/* The class_device system didn't appear until 2.5.69 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define class_device_create_file(a, b) (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+# define class_device_create(a, b, c, d, e, f, g, h) class_simple_device_add(a, c, d, e, f, g, h)
+# define class_device_destroy(a, b) class_simple_device_remove(b)
+# define class_create(a, b) class_simple_create(a, b)
+# define class_destroy(a) class_simple_destroy(a)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+# define class_device_create(a, b, c, d, e, f, g, h) class_device_create(a, c, d, e, f, g, h)
+#endif
+/* device_create/destroy added in 2.6.18 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+/* on older kernels, class_device_create will in turn be a compat macro */
+# define device_create(a, b, c, d, e, f, g) class_device_create(a, NULL, c, b, d, e, f, g)
+# define device_destroy(a, b) class_device_destroy(a, b)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+# define input_allocate_device() kzalloc(sizeof(struct input_dev),GFP_KERNEL);
+# define input_free_device(input_dev) kfree(input_dev)
+# ifdef _INPUT_H  /* input.h must be included _before_ compat.h for this to work */
+   /* input_register_device() was changed to return an error code in 2.6.15 */
+#  define input_register_device(x) (input_register_device(x), 0)
+# endif
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,15)
+#define DEFINE_MUTEX(a) DECLARE_MUTEX(a)
+#define mutex_lock_interruptible(a) down_interruptible(a)
+#define mutex_unlock(a) up(a)
+#define mutex_lock(a) down(a)
+#define mutex_init(a) init_MUTEX(a)
+#define mutex_trylock(a) down_trylock(a)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) && defined(_LINUX_SCHED_H)
+static inline signed long __sched
+schedule_timeout_interruptible(signed long timeout)
+{
+	__set_current_state(TASK_INTERRUPTIBLE);
+	return schedule_timeout(timeout);
+}
+#endif
+
+/* New 4GB DMA zone was added in 2.6.15-rc2 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#  define __GFP_DMA32	__GFP_DMA
+#endif
+
+/* setup_timer() helper added 10/31/05, 2.6.15-rc1 */
+/* Need linux/timer.h to be included for struct timer_list */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15) && defined(_LINUX_TIMER_H)
+static inline void setup_timer(struct timer_list * timer,
+			       void (*function)(unsigned long),
+			       unsigned long data)
+{
+	timer->function = function;
+	timer->data = data;
+	init_timer(timer);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#define IRQF_SHARED		SA_SHIRQ
+#define IRQF_DISABLED		SA_INTERRUPT
+#endif
+
+/* linux/usb.h must be included _before_ compat.h for this code to get
+   turned on.  We can not just include usb.h here, because there is a
+   lot of code which will not compile if it has usb.h included, due to
+   conflicts with symbol names.  */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) && \
+    defined(__LINUX_USB_H) && defined(_INPUT_H)
+#include <linux/input.h>
+/* Found in linux/usb_input.h in 2.6.13 */
+/* Moved to linux/usb/input.h in 2.6.18 */
+static inline void
+usb_to_input_id(const struct usb_device *dev, struct input_id *id)
+{
+	id->bustype = BUS_USB;
+	id->vendor = le16_to_cpu(dev->descriptor.idVendor);
+	id->product = le16_to_cpu(dev->descriptor.idProduct);
+	id->version = le16_to_cpu(dev->descriptor.bcdDevice);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+# define PCIAGP_FAIL 0
+
+#define vmalloc_32_user(a) vmalloc_32(a)
+
+#endif
+
+/* bool type and enum-based definition of true and false was added in 2.6.19 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+typedef int bool;
+#define true 1
+#define false 0
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define sony_pic_camera_command(a,b) sonypi_camera_command(a,b)
+
+#define SONY_PIC_COMMAND_SETCAMERAAGC        SONYPI_COMMAND_SETCAMERAAGC
+#define SONY_PIC_COMMAND_SETCAMERABRIGHTNESS SONYPI_COMMAND_SETCAMERABRIGHTNESS
+#define SONY_PIC_COMMAND_SETCAMERACOLOR      SONYPI_COMMAND_SETCAMERACOLOR
+#define SONY_PIC_COMMAND_SETCAMERACONTRAST   SONYPI_COMMAND_SETCAMERACONTRAST
+#define SONY_PIC_COMMAND_SETCAMERAHUE        SONYPI_COMMAND_SETCAMERAHUE
+#define SONY_PIC_COMMAND_SETCAMERAPICTURE    SONYPI_COMMAND_SETCAMERAPICTURE
+#define SONY_PIC_COMMAND_SETCAMERASHARPNESS  SONYPI_COMMAND_SETCAMERASHARPNESS
+#define SONY_PIC_COMMAND_SETCAMERA           SONYPI_COMMAND_SETCAMERA
+#endif
+
+/* Parameter to pci_match_device() changed in 2.6.13-rc2 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) && defined(LINUX_PCI_H)
+#define pci_match_device(drv, dev)	pci_match_device((drv)->id_table, dev)
+#endif
+
+/* pci_dev got a new revision field in 2.6.23-rc1 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) && defined(LINUX_PCI_H)
+/* Just make it easier to subsitute pci_dev->revision with
+ * v4l_compat_pci_rev(pci_dev).  It's too bad there isn't some kind of context
+ * sensitive macro in C that could do this for us.  */
+static inline u8 v4l_compat_pci_rev(struct pci_dev *pci)
+{ u8 rev; pci_read_config_byte(pci, PCI_REVISION_ID, &rev); return rev; }
+#endif
+
+/* ALSA removed a bunch of typedefs and renamed some structs in 2.6.16 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+# ifdef __SOUND_CORE_H
+#  define snd_card _snd_card /* struct _snd_card became struct snd_card */
+#  define snd_pcm _snd_pcm
+#  undef snd_device
+#  define snd_device _snd_device
+# endif
+# ifdef __SOUND_PCM_H
+#  define snd_pcm_substream _snd_pcm_substream
+#  define snd_pcm_hardware _snd_pcm_hardware
+#  define snd_pcm_runtime _snd_pcm_runtime
+#  define snd_pcm_ops _snd_pcm_ops
+# endif
+# ifdef __SOUND_ASOUND_H
+#  define snd_pcm_hw_params sndrv_pcm_hw_params
+#  define snd_ctl_elem_info sndrv_ctl_elem_info
+#  define snd_ctl_elem_value sndrv_ctl_elem_value
+# endif
+# ifdef __SOUND_CONTROL_H
+#  undef snd_kcontrol
+#  define snd_kcontrol _snd_kcontrol
+#  define snd_kcontrol_new _snd_kcontrol_new
+# endif
+#endif
+
+#if defined(COMPAT_PCM_TO_RATE_BIT) && defined(__SOUND_PCM_H)
+/* New alsa core utility function */
+static inline unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate)
+{
+	static const unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050,
+		32000, 44100, 48000, 64000, 88200, 96000, 176400, 192000 };
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(rates); i++)
+		if (rates[i] == rate)
+			return 1u << i;
+	return SNDRV_PCM_RATE_KNOT;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+# define task_pid_nr(current) ((current)->pid)
+
+# define sg_init_table(a,b)
+# define sg_page(p) (sg->page)
+# define sg_set_page(sglist,pg,sz,off)					\
+do {									\
+	struct scatterlist *p=sglist;					\
+	p->page   = pg;							\
+	p->length = sz;							\
+	p->offset = off;						\
+} while (0)
+#endif
+
+#ifndef BIT_MASK
+# define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+# define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#endif
+
+#endif
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_debug.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_debug.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_debug.h	2012-02-27 00:02:36.328915017 +0100
@@ -0,0 +1,4 @@
+
+// turn on/off debug for all modules
+//#define	CONFIG_DVB_USB_DEBUG	0	
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.c	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,540 @@
+#include "a867_demodulator.h"
+
+
+Dword Demodulator_writeRegister (
+      Demodulator*    demodulator,
+      Byte            chip,
+      Processor       processor,
+      Dword           registerAddress,
+      Byte            value
+) {
+    return (Standard_writeRegister (demodulator, chip, processor, registerAddress, value));
+}
+
+
+Dword Demodulator_writeRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    return (Standard_writeRegisters (demodulator, chip, processor, registerAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_writeScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+) {
+    return (Standard_writeScatterRegisters (demodulator, chip, processor, valueSetsLength, valueSets));
+}
+
+
+Dword Demodulator_writeTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    return (Standard_writeTunerRegisters (demodulator, chip, registerAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_writeGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    return (Standard_writeGenericRegisters (demodulator, chip, interfaceIndex, slaveAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_writeEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    return (Standard_writeEepromValues (demodulator, chip, registerAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_writeRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+)
+{
+    return (Standard_writeRegisterBits (demodulator, chip, processor, registerAddress, position, length, value));
+}
+
+
+Dword Demodulator_readRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    OUT Byte*           value
+) {
+    return (Standard_readRegister (demodulator, chip, processor, registerAddress, value));
+}
+
+
+Dword Demodulator_readRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+) {
+    return (Standard_readRegisters (demodulator, chip, processor, registerAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_readScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+) {
+    return (Standard_readScatterRegisters (demodulator, chip, processor, valueSetsLength, valueSets));
+}
+
+
+Dword Demodulator_readTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    return (Standard_readTunerRegisters (demodulator, chip, registerAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_readGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    return (Standard_readGenericRegisters (demodulator, chip, interfaceIndex, slaveAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_readEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+) {
+    return (Standard_readEepromValues (demodulator, chip, registerAddress, bufferLength, buffer));
+}
+
+
+Dword Demodulator_readRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    OUT Byte*           value
+) {
+    return (Standard_readRegisterBits (demodulator, chip, processor, registerAddress, position, length, value));
+}
+
+
+Dword Demodulator_getHardwareVersion (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          version
+) {
+    return (Standard_getHardwareVersion (demodulator, version));
+}
+
+
+Dword Demodulator_getFirmwareVersion (
+    IN  Demodulator*    demodulator,
+    IN  Processor       processor,
+    OUT Dword*          version
+) {
+    return (Standard_getFirmwareVersion (demodulator, processor, version));
+}
+
+
+Dword Demodulator_getRfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           rfAgc
+) {
+    return (Standard_getRfAgcGain (demodulator, chip, rfAgc));
+}
+
+
+Dword Demodulator_getIfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           ifAgc
+) {
+    return (Standard_getIfAgcGain (demodulator, chip, ifAgc));
+}
+
+
+Dword Demodulator_controlPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+) {
+    return (Standard_controlPidFilter (demodulator, chip, control));
+}
+
+
+Dword Demodulator_addPidToFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            index,
+    IN  Pid             pid
+) {
+    return (Standard_addPidToFilter (demodulator, chip, index, pid));
+}
+
+
+Dword Demodulator_resetPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+) {
+    return (Standard_resetPidFilter (demodulator, chip));
+}
+
+
+Dword Demodulator_loadIrTable (
+    IN  Demodulator*    demodulator,
+    IN  Word            tableLength,
+    IN  Byte*           table
+) {
+    return (Standard_loadIrTable (demodulator, tableLength, table));
+}
+
+
+Dword Demodulator_loadFirmware (
+    IN  Demodulator*    demodulator,
+    IN  Byte*           firmwareCodes,
+    IN  Segment*        firmwareSegments,
+    IN  Byte*           firmwarePartitions
+) {
+
+    return (Standard_loadFirmware (demodulator, firmwareCodes, firmwareSegments, firmwarePartitions));
+}
+
+
+Dword Demodulator_initialize (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chipNumber,
+    IN  Word            sawBandwidth,
+    IN  StreamType      streamType,
+    IN  Architecture    architecture
+) {
+    return (Standard_initialize (demodulator, chipNumber, sawBandwidth, streamType, architecture));
+}
+
+
+Dword Demodulator_finalize (
+    IN  Demodulator*    demodulator
+) {
+    return (Standard_finalize (demodulator));
+}
+
+
+Dword Demodulator_isAgcLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    return (Standard_isAgcLocked (demodulator, chip, locked));
+}
+
+
+Dword Demodulator_isCfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    return (Standard_isCfoeLocked (demodulator, chip, locked));
+}
+
+
+Dword Demodulator_isSfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    return (Standard_isSfoeLocked (demodulator, chip, locked));
+}
+
+
+Dword Demodulator_isTpsLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    return (Standard_isTpsLocked (demodulator, chip, locked));
+}
+
+
+Dword Demodulator_isMpeg2Locked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    return (Standard_isMpeg2Locked (demodulator, chip, locked));
+}
+
+
+Dword Demodulator_isLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+)
+{
+    return (Standard_isLocked (demodulator, chip, locked));
+}
+
+
+Dword Demodulator_setPriority (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Priority        priority
+)
+{
+    return (Standard_setPriority (demodulator, chip, priority));
+}
+
+
+Dword Demodulator_reset (
+    IN  Demodulator*    demodulator
+) {
+    return (Standard_reset (demodulator));
+}
+
+
+Dword Demodulator_getChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    OUT ChannelModulation*      channelModulation
+) {
+    return (Standard_getChannelModulation (demodulator, chip, channelModulation));
+}
+
+
+Dword Demodulator_setChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    IN  ChannelModulation*      channelModulation
+) {
+    return (Standard_setChannelModulation (demodulator, chip, channelModulation));
+}
+
+
+Dword Demodulator_acquireChannel (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,
+    IN  Dword           frequency
+) {
+    return (Standard_acquireChannel (demodulator, chip, bandwidth, frequency));
+}
+
+
+Dword Demodulator_setStreamType (
+    IN  Demodulator*    demodulator,
+    IN  StreamType      streamType
+) {
+    return (Standard_setStreamType (demodulator, streamType));
+}
+
+
+Dword Demodulator_setArchitecture (
+    IN  Demodulator*    demodulator,
+    IN  Architecture    architecture
+) {
+    return (Standard_setArchitecture (demodulator, architecture));
+}
+
+
+Dword Demodulator_getSignalQuality (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           quality
+) {
+    return (Standard_getSignalQuality (demodulator, chip, quality));
+}
+
+
+Dword Demodulator_getSignalStrength (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           strength
+) {
+    return (Standard_getSignalStrength (demodulator, chip, strength));
+}
+
+
+Dword Demodulator_getSignalStrengthDbm (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Long            rfpullUpVolt_X10,     /** RF pull up voltage multiplied by 10 */
+    IN  Long            ifpullUpVolt_X10,     /** IF pull up voltage multiplied by 10 */
+    OUT Long*           strengthDbm           /** DBm                                */
+) {
+    return (Standard_getSignalStrengthDbm (demodulator, chip, rfpullUpVolt_X10, ifpullUpVolt_X10, strengthDbm));
+}
+
+Dword Demodulator_getPostVitBer (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Dword*          postErrorCount,  /** 24 bits */
+    OUT Dword*          postBitCount,    /** 16 bits */
+    OUT Word*           abortCount
+){
+	return (Standard_getPostVitBer(demodulator, chip, postErrorCount, postBitCount, abortCount));
+}
+
+
+Dword Demodulator_setStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            superFrameCount,
+    IN  Word            packetUnit
+) {
+    return (Standard_setStatisticRange (demodulator, chip, superFrameCount, packetUnit));
+}
+
+
+Dword Demodulator_getStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte*           superFrameCount,
+    IN  Word*           packetUnit
+) {
+    return (Standard_getStatisticRange (demodulator, chip, superFrameCount, packetUnit));
+}
+
+
+Dword Demodulator_getStatistic (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Statistic*      statistic
+) {
+    return (Standard_getStatistic (demodulator, chip, statistic));
+}
+
+
+Dword Demodulator_getInterrupts (
+    IN  Demodulator*    demodulator,
+    OUT Interrupts*     interrupts
+) {
+    return (Standard_getInterrupts (demodulator, interrupts));
+}
+
+
+Dword Demodulator_clearInterrupt (
+    IN  Demodulator*    demodulator,
+    IN  Interrupt       interrupt
+) {
+    return (Standard_clearInterrupt (demodulator, interrupt));
+}
+
+
+Dword Demodulator_getDataLength (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          dataLength,
+    OUT Bool*           valid
+) {
+    return (Standard_getDataLength (demodulator, dataLength, valid));
+}
+
+
+//jamie: The function is unused.
+Dword Demodulator_getData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+) {
+    return (Standard_getData (demodulator, bufferLength, buffer));
+}
+
+//jamie: The function is unused.
+Dword Demodulator_getDatagram (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          bufferLength,
+    OUT Byte*           buffer
+) {
+    return (Standard_getDatagram (demodulator, bufferLength, buffer));
+}
+
+
+Dword Demodulator_getIrCode (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          code
+)  {
+    return (Standard_getIrCode (demodulator, code));
+}
+
+
+Dword Demodulator_reboot (
+    IN  Demodulator*    demodulator
+)  {
+    return (Standard_reboot (demodulator));
+}
+
+
+Dword Demodulator_controlPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+) {
+    return (Standard_controlPowerSaving (demodulator, chip, control));
+}
+
+
+Dword Demodulator_controlTunerPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            control
+) {
+    return (Standard_controlTunerPowerSaving (demodulator, control));
+}
+
+
+Dword Demodulator_setBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize       burstSize
+) {
+    return (Standard_setBurstSize (demodulator, burstSize));
+}
+
+
+Dword Demodulator_getBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize*      burstSize
+) {
+    return (Standard_getBurstSize (demodulator, burstSize));
+}
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.c	2012-02-27 00:02:36.298915017 +0100
@@ -0,0 +1,607 @@
+#include "a867_demodulatorextend.h"
+/*
+#include "i2cimpl.h"
+#include "spiimpl.h"
+#include "i2uimpl.h"
+#include "i2u.h"
+#include "sdioimpl.h"
+*/
+
+#include "a867_usb2impl.h"
+#include "a867_cmd.h"
+
+#include "a867_Maxlinear_MXL5007.h"
+#include "a867_Afa_AF9007.h"
+
+static PidInfo pidInfo;
+BusDescription busDesc[] =
+{
+    /** 0: NULL bus */
+    {
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+    },
+    /** 1: I2C bus */
+    {
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+    },
+    /** 2: USB bus */
+    {
+        Usb2_getDriver,
+        Usb2_writeControlBus,
+        Usb2_readControlBus,
+        Usb2_readDataBus,
+    },
+    /** 3: SPI bus */
+    {
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+    },
+    /** 4: SDIO bus */
+    {
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+    },
+    /** 5: USB11 bus */
+    {
+        Usb2_getDriver,
+        Usb2_writeControlBus,
+        Usb2_readControlBus,
+        Usb2_readDataBus,
+    },
+    /** 6: I2C for old mail box */
+    {
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+    },
+    /** 7: USB for old mail box */
+    {
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+    },
+};
+
+CmdDescription cmdDesc[] =
+{
+    /** NULL Bus */
+    {
+        0,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL
+    },
+    /** 1:I2C Bus */
+    {
+        255,
+        &busDesc[1],
+        Cmd_writeRegisters,
+        Cmd_writeScatterRegisters,
+        Cmd_writeTunerRegisters,
+        Cmd_writeEepromValues,
+        Cmd_readRegisters,
+        Cmd_readScatterRegisters,
+        Cmd_readTunerRegisters,
+        Cmd_readEepromValues,
+        Cmd_modifyRegister,
+        Cmd_loadFirmware,
+        Cmd_reboot,
+        Cmd_sendCommand,
+        Cmd_receiveData
+    },
+    /** 2:USB Bus */
+    {
+        63,
+        &busDesc[2],
+        Cmd_writeRegisters,
+        Cmd_writeScatterRegisters,
+        Cmd_writeTunerRegisters,
+        Cmd_writeEepromValues,
+        Cmd_readRegisters,
+        Cmd_readScatterRegisters,
+        Cmd_readTunerRegisters,
+        Cmd_readEepromValues,
+        Cmd_modifyRegister,
+        Cmd_loadFirmware,
+        Cmd_reboot,
+        Cmd_sendCommand,
+        Cmd_receiveData
+    },
+    /** 3:SPI Bus */
+    {
+        255,
+        &busDesc[3],
+        Cmd_writeRegisters,
+        Cmd_writeScatterRegisters,
+        Cmd_writeTunerRegisters,
+        Cmd_writeEepromValues,
+        Cmd_readRegisters,
+        Cmd_readScatterRegisters,
+        Cmd_readTunerRegisters,
+        Cmd_readEepromValues,
+        Cmd_modifyRegister,
+        Cmd_loadFirmware,
+        Cmd_reboot,
+        Cmd_sendCommand,
+        Cmd_receiveData
+    },
+    /** 4:SDIO Bus */
+    {
+        255,
+        &busDesc[4],
+        Cmd_writeRegisters,
+        Cmd_writeScatterRegisters,
+        Cmd_writeTunerRegisters,
+        Cmd_writeEepromValues,
+        Cmd_readRegisters,
+        Cmd_readScatterRegisters,
+        Cmd_readTunerRegisters,
+        Cmd_readEepromValues,
+        Cmd_modifyRegister,
+        Cmd_loadFirmware,
+        Cmd_reboot,
+        Cmd_sendCommand,
+        Cmd_receiveData
+    },
+    /** 5:USB11 Bus */
+    {
+        63,
+        &busDesc[5],
+        Cmd_writeRegisters,
+        Cmd_writeScatterRegisters,
+        Cmd_writeTunerRegisters,
+        Cmd_writeEepromValues,
+        Cmd_readRegisters,
+        Cmd_readScatterRegisters,
+        Cmd_readTunerRegisters,
+        Cmd_readEepromValues,
+        Cmd_modifyRegister,
+        Cmd_loadFirmware,
+        Cmd_reboot,
+        Cmd_sendCommand,
+        Cmd_receiveData
+    },
+    /** 6:I2C for old mailbox */
+    {
+        16,
+        &busDesc[6],
+        NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL
+    },
+    /** 7:USB for old mailbox */
+    {
+        16,
+        &busDesc[7],
+        NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL,
+	    NULL
+    },
+};
+
+Dword Demodulator_setBusTuner (
+    IN  Demodulator*    demodulator,
+    IN  Word            busId,
+    IN  Word            tunerId
+) {
+    Dword error = Error_NO_ERROR;
+
+    Ganymede* ganymede;
+    ganymede = (Ganymede*) demodulator;
+    ganymede->cmdDescription = &cmdDesc[busId];
+    ganymede->busId = busId;
+
+    switch(tunerId) {
+    case Tuner_Afatech_AF9007:
+	ganymede->tunerDescription = &tuner_AF9007;
+	break;
+
+    case Tuner_Maxlinear_MXL5007:
+	ganymede->tunerDescription = &tuner_MXL5007;
+	break;
+
+    default:
+	error = Error_INVALID_TUNER_TYPE;
+	goto exit;
+	break;
+    }
+
+    if (ganymede->tunerDescription->tunerScript == NULL) {
+        ganymede->tunerDescription->tunerScript = NULL;
+        ganymede->tunerDescription->tunerScriptSets = NULL;
+    }
+
+exit:
+    return(error);
+}
+
+Dword Demodulator_getChannelStatistic (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    OUT ChannelStatistic*       channelStatistic
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    GetChannelStatisticRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.channelStatistic = channelStatistic;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_GETCHANNELSTATISTIC,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Dword postErrCnt;
+    Dword postBitCnt;
+    Word rsdAbortCnt;
+    Ganymede* ganymede;
+
+
+    ganymede = (Ganymede*) demodulator;
+
+
+    /** Get BER if couter is ready, error = Error_RSD_COUNTER_NOT_READY if counter is not ready */
+    if (ganymede->architecture == Architecture_PIP) {
+        error = Standard_getPostVitBer (demodulator, chip, &postErrCnt, &postBitCnt, &rsdAbortCnt);
+        if (error == Error_NO_ERROR) {
+            ganymede->channelStatistic[chip].postVitErrorCount = postErrCnt;
+            ganymede->channelStatistic[chip].postVitBitCount = postBitCnt;
+            ganymede->channelStatistic[chip].abortCount = rsdAbortCnt;
+        }
+    } else {
+        error = Standard_getPostVitBer (demodulator, 0, &postErrCnt, &postBitCnt, &rsdAbortCnt);
+        if (error == Error_NO_ERROR) {
+            ganymede->channelStatistic[chip].postVitErrorCount = postErrCnt;
+            ganymede->channelStatistic[chip].postVitBitCount = postBitCnt;
+            ganymede->channelStatistic[chip].abortCount = rsdAbortCnt;
+        }
+    }
+
+    *channelStatistic = ganymede->channelStatistic[chip];
+
+#endif
+
+    return (error);
+}
+Dword Demodulator_addPid (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Pid             pid
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    AddPidRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.pid = pid;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_ADDPID,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte writeBuffer[2];
+    Byte i, j;
+    Bool found;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (pidInfo.pidinit == False) {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            for (j = 0; j < 32; j++) {
+                pidInfo.pidtable[i].pid[j] = 0xFFFF;
+            }
+        }
+        pidInfo.pidinit = True;
+    }
+
+    /** Enable pid filter */
+    if (pidInfo.pidcount == 0) {
+        error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_en, mp2if_pid_en_pos, mp2if_pid_en_len, 1);
+        if (error) goto exit;
+    } else {
+        found = False;
+        for (i = 0; i < 32; i++) {
+            if (pidInfo.pidtable[chip].pid[i] == pid.value) {
+                found = True;
+                break;
+            }
+        }
+        if (found == True)
+            goto exit;
+    }
+
+    for (i = 0; i < 32; i++) {
+        if (pidInfo.pidtable[chip].pid[i] == 0xFFFF)
+            break;
+    }
+    if (i == 32) {
+        error = Error_PID_FILTER_FULL;
+        goto exit;
+    }
+
+    writeBuffer[0] = (Byte) pid.value;
+    writeBuffer[1] = (Byte) (pid.value >> 8);
+
+    error = Standard_writeRegisters (demodulator, chip, Processor_OFDM, p_mp2if_pid_dat_l, 2, writeBuffer);
+    if (error) goto exit;
+
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_index_en, mp2if_pid_index_en_pos, mp2if_pid_index_en_len, 1);
+    if (error) goto exit;
+
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_mp2if_pid_index, i);
+    if (error) goto exit;
+
+    pidInfo.pidtable[chip].pid[i] = pid.value;
+    pidInfo.pidcount++;
+
+exit :
+#endif
+
+    return (error);
+}
+
+
+Dword Demodulator_addPidAt (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            index,
+    IN  Pid             pid
+) {
+	return (Demodulator_addPidToFilter (demodulator, chip, index, pid));
+}
+
+
+Dword Demodulator_removePid (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Pid             pid
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    RemovePidRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.pid = pid;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_REMOVEPID,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte i;
+    Bool found;
+    Interrupts interrupts;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    found = False;
+    for (i = 0; i < 32; i++) {
+        if (pidInfo.pidtable[chip].pid[i] == pid.value) {
+            found = True;
+            break;
+        }
+    }
+    if (found == False)
+        goto exit;
+
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_index_en, mp2if_pid_index_en_pos, mp2if_pid_index_en_len, 0);
+    if (error) goto exit;
+
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_mp2if_pid_index, i);
+    if (error) goto exit;
+
+    pidInfo.pidtable[chip].pid[i] = 0xFFFF;
+
+    /** Disable pid filter */
+    if (pidInfo.pidcount == 1) {
+        error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_en, mp2if_pid_en_pos, mp2if_pid_en_len, 0);
+
+        error = Standard_getInterrupts (demodulator, &interrupts);
+        if (error) goto exit;
+        if (interrupts & Interrupt_DVBT) {
+            error = Standard_clearInterrupt (demodulator, Interrupt_DVBT);
+            if (error) goto exit;
+        }
+    }
+
+    pidInfo.pidcount--;
+
+exit :
+#endif
+
+    return (error);
+}
+
+
+Dword Demodulator_removePidAt (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+	IN  Byte			index,
+    IN  Pid             pid
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+	DWORD number;
+	BOOL result;
+	RemovePidAtRequest request;
+	Ganymede* ganymede;
+
+	ganymede = (Ganymede*) demodulator;
+	
+	if (ganymede->driver != NULL) {
+		request.chip = chip;
+		request.index = index;
+		request.pid = pid;
+		result = DeviceIoControl (
+					ganymede->driver,
+					IOCTL_AFA_DEMOD_REMOVEPIDAT,
+					&request,
+					sizeof (request),
+					NULL,
+					0,
+					&number,
+					NULL
+		);
+		error = request.error;
+	} else {
+		error = Error_DRIVER_INVALID;
+	}
+#else
+	Ganymede* ganymede;
+
+	ganymede = (Ganymede*) demodulator;
+
+	error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_index_en, mp2if_pid_index_en_pos, mp2if_pid_index_en_len, 0);
+	if (error) goto exit;
+
+	error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_mp2if_pid_index, index);
+	if (error) goto exit;
+exit :
+#endif
+
+	return (error);
+}
+
+
+Dword Demodulator_resetPid (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte i;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    for (i = 0; i < 32; i++) {
+        pidInfo.pidtable[chip].pid[i] = 0xFFFF;
+    }
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_rst, mp2if_pid_rst_pos, mp2if_pid_rst_len, 1);
+    if (error) goto exit;
+
+    pidInfo.pidcount = 0;
+
+exit :
+#endif
+
+    return (error);
+}
+
+
+#ifdef UNDER_CE
+#else
+extern long ActiveSync;
+#endif
+
+Dword Demodulator_controlActiveSync (
+    IN Demodulator* demodulator,
+    IN Byte         control
+) {
+#ifdef UNDER_CE
+    if (control == 0)
+        ActiveSync = 0;
+    else
+        ActiveSync = 1;
+#endif
+
+    return (Error_NO_ERROR);
+}
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulatorextend.h	2012-02-27 00:02:36.338915017 +0100
@@ -0,0 +1,1326 @@
+#ifndef __DEMODULATOREXTEND_H__
+#define __DEMODULATOREXTEND_H__
+
+
+//#include <stdio.h>
+//#include <math.h>
+#include "a867_type.h"
+#include "a867_user.h"
+#include "a867_register.h"
+#include "a867_error.h"
+#include "a867_cmd.h"
+/*
+#include "i2cimpl.h"
+#include "spiimpl.h"
+#include "sdioimpl.h"
+*/
+#include "a867_usb2impl.h"
+#include "a867_demodulator.h"
+
+
+#define Tuner_Panasonic_ENV77H11D5			0x01
+#define Tuner_Microtune_MT2060				0x02
+#define Tuner_Maxlinear_MXL5003				0x03
+#define Tuner_Philip_TD1316AFIHP			0x04
+#define Tuner_Freescale_FS803A				0x05
+#define Tuner_Quantek_QT1010				0x06
+#define Tuner_Panasonic_ENV75H10D8			0x07
+#define Tuner_Lg_TDTMG252D					0x08
+#define Tuner_Himax_HTXR03A					0x09
+#define Tuner_Alps_TDQ44M					0x0A
+#define Tuner_Infineon_TUA6045				0x0B
+#define Tuner_Infineon_TUA6034				0x0C
+#define Tuner_Maxlinear_MXL5005				0x0D
+#define Tuner_Thomson_664X					0x0E
+#define Tuner_Thomson_6630					0x0F
+#define Tuner_Samsung_DTOS403				0x10
+#define Tuner_Samsung_DTOS446				0x11
+#define Tuner_Freescale_FS803A_DLNA			0x12
+#define Tuner_Microtune_MT2060_7SAW			0x13
+#define Tuner_Alps_TDQ03					0x14
+#define Tuner_Thomson_759X					0x15
+#define Tuner_Empire_DTN317					0x16
+#define Tuner_Partsnic_PDHTF05D				0x17
+#define Tuner_Panasonic_ENG37A30GF			0x18
+#define Tuner_Philips_FQD1216ME_MK5			0x19
+#define Tuner_Infineon_TUA6041				0x1A
+#define Tuner_Philips_TDA18271				0x1B
+#define Tuner_Alps_TDQD1X001A				0x1C
+#define Tuner_Maxlinear_MXL5005_RSSI		0x1D
+#define Tuner_Thomson_75101					0x1E
+#define Tuner_Sharp_5056					0x1F
+#define Tuner_Freescale_MC44CD02			0x20
+#define Tuner_Microtune_MT2260B0			0x21
+#define Tuner_Philips_TDA18291HN			0x22
+#define Tuner_Microtune_MT2266				0x23
+#define	Tuner_Integrant_ITD3020				0x24
+#define Tuner_Afatech_PEACOCK				0x25
+#define Tuner_Xceive_XC3028L				0x26
+#define Tuner_Infineon_TUA9001				0x27
+#define Tuner_Fitipower_FC0011				0x28
+#define Tuner_Afatech_AF9007				0xFF
+#define Tuner_Maxlinear_MXL5007				0xA0
+
+/**
+ * Define commands for AGC general set function
+ */
+#define APO_AGC_SET_RF_ACQUIRE				1
+#define APO_AGC_SET_RF_TRACK				2
+#define APO_AGC_SET_IF_ACQUIRE				3
+#define APO_AGC_SET_IF_TRACK				4
+#define APO_AGC_SET_ADC_OUT_DESIRED_S		5
+#define APO_AGC_SET_RF_TOP_S				6
+#define APO_AGC_SET_IF_TOP_S				7
+#define APO_AGC_SET_RF_LOCK_TH_ACQUIRE		8
+#define APO_AGC_SET_RF_LOCK_TH_TRACK		9
+#define APO_AGC_SET_IF_LOCK_TH_ACQUIRE		10
+#define APO_AGC_SET_IF_LOCK_TH_TRACK		11
+#define APO_AGC_SET_ADC_OUT_DESIRED_M		12
+#define APO_AGC_SET_RF_TOP_M				13
+#define APO_AGC_SET_IF_TOP_M				14
+#define APO_AGC_SET_RF_TOP					15
+#define APO_AGC_SET_IF_TOP					16
+
+
+/**
+ * Define commands for AGC general set function
+ */
+#define APO_AGC_GET_RF_ACQUIRE				1
+#define APO_AGC_GET_RF_TRACK				2
+#define APO_AGC_GET_IF_ACQUIRE				3
+#define APO_AGC_GET_IF_TRACK				4
+#define APO_AGC_GET_RF_LOCK_TH_ACQUIRE		5
+#define APO_AGC_GET_RF_LOCK_TH_TRACK		6
+#define APO_AGC_GET_IF_LOCK_TH_ACQUIRE		7
+#define APO_AGC_GET_IF_LOCK_TH_TRACK		8
+#define APO_AGC_GET_RF_MAX					9
+#define APO_AGC_GET_RF_MIN					10
+#define APO_AGC_GET_RF_TOP_S				11
+#define APO_AGC_GET_RF_TOP_M				17
+#define APO_AGC_GET_IF_MAX					12
+#define APO_AGC_GET_IF_MIN					13
+#define APO_AGC_GET_IF_TOP_S				14
+#define APO_AGC_GET_IF_TOP_M				18
+#define APO_AGC_GET_RF_TOP					19
+#define APO_AGC_GET_IF_TOP					20
+#define APO_AGC_GET_ADC_OUT_DESIRED_S		15
+#define APO_AGC_GET_ADC_OUT_DESIRED_M		16
+
+
+/**
+ * Define Options
+ */
+#define APO_OPTION_FREQSHIFT				0x00000001
+#define APO_OPTION_DYNATOP					0x00000002
+#define APO_OPTION_RET_NOW					0x00000004
+#define APO_OPTION_REPEAT_RETRAIN			0x00000008
+
+
+/**
+ * Define Demodulator_getDouble index
+ */
+#define APO_GET_FREQ_SHIFT					1
+#define APO_GET_ORIG_RF_TOP					2
+#define APO_GET_ORIG_IF_TOP					3
+#define APO_GET_FINAL_RF_TOP				4
+#define APO_GET_FINAL_IF_TOP				5
+#define APO_GET_BEST_RF_TOP					6
+#define APO_GET_BEST_IF_TOP					7
+
+
+/**
+ * Define commands for general CE information function
+ */
+#define APO_AGC_CLEAR_REGS				1
+#define APO_AGC_STALL_OFSM_ACCESS		2
+#define APO_AGC_RESTORE_OFSM_ACCESS		3
+
+
+#define APO_DCA_EN_UPPER				0x01
+#define APO_DCA_EN_LOWER				0x02
+#define APO_DCA_BOTH					0x00
+
+
+/** keep for internal api release */
+/**
+ * The type defination of PidTable.
+ */
+typedef struct {
+	Word pid[32];
+} PidTable;
+
+typedef struct {
+	PidTable pidtable[2];
+	Byte pidcount;
+	Bool pidinit;
+} PidInfo;
+/** end keep for internal api release */
+
+
+extern Word DemodulatorExtend_diversityMode;
+extern double DemodulatorExtend_crystalFrequency;
+extern Word Tdmb_bitRateTable[64];
+
+
+/**
+ * Set control bus and tuner.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param busId The ID of bus.
+ * @param tunerId The ID of tuner.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set I2C as the control bus. 
+ *     error = Demodulator_setBusTuner ((Demodulator*) &ganymede, Bus_I2C, Tuner_MICROTUNE_MT2060);
+ *     if (error) 
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setBusTuner (
+	IN  Demodulator*	demodulator,
+	IN  Word			busId,
+	IN  Word			tunerId
+);
+
+
+/**
+ * Set firmware and script.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param crystalFrequency The value of crystal frequency on board (KHz).
+ * @param adcFrequency The value of desire internal ADC frequency (Hz).
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set frequencies. 
+ *     error = Demodulator_setCrystalAdcFrequency ((Demodulator*) &ganymede, 30000, 20156250);
+ *     if (error) 
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setCrystalAdcFrequency (
+	IN  Demodulator*	demodulator,
+	IN  Dword			crystalFrequency,
+	IN  Dword			adcFrequency
+);
+
+
+/**
+ * Set firmware and script.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param firmwareCodes The byte array of firmware code.
+ * @param firmwareSegments The segments of firmwares.
+ * @param firmwarePartitions The partitions of firmwares.
+ * @param scriptSets The sets of script.
+ * @param scripts The byte array of script.
+ * @param tunerScriptSets The sets of tunerScript.
+ * @param tunerScripts The byte array of tunerScript.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte firmware[65535];
+ *     ValueSet script[256];
+ *     ValueSet tunerScript[256];
+ *     Ganymede ganymede;
+ *
+ *     // Set I2C as the control bus. 
+ *     error = Demodulator_setFirmwareScript ((Demodulator*) &ganymede, firmware, 65535, script, 256, tunerScript, 256);
+ *     if (error) 
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setFirmwareScript (
+	IN  Demodulator*	demodulator,
+	IN  Byte*			firmwareCodes,
+	IN  Segment*		firmwareSegments,
+	IN  Byte*			firmwarePartitions,
+	IN  Word*			scriptSets,
+	IN  ValueSet*		scripts,
+	IN  Word*           tunerScriptSets,
+	IN  ValueSet*       tunerScripts
+);
+
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param statistic the structure that store all statistic values.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     ChannelStatistic channelStatistic;
+ *     double preBer;
+ *     double postBer;
+ *     Ganymede ganymede;
+ *
+ *     // Set statistic range. 
+ *     error = Demodulator_getChannelStatistic ((Demodulator*) &ganymede, 0, &channelStatistic);
+ *     if (error) 
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     preBer = (double) channelStatistic.preVitErrorCount / (double) channelStatistic.preVitBitCount;
+ *     printf ("Pre-Viterbi BER = %f\n", preBer);
+ *     postBer = (double) channelStatistic.postVitErrorCount / (double) channelStatistic.postVitBitCount;
+ *     printf ("Post-Viterbi BER = %f\n", postBer);
+ *     printf ("Abort Count = %d\n", channelStatistic.abortCount);
+ * </pre>
+ */
+Dword Demodulator_getChannelStatistic (
+	IN  Demodulator*			demodulator,
+	IN  Byte					chip,
+	OUT ChannelStatistic*		channelStatistic
+);
+
+
+/**
+ * Set the counting range for Pre-Viterbi and Post-Viterbi. 
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param preErrorCount the number of super frame for Pre-Viterbi.
+ * @param preBitCount the number of packet unit for Post-Viterbi.
+ * @param snr the signal to noise ratio.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_getPreVitBer (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	OUT Dword*			preErrorCount,
+	OUT Dword*			preBitCount,
+	OUT double*			snr
+);
+
+
+/**
+ * Set the counting range for Pre-Viterbi and Post-Viterbi. 
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param preErrorCount the number of super frame for Pre-Viterbi.
+ * @param preBitCount the number of packet unit for Post-Viterbi.
+ * @param snr the signal to noise ratio.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_getSoftBer (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	OUT Dword*			preErrorCount,
+	OUT Dword*			preBitCount,
+	OUT double*			snr
+);
+
+
+/**
+ * This function is used to get signal quality indicator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param sqi signal quality indicator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ *     Byte sqi;
+ * 
+ *     Demodulator_getSqi (0x38, 0, &sqi);
+ * </pre>
+ */
+Dword Demodulator_getSqi (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    OUT Byte*			sqi
+);
+
+
+/**
+ * Get IF agc voltage.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param doPullUpVolt The pull up voltage of tunre.
+ * @param dopVolt IF AGC voltage to be returned.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getIfAgcVoltage (
+	IN  Demodulator*	demodulator,
+    IN  double			doPullUpVolt,
+    OUT double*			dopVolt
+);
+
+
+/**
+ * Set maximum RF agc. 
+ *
+ * @param demodulator the handle of demodulator.
+ * @param doMaxRfAgc The maximum value of RF AGC.
+ * @param doVolt RF AGC voltage to be set.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setMaxRfAgc (
+	IN  Demodulator*	demodulator,
+    IN	double			doMaxRfAgc,
+	IN  double			doVolt
+);
+
+
+/**
+ * Set minimum rf agc.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param doMinRfAgc The minimum value of RF AGC.
+ * @param doVolt RF AGC voltage to be set.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setMinRfAgc (
+	IN  Demodulator*	demodulator,
+    IN	double			doMinRfAgc,
+	IN  double			doVolt
+);
+
+
+/**
+ * Set max if agc.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param doMaxIfAgc The maximum value of IF AGC.
+ * @param doVolt IF AGC voltage to be set.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setMaxIfAgc (
+	IN  Demodulator*	demodulator,
+    IN	double			doMaxIfAgc,
+	IN  double			doVolt
+);
+
+
+/**
+ * Set min if agc. 
+ *
+ * @param demodulator the handle of demodulator.
+ * @param doMinIfAgc The minimum value of IF AGC.
+ * @param doVolt IF AGC voltage to be set.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setMinIfAgc (
+	IN  Demodulator*	demodulator,
+    IN	double			doMinIfAgc,
+	IN  double			doVolt
+);
+
+
+/**
+ * General agc set function.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucCmd .
+ * @param vpParams .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setAgc (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ucCmd,
+    IN	Word*			vpParams
+);
+
+
+/**
+ * General agc get function.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucCmd .
+ * @param vpParams .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getAgc (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ucCmd,
+    IN	void*			vpParams
+);
+
+
+/**
+ * Check if INR detected.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param count INR count.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getInrCount (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    OUT Word*			count
+);
+
+
+/**
+ * Check if CCI happens.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param cci0 1: CCI happen, 0: CCI doesn't happen.
+ * @param cci1 1: CCI happen, 0: CCI doesn't happen.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isCci (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    OUT Bool*			cci0,
+    OUT Bool*			cci1
+);
+
+
+/**
+ * Check if ACI happens
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param aci0 1: ACI happen, 0: ACI doesn't happen.
+ * @param aci1 1: ACI happen, 0: ACI doesn't happen.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isAci (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    OUT Bool*			aci0,
+    OUT Bool*			aci1
+);
+
+
+/**
+ * Get frequency offset.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param doTs Sampling period.
+ * @param lpNormOffset Normalized frequency offset (carrier spacing).
+ * @param lpOffset Frequency offset (22 bits) (Hz).
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getFrequencyOffset (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  double			elementaryPeriod,
+	OUT Long*			normalizedOffset,
+	OUT Long*			offset
+);
+
+
+/**
+ * Get sampling clock offset in second
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param adcFrequency ADC frequency.
+ * @param elementaryPeriod Sampling period.
+ * @param offset ADC sampling clock offset in sec.
+ * @param offsetPpm ADC sampling clock offset in PPM.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getTimeOffset (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    IN  double			adcFrequency,
+    IN  double			elementaryPeriod,
+    OUT double*			offset,
+    OUT double*			offsetPpm
+);
+
+
+/**
+ * Set IF1 frequency of MT2060.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param dwIf1 The IF1 frequency (KHz).
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setMT2060If1 (
+	IN  Demodulator*	demodulator,
+    IN  Dword			dwIf1
+);
+
+
+/**
+ * Clear FFT window position valid bit.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_resetFftWinPos (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+
+/**
+ * Clear FFT window position valid bit.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param delta Delta value for FFT window position.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getFftWinPos (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    IN	Long*			delta	
+);
+
+
+/**
+ * Get crystal frequency (KHz).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param fpFreq Crystal frequency.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getXtalFreq (
+	IN  Demodulator*	demodulator,
+    IN	float*			fpFreq
+);
+
+
+/**
+ * Test register.
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_testRegister (
+	IN  Demodulator*	demodulator
+);
+
+
+/**
+ * Dump register.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param cpFileName The name of file to be write.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_dumpRegister (
+	IN  Demodulator*	demodulator,
+    IN  char*			cpFileName
+);
+
+
+/**
+ * Get frequency response from hardware.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param tone Sub-Carrier Index ( Real Index = 200*wIndex).
+ * @param realPart Real part of Constellation value.
+ * @param imaginaryPart Imaginary part of Constellation value.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getFrequencyResponse (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	OUT Word*			tone,
+	OUT Long*			realPart,
+	OUT Long*			imaginaryPart
+);
+
+
+/**
+ * Get constellation value.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param tone Sub-Carrier Index ( Real Index = 200*wIndex).
+ * @param realPart Real part of Constellation value.
+ * @param imaginaryPart Imaginary part of Constellation value.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getConstellation (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Word			tone,
+	OUT float*			realPart,
+	OUT float*			imaginaryPart
+);
+
+
+/**
+ * Capture constellation value (2).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param wIndex Sub-Carrier Index ( Real Index = 200*wIndex).
+ * @param wpReal real part of constellation value.
+ * @param wpImag imaginary part of constellation value.
+ * @param wpH2 H2 value.
+ * @param wpRealH real part of H.
+ * @param wpImagH imaginary part of H.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_capConstellation2 (
+	IN  Demodulator*	demodulator,
+    IN  Word			wIndex,
+    OUT Byte*			ucpSymCnt,
+    OUT Byte*			ucpReal,
+    OUT Byte*			ucpImag,
+    OUT Word*			wpRealH,
+    OUT Word*			wpImagH
+);
+
+
+/**
+ * Get status.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param dwpStatus Pointer to system information.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getStatus (
+	IN  Demodulator*	demodulator,
+    OUT Dword*			dwpStatus
+);
+
+
+/**
+ * Get frequency shift.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param index .
+ * @param dopShift .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getDouble (
+	IN  Demodulator*	demodulator,
+    IN  Byte			index,
+    IN  double*			dopValue
+);
+
+
+/**
+ * Get IR byte.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucpIRByte IR packet buffer.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getIr (
+	IN  Demodulator*	demodulator,
+    OUT	Byte*			ucpIRByte
+);
+
+
+/**
+ * Dump EEPROM.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param dwDelay .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_dumpEeprom (
+	IN  Demodulator*	demodulator,
+    IN  Dword			dwDelay
+);
+
+
+/**
+ * Load file to EEPROM.
+ *
+ * @param fileName File name to load to EEPROM.
+ * @param dwDelay .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_loadEeprom (
+	IN  Demodulator*	demodulator,
+    IN  char*			fileName,
+    IN  Dword			dwDelay
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isFecMonEnabled (
+	IN  Demodulator*	demodulator,
+	OUT Bool*			enabled
+);
+
+
+/**
+ * Generate ce information.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param command .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_genCeInfoFunc (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Byte			command
+);
+
+
+/**
+ * Get ce information.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param spCentroid .
+ * @param spBias .
+ * @param dwpRh0 .
+ * @param wpM2 .
+ * @param dwpEh2 .
+ * @param ucpM2q .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getCeInfo (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	OUT Short*			spCentroid,
+	OUT Short*			spBias,
+	OUT Dword*			dwpRh0,
+	OUT Word*			wpM2,
+	OUT Dword*			dwpEh2,
+	OUT Byte*			ucpM2q
+);
+
+
+/**
+ * Enable/disable retrain.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param enable .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setRetrain (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Byte			enable
+);
+
+
+/**
+ * Enable/disable CCIR.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucEnable .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setCcir (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ucEnable
+);
+
+
+/**
+ * Handle CCIF
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ccifId .
+ * @param ctrl .
+ * @param ucBw .
+ * @param wFreq .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_handleCcif (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ccifId,
+	IN  Byte			ctrl,
+	IN  Byte			ucBw,
+	IN  Word			wFreq
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param level .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getAdcDesiredLevel (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	OUT Word*			level
+);
+
+	
+/**
+ * Set tuner type
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucTuner .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setTunerType (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ucTuner
+);
+
+
+/**
+ * Set board id
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucBoard .
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setBoardId (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ucBoard
+);
+
+
+/**
+ * Get signal strength in Dbm
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucTunerType tuner type.
+ * @param ucBoardId Board ids.
+ * @param dopStrength signal strength.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getSignalStrengthDBm (
+	IN  Demodulator*	demodulator,
+	IN  Byte			ucTunerType,
+    IN  Byte			ucBoardId,
+    OUT double*			dopStrength		
+);
+
+
+/**
+ * Program CFOE 2.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ucBw Current channel bandwidth in MHz.
+ * @param dFs ADC sampling frequency.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_programCFOE2 (
+	IN  Demodulator*	demodulator,
+    IN  Byte			ucBw,
+    IN  double			dFs
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setCalibratAgc (
+	IN  Demodulator*	demodulator
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setCrystalFrequency (
+	IN  Demodulator*	demodulator,
+	IN  double			crystalFrequency
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_writeMt2060If1 (
+	IN  Demodulator*	demodulator,
+	IN  Dword			dwIF1
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getSnr (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	OUT double*			snr
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param speed the I2C speed in KHz.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setI2cSpeed (
+	IN  Demodulator*	demodulator,
+	IN  Dword			speed
+);
+
+
+/**
+ * Ask fw to go back to boot code
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_backToBootCode (
+	IN  Demodulator*	demodulator
+);
+
+
+/**
+ * Control gpio3 (AF9015 use this pin to turn on/off tuner)
+ * ucOn = 1 => turn on tuner
+ * ucOn = 0 => turn off tuner
+ *
+ * @param demodulator the handle of demodulator.
+ * @param contorl True: Enable, False: Disable;
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_controlTunerPower (
+	IN  Demodulator*	demodulator,
+	IN  Byte			control
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param multiplier ADC frequency multiplier;
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setMultiplier (
+	IN  Demodulator*	demodulator,
+	IN  Multiplier		multiplier
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param multiplier ADC frequency multiplier;
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getMultiplier (
+	IN  Demodulator*	demodulator,
+	IN  Multiplier*		multiplier
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param ifFrequency the IF frequency of tuner;
+ * @param inversion True if tuner's pectrum is inversed;
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_modifyTunerDescription (
+	IN  Demodulator*	demodulator,
+	IN  Byte			tunerAddress,
+	IN  Byte			registerAddressLength,
+	IN  Dword			ifFrequency,
+	IN  Bool			inversion
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_writeRawData (
+	IN  Demodulator*	demodulator,
+	IN  Byte			writeBufferLength,
+	IN  Byte*			writeBuffer
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_readRawData (
+	IN  Demodulator*	demodulator,
+	IN  Byte			readBufferLength,
+	OUT Byte*			readBuffer
+);
+
+
+/**
+ * Open tuner.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ */
+Dword Demodulator_openTuner (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+/**
+ * Set tuner.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param bandwidth The desired bandwidth.
+ * @param frequency The desired frequency.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ */
+Dword Demodulator_setTuner (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN	Word			bandwidth,
+	IN  Dword			frequency
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param block How many block (logical frame) to be check.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setPostVitAllZeroBlock (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Word			block
+);
+
+
+/**
+ * Add PID to PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param pid the PID that will be add to PID filter.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_addPid (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Pid				pid
+);
+
+
+/**
+ * Add PID to PID filter by index.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param index the index of PID filter.
+ * @param pid the PID that will be add to PID filter.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_addPidAt (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    IN  Byte            index,
+	IN  Pid				pid
+);
+
+
+/**
+ * Remove PID from PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param pid the PID that will be remove from PID filter.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_removePid (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Pid				pid
+);
+
+/**
+ * Remove PID from PID filter by index.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @param index the index of PID filter.
+ * @param pid the PID that will be remove from PID filter.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_removePidAt (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+	IN  Byte			index,
+    IN  Pid             pid
+);
+
+
+/**
+ * Reset PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are 
+ *        0~7.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_resetPid (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+
+/**
+ * Control Active Sync.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param contorl 0: Disable(BDA Extend), 1: Enable (Active Sync)
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_controlActiveSync (
+	IN  Demodulator*	demodulator,
+	IN  Byte			control
+);
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_demodulator.h	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,1495 @@
+#ifndef __GANYMEDE_H__
+#define __GANYMEDE_H__
+
+
+#include "a867_type.h"
+#include "a867_user.h"
+#include "a867_error.h"
+#include "a867_register.h"
+#include "a867_variable.h"
+#include "a867_cmd.h"
+#include "a867_standard.h"
+#include "a867_demodulatorextend.h"  /** release1remove */
+#include "a867_version.h"
+
+/**
+ * Write one byte (8 bits) to a specific register in demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be written.
+ * @param value the value to be written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set the value of register 0xA000 in demodulator to 0.
+ *     error = Demodulator_writeRegister ((Demodulator*) &ganymede, 0, Processor_LINK, 0xA000, 0);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_writeRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            value
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the start address of the registers to be written.
+ * @param bufferLength the number of registers to be written.
+ * @param buffer a byte array which is used to store values to be written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte buffer[3] = { 0x00, 0x01, 0x02 };
+ *     Ganymede ganymede;
+ *
+ *     // Set the value of register 0xA000 in demodulator to 0.
+ *     // Set the value of register 0xA001 in demodulator to 1.
+ *     // Set the value of register 0xA002 in demodulator to 2.
+ *     error = Demodulator_writeRegisters ((Demodulator*) &ganymede, 0, Processor_LINK, 0xA000, 3, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_writeRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Write a collection of values to discontiguous registers in demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param valueSetsLength the number of values to be written.
+ * @param valueSets a ValueSet array which is used to store values to be
+ *        written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     ValueSet valueSet[3];
+ *     Ganymede ganymede;
+ *
+ *     // Get the value of register 0xA000, 0xA001 and 0xA002 in demodulator.
+ *     valueSet[0].address = 0xA000;
+ *     valueSet[0].value = 0x00;
+ *     valueSet[1].address = 0xA001;
+ *     valueSet[1].value = 0x01;
+ *     valueSet[2].address = 0xA002;
+ *     valueSet[2].value = 0x02;
+ *     error = Demodulator_writeScatterRegisters ((Demodulator*) &ganymede, 0, Processor_LINK, 3, valueSet);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_writeScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in slave device.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the registers to be read.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte buffer[3] = { 0x00, 0x01, 0x02 };
+ *     Ganymede ganymede;
+ *
+ *     // Set the value of register 0x0000 in tuner to 0.
+ *     // Set the value of register 0x0001 in tuner to 1.
+ *     // Set the value of register 0x0002 in tuner to 2.
+ *     error = Demodulator_writeTunerRegistersWithAddress ((Demodulator*) &ganymede, 0, 0x38, 0x00, 1, 3, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_writeTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in slave device
+ * through specified interface (1, 2, 3).
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param interfaceIndex the index of interface. The possible values are
+ *        1~3.
+ * @param slaveAddress the I2c address of slave device.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_writeGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous cells in the EEPROM.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5 (firmware will detect EEPROM address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the cells to be written.
+ * @param registerAddressLength the valid bytes of registerAddress.
+ * @param bufferLength the number of cells to be written.
+ * @param buffer a byte array which is used to store values to be written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte buffer[3] = { 0x00, 0x01, 0x02 };
+ *     Ganymede ganymede;
+ *
+ *     // Set the value of cell 0x0000 in EEPROM to 0.
+ *     // Set the value of cell 0x0001 in EEPROM to 1.
+ *     // Set the value of cell 0x0002 in EEPROM to 2.
+ *     error = Demodulator_writeEepromValues ((Demodulator*) &ganymede, 0, 0x0000, 3, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_writeEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Modify bits in the specific register.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be written.
+ * @param position the start position of bits to be modified (0 means the
+ *        LSB of the specifyed register).
+ * @param length the length of bits.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Modify the LSB of register 0xA000 in demodulator to 0.
+ *     error = Demodulator_writeRegisterBits ((Demodulator*) &ganymede, 0, Processor_LINK, 0xA000, 0, 1, 0);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_writeRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+);
+
+
+/**
+ * Read one byte (8 bits) from a specific register in demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be read.
+ * @param value the pointer used to store the value read from demodulator
+ *        register.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte value;
+ *     Ganymede ganymede;
+ *
+ *     // Get the value of register 0xA000 in demodulator.
+ *     error = Demodulator_readRegister ((Demodulator*) &ganymede, 0, Processor_LINK, 0xA000, &value);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     printf ("The value of 0xA000 is %2x", value);
+ * </pre>
+ */
+Dword Demodulator_readRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    OUT Byte*           value
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous registers in demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be read.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte buffer[3];
+ *     Ganymede ganymede;
+ *
+ *     // Get the value of register 0xA000, 0xA001, 0xA002 in demodulator.
+ *     error = Demodulator_readRegisters ((Demodulator*) &ganymede, 0, Processor_LINK, 0xA000, 3, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     printf ("The value of 0xA000 is %2x", buffer[0]);
+ *     printf ("The value of 0xA001 is %2x", buffer[1]);
+ *     printf ("The value of 0xA002 is %2x", buffer[2]);
+ * </pre>
+ */
+Dword Demodulator_readRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Read a collection of values to discontiguous registers from demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param valueSetsLength the number of values to be read.
+ * @param valueSets a ValueSet array which is used to store values to be
+ *        read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     ValueSet valueSet[3];
+ *     Ganymede ganymede;
+ *
+ *     // Get the value of register 0xA000, 0xA001 and 0xA002 in demodulator.
+ *     valueSet[0].address = 0xA000;
+ *     valueSet[1].address = 0xA001;
+ *     valueSet[2].address = 0xA002;
+ *     error = Demodulator_readScatterRegisters ((Demodulator*) &ganymede, 0, Processor_LINK, 3, valueSet);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     printf ("The value of 0xA000 is %2x", valueSet[0].value);
+ *     printf ("The value of 0xA001 is %2x", valueSet[1].value);
+ *     printf ("The value of 0xA002 is %2x", valueSet[2].value);
+ * </pre>
+ */
+Dword Demodulator_readScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous registers in tuner.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the registers to be read.
+ * @param registerAddressLength the valid bytes of registerAddress.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte buffer[3];
+ *     Ganymede ganymede;
+ *
+ *     // Get the value of register 0x0000, 0x0001, 0x0002 in tuner.
+ *     error = Demodulator_readTunerRegisters ((Demodulator*) &ganymede, 0, 0x0000, 3, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     printf ("The value of 0x0000 is %2x", buffer[0]);
+ *     printf ("The value of 0x0001 is %2x", buffer[1]);
+ *     printf ("The value of 0x0002 is %2x", buffer[2]);
+ * </pre>
+ */
+Dword Demodulator_readTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous registers in slave device
+ * through specified interface (1, 2, 3).
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param interfaceIndex the index of interface. The possible values are
+ *        1~3.
+ * @param slaveAddress the I2c address of slave device.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_readGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous cells in the EEPROM.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5 (firmware will detect EEPROM address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the cells to be read.
+ * @param registerAddressLength the valid bytes of registerAddress.
+ * @param bufferLength the number of cells to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte buffer[3];
+ *     Ganymede ganymede;
+ *
+ *     // Get the value of cell 0x0000, 0x0001, 0x0002 in EEPROM.
+ *     error = Demodulator_readEepromValues ((Demodulator*) &ganymede, 0, 0x0000, 3, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     printf ("The value of 0x0000 is %2x", buffer[0]);
+ *     printf ("The value of 0x0001 is %2x", buffer[1]);
+ *     printf ("The value of 0x0002 is %2x", buffer[2]);
+ * </pre>
+ */
+Dword Demodulator_readEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Read bits of the specified register.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be read.
+ * @param position the start position of bits to be read (0 means the
+ *        LSB of the specifyed register).
+ * @param length the length of bits.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte value;
+ *     Ganymede ganymede;
+ *
+ *     // Read the LSB of register 0xA000 in demodulator.
+ *     error = Demodulator_readRegisterBits ((Demodulator*) &ganymede, 0, Processor_LINK, 0xA000, 0, 1, &value);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     printf ("The value of LSB of 0xA000 is %2x", value);
+ * </pre>
+ */
+Dword Demodulator_readRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    OUT Byte*           value
+);
+
+
+/**
+ * Get the version of hardware.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param version the version of hardware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Dword version;
+ *     Ganymede ganymede;
+ *
+ *     // Add PID to PID filter.
+ *     error = Demodulator_getHardwareVersion ((Demodulator*) &ganymede, &version);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("The version of hardware is : %X", version);
+ * </pre>
+ */
+Dword Demodulator_getHardwareVersion (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          version
+);
+
+
+/**
+ * Get the version of firmware.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param version the version of firmware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Dword version;
+ *     Ganymede ganymede;
+ *
+ *     // Get the version of Link layer firmware.
+ *     error = Demodulator_getFirmwareVersion ((Demodulator*) &ganymede, Processor_LINK, &version);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("The version of firmware is : %X", version);
+ * </pre>
+ */
+Dword Demodulator_getFirmwareVersion (
+    IN  Demodulator*    demodulator,
+    IN  Processor       processor,
+    OUT Dword*          version
+);
+
+
+/**
+ * Add PID to PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param index the index of PID filter.
+ * @param pid the PID that will be add to PID filter.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Pid pid;
+ *     Ganymede ganymede;
+ *
+ *     pid.value = 0x0000;
+ *
+ *     // Add PID to PID filter.
+ *     error = Demodulator_addPidToFilter ((Demodulator*) &ganymede, 0, 1, pid);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_addPidToFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            index,
+    IN  Pid             pid
+);
+
+
+/**
+ * Reset PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     error = Demodulator_resetPidFilter ((Demodulator*) &ganymede, 0);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_resetPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+);
+
+
+/**
+ * Get datagram from device.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @return Error_BUFFER_INSUFFICIENT: if buffer is too small.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Word bufferLength;
+ *     Byte buffer[4096];
+ *     Ganymede ganymede;
+ *
+ *     bufferLength = 4096;
+ *     error = Demodulator_getDatagram ((Demodulator*) &ganymede, &bufferLength, buffer);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_getDatagram (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Get RF AGC gain.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param rfAgc the value of RF AGC.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte rfAgc;
+ *     Ganymede ganymede;
+ *
+ *     // Set I2C as the control bus.
+ *     error = Demodulator_getRfAgcGain ((Demodulator*) &ganymede, 0, rfAgc);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_getRfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           rfAgc
+);
+
+
+/**
+ * Get IF AGC.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param ifAgc the value of IF AGC.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte ifAgc;
+ *     Ganymede ganymede;
+ *
+ *     // Set I2C as the control bus.
+ *     error = Demodulator_getIfAgcGain ((Demodulator*) &ganymede, 0, ifAgc);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_getIfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           ifAgc
+);
+
+
+/**
+ * Load the IR table for USB device.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param tableLength The length of IR table.
+ * @param table The content of IR table.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_loadIrTable (
+    IN  Demodulator*    demodulator,
+    IN  Word            tableLength,
+    IN  Byte*           table
+);
+
+
+/**
+ * Load firmware to device
+ *
+ * @param demodulator the handle of demodulator.
+ * @firmwareCodes pointer to fw binary.
+ * @firmwareSegments pointer to fw segments.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Demodulator_loadFirmware (
+    IN  Demodulator*    demodulator,
+    IN  Byte*           firmwareCodes,
+    IN  Segment*        firmwareSegments,
+    IN  Byte*           firmwarePartitions
+);
+
+
+/**
+ * First, download firmware from host to demodulator. Actually, firmware is
+ * put in firmware.h as a part of source code. Therefore, in order to
+ * update firmware the host have to re-compile the source code.
+ * Second, setting all parameters which will be need at the beginning.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chipNumber The total number of demodulators.
+ * @param sawBandwidth SAW filter bandwidth in KHz. The possible values
+ *        are 6000, 7000, and 8000 (KHz).
+ * @param streamType The format of output stream.
+ * @param architecture the architecture of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Initialize demodulators.
+ *     // SAW Filter  : 8MHz
+ *     // Stream Type : IP Datagram.
+ *     error = Demodulator_initialize ((Demodulator*) &ganymede, 1, 8, StreamType_IP_DATAGRAM, Architecture_DCA);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_initialize (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chipNumber,
+    IN  Word            sawBandwidth,
+    IN  StreamType      streamType,
+    IN  Architecture    architecture
+);
+
+
+/**
+ * Power off the demodulators.
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Finalize demodulators.
+ *     error = Demodulator_finalize ((Demodulator*) &ganymede);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_finalize (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isAgcLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isCfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isSfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isTpsLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_isMpeg2Locked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param locked the result of frequency tuning. True if there is
+ *        demodulator can lock signal, False otherwise.
+ * @see Demodulator_acquireChannel
+ */
+Dword Demodulator_isLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ * Set priorty of modulation.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param priority modulation priority.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set priority.
+ *     error = Demodulator_setPriority ((Demodulator*) &ganymede, 0, Priority_HIGH);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setPriority (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Priority        priority
+);
+
+
+/**
+ * Reset demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Reset demodulator.
+ *     error = Demodulator_reset ((Demodulator*) &ganymede);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_reset (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Get channel modulation related information.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param channelModulation The modulation of channel.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    OUT ChannelModulation*      channelModulation
+);
+
+
+/**
+ * Set channel modulation related information.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param channelModulation The modulation of channel.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_setChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    IN  ChannelModulation*      channelModulation
+);
+
+
+/**
+ * Specify the bandwidth of channel and tune the channel to the specific
+ * frequency. Afterwards, host could use output parameter dvbH to determine
+ * if there is a DVB-H signal.
+ * In DVB-T mode, after calling this function the output parameter dvbH
+ * should return False and host could use output parameter "locked" to check
+ * if the channel has correct TS output.
+ * In DVB-H mode, after calling this function the output parameter dvbH should
+ * return True and host could start get platform thereafter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param bandwidth The channel bandwidth.
+ *        DVB-T: 5000, 6000, 7000, and 8000 (KHz).
+ *        DVB-H: 5000, 6000, 7000, and 8000 (KHz).
+ *        T-DMB: 5000, 6000, 7000, and 8000 (KHz).
+ *        FM: 100, and 200 (KHz).
+ * @param frequency the channel frequency in KHz.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Bool locked;
+ *     Ganymede ganymede;
+ *
+ *     error = Demodulator_acquireChannel ((Demodulator*) &ganymede, 0, 8000, 666000);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *
+ *     error = Demodulator_isLocked ((Demodulator*) &ganymede, 0, &locked);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *
+ *     if (locked == True) {
+ *         // In DVB-T mode.
+ *         // Start to process TS
+ *         // Because DVB-T could be multiplex with DVB-H
+ *     }
+ * </pre>
+ */
+Dword Demodulator_acquireChannel (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,
+    IN  Dword           frequency
+);
+
+
+
+/**
+ * Set the output stream type of chip. Because the device could output in
+ * many stream type, therefore host have to choose one type before receive
+ * data.
+ *
+ * Note: After host know all the available channels, and want to change to
+ *       specific channel, host have to choose output mode before receive
+ *       data. Please refer the example of Demodulator_setStreamType.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param streamType the possible values are
+ *        DVB-H:    StreamType_DVBH_DATAGRAM
+ *                  StreamType_DVBH_DATABURST
+ *        DVB-T:    StreamType_DVBT_DATAGRAM
+ *                  StreamType_DVBT_PARALLEL
+ *                  StreamType_DVBT_SERIAL
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     error = Demodulator_setStreamType ((Demodulator*) &ganymede, StreamType_DVBT_PARALLEL)
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setStreamType (
+    IN  Demodulator*    demodulator,
+    IN  StreamType      streamType
+);
+
+
+/**
+ * Set the architecture of chip. When two of our device are using, they could
+ * be operated in Diversity Combine Architecture (DCA) or (PIP). Therefore,
+ * host could decide which mode to be operated.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param architecture the possible values are
+ *        Architecture_DCA
+ *        Architecture_PIP
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set architecture.
+ *     error = Demodulator_setArchitecture ((Demodulator*) &ganymede, Architecture_DCA)
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setArchitecture (
+    IN  Demodulator*    demodulator,
+    IN  Architecture    architecture
+);
+
+
+/**
+ * Get the length of Data
+ * In DVB-T mode, data length should always equals 2K,
+ * In DVB-H mode, data length would be the length of IP datagram.
+ * NOTE: data can't be transfer via I2C bus, in order to transfer data
+ * host must provide SPI bus.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param dataLength the length of data.
+ * @param valid True if the data length is valid.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @see Demodulator_addIp
+ */
+Dword Demodulator_getDataLength (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          dataLength,
+    OUT Bool*           valid
+);
+
+
+/**
+ * Get the IP datagram of Data.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param bufferLength the length of buffer.
+ * @param buffer buffer used to get Data.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @see Demodulator_addIp
+ */
+Dword Demodulator_getData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Get the type of interrupts.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param interrupts the type of interrupts.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Interrupt interrupts;
+ *     Ganymede ganymede;
+ *
+ *     // Get the type of interrupts.
+ *     error = Demodulator_getInterrupts ((Demodulator*) &ganymede, &interrupts);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     if (interrupts & Interrupt_VERSION) {
+ *         // Get IP version
+ *     }
+ *     if (interrupts & Interrupt_DVBH) {
+ *         // Get DVB-H Data
+ *     }
+ *     if (interrupts & Interrupt_DVBT) {
+ *         // Get DVB-T Data
+ *     }
+ *     if (interrupts & Interrupt_SIPSI) {
+ *         // Get SI/PSI
+ *     }
+ * </pre>
+ */
+Dword Demodulator_getInterrupts (
+    IN  Demodulator*    demodulator,
+    OUT Interrupts*     interrupts
+);
+
+
+/**
+ * Clear interrupts flag.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param interrupts interrupts flag.
+ * @param packetUnit the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set statistic range.
+ *     error = Demodulator_clearInterrupt ((Demodulator*) &ganymede, Interrupt_SIPSI);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_clearInterrupt (
+    IN  Demodulator*    demodulator,
+    IN  Interrupt       interrupt
+);
+
+
+/**
+ * Get siganl quality.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param quality The value of signal quality.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getSignalQuality (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           quality
+);
+
+
+/**
+ * Get signal strength
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param strength The value of signal strength.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getSignalStrength (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           strength
+);
+
+
+/**
+ * Get signal strength in dbm
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param rfpullUpVolt_X10 the pullup voltag of RF multiply 10.
+ * @param ifpullUpVolt_X10 the pullup voltag of IF multiply 10.
+ * @param strengthDbm The value of signal strength in DBm.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getSignalStrengthDbm (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Long            rfpullUpVolt_X10,     /** RF pull up voltage multiplied by 10   */
+    IN  Long            ifpullUpVolt_X10,     /** IF pull up voltage multiplied by 10   */
+    OUT Long*           strengthDbm           /** DBm                                   */
+);
+
+
+/**
+ * Get post VitBer
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param postErrorCount error count after viterbi
+ * @param postBitCount total count after viterbi
+ * @param abortCount error count after reed-soloman
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getPostVitBer (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Dword*          postErrorCount,  /** 24 bits */
+    OUT Dword*          postBitCount,    /** 16 bits */
+    OUT Word*           abortCount
+);
+
+
+/**
+ * Set the counting range for Pre-Viterbi and Post-Viterbi.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param frameCount the number of super frame for Pre-Viterbi.
+ * @param packetUnit the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Ganymede ganymede;
+ *
+ *     // Set statistic range.
+ *     error = Demodulator_setStatisticRange ((Demodulator*) &ganymede, 0, 1, 10000);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_setStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            superFrameCount,
+    IN  Word            packetUnit
+);
+
+
+/**
+ * Get the counting range for Pre-Viterbi and Post-Viterbi.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param frameCount the number of super frame for Pre-Viterbi.
+ * @param packetUnit the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Byte superFrameCount;
+ *     Word packetUnit;
+ *     Ganymede ganymede;
+ *
+ *     // Set statistic range.
+ *     error = Demodulator_getStatisticRange ((Demodulator*) &ganymede, 0, &superFrameCount, &packetUnit);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ * </pre>
+ */
+Dword Demodulator_getStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte*           superFrameCount,
+    IN  Word*           packetUnit
+);
+
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param statistic the structure that store all statistic values.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ *     Dword error = Error_NO_ERROR;
+ *     Statistic statistic;
+ *     double preBer;
+ *     double postBer;
+ *     Ganymede ganymede;
+ *
+ *     // Set statistic range.
+ *     error = Demodulator_getStatistic ((Demodulator*) &ganymede, 0, &statistic);
+ *     if (error)
+ *         printf ("Error Code = %X", error);
+ *     else
+ *         printf ("Success");
+ *     preBer = (double) statistic.preVitErrorCount / (double) statistic.preVitBitCount;
+ *     printf ("Pre-Viterbi BER = %f\n", preBer);
+ *     postBer = (double) statistic.postVitErrorCount / (double) statistic.postVitBitCount;
+ *     printf ("Post-Viterbi BER = %f\n", postBer);
+ *     printf ("Abort Count = %d\n", statistic.abortCount);
+ *     if (statistic.signalPresented == True)
+ *         printf ("Signal Presented = True\n");
+ *     else
+ *         printf ("Signal Presented = False\n");
+ *     if (statistic.signalLocked == True)
+ *         printf ("Signal Locked = True\n");
+ *     else
+ *         printf ("Signal Locked = False\n");
+ *     printf ("Signal Quality = %d\n", statistic.signalQuality);
+ *     printf ("Signal Strength = %d\n", statistic.signalStrength);
+ * </pre>
+ */
+Dword Demodulator_getStatistic (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Statistic*      statistic
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param code the value of IR raw code, the size should be 4 or 6,
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_getIrCode (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          code
+);
+
+
+/**
+ * Return to boot code
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_reboot (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Control PID fileter
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param contorl 0: Disable, 1: Enable.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_controlPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param contorl 1: Power up, 0: Power down;
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_controlPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+);
+
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param contorl 1: Power up, 0: Power down;
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Demodulator_controlTunerPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            control
+);
+
+
+/**
+ * Set datagram burst size.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param burstSize the burst size.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @return Error_NOT_SUPPORT: if the burst size is not support.
+ */
+Dword Demodulator_setBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize       burstSize
+);
+
+
+/**
+ * Get datagram burst size.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param burstSize the burst size.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @return Error_NOT_SUPPORT: if the burst size is not support.
+ */
+Dword Demodulator_getBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize*      burstSize
+);
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_error.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_error.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_error.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_error.h	2012-02-27 00:02:36.878915017 +0100
@@ -0,0 +1,141 @@
+#ifndef __ERROR_H__
+#define __ERROR_H__
+
+#define Error_NO_ERROR							0x00000000ul
+#define Error_RESET_TIMEOUT						0x00000001ul
+#define Error_WRITE_REG_TIMEOUT					0x00000002ul
+#define Error_WRITE_TUNER_TIMEOUT				0x00000003ul
+#define Error_WRITE_TUNER_FAIL					0x00000004ul
+#define Error_RSD_COUNTER_NOT_READY				0x00000005ul
+#define Error_VTB_COUNTER_NOT_READY				0x00000006ul
+#define Error_FEC_MON_NOT_ENABLED				0x00000007ul
+#define Error_INVALID_DEV_TYPE					0x00000008ul
+#define Error_INVALID_TUNER_TYPE				0x00000009ul
+#define Error_OPEN_FILE_FAIL					0x0000000Aul
+#define Error_WRITEFILE_FAIL					0x0000000Bul
+#define Error_READFILE_FAIL						0x0000000Cul
+#define Error_CREATEFILE_FAIL					0x0000000Dul
+#define Error_MALLOC_FAIL						0x0000000Eul
+#define Error_INVALID_FILE_SIZE					0x0000000Ful
+#define Error_INVALID_READ_SIZE					0x00000010ul
+#define Error_LOAD_FW_DONE_BUT_FAIL				0x00000011ul
+#define Error_NOT_IMPLEMENTED					0x00000012ul
+#define Error_NOT_SUPPORT						0x00000013ul
+#define Error_WRITE_MBX_TUNER_TIMEOUT			0x00000014ul
+#define Error_DIV_MORE_THAN_8_CHIPS				0x00000015ul
+#define Error_DIV_NO_CHIPS						0x00000016ul
+#define Error_SUPER_FRAME_CNT_0					0x00000017ul
+#define Error_INVALID_FFT_MODE					0x00000018ul
+#define Error_INVALID_CONSTELLATION_MODE		0x00000019ul
+#define Error_RSD_PKT_CNT_0						0x0000001Aul
+#define Error_FFT_SHIFT_TIMEOUT					0x0000001Bul
+#define Error_WAIT_TPS_TIMEOUT					0x0000001Cul
+#define Error_INVALID_BW						0x0000001Dul
+#define Error_INVALID_BUF_LEN					0x0000001Eul
+#define Error_NULL_PTR							0x0000001Ful
+#define Error_INVALID_AGC_VOLT					0x00000020ul
+#define Error_MT_OPEN_FAIL						0x00000021ul
+#define Error_MT_TUNE_FAIL						0x00000022ul
+#define Error_CMD_NOT_SUPPORTED					0x00000023ul
+#define Error_CE_NOT_READY						0x00000024ul
+#define Error_EMBX_INT_NOT_CLEARED				0x00000025ul
+#define Error_INV_PULLUP_VOLT					0x00000026ul
+#define Error_FREQ_OUT_OF_RANGE					0x00000027ul
+#define Error_INDEX_OUT_OF_RANGE				0x00000028ul
+#define Error_NULL_SETTUNER_PTR					0x00000029ul
+#define Error_NULL_INITSCRIPT_PTR				0x0000002Aul
+#define Error_INVALID_INITSCRIPT_LEN			0x0000002Bul
+#define Error_INVALID_POS						0x0000002Cul
+#define Error_BACK_TO_BOOTCODE_FAIL				0x0000002Dul
+#define Error_GET_BUFFER_VALUE_FAIL				0x0000002Eul
+#define Error_INVALID_REG_VALUE					0x0000002Ful
+#define Error_INVALID_INDEX						0x00000030ul
+#define Error_READ_TUNER_TIMEOUT				0x00000031ul
+#define Error_READ_TUNER_FAIL					0x00000032ul
+#define Error_UNDEFINED_SAW_BW					0x00000033ul
+#define Error_MT_NOT_AVAILABLE					0x00000034ul
+#define Error_NO_SUCH_TABLE						0x00000035ul
+#define Error_WRONG_CHECKSUM					0x00000036ul
+#define Error_INVALID_XTAL_FREQ					0x00000037ul
+#define Error_COUNTER_NOT_AVAILABLE				0x00000038ul
+#define Error_INVALID_DATA_LENGTH				0x00000039ul
+#define Error_BOOT_FAIL							0x0000003Aul
+#define Error_BUFFER_INSUFFICIENT				0x0000003Bul
+#define Error_NOT_READY							0x0000003Cul
+#define Error_DRIVER_INVALID					0x0000003Dul
+#define Error_INTERFACE_FAIL					0x0000003Eul
+#define Error_PID_FILTER_FULL					0x0000003Ful
+#define Error_OPERATION_TIMEOUT					0x00000040ul
+#define Error_LOADFIRMWARE_SKIPPED				0x00000041ul
+#define Error_REBOOT_FAIL						0x00000042ul
+#define Error_PROTOCOL_FORMAT_INVALID			0x00000043ul
+#define Error_ACTIVESYNC_ERROR					0x00000044ul
+#define Error_CE_READWRITEBUS_ERROR				0x00000045ul
+#define Error_CE_NODATA_ERROR					0x00000046ul
+#define Error_NULL_FW_SCRIPT					0x00000047ul
+#define Error_NULL_TUNER_SCRIPT					0x00000048ul
+
+/** Error Code of Gemini System */
+#define Error_INVALID_INDICATOR_TYPE			0x00000101ul
+#define Error_INVALID_SC_NUMBER					0x00000102ul
+#define Error_INVALID_SC_INFO					0x00000103ul
+#define Error_FIGBYPASS_FAIL					0x00000104ul
+
+/** Error Code of Firmware */
+#define Error_FIRMWARE_STATUS					0x01000000ul
+
+/** Error Code of I2C Module */
+#define Error_I2C_DATA_HIGH_FAIL				0x02001000ul
+#define Error_I2C_CLK_HIGH_FAIL					0x02002000ul
+#define Error_I2C_WRITE_NO_ACK					0x02003000ul
+#define Error_I2C_DATA_LOW_FAIL					0x02004000ul
+
+/** Error Code of USB Module */
+#define Error_USB_NULL_HANDLE					0x03010001ul
+#define Error_USB_WRITEFILE_FAIL				0x03000002ul
+#define Error_USB_READFILE_FAIL					0x03000003ul
+#define Error_USB_INVALID_READ_SIZE				0x03000004ul
+#define Error_USB_INVALID_STATUS				0x03000005ul
+#define Error_USB_INVALID_SN					0x03000006ul
+#define Error_USB_INVALID_PKT_SIZE				0x03000007ul
+#define Error_USB_INVALID_HEADER				0x03000008ul
+#define Error_USB_NO_IR_PKT						0x03000009ul
+#define Error_USB_INVALID_IR_PKT				0x0300000Aul
+#define Error_USB_INVALID_DATA_LEN				0x0300000Bul
+#define Error_USB_EP4_READFILE_FAIL				0x0300000Cul
+#define Error_USB_EP$_INVALID_READ_SIZE			0x0300000Dul
+#define Error_USB_BOOT_INVALID_PKT_TYPE			0x0300000Eul
+#define Error_USB_BOOT_BAD_CONFIG_HEADER		0x0300000Ful
+#define Error_USB_BOOT_BAD_CONFIG_SIZE			0x03000010ul
+#define Error_USB_BOOT_BAD_CONFIG_SN			0x03000011ul
+#define Error_USB_BOOT_BAD_CONFIG_SUBTYPE		0x03000012ul
+#define Error_USB_BOOT_BAD_CONFIG_VALUE			0x03000013ul
+#define Error_USB_BOOT_BAD_CONFIG_CHKSUM		0x03000014ul
+#define Error_USB_BOOT_BAD_CONFIRM_HEADER		0x03000015ul
+#define Error_USB_BOOT_BAD_CONFIRM_SIZE			0x03000016ul
+#define Error_USB_BOOT_BAD_CONFIRM_SN			0x03000017ul
+#define Error_USB_BOOT_BAD_CONFIRM_SUBTYPE		0x03000018ul
+#define Error_USB_BOOT_BAD_CONFIRM_VALUE		0x03000019ul
+#define Error_USB_BOOT_BAD_CONFIRM_CHKSUM		0x03000020ul
+#define Error_USB_BOOT_BAD_BOOT_HEADER			0x03000021ul
+#define Error_USB_BOOT_BAD_BOOT_SIZE			0x03000022ul
+#define Error_USB_BOOT_BAD_BOOT_SN				0x03000023ul
+#define Error_USB_BOOT_BAD_BOOT_PATTERN_01		0x03000024ul
+#define Error_USB_BOOT_BAD_BOOT_PATTERN_10		0x03000025ul
+#define Error_USB_BOOT_BAD_BOOT_CHKSUM			0x03000026ul
+#define Error_USB_INVALID_BOOT_PKT_TYPE			0x03000027ul
+#define Error_USB_BOOT_BAD_CONFIG_VAlUE			0x03000028ul
+#define Error_USB_COINITIALIZEEX_FAIL			0x03000029ul
+#define Error_USB_COCREATEINSTANCE_FAIL			0x0300003Aul
+#define Error_USB_COCREATCLSEENUMERATOR_FAIL    0x0300002Bul
+#define Error_USB_QUERY_INTERFACE_FAIL			0x0300002Cul
+#define Error_USB_PKSCTRL_NULL					0x0300002Dul
+#define Error_USB_INVALID_REGMODE				0x0300002Eul
+#define Error_USB_INVALID_REG_COUNT				0x0300002Ful
+#define Error_USB_INVALID_HANDLE				0x03000100ul
+#define Error_USB_WRITE_FAIL					0x03000200ul
+#define Error_USB_UNEXPECTED_WRITE_LEN			0x03000300ul
+#define Error_USB_READ_FAIL						0x03000400ul
+
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_firmware.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_firmware.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_firmware.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_firmware.h	2012-02-27 00:02:36.328915017 +0100
@@ -0,0 +1,10867 @@
+// This file is automatically generated. Do not edit.
+
+#ifndef __FIRMWARE_H__
+
+#define __FIRMWARE_H__
+
+
+/* moved to a867_ofdm.h
+
+#define DVB_LL_VERSION1 10
+
+#define DVB_LL_VERSION2 10
+
+#define DVB_LL_VERSION3 3
+
+#define DVB_LL_VERSION4 0
+
+
+
+#define DVB_OFDM_VERSION1 4
+
+#define DVB_OFDM_VERSION2 21
+
+#define DVB_OFDM_VERSION3 6
+
+#define DVB_OFDM_VERSION4 251
+*/
+
+
+#include "a867_type.h"
+
+
+
+
+
+#define Firmware_CODELENGTH				0x0000A4D6
+
+#define Firmware_SEGMENTLENGTH			0x00000004
+
+#define Firmware_PARTITIONLENGTH		0x00000001
+
+
+
+
+
+static Byte Firmware_codes[] = {
+
+	0x01,0x41,0x00,0x00,0x03,0xFB,0xBE,0x02,
+
+	0x54,0x30,
+
+	0x01,0x47,0x00,0x3A,0x07,0xF7,0x7E,0x32,
+
+	0x32,0xA9,0x07,0x89,0x0E,0xE5,0x0E,0x24,
+
+	0x04,0x90,0xF7,0x00,0xF0,0x90,0xF7,0x03,
+
+	0xE0,0x90,0xF7,0x01,0xF0,0xA3,0xE4,0xF0,
+
+	0xE5,0x0E,0x24,0x05,0x90,0xF4,0x12,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0xE0,0x54,0xFC,0xF0,
+
+	0x75,0x0C,0xF7,0x75,0x0D,0x03,0x90,0xF7,
+
+	0x01,0xE0,0xF5,0x08,0xA3,0xE0,0xF5,0x09,
+
+	0xE5,0x0E,0x60,0x57,0xB4,0x01,0x1A,0x8D,
+
+	0x82,0x8C,0x83,0xE0,0x85,0x0D,0x82,0x85,
+
+	0x0C,0x83,0xF0,0xE0,0xFE,0xE4,0x25,0x09,
+
+	0xF5,0x09,0xEE,0x35,0x08,0xF5,0x08,0x80,
+
+	0x3A,0x8D,0x82,0x8C,0x83,0xE0,0xF5,0x0A,
+
+	0xA3,0xE0,0xF5,0x0B,0x85,0x0D,0x82,0x85,
+
+	0x0C,0x83,0xE5,0x0A,0xF0,0xA3,0xE5,0x0B,
+
+	0xF0,0x25,0x09,0xF5,0x09,0xE5,0x0A,0x35,
+
+	0x08,0xF5,0x08,0x74,0x02,0x2D,0xFD,0xE4,
+
+	0x3C,0xFC,0x74,0x02,0x25,0x0D,0xF5,0x0D,
+
+	0xE4,0x35,0x0C,0xF5,0x0C,0x15,0x0E,0x15,
+
+	0x0E,0x80,0xA5,0xE5,0x09,0xF4,0xFF,0xE5,
+
+	0x08,0xF4,0xFE,0x74,0x03,0x29,0xF5,0x82,
+
+	0xE4,0x34,0xF7,0xF5,0x83,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0x22,0x90,0x41,0x82,0xEE,0xF0,
+
+	0xA3,0xEF,0xF0,0xE4,0xA3,0xF0,0xA3,0xF0,
+
+	0xFC,0xEC,0xC3,0x9D,0x50,0x43,0xEC,0x30,
+
+	0xE0,0x1F,0x90,0x41,0x82,0xE0,0xFE,0xA3,
+
+	0xE0,0x2C,0xF5,0x82,0xE4,0x3E,0xF5,0x83,
+
+	0xE0,0xFF,0x90,0x41,0x85,0xE0,0x2F,0xF0,
+
+	0x90,0x41,0x84,0xE0,0x34,0x00,0xF0,0x80,
+
+	0x1D,0x90,0x41,0x82,0xE0,0xFE,0xA3,0xE0,
+
+	0x2C,0xF5,0x82,0xE4,0x3E,0xF5,0x83,0xE0,
+
+	0xFE,0x90,0x41,0x85,0xE0,0x24,0x00,0xF0,
+
+	0x90,0x41,0x84,0xE0,0x3E,0xF0,0x0C,0x80,
+
+	0xB8,0x90,0x41,0x84,0xE0,0xFE,0xA3,0xE0,
+
+	0xF4,0xFF,0xEE,0xF4,0xFE,0x22,0xC0,0xE0,
+
+	0xC0,0xF0,0xC0,0x83,0xC0,0x82,0xC0,0x85,
+
+	0xC0,0x84,0xC0,0x86,0x75,0x86,0x00,0xC0,
+
+	0xD0,0x75,0xD0,0x00,0xC0,0x00,0xC0,0x01,
+
+	0xC0,0x02,0xC0,0x03,0xC0,0x04,0xC0,0x05,
+
+	0xC0,0x06,0xC0,0x07,0x90,0x41,0xAD,0x74,
+
+	0xFE,0xF0,0x90,0xF4,0x05,0xE0,0x20,0xE5,
+
+	0x03,0x02,0x52,0xAD,0x75,0x12,0x00,0x90,
+
+	0xF6,0xB4,0xE0,0x30,0xE0,0x1F,0x90,0xF4,
+
+	0x09,0xE0,0xF4,0x60,0x18,0x90,0xF7,0x00,
+
+	0xE0,0x04,0xFF,0x90,0xF4,0x09,0xE0,0xC3,
+
+	0x9F,0x50,0x0A,0x90,0xF4,0x05,0xE0,0x44,
+
+	0x20,0xF0,0x02,0x52,0xAD,0x90,0xF6,0xB4,
+
+	0xE0,0x30,0xE0,0x05,0x90,0xF4,0x09,0xE4,
+
+	0xF0,0x90,0xF6,0xB4,0xE0,0x20,0xE0,0x46,
+
+	0x90,0xF6,0x6F,0xE0,0x20,0xE0,0x3F,0x90,
+
+	0xF6,0x04,0xE0,0x54,0xF0,0x60,0x37,0x90,
+
+	0xF6,0x03,0xE0,0x04,0xF0,0x90,0xF4,0x05,
+
+	0x74,0x20,0xF0,0x90,0x41,0x8C,0xE0,0x04,
+
+	0xF0,0x70,0x06,0x90,0x41,0x8B,0xE0,0x04,
+
+	0xF0,0x90,0xF6,0x04,0xE0,0x30,0xE1,0xF9,
+
+	0x90,0xF6,0x04,0xE4,0xF0,0xE0,0x44,0x01,
+
+	0xF0,0xE0,0x54,0xFE,0xF0,0x90,0xF6,0x03,
+
+	0xE0,0x14,0xF0,0x02,0x52,0xAD,0x90,0xF7,
+
+	0x01,0xE0,0x54,0x70,0x70,0x03,0x02,0x4A,
+
+	0x6A,0xE0,0x54,0x0F,0xFE,0xA3,0xE0,0xC3,
+
+	0x94,0x06,0xEE,0x94,0x00,0x40,0x03,0x02,
+
+	0x4A,0x61,0x90,0xF1,0x03,0xE0,0x90,0x41,
+
+	0x91,0xF0,0x90,0xF6,0xB5,0xE0,0x54,0xF7,
+
+	0x44,0x08,0xF0,0xE0,0x54,0xF7,0xF0,0x90,
+
+	0x41,0x91,0xE0,0x90,0xF1,0x03,0xF0,0x90,
+
+	0x41,0x8E,0xE0,0x90,0xF0,0x00,0xF0,0x90,
+
+	0x44,0xB8,0xE0,0x60,0x09,0x90,0xF1,0x04,
+
+	0xE0,0x54,0xF3,0xF0,0x80,0x09,0x90,0xF1,
+
+	0x04,0xE0,0x54,0xF3,0x44,0x04,0xF0,0x90,
+
+	0xF7,0x00,0xE0,0x04,0xF5,0x11,0x90,0xF1,
+
+	0x01,0xF0,0x90,0xF7,0x01,0xE0,0x54,0x70,
+
+	0xFF,0x74,0xFE,0x25,0x11,0xF5,0x82,0xE4,
+
+	0x34,0xF6,0xF5,0x83,0xE0,0x2F,0xF0,0x90,
+
+	0xF7,0x01,0xE0,0x54,0x8F,0xF0,0xE5,0x11,
+
+	0x60,0x1E,0x15,0x11,0xE4,0x25,0x11,0xF5,
+
+	0x82,0xE4,0x34,0xF7,0xF5,0x83,0xE0,0xFF,
+
+	0xE5,0x11,0x24,0x01,0xFD,0xE4,0x34,0xF0,
+
+	0x8D,0x82,0xF5,0x83,0xEF,0xF0,0x80,0xDE,
+
+	0x90,0xF1,0x00,0xE0,0x54,0xFE,0xF0,0x90,
+
+	0xF1,0x02,0x74,0x01,0xF0,0x90,0xF7,0x02,
+
+	0xE0,0x30,0xE0,0x05,0x75,0x11,0x05,0x80,
+
+	0x08,0x90,0xF7,0x04,0xE0,0x24,0x05,0xF5,
+
+	0x11,0x90,0xF1,0x02,0xE0,0x30,0xE2,0x0F,
+
+	0x90,0xF4,0x05,0x74,0x20,0xF0,0x90,0xF1,
+
+	0x02,0x74,0x02,0xF0,0x02,0x52,0xAD,0x90,
+
+	0xF1,0x02,0xE0,0x30,0xE1,0xE3,0x74,0x02,
+
+	0xF0,0x90,0xF4,0x12,0xE5,0x11,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0xE0,0x54,0xFC,0xF0,0x90,
+
+	0xF0,0x00,0xE0,0x04,0xF0,0x90,0xF1,0x01,
+
+	0xE5,0x11,0xF0,0x90,0xF1,0x00,0xE0,0x44,
+
+	0x01,0xF0,0x90,0xF1,0x02,0x74,0x01,0xF0,
+
+	0x75,0x0F,0x00,0x75,0x10,0x00,0x90,0xF1,
+
+	0x02,0xE0,0x20,0xE3,0x2A,0xE0,0x30,0xE2,
+
+	0xF5,0x74,0x02,0xF0,0xAE,0x0F,0xAF,0x10,
+
+	0xBE,0xFF,0x0C,0xBF,0xFF,0x09,0x90,0xF4,
+
+	0x05,0x74,0x20,0xF0,0x02,0x52,0xAD,0x90,
+
+	0xF1,0x02,0x74,0x01,0xF0,0x05,0x10,0xE5,
+
+	0x10,0x70,0x02,0x05,0x0F,0x80,0xCF,0xE5,
+
+	0x11,0x60,0x1D,0x15,0x11,0xE4,0x25,0x11,
+
+	0xFF,0xE4,0x34,0xF0,0x8F,0x82,0xF5,0x83,
+
+	0xE0,0xFF,0xE4,0x25,0x11,0xF5,0x82,0xE4,
+
+	0x34,0xF7,0xF5,0x83,0xEF,0xF0,0x80,0xDF,
+
+	0x90,0xF4,0x05,0x74,0x20,0xF0,0x90,0x44,
+
+	0xB8,0xE0,0x60,0x1C,0x7E,0xDE,0x7F,0x40,
+
+	0x90,0xF7,0x00,0xE0,0x04,0xFB,0x7D,0x00,
+
+	0x7C,0xF7,0x12,0x56,0x9C,0x90,0xF7,0x00,
+
+	0xE0,0x04,0x90,0xDD,0x86,0xF0,0x80,0x07,
+
+	0x90,0xF4,0x11,0xE0,0x54,0xFC,0xF0,0x90,
+
+	0xF1,0x02,0x74,0x08,0xF0,0x02,0x52,0xAD,
+
+	0x90,0xF4,0x05,0x74,0x20,0xF0,0x02,0x52,
+
+	0xAD,0x90,0xF7,0x03,0xE0,0x90,0x41,0xB2,
+
+	0xF0,0x90,0xF7,0x00,0xE0,0x64,0x03,0x70,
+
+	0x2C,0xA3,0xE0,0x64,0x02,0x70,0x26,0x90,
+
+	0xF7,0x00,0x04,0xF0,0x90,0xF7,0x02,0xE0,
+
+	0xFE,0xA3,0xE0,0xF5,0x82,0x8E,0x83,0xE0,
+
+	0x90,0xF7,0x01,0xF0,0x90,0xF4,0x12,0x74,
+
+	0x02,0xF0,0xA3,0xE4,0xF0,0xA3,0xE0,0x54,
+
+	0xFC,0xF0,0x02,0x51,0xE1,0x90,0xF7,0x00,
+
+	0xE0,0xB4,0x04,0x20,0xA3,0xE0,0xB4,0x03,
+
+	0x1B,0x90,0xF7,0x04,0xE0,0xFF,0x90,0xF7,
+
+	0x02,0xE0,0xFC,0xA3,0xE0,0xF5,0x82,0x8C,
+
+	0x83,0xEF,0xF0,0x90,0xF4,0x05,0x74,0x20,
+
+	0xF0,0x02,0x52,0xAD,0x90,0xF7,0x00,0xE0,
+
+	0xB4,0x04,0x0D,0xA3,0xE0,0xB4,0x04,0x08,
+
+	0x90,0x41,0xAE,0x74,0x01,0xF0,0x80,0x12,
+
+	0x90,0xF7,0x00,0xE0,0x64,0x05,0x70,0x77,
+
+	0xA3,0xE0,0x64,0x05,0x70,0x71,0x90,0x41,
+
+	0xAE,0xF0,0x90,0xF7,0x02,0xE0,0xFD,0x90,
+
+	0x41,0xAE,0xE0,0xFB,0x90,0xF7,0x03,0xE0,
+
+	0x90,0x41,0xC4,0xF0,0x90,0xF7,0x04,0xE0,
+
+	0xFF,0xA3,0xE0,0x90,0x41,0xC5,0xCF,0xF0,
+
+	0xA3,0xEF,0xF0,0xEB,0x60,0x06,0x7E,0xF7,
+
+	0x7F,0x01,0x80,0x04,0x7E,0xF7,0x7F,0x06,
+
+	0x90,0x41,0xC7,0xEE,0xF0,0xA3,0xEF,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x04,0xF0,0x7F,0x02,
+
+	0x12,0x57,0x94,0x90,0x41,0xB0,0xEF,0xF0,
+
+	0x90,0x41,0xAE,0xE0,0x70,0x09,0x90,0xF4,
+
+	0x05,0x74,0x20,0xF0,0x02,0x52,0xAD,0x90,
+
+	0xF7,0x00,0x74,0x01,0xF0,0x90,0x41,0xB0,
+
+	0xE0,0x70,0x03,0x02,0x4A,0x95,0x90,0xF7,
+
+	0x01,0x74,0xFF,0xF0,0x02,0x4A,0x95,0x90,
+
+	0x41,0xAD,0x74,0xFF,0xF0,0x90,0x41,0xB8,
+
+	0x74,0x01,0xF0,0x90,0xF7,0x01,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0xEE,0x60,0x03,0x02,0x51,
+
+	0xDE,0xEF,0x12,0x7E,0xB5,0x4E,0x42,0x00,
+
+	0x4B,0xB2,0x01,0x4C,0xE8,0x02,0x4C,0xE1,
+
+	0x03,0x4D,0x9B,0x04,0x4D,0x94,0x05,0x4E,
+
+	0x5A,0x06,0x4C,0x6A,0x18,0x4C,0x0C,0x22,
+
+	0x4F,0xE3,0x23,0x51,0xD3,0x25,0x50,0xA2,
+
+	0x29,0x50,0x18,0x2A,0x50,0x2F,0x2B,0x4E,
+
+	0x5A,0x30,0x4E,0xE2,0x32,0x00,0x00,0x51,
+
+	0xDE,0x90,0xF6,0xB4,0xE0,0x54,0x08,0xF5,
+
+	0x12,0x60,0x04,0xE0,0x54,0xF7,0xF0,0x90,
+
+	0xF7,0x04,0xE0,0xF5,0x11,0x90,0xF7,0x08,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x80,0x00,0xE5,
+
+	0x11,0x60,0x27,0x15,0x11,0x74,0x0A,0x25,
+
+	0x11,0xF5,0x82,0xE4,0x34,0xF7,0xF5,0x83,
+
+	0xE0,0xFF,0xE5,0x11,0xFD,0x7C,0x00,0x90,
+
+	0xF7,0x08,0xE0,0xFA,0xA3,0xE0,0x2D,0xFD,
+
+	0xEC,0x3A,0x8D,0x82,0xF5,0x83,0xEF,0xF0,
+
+	0x80,0xD5,0xE5,0x12,0x60,0x07,0x90,0xF6,
+
+	0xB4,0xE0,0x44,0x08,0xF0,0x75,0x12,0x00,
+
+	0x02,0x51,0xE1,0x90,0xF4,0x12,0x74,0x09,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xE0,0x54,0xFC,
+
+	0xF0,0x90,0xF7,0x00,0x74,0x08,0xF0,0x90,
+
+	0xF7,0x03,0xE0,0x90,0xF7,0x01,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x74,0x0A,0xF0,0xA3,0xF0,
+
+	0xA3,0x74,0x03,0xF0,0xA3,0xE4,0xF0,0x90,
+
+	0xF7,0x03,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0xF7,0x01,0xE0,0xFC,0xA3,0xE0,0x2F,0xFF,
+
+	0xEC,0x3E,0xFE,0x90,0xF7,0x05,0xE0,0xFC,
+
+	0xA3,0xE0,0x2F,0xFF,0xEC,0x3E,0xFE,0xEF,
+
+	0xF4,0xFF,0xEE,0xF4,0xA3,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x41,0xAD,0xE4,0xF0,0x02,0x51,
+
+	0xE1,0x90,0xF7,0x00,0x74,0x08,0xF0,0x90,
+
+	0xF7,0x03,0xE0,0x90,0xF7,0x01,0xF0,0x90,
+
+	0x44,0xDE,0xE0,0x60,0x40,0x90,0x44,0xDE,
+
+	0xE4,0xF0,0x90,0xF7,0x02,0xF0,0x90,0x44,
+
+	0xDD,0x04,0xF0,0x90,0x44,0xDF,0xE0,0xFF,
+
+	0x90,0x41,0x86,0xF0,0x90,0xDE,0x80,0xE0,
+
+	0x90,0xF7,0x03,0xF0,0x90,0xDE,0x81,0xE0,
+
+	0x90,0xF7,0x04,0xF0,0x90,0xDE,0x82,0xE0,
+
+	0x90,0xF7,0x05,0xF0,0x90,0xDE,0x83,0xE0,
+
+	0x90,0xF7,0x06,0xF0,0x90,0x41,0x86,0xE0,
+
+	0xB5,0x07,0xC2,0x80,0x06,0x90,0xF7,0x02,
+
+	0x74,0x01,0xF0,0x90,0xF7,0x00,0xE0,0x04,
+
+	0x90,0xF4,0x12,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0xE0,0x54,0xFC,0xF0,0x90,0x44,0xDD,0xE4,
+
+	0xF0,0x90,0x41,0xAD,0xF0,0x02,0x51,0xE1,
+
+	0x90,0x41,0xAE,0xE4,0xF0,0x80,0x06,0x90,
+
+	0x41,0xAE,0x74,0x01,0xF0,0x90,0x41,0xAF,
+
+	0x74,0x02,0xF0,0x90,0x41,0xAE,0xE0,0x60,
+
+	0x07,0x90,0xF7,0x04,0xE0,0xFF,0x80,0x02,
+
+	0x7F,0x00,0xEF,0x24,0x04,0x90,0x41,0xB1,
+
+	0xF0,0x90,0xF7,0x05,0xE0,0xB4,0x01,0x08,
+
+	0x90,0x41,0xDE,0xE0,0xFF,0xFD,0x80,0x06,
+
+	0x90,0xF7,0x05,0xE0,0xFF,0xFD,0x90,0x41,
+
+	0xAE,0xE0,0xFB,0x90,0xF7,0x06,0xE0,0x90,
+
+	0x41,0xC4,0xF0,0x90,0xF7,0x07,0xE0,0xFF,
+
+	0xA3,0xE0,0x90,0x41,0xC5,0xCF,0xF0,0xA3,
+
+	0xEF,0xF0,0xEB,0x60,0x06,0x7E,0xF7,0x7F,
+
+	0x03,0x80,0x04,0x7E,0xF7,0x7F,0x09,0x90,
+
+	0x41,0xC7,0xEE,0xF0,0xA3,0xEF,0xF0,0x90,
+
+	0xF7,0x04,0xE0,0xFF,0x90,0x41,0xC9,0xE4,
+
+	0xF0,0xA3,0xEF,0xF0,0x7F,0x02,0x12,0x57,
+
+	0x94,0x90,0x41,0xB0,0xEF,0xF0,0xA3,0xE0,
+
+	0xFF,0x90,0xF7,0x00,0xF0,0x90,0x41,0xB2,
+
+	0xE0,0x90,0xF7,0x01,0xF0,0x90,0x41,0xB0,
+
+	0xE0,0x90,0xF7,0x02,0xF0,0xEF,0x04,0x90,
+
+	0xF4,0x12,0xF0,0xA3,0xE4,0xF0,0xA3,0xE0,
+
+	0x54,0xFC,0xF0,0x90,0x41,0xAD,0xE4,0xF0,
+
+	0x02,0x51,0xE1,0x90,0x41,0xAE,0xE4,0xF0,
+
+	0x80,0x06,0x90,0x41,0xAE,0x74,0x01,0xF0,
+
+	0x90,0x44,0xB8,0xE0,0x60,0x04,0x7F,0x01,
+
+	0x80,0x02,0x7F,0x03,0x90,0x41,0xAF,0xEF,
+
+	0xF0,0x90,0x41,0xAE,0xE0,0xFB,0x60,0x07,
+
+	0x90,0xF7,0x04,0xE0,0xFF,0x80,0x02,0x7F,
+
+	0x00,0xEF,0x24,0x04,0x90,0x41,0xB1,0xF0,
+
+	0x90,0xF7,0x05,0xE0,0xB4,0x01,0x08,0x90,
+
+	0x41,0xDE,0xE0,0xFF,0xFD,0x80,0x06,0x90,
+
+	0xF7,0x05,0xE0,0xFF,0xFD,0x90,0xF7,0x08,
+
+	0xE0,0x90,0x44,0xC9,0xF0,0xEB,0x60,0x06,
+
+	0x7E,0xF7,0x7F,0x03,0x80,0x04,0x7E,0xF7,
+
+	0x7F,0x09,0x90,0x44,0xCA,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0x90,0xF7,0x04,0xE0,0xFF,0x90,
+
+	0x44,0xCC,0xE4,0xF0,0xA3,0xEF,0xF0,0x90,
+
+	0x41,0xAF,0xE0,0xFF,0x12,0x6A,0xEA,0x90,
+
+	0x41,0xB0,0xEF,0xF0,0xA3,0xE0,0xFF,0x90,
+
+	0xF7,0x00,0xF0,0x90,0x41,0xB2,0xE0,0x90,
+
+	0xF7,0x01,0xF0,0x90,0x41,0xB0,0xE0,0x90,
+
+	0xF7,0x02,0xF0,0xEF,0x04,0x90,0xF4,0x12,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xE0,0x54,0xFC,
+
+	0xF0,0x90,0x41,0xAD,0xE4,0xF0,0x02,0x51,
+
+	0xE1,0x90,0xF7,0x04,0xE0,0xFF,0x90,0xF7,
+
+	0x08,0xE0,0xFC,0xA3,0xE0,0xFD,0x12,0x47,
+
+	0x02,0x90,0x41,0xAD,0xE4,0xF0,0x02,0x51,
+
+	0xE1,0xC2,0x8C,0xC2,0x8D,0x75,0x8A,0x00,
+
+	0x75,0x8C,0x00,0xE5,0x89,0x54,0xF0,0x44,
+
+	0x01,0xF5,0x89,0xD2,0x8C,0x90,0x41,0x87,
+
+	0xE4,0xF0,0x90,0xF4,0x04,0xE0,0x54,0x04,
+
+	0xFF,0x13,0x13,0x54,0x3F,0x60,0x21,0xE0,
+
+	0x54,0xFB,0x44,0x04,0xF0,0xA3,0x74,0x20,
+
+	0xF0,0x90,0xF4,0x14,0xE0,0x54,0x7F,0xF0,
+
+	0x90,0xF4,0x11,0xE0,0x54,0xFC,0x44,0x02,
+
+	0xF0,0xC2,0x8C,0xC2,0x8D,0x02,0x52,0xAD,
+
+	0x30,0x8D,0xCF,0xC2,0x8C,0xC2,0x8D,0x90,
+
+	0x41,0x87,0xE0,0x04,0xF0,0xE0,0xD3,0x94,
+
+	0x01,0x40,0x2A,0x90,0xF4,0x14,0xE0,0x54,
+
+	0x7F,0x44,0x80,0xF0,0xE0,0x54,0xFC,0xF0,
+
+	0x90,0xF4,0x13,0x74,0x08,0xF0,0x90,0xF4,
+
+	0x12,0xE4,0xF0,0x90,0xF4,0x05,0x74,0x20,
+
+	0xF0,0x90,0xF4,0x11,0xE0,0x54,0xFC,0x44,
+
+	0x01,0xF0,0x02,0x52,0xAD,0xD2,0x8C,0x80,
+
+	0x91,0x90,0xF7,0x0A,0xE0,0xFF,0x90,0x41,
+
+	0xB8,0xF0,0x90,0x41,0x88,0xF0,0x90,0xF4,
+
+	0x14,0xE0,0x30,0xE7,0x1F,0x90,0xF7,0x04,
+
+	0xE0,0x54,0x03,0xFF,0x90,0xF4,0x14,0xE0,
+
+	0x54,0xFC,0x4F,0xF0,0x90,0xF7,0x05,0xE0,
+
+	0x90,0xF4,0x13,0xF0,0x90,0xF7,0x06,0xE0,
+
+	0x90,0xF4,0x12,0xF0,0x90,0xF4,0x05,0x74,
+
+	0x20,0xF0,0x90,0xF4,0x11,0xE0,0x54,0x03,
+
+	0x60,0x08,0x90,0x41,0x89,0xE0,0x64,0x01,
+
+	0x60,0x1B,0x90,0xF7,0x07,0xE0,0xB4,0xF0,
+
+	0x0B,0x90,0xF4,0x11,0xE0,0x54,0xFC,0x44,
+
+	0x02,0xF0,0x80,0x09,0x90,0xF4,0x11,0xE0,
+
+	0x54,0xFC,0x44,0x01,0xF0,0x90,0x41,0x89,
+
+	0xE4,0xF0,0x90,0x41,0x88,0xE0,0xB4,0x01,
+
+	0x0C,0x90,0xF4,0x04,0xE0,0x54,0xFB,0x44,
+
+	0x04,0xF0,0x02,0x52,0xAD,0x90,0xF4,0x05,
+
+	0xE0,0x20,0xE5,0x09,0x90,0xF4,0x15,0xE0,
+
+	0xC3,0x94,0x05,0x40,0xF0,0x90,0xF4,0x04,
+
+	0xE0,0x54,0xFB,0x44,0x04,0xF0,0xA3,0xE0,
+
+	0x30,0xE5,0x09,0x90,0x41,0x89,0x74,0x01,
+
+	0xF0,0x02,0x52,0xAD,0x90,0x41,0xB8,0xE0,
+
+	0x14,0xF0,0x70,0x03,0x02,0x52,0xAD,0x90,
+
+	0xF4,0x15,0xE0,0x70,0xFA,0xA3,0xE0,0x70,
+
+	0xF6,0xA3,0xE0,0x54,0x03,0x70,0xF0,0x90,
+
+	0xF4,0x04,0xE0,0x54,0x04,0xFF,0x13,0x13,
+
+	0x54,0x3F,0x60,0x0C,0x90,0x41,0x8A,0xE0,
+
+	0xC3,0x94,0xFF,0x50,0x03,0xE0,0x04,0xF0,
+
+	0x90,0xF4,0x05,0xE0,0x20,0xE5,0x0D,0x90,
+
+	0xF4,0x04,0xE0,0x54,0x04,0xFF,0x13,0x13,
+
+	0x54,0x3F,0x60,0xEC,0x90,0xF4,0x05,0xE0,
+
+	0x20,0xE5,0x03,0x02,0x4F,0x1B,0x90,0xF4,
+
+	0x04,0xE0,0x54,0xFB,0x44,0x04,0xF0,0x02,
+
+	0x52,0xAD,0xC2,0xAF,0x90,0xF6,0xB3,0xE0,
+
+	0x54,0xFE,0xF0,0x90,0xF6,0xDE,0xE0,0x54,
+
+	0xFE,0x44,0x01,0xF0,0x90,0xF6,0xDE,0xE0,
+
+	0x20,0xE0,0xF9,0x90,0x44,0xB8,0xE0,0x60,
+
+	0x07,0x90,0xDD,0x00,0xE0,0x54,0x7F,0xF0,
+
+	0x90,0xF4,0x05,0x74,0x20,0xF0,0x90,0xF6,
+
+	0x2F,0xE0,0x54,0xFE,0x44,0x01,0xF0,0x90,
+
+	0x41,0xAE,0x74,0x01,0xF0,0x90,0xF7,0x06,
+
+	0xE0,0x44,0x01,0xF0,0x90,0xF7,0x03,0xE0,
+
+	0x90,0xF7,0x01,0xF0,0x80,0x1D,0x90,0x41,
+
+	0xAE,0xE4,0xF0,0x90,0xF7,0x03,0xE0,0x90,
+
+	0xF7,0x01,0xF0,0x7E,0xF0,0x7F,0x01,0x90,
+
+	0xF7,0x04,0xE0,0xFB,0x7D,0x07,0x7C,0xF7,
+
+	0x12,0x56,0x9C,0x90,0xF7,0x04,0xE0,0xF5,
+
+	0x11,0xA3,0xE0,0xFF,0xA3,0xE0,0xFD,0x90,
+
+	0x41,0xBD,0x74,0x01,0xF0,0xAB,0x11,0x12,
+
+	0x54,0xB6,0x8F,0x12,0x90,0xF7,0x02,0xEF,
+
+	0xF0,0x90,0x41,0xAE,0xE0,0x64,0x01,0x60,
+
+	0x03,0x02,0x51,0xE1,0x7C,0xF0,0x7D,0x00,
+
+	0x90,0xF7,0x04,0xE0,0xFB,0x7F,0x03,0x7E,
+
+	0xF7,0x12,0x56,0x9C,0x90,0x41,0xAD,0xE4,
+
+	0xF0,0xE5,0x11,0x24,0x04,0x90,0xF7,0x00,
+
+	0xF0,0xE0,0x90,0xF4,0x12,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0xE0,0x54,0xFC,0xF0,0x02,0x51,
+
+	0xE1,0x90,0x41,0xB6,0x74,0xF7,0xF0,0xA3,
+
+	0x74,0x08,0xF0,0x90,0xF7,0x04,0xE0,0x24,
+
+	0xFE,0x60,0x10,0x14,0x60,0x7F,0x24,0x02,
+
+	0x60,0x03,0x02,0x51,0xC8,0x75,0x12,0x01,
+
+	0x02,0x51,0xC8,0x90,0xF7,0x07,0xE0,0x75,
+
+	0xF0,0x02,0xA4,0x24,0x08,0xFE,0xE5,0xF0,
+
+	0x34,0xF7,0x90,0x41,0xB4,0xF0,0xA3,0xCE,
+
+	0xF0,0x90,0x41,0xB3,0xE4,0xF0,0x90,0xF7,
+
+	0x07,0xE0,0xFF,0x90,0x41,0xB3,0xE0,0xC3,
+
+	0x9F,0x50,0x44,0xA3,0xE0,0xFE,0xA3,0xE0,
+
+	0xF5,0x82,0x8E,0x83,0xE0,0xFF,0x90,0x41,
+
+	0xB6,0xE0,0xFC,0xA3,0xE0,0xF5,0x82,0x8C,
+
+	0x83,0xE0,0xFC,0xA3,0xE0,0xF5,0x82,0x8C,
+
+	0x83,0xEF,0xF0,0x90,0x41,0xB3,0xE0,0x04,
+
+	0xF0,0x90,0x41,0xB5,0xE0,0x04,0xF0,0x70,
+
+	0x06,0x90,0x41,0xB4,0xE0,0x04,0xF0,0x90,
+
+	0x41,0xB7,0xE0,0x24,0x02,0xF0,0x90,0x41,
+
+	0xB6,0xE0,0x34,0x00,0xF0,0x80,0xAF,0x75,
+
+	0x12,0x00,0x02,0x51,0xC8,0x90,0xF7,0x07,
+
+	0xE0,0x75,0xF0,0x03,0xA4,0x24,0x08,0xFE,
+
+	0xE5,0xF0,0x34,0xF7,0x90,0x41,0xB4,0xF0,
+
+	0xA3,0xCE,0xF0,0x90,0xF7,0x07,0xE0,0x75,
+
+	0xF0,0x03,0xA4,0x24,0x08,0x90,0xF6,0x20,
+
+	0xF0,0x90,0x41,0xB3,0xE4,0xF0,0x90,0xF7,
+
+	0x07,0xE0,0xFF,0x90,0x41,0xB3,0xE0,0xC3,
+
+	0x9F,0x50,0x59,0x90,0x41,0xB6,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x24,0x02,0xFD,0xE4,0x3E,
+
+	0x8D,0x82,0xF5,0x83,0xE0,0xFD,0x90,0x41,
+
+	0xB9,0xF0,0xFB,0x8F,0x82,0x8E,0x83,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x41,0xB4,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0x12,0x56,0x9C,0x90,
+
+	0x41,0xB9,0xE0,0xFF,0x90,0x41,0xB5,0xE0,
+
+	0x2F,0xF0,0x90,0x41,0xB4,0xE0,0x34,0x00,
+
+	0xF0,0x90,0x41,0xB3,0xE0,0x04,0xF0,0x90,
+
+	0x41,0xB6,0xE0,0xFE,0xA3,0xE0,0x24,0x03,
+
+	0xFF,0xE4,0x3E,0x90,0x41,0xB6,0xF0,0xA3,
+
+	0xEF,0xF0,0x80,0x9A,0x75,0x12,0x00,0x90,
+
+	0x41,0xAD,0x74,0xFF,0xF0,0x75,0x12,0x00,
+
+	0x80,0x0E,0x90,0x41,0xAD,0x74,0xFF,0xF0,
+
+	0x75,0x12,0xFA,0x80,0x03,0x75,0x12,0x02,
+
+	0x90,0x41,0xAD,0xE0,0xFF,0xF4,0x60,0x5E,
+
+	0xEF,0x64,0xFE,0x60,0x59,0x90,0xF7,0x00,
+
+	0xE0,0x24,0xFE,0xFD,0x7F,0x01,0x7E,0xF7,
+
+	0x12,0x47,0xAC,0x90,0xF7,0x00,0xE0,0x24,
+
+	0xFF,0xF5,0x82,0xE4,0x34,0xF6,0xF5,0x83,
+
+	0xEE,0xF0,0xA3,0xEF,0xF0,0x90,0xF4,0x05,
+
+	0x74,0x20,0xF0,0x90,0x44,0xB8,0xE0,0x60,
+
+	0x1C,0x7E,0xDE,0x7F,0x40,0x90,0xF7,0x00,
+
+	0xE0,0x04,0xFB,0x7D,0x00,0x7C,0xF7,0x12,
+
+	0x56,0x9C,0x90,0xF7,0x00,0xE0,0x04,0x90,
+
+	0xDD,0x86,0xF0,0x80,0x77,0x90,0x41,0xAD,
+
+	0xE0,0x54,0x03,0xFF,0x90,0xF4,0x11,0xE0,
+
+	0x54,0xFC,0x4F,0xF0,0x80,0x66,0x90,0x41,
+
+	0xAD,0xE0,0xF4,0x70,0x30,0x90,0xF4,0x12,
+
+	0x74,0x05,0xF0,0xA3,0xE4,0xF0,0xA3,0xE0,
+
+	0x54,0xFC,0xF0,0x90,0xF7,0x00,0x74,0x04,
+
+	0xF0,0x90,0xF7,0x03,0xE0,0x90,0xF7,0x01,
+
+	0xF0,0xA3,0xE5,0x12,0xF0,0x90,0xF7,0x01,
+
+	0xE0,0xFE,0xA3,0xE0,0xF4,0xFF,0xEE,0xF4,
+
+	0xA3,0xF0,0xA3,0xEF,0xF0,0x90,0xF4,0x05,
+
+	0x74,0x20,0xF0,0x90,0x44,0xB8,0xE0,0x60,
+
+	0x1C,0x7E,0xDE,0x7F,0x40,0x90,0xF7,0x00,
+
+	0xE0,0x04,0xFB,0x7D,0x00,0x7C,0xF7,0x12,
+
+	0x56,0x9C,0x90,0xF7,0x00,0xE0,0x04,0x90,
+
+	0xDD,0x86,0xF0,0x80,0x07,0x90,0xF4,0x11,
+
+	0xE0,0x54,0xFC,0xF0,0xD0,0x07,0xD0,0x06,
+
+	0xD0,0x05,0xD0,0x04,0xD0,0x03,0xD0,0x02,
+
+	0xD0,0x01,0xD0,0x00,0xD0,0xD0,0xD0,0x86,
+
+	0xD0,0x84,0xD0,0x85,0xD0,0x82,0xD0,0x83,
+
+	0xD0,0xF0,0xD0,0xE0,0x32,0x32,0x32,0x32,
+
+	0x32,0x32,0x90,0xF6,0x13,0xE0,0x30,0xE0,
+
+	0x03,0x7F,0x03,0x22,0x90,0xF6,0xB4,0xE0,
+
+	0x30,0xE0,0x03,0x7F,0x00,0x22,0x90,0xF6,
+
+	0x6F,0xE0,0x30,0xE0,0x03,0x7F,0x02,0x22,
+
+	0x7F,0x01,0x22,0x90,0x41,0x7F,0xE0,0x90,
+
+	0x41,0x8E,0xF0,0xE0,0x54,0xF9,0xFF,0xBF,
+
+	0x38,0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,
+
+	0xEF,0x54,0x01,0xFF,0x90,0xD8,0x1A,0xE0,
+
+	0x54,0xFE,0x4F,0xF0,0x90,0xF6,0x41,0xE0,
+
+	0xB4,0x22,0x12,0x90,0xD8,0xD1,0xE0,0x54,
+
+	0xFE,0x44,0x01,0xF0,0x90,0xD8,0xD0,0xE0,
+
+	0x54,0xFE,0x44,0x01,0xF0,0x90,0xD8,0x30,
+
+	0xE0,0x54,0xFE,0x44,0x01,0xF0,0xA3,0xE0,
+
+	0x54,0xFE,0xF0,0xA3,0xE0,0x54,0xFE,0xF0,
+
+	0x90,0xD8,0x29,0xE0,0x54,0xFE,0xF0,0x90,
+
+	0xF6,0xB3,0xE0,0x54,0xFE,0x44,0x01,0xF0,
+
+	0x90,0xF6,0x32,0x74,0xFF,0xF0,0xA3,0xF0,
+
+	0x90,0xF6,0x31,0xE0,0x54,0xFE,0x44,0x01,
+
+	0xF0,0x90,0xF6,0x13,0xE0,0x54,0x01,0x90,
+
+	0x44,0xB8,0xF0,0x12,0x7C,0x41,0x12,0x52,
+
+	0xD3,0x90,0x41,0x90,0xEF,0xF0,0x90,0xF6,
+
+	0xA0,0x74,0x04,0xF0,0x90,0x41,0x90,0xE0,
+
+	0x90,0xF6,0xA1,0xF0,0x90,0xF6,0xDE,0xE0,
+
+	0x54,0xFE,0x44,0x01,0xF0,0x90,0xF6,0xDE,
+
+	0xE0,0x20,0xE0,0xF9,0x90,0xDF,0x82,0xE0,
+
+	0x44,0x20,0xF0,0x90,0xDD,0x17,0xE0,0x54,
+
+	0xFE,0xF0,0xC2,0xDC,0xD2,0xBC,0x12,0x56,
+
+	0xD8,0xD2,0xE9,0x12,0x78,0x4B,0x12,0x5A,
+
+	0x72,0x90,0xF4,0x18,0xE4,0xF0,0xA3,0xE0,
+
+	0x54,0xF0,0x44,0x08,0xF0,0x90,0xF4,0x1E,
+
+	0xE0,0x54,0xEF,0x44,0x10,0xF0,0xC2,0xB8,
+
+	0xC2,0xBA,0xD2,0xAF,0xD2,0xA8,0xD2,0xAA,
+
+	0x90,0xDF,0x82,0xE0,0x30,0xE0,0x1A,0xA2,
+
+	0xAF,0xE4,0x33,0x90,0x41,0x8D,0xF0,0xC2,
+
+	0xAF,0x90,0xDF,0x82,0x74,0x20,0xF0,0xE4,
+
+	0xF0,0x90,0x41,0x8D,0xE0,0x24,0xFF,0x92,
+
+	0xAF,0x90,0x41,0x81,0xE0,0xFF,0x90,0x43,
+
+	0x43,0xE0,0x6F,0x60,0x1D,0xA2,0xAF,0xE4,
+
+	0x33,0x90,0x41,0x8D,0xF0,0xC2,0xAF,0x90,
+
+	0x44,0xDE,0xE0,0x70,0x05,0x90,0x43,0x43,
+
+	0xEF,0xF0,0x90,0x41,0x8D,0xE0,0x24,0xFF,
+
+	0x92,0xAF,0x12,0x58,0xDB,0x90,0x41,0x8F,
+
+	0xE0,0xB4,0x07,0x05,0x12,0x5A,0x0B,0x80,
+
+	0xA7,0x12,0x59,0x73,0x80,0xA2,0x22,0x75,
+
+	0x81,0x18,0x02,0x54,0x71,0x02,0x52,0xF4,
+
+	0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+
+	0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+
+	0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+
+	0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+
+	0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+
+	0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+
+	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+
+	0x90,0x64,0x98,0xE4,0x7E,0x01,0x93,0x60,
+
+	0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+
+	0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+
+	0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+
+	0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+
+	0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+
+	0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+
+	0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+
+	0xE9,0xDE,0xE7,0x80,0xBE,0x90,0x41,0xBA,
+
+	0xEF,0xF0,0xA3,0xED,0xF0,0xA3,0xEB,0xF0,
+
+	0x90,0x41,0x92,0xE0,0xB4,0x01,0x2E,0x90,
+
+	0x41,0xBC,0xE0,0x24,0x01,0xFF,0xE4,0x33,
+
+	0xFE,0xE4,0xFC,0xFD,0x7B,0xFB,0x7A,0x04,
+
+	0xF9,0xF8,0x12,0x7D,0x98,0xE4,0x7B,0x04,
+
+	0xFA,0xF9,0xF8,0x12,0x7E,0x23,0xEF,0x24,
+
+	0x03,0xFF,0xE4,0x3E,0xFE,0xE4,0x3D,0xFD,
+
+	0xE4,0x3C,0xFC,0x80,0x3F,0x90,0x41,0xBC,
+
+	0xE0,0x24,0x01,0xFF,0xE4,0x33,0xFE,0xE4,
+
+	0xFC,0xFD,0x7B,0x05,0xFA,0xF9,0xF8,0x12,
+
+	0x7D,0x98,0xA8,0x04,0xA9,0x05,0xAA,0x06,
+
+	0xAB,0x07,0x90,0xF1,0x03,0xE0,0xFF,0xE4,
+
+	0xFC,0xFD,0xFE,0x12,0x7D,0x98,0xE4,0x7B,
+
+	0x04,0xFA,0xF9,0xF8,0x12,0x7E,0x23,0xEF,
+
+	0x24,0x03,0xFF,0xE4,0x3E,0xFE,0xE4,0x3D,
+
+	0xFD,0xE4,0x3C,0xFC,0x90,0x41,0xBF,0xEE,
+
+	0xF0,0xA3,0xEF,0xF0,0x90,0x41,0xBB,0xE0,
+
+	0x90,0xF0,0x00,0xF0,0x90,0x41,0x92,0xE0,
+
+	0xB4,0x01,0x27,0x90,0x41,0x98,0xE0,0xFF,
+
+	0x90,0x41,0x97,0xE0,0x2F,0xFF,0xE4,0x33,
+
+	0xFE,0xC3,0xEF,0x94,0x0A,0xEE,0x64,0x80,
+
+	0x94,0x80,0x50,0x05,0x12,0x7C,0x0E,0x80,
+
+	0x09,0x90,0x41,0xBE,0x74,0x05,0xF0,0x02,
+
+	0x56,0x8E,0x90,0xF1,0x03,0xE0,0x90,0x41,
+
+	0x91,0xF0,0x90,0xF6,0xB5,0xE0,0x54,0xF7,
+
+	0x44,0x08,0xF0,0xE0,0x54,0xF7,0xF0,0x90,
+
+	0x41,0x91,0xE0,0x90,0xF1,0x03,0xF0,0x90,
+
+	0x41,0xBA,0xE0,0xFF,0xB4,0x01,0x09,0x90,
+
+	0xF1,0x04,0xE0,0x54,0xF3,0xF0,0x80,0x18,
+
+	0xEF,0xB4,0x02,0x0B,0x90,0xF1,0x04,0xE0,
+
+	0x54,0xF3,0x44,0x08,0xF0,0x80,0x09,0x90,
+
+	0xF1,0x04,0xE0,0x54,0xF3,0x44,0x04,0xF0,
+
+	0x90,0x41,0xBB,0xE0,0x54,0x01,0xFF,0x90,
+
+	0xF1,0x00,0xE0,0x54,0xFE,0x4F,0xF0,0x90,
+
+	0x41,0xBC,0xE0,0x90,0xF1,0x01,0xF0,0x12,
+
+	0x7B,0x3E,0x90,0x41,0xBD,0xE0,0x64,0x01,
+
+	0x60,0x03,0x02,0x56,0x6C,0x90,0xF1,0x02,
+
+	0xE0,0x20,0xE2,0x16,0xE0,0x20,0xE1,0x12,
+
+	0xE0,0x20,0xE3,0x0E,0x90,0x41,0xBF,0x74,
+
+	0xFF,0xF5,0xF0,0x12,0x7D,0x6C,0x45,0xF0,
+
+	0x70,0xE3,0x90,0x41,0xBF,0xE0,0x70,0x02,
+
+	0xA3,0xE0,0x70,0x25,0x90,0xF1,0x03,0xE0,
+
+	0x90,0x41,0x91,0xF0,0x90,0xF6,0xB5,0xE0,
+
+	0x54,0xF7,0x44,0x08,0xF0,0xE0,0x54,0xF7,
+
+	0xF0,0x90,0x41,0x91,0xE0,0x90,0xF1,0x03,
+
+	0xF0,0x90,0x41,0xBE,0x74,0x04,0xF0,0x80,
+
+	0x49,0x90,0xF1,0x02,0xE0,0x30,0xE2,0x08,
+
+	0x90,0x41,0xBE,0x74,0x02,0xF0,0x80,0x3A,
+
+	0x90,0x41,0xBB,0xE0,0x30,0xE0,0x16,0x90,
+
+	0xF1,0x02,0xE0,0x30,0xE1,0x08,0x90,0x41,
+
+	0xBE,0x74,0x01,0xF0,0x80,0x24,0xE4,0x90,
+
+	0x41,0xBE,0xF0,0x80,0x1D,0x90,0xF1,0x02,
+
+	0xE0,0x30,0xE3,0x08,0x90,0x41,0xBE,0x74,
+
+	0x01,0xF0,0x80,0x0E,0xE4,0x90,0x41,0xBE,
+
+	0xF0,0x80,0x07,0xE4,0x90,0x41,0xBE,0xF0,
+
+	0x80,0x1B,0x90,0x41,0xBB,0xE0,0x30,0xE0,
+
+	0x0B,0x90,0xF1,0x02,0xE0,0x54,0xF7,0x44,
+
+	0x08,0xF0,0x80,0x09,0x90,0xF1,0x02,0xE0,
+
+	0x54,0xFD,0x44,0x02,0xF0,0x90,0x41,0x91,
+
+	0xE0,0x90,0xF1,0x03,0xF0,0x90,0x41,0xBE,
+
+	0xE0,0xFF,0x22,0xAA,0x86,0x53,0x86,0xFE,
+
+	0x8E,0x85,0x8F,0x84,0x8C,0x83,0x8D,0x82,
+
+	0x0B,0x80,0x0A,0xE0,0xA3,0x63,0x86,0x01,
+
+	0xF0,0xA3,0x63,0x86,0x01,0xDB,0xF4,0x8A,
+
+	0x86,0x22,0x43,0x8E,0x08,0x53,0x89,0xF0,
+
+	0x43,0x89,0x01,0x22,0xAD,0x07,0xAC,0x06,
+
+	0xC2,0x8C,0xC2,0x8D,0xEC,0xF4,0xF5,0x8C,
+
+	0xED,0xF4,0xF5,0x8A,0xD2,0x8C,0x22,0xC2,
+
+	0xAF,0x90,0x41,0x03,0x74,0x02,0xF0,0xA3,
+
+	0x74,0x47,0xF0,0xA3,0x74,0x00,0xF0,0x90,
+
+	0x41,0x0B,0x74,0x02,0xF0,0xA3,0x74,0x47,
+
+	0xF0,0xA3,0x74,0x01,0xF0,0x90,0x41,0x13,
+
+	0x74,0x02,0xF0,0xA3,0x74,0x48,0xF0,0xA3,
+
+	0x74,0x0F,0xF0,0x90,0x41,0x1B,0x74,0x02,
+
+	0xF0,0xA3,0x74,0x52,0xF0,0xA3,0x74,0xCE,
+
+	0xF0,0x90,0x41,0x23,0x74,0x02,0xF0,0xA3,
+
+	0x74,0x57,0xF0,0xA3,0x74,0x93,0xF0,0x90,
+
+	0x41,0x2B,0x74,0x02,0xF0,0xA3,0x74,0x6D,
+
+	0xF0,0xA3,0x74,0xA9,0xF0,0x90,0x41,0x33,
+
+	0x74,0x02,0xF0,0xA3,0x74,0x67,0xF0,0xA3,
+
+	0x74,0x3B,0xF0,0x90,0x41,0x3B,0x74,0x02,
+
+	0xF0,0xA3,0x74,0x52,0xF0,0xA3,0x74,0xCF,
+
+	0xF0,0x90,0x41,0x43,0x74,0x02,0xF0,0xA3,
+
+	0x74,0x52,0xF0,0xA3,0x74,0xD0,0xF0,0x90,
+
+	0x41,0x4B,0x74,0x02,0xF0,0xA3,0x74,0x60,
+
+	0xF0,0xA3,0x74,0x6A,0xF0,0x90,0x41,0x53,
+
+	0x74,0x02,0xF0,0xA3,0x74,0x52,0xF0,0xA3,
+
+	0x74,0xD1,0xF0,0x90,0x41,0x5B,0x74,0x02,
+
+	0xF0,0xA3,0x74,0x52,0xF0,0xA3,0x74,0xD2,
+
+	0xF0,0x90,0x41,0x63,0x74,0x02,0xF0,0xA3,
+
+	0x74,0x67,0xF0,0xA3,0x74,0x85,0xF0,0xD2,
+
+	0xAF,0x22,0x32,0x90,0x41,0xC1,0xEF,0xF0,
+
+	0xA3,0xED,0xF0,0xEB,0x70,0x61,0x90,0x41,
+
+	0xC4,0xE0,0xFF,0xB4,0x01,0x0A,0x90,0x41,
+
+	0xC6,0xE0,0x90,0xF0,0x01,0xF0,0x80,0x14,
+
+	0xEF,0xB4,0x02,0x10,0x90,0x41,0xC5,0xE0,
+
+	0x90,0xF0,0x01,0xF0,0x90,0x41,0xC6,0xE0,
+
+	0x90,0xF0,0x02,0xF0,0x90,0x41,0xC4,0xE0,
+
+	0x24,0x01,0xF5,0x82,0xE4,0x34,0xF0,0xAF,
+
+	0x82,0xFE,0x90,0x41,0xC7,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0x90,0x41,0xCA,0xE0,0xFB,0x12,
+
+	0x56,0x9C,0x90,0x41,0xC1,0xE0,0xFF,0xA3,
+
+	0xE0,0xFD,0x90,0x41,0xCA,0xE0,0xFE,0x90,
+
+	0x41,0xC4,0xE0,0x2E,0xFB,0x90,0x41,0xBD,
+
+	0x74,0x01,0xF0,0x12,0x54,0xB6,0x22,0x90,
+
+	0x41,0xC4,0xE0,0x70,0x22,0x90,0x41,0xC1,
+
+	0xE0,0xFF,0xA3,0xE0,0x44,0x01,0xFD,0x90,
+
+	0x41,0xCA,0xE0,0xFB,0x90,0x41,0xBD,0x74,
+
+	0x01,0xF0,0x12,0x54,0xB6,0x90,0x41,0xCB,
+
+	0xEF,0xF0,0x60,0x5F,0xE0,0xFF,0x22,0x7E,
+
+	0xF0,0x7F,0x01,0x90,0x41,0xC4,0xE0,0xFD,
+
+	0xC3,0x74,0xC7,0x9D,0xF9,0x74,0x41,0x94,
+
+	0x00,0xFC,0xAD,0x01,0xE0,0xFB,0x12,0x56,
+
+	0x9C,0x90,0x41,0xC1,0xE0,0xFF,0xA3,0xE0,
+
+	0xFD,0x90,0x41,0xC4,0xE0,0xFB,0x90,0x41,
+
+	0xBD,0x74,0x01,0xF0,0x12,0x54,0xB6,0x90,
+
+	0x41,0xCB,0xEF,0xF0,0x60,0x03,0xE0,0xFF,
+
+	0x22,0x90,0x41,0xC1,0xE0,0xFF,0xA3,0xE0,
+
+	0x44,0x01,0xFD,0x90,0x41,0xCA,0xE0,0xFB,
+
+	0x90,0x41,0xBD,0x74,0x01,0xF0,0x12,0x54,
+
+	0xB6,0x90,0x41,0xCB,0xEF,0xF0,0x60,0x03,
+
+	0xE0,0xFF,0x22,0x90,0x41,0xC7,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x7C,0xF0,0x7D,0x00,0x90,
+
+	0x41,0xCA,0xE0,0xFB,0x12,0x56,0x9C,0x7F,
+
+	0x00,0x22,0x90,0x41,0xCC,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0xA3,0xEC,0xF0,0xA3,0xED,0xF0,
+
+	0x90,0x41,0xC4,0x74,0x01,0xF0,0x90,0x41,
+
+	0xCC,0xE0,0xFF,0xA3,0xE0,0x90,0x41,0xC5,
+
+	0xCF,0xF0,0xA3,0xEF,0xF0,0x90,0x41,0xCE,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x41,0xC7,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x04,0xF0,0x7D,0xC0,0x7F,0x02,0x12,0x57,
+
+	0x94,0x22,0xC2,0xE9,0x90,0x41,0xD3,0xE0,
+
+	0xFF,0xA3,0xE0,0xFE,0xA3,0xE0,0xFD,0xA3,
+
+	0xE0,0xFC,0xD2,0xE9,0x60,0x06,0xED,0xD3,
+
+	0x94,0x02,0x40,0x06,0x90,0xF6,0xA5,0xE4,
+
+	0xF0,0x22,0xED,0xD3,0x94,0x00,0x40,0x16,
+
+	0xED,0xC4,0x54,0xF0,0xFC,0x74,0x37,0x9C,
+
+	0xFC,0xEE,0xC4,0x54,0x0F,0xFB,0xC3,0xEC,
+
+	0x9B,0x90,0xF6,0xA5,0xF0,0x22,0xEE,0xD3,
+
+	0x94,0x0C,0x40,0x10,0xEE,0x13,0x13,0x13,
+
+	0x54,0x1F,0xFC,0xC3,0x74,0x49,0x9C,0x90,
+
+	0xF6,0xA5,0xF0,0x22,0xEE,0xD3,0x94,0x02,
+
+	0x40,0x19,0xEE,0x25,0xE0,0xFC,0xC3,0x74,
+
+	0x5F,0x9C,0xFC,0xEF,0xC4,0x13,0x13,0x13,
+
+	0x54,0x01,0xFB,0xC3,0xEC,0x9B,0x90,0xF6,
+
+	0xA5,0xF0,0x22,0xED,0xD3,0x94,0x10,0x40,
+
+	0x1A,0xEE,0x25,0xE0,0x25,0xE0,0xFE,0xC3,
+
+	0x74,0x64,0x9E,0xFE,0xEF,0xC4,0x13,0x13,
+
+	0x54,0x03,0xFF,0xC3,0xEE,0x9F,0x90,0xF6,
+
+	0xA5,0xF0,0x22,0x90,0xF6,0xA5,0x74,0x64,
+
+	0xF0,0x22,0xC2,0xE9,0x90,0x41,0xD7,0xE0,
+
+	0xFF,0x90,0x41,0xD9,0xE0,0xFD,0x90,0x41,
+
+	0xDB,0xE0,0x90,0x41,0xD2,0xF0,0x90,0x41,
+
+	0xDC,0xE0,0xF9,0xD2,0xE9,0xEF,0xFE,0x7C,
+
+	0x00,0xE4,0x2D,0xFF,0xEC,0x3E,0xFE,0x90,
+
+	0x41,0xD0,0xF0,0xA3,0xEF,0xF0,0xD3,0x94,
+
+	0x64,0xEE,0x94,0x00,0x40,0x45,0x90,0x43,
+
+	0x4F,0xE0,0xB4,0x01,0x1C,0xE9,0xFF,0x90,
+
+	0x41,0xD2,0xE0,0x2F,0xFF,0xEC,0x33,0xCF,
+
+	0x24,0x71,0xCF,0x34,0xFF,0xFE,0x7D,0x28,
+
+	0x12,0x7D,0x05,0xAA,0x06,0xAB,0x07,0x80,
+
+	0x13,0xAF,0x01,0x7E,0x00,0x7C,0x00,0x7D,
+
+	0x28,0x12,0x7D,0x05,0xEF,0x24,0xA0,0xFB,
+
+	0xEE,0x34,0x14,0xFA,0xEA,0xFF,0x90,0x43,
+
+	0x4E,0xE0,0x2F,0xFF,0x24,0x05,0x90,0xF6,
+
+	0xA6,0xF0,0x22,0x90,0x41,0xD0,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0xC3,0x74,0x64,0x9F,0xFF,
+
+	0xE4,0x9E,0xFE,0x7C,0x00,0x7D,0x06,0x12,
+
+	0x7D,0x17,0xEF,0x24,0x50,0x90,0xF6,0xA6,
+
+	0xF0,0x22,0xC2,0xE9,0x90,0x41,0xDD,0xE0,
+
+	0xFF,0xD2,0xE9,0xC3,0x13,0x24,0x1A,0x90,
+
+	0xF6,0xA6,0xF0,0xE0,0xC3,0x94,0x5A,0x40,
+
+	0x0A,0xE0,0xD3,0x94,0x64,0x50,0x04,0xA3,
+
+	0xE4,0xF0,0x22,0x90,0xF6,0xA6,0xE0,0xFF,
+
+	0x74,0x5A,0xD3,0x9F,0x40,0x0F,0xE0,0x94,
+
+	0x28,0x40,0x0A,0xE0,0xFF,0x74,0x5A,0x9F,
+
+	0x25,0xE0,0xA3,0xF0,0x22,0x90,0xF6,0xA6,
+
+	0xE0,0xC3,0x94,0x28,0x50,0x0A,0xE0,0xC3,
+
+	0x94,0x00,0x40,0x04,0xA3,0x74,0x64,0xF0,
+
+	0x22,0xE4,0x90,0x44,0xB5,0xF0,0x90,0x44,
+
+	0xB6,0xF0,0x90,0x44,0xB7,0xF0,0x90,0x44,
+
+	0xC5,0xF0,0x12,0x6A,0xDF,0x12,0x64,0xA0,
+
+	0x22,0x90,0x45,0x18,0xE0,0x60,0x38,0x74,
+
+	0x41,0x90,0x41,0x7F,0xF0,0x74,0xE4,0xA3,
+
+	0xF0,0x90,0x45,0x34,0xE0,0x70,0x05,0x12,
+
+	0x6D,0x4C,0x80,0x1B,0x90,0x45,0x34,0xE0,
+
+	0xB4,0x01,0x05,0x12,0x6D,0x56,0x80,0x0F,
+
+	0x90,0x45,0x34,0xE0,0x64,0x02,0x60,0x04,
+
+	0xE0,0xB4,0xFF,0x03,0x12,0x78,0xFE,0x90,
+
+	0x44,0xB8,0xE0,0x70,0x02,0xD2,0xDD,0x90,
+
+	0x44,0xB8,0xE0,0x60,0x06,0x12,0x68,0x68,
+
+	0x12,0x68,0x49,0x22,0x90,0x43,0x54,0xE0,
+
+	0xFF,0x20,0xE7,0x03,0x02,0x5B,0x98,0xB4,
+
+	0xA1,0x19,0xA3,0xE0,0x24,0xFE,0x60,0x0D,
+
+	0x14,0x60,0x0D,0x24,0x02,0x60,0x03,0x02,
+
+	0x5C,0x52,0x7F,0x21,0x22,0x7F,0x22,0x22,
+
+	0x7F,0x23,0x22,0x90,0x43,0x54,0xE0,0xFF,
+
+	0x54,0x60,0x60,0x03,0x02,0x5C,0x52,0x90,
+
+	0x43,0x55,0xE0,0x24,0xFA,0x60,0x2D,0x24,
+
+	0xFE,0x70,0x03,0x02,0x5B,0x92,0x24,0xFE,
+
+	0x70,0x03,0x02,0x5B,0x95,0x24,0x0A,0x60,
+
+	0x03,0x02,0x5C,0x52,0xEF,0x24,0x7F,0x60,
+
+	0x0D,0x14,0x60,0x0D,0x24,0x02,0x60,0x03,
+
+	0x02,0x5C,0x52,0x7F,0x01,0x22,0x7F,0x02,
+
+	0x22,0x7F,0x03,0x22,0x90,0x43,0x54,0xE0,
+
+	0xB4,0x81,0x1B,0x90,0x43,0x57,0xE0,0x24,
+
+	0xDE,0x60,0x0D,0x14,0x60,0x0D,0x24,0x02,
+
+	0x60,0x03,0x02,0x5C,0x52,0x7F,0x6B,0x22,
+
+	0x7F,0x6C,0x22,0x7F,0x6D,0x22,0x90,0x43,
+
+	0x57,0xE0,0x14,0xB4,0x08,0x00,0x40,0x03,
+
+	0x02,0x5C,0x52,0x90,0x5B,0x62,0x75,0xF0,
+
+	0x03,0xA4,0xC5,0x83,0x25,0xF0,0xC5,0x83,
+
+	0x73,0x02,0x5B,0x7A,0x02,0x5B,0x7D,0x02,
+
+	0x5B,0x80,0x02,0x5B,0x83,0x02,0x5B,0x86,
+
+	0x02,0x5B,0x89,0x02,0x5B,0x8C,0x02,0x5B,
+
+	0x8F,0x7F,0x60,0x22,0x7F,0x61,0x22,0x7F,
+
+	0x62,0x22,0x7F,0x63,0x22,0x7F,0x64,0x22,
+
+	0x7F,0x65,0x22,0x7F,0x66,0x22,0x7F,0x67,
+
+	0x22,0x7F,0x80,0x22,0x7F,0xA0,0x22,0x90,
+
+	0x43,0x54,0xE0,0xB4,0x21,0x19,0xA3,0xE0,
+
+	0x24,0xF6,0x60,0x0D,0x14,0x60,0x0D,0x24,
+
+	0x02,0x60,0x03,0x02,0x5C,0x52,0x7F,0x29,
+
+	0x22,0x7F,0x2B,0x22,0x7F,0x2B,0x22,0x90,
+
+	0x43,0x54,0xE0,0xFF,0x54,0x60,0x60,0x03,
+
+	0x02,0x5C,0x52,0x90,0x43,0x55,0xE0,0x24,
+
+	0xFD,0x60,0x39,0x24,0xFE,0x60,0x63,0x24,
+
+	0xFE,0x60,0x6B,0x24,0xFE,0x60,0x74,0x24,
+
+	0xFE,0x60,0x73,0x24,0x0A,0x70,0x72,0xEF,
+
+	0x24,0xFE,0x60,0x17,0x24,0x02,0x70,0x69,
+
+	0x90,0x43,0x56,0xE0,0xFE,0xB4,0x01,0x03,
+
+	0x7F,0x10,0x22,0xEE,0x64,0x02,0x70,0x59,
+
+	0x7F,0x12,0x22,0x90,0x43,0x56,0xE0,0x70,
+
+	0x50,0x7F,0x13,0x22,0x90,0x43,0x54,0xE0,
+
+	0x24,0xFE,0x60,0x1D,0x24,0x02,0x70,0x41,
+
+	0x90,0x43,0x56,0xE0,0xFE,0xB4,0x01,0x03,
+
+	0x7F,0x30,0x22,0xEE,0x64,0x02,0x70,0x31,
+
+	0x90,0x43,0x58,0xE0,0x70,0x2B,0x7F,0x31,
+
+	0x22,0x90,0x43,0x56,0xE0,0x70,0x22,0x7F,
+
+	0x32,0x22,0x90,0x43,0x56,0xE0,0xC3,0x94,
+
+	0x80,0x50,0x16,0x7F,0x50,0x22,0x90,0x43,
+
+	0x54,0xE0,0xB4,0x01,0x03,0x7F,0x71,0x22,
+
+	0x7F,0x70,0x22,0x7F,0x90,0x22,0x7F,0xB0,
+
+	0x22,0x7F,0x00,0x22,0xE4,0xFF,0x7F,0x06,
+
+	0x90,0x43,0x5C,0xE4,0xF0,0xA3,0xDF,0xFC,
+
+	0x22,0x90,0x44,0x67,0xE0,0x24,0xA0,0x60,
+
+	0x2D,0x14,0x60,0x35,0x14,0x70,0x03,0x02,
+
+	0x5C,0xFD,0x24,0xFD,0x70,0x03,0x02,0x5D,
+
+	0x5D,0x14,0x70,0x03,0x02,0x5D,0x67,0x24,
+
+	0x16,0x60,0x03,0x02,0x5D,0xC9,0x90,0x43,
+
+	0x56,0xE0,0x90,0xDD,0x10,0xF0,0xE4,0x90,
+
+	0x44,0x68,0xF0,0x02,0x5D,0xCC,0x90,0x43,
+
+	0x64,0xE0,0xFF,0x12,0x68,0xD9,0x02,0x5D,
+
+	0xCC,0x90,0x44,0xC5,0xE0,0x60,0x29,0x78,
+
+	0x89,0x7C,0x43,0x7D,0x01,0x7B,0x01,0x7A,
+
+	0x43,0x79,0x80,0x7E,0x00,0x7F,0x09,0x12,
+
+	0x7F,0x9D,0x90,0x43,0x8A,0x74,0x02,0xF0,
+
+	0x7F,0x00,0x7E,0x40,0x12,0x6A,0x7A,0x7F,
+
+	0x02,0x7E,0x00,0x12,0x6A,0xBB,0x80,0x21,
+
+	0x78,0x89,0x7C,0x43,0x7D,0x01,0x7B,0x01,
+
+	0x7A,0x44,0x79,0x6A,0x7E,0x00,0x7F,0x09,
+
+	0x12,0x7F,0x9D,0x7F,0x02,0x7E,0x00,0x12,
+
+	0x6A,0x7A,0x7F,0x14,0x7E,0x00,0x12,0x6A,
+
+	0xBB,0x90,0x43,0x8B,0xE0,0xFF,0x12,0x68,
+
+	0xD9,0x02,0x5D,0xCC,0xE4,0xFF,0x90,0x43,
+
+	0x56,0xE0,0xFE,0xEF,0xC3,0x9E,0x50,0x2C,
+
+	0x90,0x44,0x69,0xE0,0xFE,0x90,0x45,0x03,
+
+	0xE0,0x75,0xF0,0x08,0xA4,0x2E,0xF5,0x82,
+
+	0xE4,0x35,0xF0,0xF5,0x83,0xE5,0x82,0x24,
+
+	0x00,0xF5,0x82,0xE5,0x83,0x34,0x45,0xF5,
+
+	0x83,0xE0,0xFE,0x90,0x44,0x69,0xE0,0x2E,
+
+	0xF0,0x0F,0x80,0xCA,0x90,0x44,0x69,0xE0,
+
+	0xFF,0x90,0x45,0x03,0xE0,0x75,0xF0,0x08,
+
+	0xA4,0x2F,0xF5,0x82,0xE4,0x35,0xF0,0xF5,
+
+	0x83,0xE5,0x82,0x24,0x00,0xF5,0x82,0xE5,
+
+	0x83,0x34,0x45,0xF5,0x83,0xE0,0xFF,0x12,
+
+	0x68,0xD9,0x80,0x6F,0x90,0x43,0x76,0xE0,
+
+	0xFF,0x12,0x68,0xD9,0x80,0x65,0x90,0x44,
+
+	0xC5,0xE0,0x60,0x31,0x78,0x89,0x7C,0x43,
+
+	0x7D,0x01,0x7B,0x01,0x7A,0x44,0x79,0x6A,
+
+	0x7E,0x00,0x7F,0x09,0x12,0x7F,0x9D,0x90,
+
+	0x43,0x8A,0x74,0x07,0xF0,0x7F,0x02,0x7E,
+
+	0x00,0x12,0x6A,0x7A,0x7F,0x14,0x7E,0x00,
+
+	0x12,0x6A,0xBB,0x90,0x43,0x8B,0xE0,0xFF,
+
+	0x12,0x68,0xD9,0x80,0x2E,0x78,0x89,0x7C,
+
+	0x43,0x7D,0x01,0x7B,0x01,0x7A,0x43,0x79,
+
+	0x80,0x7E,0x00,0x7F,0x09,0x12,0x7F,0x9D,
+
+	0x90,0x43,0x8B,0xE0,0xFF,0x12,0x68,0xD9,
+
+	0x7F,0x00,0x7E,0x40,0x12,0x6A,0x7A,0x7F,
+
+	0x02,0x7E,0x00,0x12,0x6A,0xBB,0x80,0x03,
+
+	0x7F,0x07,0x22,0x7F,0x00,0x22,0x90,0x44,
+
+	0x67,0xE0,0xFF,0x14,0x24,0xFD,0x50,0x3A,
+
+	0x24,0xF4,0x70,0x03,0x02,0x5E,0x6D,0x24,
+
+	0xFD,0x70,0x03,0x02,0x5E,0x75,0x24,0xE2,
+
+	0x70,0x03,0x02,0x5E,0xA6,0x14,0x70,0x03,
+
+	0x02,0x5E,0x8D,0x24,0xB2,0x70,0x03,0x02,
+
+	0x5E,0xD6,0x24,0xF0,0x70,0x03,0x02,0x5E,
+
+	0xE6,0x24,0xF0,0x70,0x03,0x02,0x5E,0xF8,
+
+	0x24,0xF0,0x70,0x03,0x02,0x5F,0x08,0x02,
+
+	0x5F,0x1A,0xEF,0xB4,0x01,0x26,0x90,0x44,
+
+	0xC5,0xE0,0x60,0x10,0x90,0x43,0x87,0xE0,
+
+	0xFF,0xC4,0x13,0x13,0x54,0x01,0x90,0xDE,
+
+	0x00,0xF0,0x80,0x32,0x90,0x44,0x71,0xE0,
+
+	0xFF,0xC4,0x13,0x13,0x54,0x01,0x90,0xDE,
+
+	0x00,0xF0,0x80,0x22,0x90,0x44,0x67,0xE0,
+
+	0xB4,0x02,0x07,0xE4,0x90,0xDE,0x00,0xF0,
+
+	0x80,0x14,0x90,0x43,0x58,0xE0,0x54,0x0F,
+
+	0x24,0x5C,0xF5,0x82,0xE4,0x34,0x43,0xF5,
+
+	0x83,0xE0,0x90,0xDE,0x00,0xF0,0xE4,0x90,
+
+	0xDE,0x01,0xF0,0x90,0x44,0x68,0x74,0x02,
+
+	0xF0,0x02,0x5F,0x1D,0xE4,0x90,0x44,0x68,
+
+	0xF0,0x02,0x5F,0x1D,0x90,0x43,0x58,0xE0,
+
+	0x54,0x0F,0x24,0x5C,0xF5,0x82,0xE4,0x34,
+
+	0x43,0xF5,0x83,0xE4,0xF0,0x90,0x44,0x68,
+
+	0xF0,0x02,0x5F,0x1D,0x90,0x43,0x58,0xE0,
+
+	0x54,0x0F,0x24,0x5C,0xF5,0x82,0xE4,0x34,
+
+	0x43,0xF5,0x83,0x74,0x01,0xF0,0xE4,0x90,
+
+	0x44,0x68,0xF0,0x80,0x77,0x90,0x44,0xC5,
+
+	0xE0,0x60,0x08,0xE4,0x90,0x44,0xB6,0xF0,
+
+	0x7F,0x07,0x22,0x90,0x43,0x59,0xE0,0x14,
+
+	0x24,0xFC,0x50,0x02,0x80,0x08,0x90,0x44,
+
+	0xB6,0x74,0x01,0xF0,0x80,0x08,0xE4,0x90,
+
+	0x44,0xB6,0xF0,0x7F,0x07,0x22,0xE4,0x90,
+
+	0x44,0x68,0xF0,0x80,0x47,0x90,0x43,0x62,
+
+	0xE0,0x90,0xDE,0x00,0xF0,0x90,0x44,0x68,
+
+	0x74,0x01,0xF0,0x80,0x37,0x12,0x5C,0x55,
+
+	0x90,0x43,0x56,0xE0,0x90,0x43,0x62,0xF0,
+
+	0xE4,0x90,0x44,0x68,0xF0,0x80,0x25,0x90,
+
+	0x43,0x63,0xE0,0x90,0xDE,0x00,0xF0,0x90,
+
+	0x44,0x68,0x74,0x01,0xF0,0x80,0x15,0x12,
+
+	0x5C,0x55,0x90,0x43,0x56,0xE0,0x90,0x43,
+
+	0x63,0xF0,0xE4,0x90,0x44,0x68,0xF0,0x80,
+
+	0x03,0x7F,0x07,0x22,0x7F,0x00,0x22,0x90,
+
+	0x44,0x67,0xE0,0x24,0xDE,0x60,0x1F,0x24,
+
+	0xF7,0x60,0x2B,0x24,0xBF,0x60,0x0D,0x04,
+
+	0x70,0x33,0x90,0x43,0xF3,0xE0,0xFF,0x12,
+
+	0x68,0xD9,0x80,0x2C,0x90,0x43,0xFA,0xE0,
+
+	0xFF,0x12,0x68,0xD9,0x80,0x22,0x90,0x44,
+
+	0xB4,0xE0,0x90,0xDE,0x00,0xF0,0x90,0x44,
+
+	0x68,0x74,0x01,0xF0,0x80,0x12,0x90,0x43,
+
+	0x57,0xE0,0x90,0x44,0xB4,0xF0,0xE4,0x90,
+
+	0x44,0x68,0xF0,0x80,0x03,0x7F,0x07,0x22,
+
+	0x7F,0x00,0x22,0x90,0x44,0x67,0xE0,0x12,
+
+	0x7E,0xB5,0x5F,0xB6,0x01,0x5F,0xB6,0x02,
+
+	0x5F,0xB6,0x03,0x5F,0xB6,0x10,0x5F,0xB6,
+
+	0x13,0x5F,0xB6,0x22,0x5F,0xB6,0x2B,0x5F,
+
+	0xB6,0x31,0x5F,0xB6,0x32,0x5F,0xB6,0x50,
+
+	0x5F,0xC0,0x60,0x5F,0xD6,0x61,0x5F,0xEC,
+
+	0x62,0x5F,0xCB,0x65,0x5F,0xE1,0x66,0x60,
+
+	0x03,0x6B,0x60,0x0E,0x6C,0x5F,0xB6,0x80,
+
+	0x5F,0xB6,0x90,0x5F,0xB6,0xA0,0x5F,0xB6,
+
+	0xB0,0x00,0x00,0x60,0x19,0x90,0x44,0x68,
+
+	0xE0,0x90,0xDD,0x85,0xF0,0x80,0x5C,0x7A,
+
+	0x43,0x79,0x64,0x7B,0x01,0x12,0x68,0xFE,
+
+	0x80,0x51,0x7A,0x43,0x79,0x76,0x7B,0x01,
+
+	0x12,0x68,0xFE,0x80,0x46,0x7A,0x43,0x79,
+
+	0x89,0x7B,0x01,0x12,0x68,0xFE,0x80,0x3B,
+
+	0x7A,0x43,0x79,0x89,0x7B,0x01,0x12,0x68,
+
+	0xFE,0x80,0x30,0x90,0x45,0x03,0xE0,0x75,
+
+	0xF0,0x08,0xA4,0x24,0x00,0xF9,0x74,0x45,
+
+	0x35,0xF0,0xFA,0x7B,0x01,0x12,0x68,0xFE,
+
+	0x80,0x19,0x7A,0x43,0x79,0xF3,0x7B,0x01,
+
+	0x12,0x68,0xFE,0x80,0x0E,0x7B,0x01,0x7A,
+
+	0x44,0x79,0x73,0x12,0x68,0xFE,0x80,0x03,
+
+	0x7F,0x03,0x22,0x7F,0x00,0x22,0x12,0x5A,
+
+	0xBD,0x90,0x44,0x67,0xEF,0xF0,0x90,0x44,
+
+	0x67,0xE0,0x70,0x03,0x7F,0x06,0x22,0x12,
+
+	0x68,0xA2,0xEF,0x60,0x01,0x22,0x7F,0x00,
+
+	0x22,0x12,0x5F,0x6C,0xEF,0x60,0x01,0x22,
+
+	0x7F,0x00,0x22,0x90,0xDE,0xC3,0xE0,0x90,
+
+	0xDE,0x41,0xF0,0xE4,0xA3,0xF0,0x7C,0xDE,
+
+	0x7D,0xC0,0x90,0xDE,0xC0,0xE0,0x04,0xFB,
+
+	0x7F,0x00,0x7E,0xF7,0x12,0x56,0x9C,0x90,
+
+	0xF4,0x10,0xE0,0x54,0xFE,0x44,0x01,0xF0,
+
+	0x22,0xC0,0xE0,0xC0,0xF0,0xC0,0x83,0xC0,
+
+	0x82,0xC0,0x85,0xC0,0x84,0xC0,0x86,0x75,
+
+	0x86,0x00,0xC0,0xD0,0x75,0xD0,0x00,0xC0,
+
+	0x00,0xC0,0x01,0xC0,0x02,0xC0,0x03,0xC0,
+
+	0x04,0xC0,0x05,0xC0,0x06,0xC0,0x07,0x90,
+
+	0xF6,0xA8,0xE0,0x12,0x7E,0xB5,0x60,0xCE,
+
+	0x00,0x63,0x39,0x01,0x63,0x39,0x02,0x60,
+
+	0xEB,0x04,0x61,0x0E,0x05,0x61,0x47,0x07,
+
+	0x62,0x73,0x0D,0x62,0x73,0x0E,0x62,0x73,
+
+	0x0F,0x62,0xC6,0x10,0x62,0x3D,0x11,0x61,
+
+	0x58,0x12,0x61,0xA4,0x13,0x62,0x04,0x14,
+
+	0x62,0x04,0x15,0x64,0x0D,0x16,0x64,0x3E,
+
+	0x17,0x00,0x00,0x64,0x6D,0x7E,0xDE,0x7F,
+
+	0x40,0x90,0xF7,0x00,0xE0,0x04,0xFB,0x7D,
+
+	0x00,0x7C,0xF7,0x12,0x56,0x9C,0x90,0xF7,
+
+	0x00,0xE0,0x04,0x90,0xDD,0x86,0xF0,0x02,
+
+	0x64,0x6D,0x90,0xF6,0xA9,0xE0,0x90,0x41,
+
+	0xD3,0xF0,0x90,0xF6,0xAA,0xE0,0x90,0x41,
+
+	0xD4,0xF0,0x90,0xF6,0xAB,0xE0,0x90,0x41,
+
+	0xD5,0xF0,0x90,0xF6,0xAC,0xE0,0x90,0x41,
+
+	0xD6,0xF0,0x02,0x64,0x6D,0x90,0x41,0x8F,
+
+	0x74,0x05,0xF0,0x90,0xF6,0xA9,0xE0,0x90,
+
+	0x41,0xD7,0xF0,0x90,0xF6,0xAA,0xE0,0x90,
+
+	0x41,0xD9,0xF0,0x90,0xF6,0xAB,0xE0,0x90,
+
+	0x41,0xD8,0xF0,0x90,0xF6,0xAC,0xE0,0x90,
+
+	0x41,0xDA,0xF0,0x90,0xF6,0xAD,0xE0,0x90,
+
+	0x41,0xDB,0xF0,0x90,0xF6,0xAE,0xE0,0x90,
+
+	0x41,0xDC,0xF0,0x02,0x64,0x6D,0x90,0x41,
+
+	0x8F,0x74,0x07,0xF0,0x90,0xF6,0xA9,0xE0,
+
+	0x90,0x41,0xDD,0xF0,0x02,0x64,0x6D,0x90,
+
+	0x41,0xC4,0x74,0x01,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0xF0,0xA3,0x74,0xF0,0xF0,0xA3,0x74,
+
+	0x00,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x10,
+
+	0xF0,0x7B,0x01,0x7D,0xC0,0x7F,0x02,0x12,
+
+	0x57,0x94,0x90,0xF0,0x01,0xE0,0xFF,0x13,
+
+	0x13,0x54,0x01,0xFE,0xEF,0x13,0x13,0x13,
+
+	0x54,0x03,0x2E,0xFF,0xE0,0x54,0x03,0x2F,
+
+	0xFF,0xC4,0x54,0xF0,0xFF,0xA3,0xE0,0xFE,
+
+	0xC4,0x54,0x0F,0x2F,0x90,0xF6,0xA4,0xF0,
+
+	0x02,0x64,0x6D,0x90,0xF6,0xA9,0xE0,0xC3,
+
+	0x94,0x40,0x50,0x1F,0xE0,0x54,0x0F,0x90,
+
+	0x43,0x4B,0xF0,0x90,0xF6,0xA9,0xE0,0xFF,
+
+	0xC4,0x54,0x0F,0x24,0x50,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xE0,0x90,0x43,0x4A,
+
+	0xF0,0x80,0x10,0x90,0xF6,0xA9,0xE0,0x54,
+
+	0x3F,0x90,0x43,0x4B,0xF0,0x90,0x43,0x4A,
+
+	0x74,0xFE,0xF0,0x90,0x41,0xC4,0x74,0x01,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x0A,0xF0,
+
+	0xA3,0x74,0x43,0xF0,0xA3,0x74,0x4A,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0x02,0xF0,0xE4,
+
+	0xFB,0x7D,0xC0,0x7F,0x02,0x12,0x57,0x94,
+
+	0x02,0x64,0x6D,0x90,0xF6,0xA8,0xE0,0xB4,
+
+	0x15,0x04,0x7F,0xAC,0x80,0x02,0x7F,0x9C,
+
+	0x90,0x43,0x49,0xEF,0xF0,0x90,0x41,0xC4,
+
+	0x74,0x01,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x04,0xF0,0xA3,0x74,0x43,0xF0,0xA3,0x74,
+
+	0x49,0xF0,0xA3,0xE4,0xF0,0xA3,0x04,0xF0,
+
+	0xE4,0xFB,0x7D,0xC0,0x7F,0x02,0x12,0x57,
+
+	0x94,0x02,0x64,0x6D,0x7C,0x43,0x7D,0x48,
+
+	0x7B,0x01,0x7F,0x1C,0x7E,0x00,0x12,0x58,
+
+	0x9B,0x90,0x43,0x48,0xE0,0x54,0xF7,0xF0,
+
+	0xE0,0xFF,0x90,0xF6,0xA9,0xE0,0xFE,0x33,
+
+	0x33,0x33,0x54,0xF8,0xFE,0xEF,0x4E,0x90,
+
+	0x43,0x48,0xF0,0x7C,0x43,0x7D,0x48,0xE4,
+
+	0xFB,0x7F,0x1C,0xFE,0x12,0x58,0x9B,0x02,
+
+	0x64,0x6D,0x90,0x44,0xB8,0xE0,0x60,0x08,
+
+	0x90,0x43,0x46,0x74,0x01,0xF0,0x80,0x06,
+
+	0x90,0x43,0x46,0x74,0x03,0xF0,0x90,0xF0,
+
+	0x01,0x74,0x05,0xF0,0xA3,0x74,0x80,0xF0,
+
+	0x90,0xF6,0xA8,0xE0,0x90,0xF0,0x03,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0x7F,0xF0,0x90,
+
+	0xF6,0xA8,0xE0,0xF4,0x90,0xF0,0x06,0xF0,
+
+	0x90,0x43,0x46,0xE0,0xFF,0x90,0x41,0x8E,
+
+	0xE0,0xFD,0x90,0x41,0xBD,0x74,0x01,0xF0,
+
+	0x7B,0x07,0x12,0x54,0xB6,0x90,0x43,0x45,
+
+	0xEF,0xF0,0x02,0x64,0x6D,0x90,0x41,0xC4,
+
+	0x74,0x01,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x07,0xF0,0xA3,0x74,0x43,0xF0,0xA3,0x74,
+
+	0x44,0xF0,0xA3,0xE4,0xF0,0xA3,0x04,0xF0,
+
+	0xFB,0x7D,0xC0,0x7F,0x02,0x12,0x57,0x94,
+
+	0x90,0xF6,0xA9,0xE0,0x90,0x43,0x4E,0xF0,
+
+	0x90,0x43,0x44,0xE0,0x54,0xC3,0xF0,0xE0,
+
+	0xFF,0x90,0x43,0x4E,0xE0,0xFE,0x25,0xE0,
+
+	0x25,0xE0,0xFE,0xEF,0x4E,0x90,0x43,0x44,
+
+	0xF0,0x90,0x41,0xC4,0x74,0x01,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x74,0x07,0xF0,0xA3,0x74,
+
+	0x43,0xF0,0xA3,0x74,0x44,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0x04,0xF0,0xE4,0xFB,0x7D,0xC0,
+
+	0x7F,0x02,0x12,0x57,0x94,0x90,0x43,0x4E,
+
+	0xE0,0x90,0xF6,0xA9,0xF0,0x02,0x64,0x6D,
+
+	0x90,0xF6,0x41,0xE0,0x24,0xDE,0x70,0x03,
+
+	0x02,0x63,0xEA,0x14,0x60,0x0E,0x24,0xFB,
+
+	0x70,0x03,0x02,0x63,0xEA,0x24,0x07,0x60,
+
+	0x03,0x02,0x64,0x6D,0x90,0xF0,0x02,0x74,
+
+	0x52,0xF0,0x90,0x41,0xC4,0x74,0x01,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0x05,0xF0,0xA3,
+
+	0x74,0x43,0xF0,0xA3,0x74,0x44,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x04,0xF0,0xFB,0x7D,0xC0,
+
+	0x7F,0x02,0x12,0x57,0x94,0x90,0xF6,0xA8,
+
+	0xE0,0xB4,0x01,0x0C,0x90,0x43,0x47,0x74,
+
+	0x01,0xF0,0x90,0x43,0x4F,0xF0,0x80,0x12,
+
+	0x90,0xF6,0xA8,0xE0,0xB4,0x02,0x0B,0x90,
+
+	0x43,0x47,0x74,0x02,0xF0,0x90,0x43,0x4F,
+
+	0xE4,0xF0,0x90,0x43,0x44,0xE0,0x54,0xCF,
+
+	0xF0,0xE0,0xFF,0x90,0x43,0x47,0xE0,0xFE,
+
+	0xC4,0x54,0xF0,0xFE,0xEF,0x4E,0x90,0x43,
+
+	0x44,0xF0,0x90,0x41,0xC4,0x74,0x01,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0x05,0xF0,0xA3,
+
+	0x74,0x43,0xF0,0xA3,0x74,0x44,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x04,0xF0,0xE4,0xFB,0x7D,
+
+	0xC0,0x7F,0x02,0x12,0x57,0x94,0x90,0x43,
+
+	0x47,0xE0,0x90,0xF6,0xA9,0xF0,0x02,0x64,
+
+	0x6D,0x90,0xF6,0xA8,0xE0,0xB4,0x01,0x0B,
+
+	0x90,0xD8,0xCF,0xE0,0x54,0xFE,0x44,0x01,
+
+	0xF0,0x80,0x71,0x90,0xF6,0xA8,0xE0,0x64,
+
+	0x02,0x70,0x69,0x90,0xD8,0xCF,0xE0,0x54,
+
+	0xFE,0xF0,0x80,0x60,0x90,0x43,0x4C,0x74,
+
+	0xC0,0xF0,0xA3,0x74,0x16,0xF0,0x90,0x41,
+
+	0xC4,0x74,0x01,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0x36,0xF0,0xA3,0x74,0x43,0xF0,0xA3,
+
+	0x74,0x4C,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x02,0xF0,0xE4,0xFB,0x7D,0xC0,0x7F,0x02,
+
+	0x12,0x57,0x94,0x80,0x2F,0x90,0x43,0x4C,
+
+	0x74,0xC0,0xF0,0xA3,0x74,0x13,0xF0,0x90,
+
+	0x41,0xC4,0x74,0x01,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0x74,0x36,0xF0,0xA3,0x74,0x43,0xF0,
+
+	0xA3,0x74,0x4C,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0x02,0xF0,0xE4,0xFB,0x7D,0xC0,0x7F,
+
+	0x02,0x12,0x57,0x94,0x53,0x91,0xDF,0x90,
+
+	0xF6,0xDF,0xE0,0x54,0xFE,0xF0,0xD0,0x07,
+
+	0xD0,0x06,0xD0,0x05,0xD0,0x04,0xD0,0x03,
+
+	0xD0,0x02,0xD0,0x01,0xD0,0x00,0xD0,0xD0,
+
+	0xD0,0x86,0xD0,0x84,0xD0,0x85,0xD0,0x82,
+
+	0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,0x44,
+
+	0x43,0x50,0x9E,0xBE,0xDE,0xFE,0x00,0x78,
+
+	0x64,0x7C,0x43,0x7D,0x01,0x7B,0xFF,0x7A,
+
+	0x7F,0x79,0xC3,0x7E,0x01,0x7F,0x03,0x12,
+
+	0x7F,0x9D,0x78,0x6A,0x7C,0x44,0x7D,0x01,
+
+	0x7B,0x01,0x7A,0x43,0x79,0x89,0x7E,0x00,
+
+	0x7F,0x09,0x12,0x7F,0x9D,0x78,0x73,0x7C,
+
+	0x44,0x7D,0x01,0x7B,0xFF,0x7A,0x80,0x79,
+
+	0xC6,0x7E,0x00,0x7F,0x41,0x12,0x7F,0x9D,
+
+	0x22,0x90,0x44,0xB9,0x74,0xAF,0xF0,0xA3,
+
+	0xEF,0xF0,0xA3,0x74,0x22,0xF0,0x7A,0x44,
+
+	0x79,0xB9,0x12,0x7E,0xDB,0x22,0x90,0x44,
+
+	0xB9,0x74,0x8F,0xF0,0xA3,0xEF,0xF0,0xA3,
+
+	0x74,0x22,0xF0,0xAF,0x05,0x7C,0x44,0x7D,
+
+	0xB9,0x90,0x44,0xB9,0x12,0x7E,0xDF,0x22,
+
+	0xE4,0x90,0x44,0xBE,0xF0,0x90,0x44,0xB8,
+
+	0xE0,0x60,0x0D,0x90,0xDD,0xA8,0xE0,0x30,
+
+	0xE0,0x06,0x12,0x68,0x77,0x02,0x67,0x38,
+
+	0x90,0xDF,0x82,0xE0,0x20,0xE1,0x06,0x12,
+
+	0x67,0xD1,0x02,0x67,0x38,0x90,0x44,0xB8,
+
+	0xE0,0x70,0x09,0x90,0x44,0xBF,0xE0,0x04,
+
+	0xF0,0x02,0x67,0x38,0x90,0xDD,0xA8,0xE0,
+
+	0x30,0xE0,0x06,0x12,0x68,0x77,0x02,0x67,
+
+	0x38,0x90,0xDD,0x1B,0xE0,0x30,0xE1,0x12,
+
+	0x90,0xDD,0x1D,0x74,0xFF,0xF0,0x90,0xDD,
+
+	0x1B,0x74,0x02,0xF0,0x12,0x68,0x20,0x02,
+
+	0x67,0x38,0x90,0x45,0x33,0xE0,0x64,0x01,
+
+	0x70,0x29,0x90,0xDD,0x1B,0xE0,0x30,0xE0,
+
+	0x22,0x74,0x01,0xF0,0xE4,0x90,0x44,0xBD,
+
+	0xF0,0x90,0xDD,0x1B,0xE0,0x30,0xE0,0x0D,
+
+	0x74,0x01,0xF0,0x90,0x44,0xBD,0xE0,0x04,
+
+	0xF0,0xE0,0xB4,0x02,0xEC,0x12,0x68,0x3F,
+
+	0x02,0x67,0x38,0x90,0xDD,0x1B,0xE0,0x30,
+
+	0xE2,0x28,0x90,0xDD,0x14,0xE0,0x44,0x01,
+
+	0xF0,0x12,0x69,0x63,0x12,0x60,0x1F,0x90,
+
+	0x44,0xBC,0xEF,0xF0,0x70,0x03,0x02,0x67,
+
+	0x38,0x90,0xDD,0x14,0xE0,0x54,0xFE,0xF0,
+
+	0x90,0xDD,0x12,0xE0,0x44,0x01,0xF0,0x02,
+
+	0x67,0x38,0x90,0xDD,0x19,0xE0,0x30,0xE0,
+
+	0x42,0x90,0xDD,0x14,0xE0,0x44,0x01,0xF0,
+
+	0x90,0xDD,0x19,0x74,0x01,0xF0,0x90,0xDD,
+
+	0x13,0xE0,0x44,0x01,0xF0,0x90,0x44,0xB6,
+
+	0xE0,0x64,0x01,0x60,0x03,0x02,0x67,0x38,
+
+	0x90,0xDD,0x00,0xC0,0x83,0xC0,0x82,0xE0,
+
+	0xFF,0x90,0x43,0x59,0xE0,0xFE,0x33,0x33,
+
+	0x33,0x54,0xF8,0xFE,0xEF,0x4E,0xD0,0x82,
+
+	0xD0,0x83,0xF0,0xE4,0x90,0x44,0xB6,0xF0,
+
+	0x02,0x67,0x38,0x90,0xDD,0x18,0xE0,0x30,
+
+	0xE0,0x31,0x90,0xDD,0x14,0xE0,0x30,0xE0,
+
+	0x2A,0x90,0xDD,0x14,0xE0,0x54,0xFE,0xF0,
+
+	0x12,0x60,0x3A,0x90,0x44,0xBC,0xEF,0xF0,
+
+	0x60,0x09,0x90,0xDD,0x12,0xE0,0x44,0x01,
+
+	0xF0,0x80,0x07,0x90,0xDD,0x13,0xE0,0x54,
+
+	0xFE,0xF0,0x90,0xDD,0x18,0x74,0x01,0xF0,
+
+	0x02,0x67,0x38,0x90,0xDD,0x19,0xE0,0x30,
+
+	0xE1,0x10,0x90,0xDD,0x19,0x74,0x02,0xF0,
+
+	0x90,0xDD,0x13,0xE0,0x44,0x02,0xF0,0x02,
+
+	0x67,0x38,0x90,0xDD,0x18,0xE0,0x30,0xE1,
+
+	0x16,0x90,0xDD,0x84,0x74,0x40,0xF0,0x90,
+
+	0xDD,0x13,0xE0,0x54,0xFD,0xF0,0x90,0xDD,
+
+	0x18,0x74,0x02,0xF0,0x02,0x67,0x38,0x90,
+
+	0xDD,0x19,0xE0,0x30,0xE4,0x6A,0x90,0xDD,
+
+	0x19,0x74,0x10,0xF0,0x90,0x43,0x43,0xE0,
+
+	0x64,0x01,0x60,0x03,0x02,0x67,0x38,0x90,
+
+	0x44,0xDE,0xE0,0xFF,0xB4,0x01,0x31,0xE4,
+
+	0x90,0x44,0xBD,0xF0,0x90,0x44,0xBD,0xE0,
+
+	0xFE,0xC3,0x94,0x08,0x50,0x14,0x74,0x80,
+
+	0x2E,0xF5,0x82,0xE4,0x34,0xDE,0xF5,0x83,
+
+	0xE4,0xF0,0x90,0x44,0xBD,0xE0,0x04,0xF0,
+
+	0x80,0xE2,0x90,0xDD,0x87,0x74,0x08,0xF0,
+
+	0x90,0x44,0xDE,0x74,0x02,0xF0,0x80,0x6F,
+
+	0xEF,0x64,0x02,0x70,0x6A,0x90,0x44,0xDE,
+
+	0xF0,0x90,0xDD,0x13,0xE0,0x44,0x10,0xF0,
+
+	0x90,0x41,0x81,0xE0,0xFF,0x64,0x01,0x60,
+
+	0x56,0x90,0x43,0x43,0xEF,0xF0,0x80,0x4F,
+
+	0x90,0xDD,0x19,0xE0,0x30,0xE3,0x18,0x90,
+
+	0xDD,0x13,0xE0,0x44,0x08,0xF0,0x90,0xDD,
+
+	0x19,0x74,0x08,0xF0,0x12,0x60,0x44,0x90,
+
+	0x44,0xB7,0x74,0x01,0xF0,0x80,0x30,0x90,
+
+	0xDD,0x14,0xE0,0x54,0x08,0xFF,0x13,0x13,
+
+	0x13,0x54,0x1F,0x60,0x1C,0x90,0xDD,0x18,
+
+	0xE0,0x30,0xE3,0x15,0x90,0xDD,0x84,0x74,
+
+	0x40,0xF0,0x90,0xDD,0x13,0xE0,0x54,0xF7,
+
+	0xF0,0x90,0xDD,0x18,0x74,0x08,0xF0,0x80,
+
+	0x06,0x90,0x44,0xC0,0xE0,0x04,0xF0,0xC2,
+
+	0xDC,0x22,0xC0,0xE0,0xC0,0xF0,0xC0,0x83,
+
+	0xC0,0x82,0xC0,0x85,0xC0,0x84,0xC0,0x86,
+
+	0x75,0x86,0x00,0xC0,0xD0,0x75,0xD0,0x00,
+
+	0xC0,0x00,0xC0,0x01,0xC0,0x02,0xC0,0x03,
+
+	0xC0,0x04,0xC0,0x05,0xC0,0x06,0xC0,0x07,
+
+	0x12,0x65,0x09,0xD0,0x07,0xD0,0x06,0xD0,
+
+	0x05,0xD0,0x04,0xD0,0x03,0xD0,0x02,0xD0,
+
+	0x01,0xD0,0x00,0xD0,0xD0,0xD0,0x86,0xD0,
+
+	0x84,0xD0,0x85,0xD0,0x82,0xD0,0x83,0xD0,
+
+	0xF0,0xD0,0xE0,0x32,0xC0,0xE0,0xC0,0xF0,
+
+	0xC0,0x83,0xC0,0x82,0xC0,0x85,0xC0,0x84,
+
+	0xC0,0x86,0x75,0x86,0x00,0xC0,0xD0,0x75,
+
+	0xD0,0x00,0xC0,0x00,0xC0,0x01,0xC0,0x02,
+
+	0xC0,0x03,0xC0,0x04,0xC0,0x05,0xC0,0x06,
+
+	0xC0,0x07,0xC2,0xDB,0x12,0x65,0x09,0xD0,
+
+	0x07,0xD0,0x06,0xD0,0x05,0xD0,0x04,0xD0,
+
+	0x03,0xD0,0x02,0xD0,0x01,0xD0,0x00,0xD0,
+
+	0xD0,0xD0,0x86,0xD0,0x84,0xD0,0x85,0xD0,
+
+	0x82,0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,
+
+	0x90,0x45,0x18,0xE0,0x64,0x01,0x60,0x05,
+
+	0xE0,0x64,0x05,0x70,0x41,0x90,0x45,0x34,
+
+	0xE0,0x70,0x05,0x12,0x6E,0x3F,0x80,0x1B,
+
+	0x90,0x45,0x34,0xE0,0xB4,0x01,0x05,0x12,
+
+	0x6F,0xCD,0x80,0x0F,0x90,0x45,0x34,0xE0,
+
+	0x64,0x02,0x60,0x04,0xE0,0xB4,0xFF,0x03,
+
+	0x12,0x79,0x40,0x90,0x43,0x43,0xE0,0xB4,
+
+	0x01,0x14,0x90,0x44,0xDE,0xE0,0xB4,0x01,
+
+	0x0D,0x90,0xDD,0x13,0xE0,0x54,0xEF,0xF0,
+
+	0x90,0xDD,0x87,0x74,0x08,0xF0,0x22,0x12,
+
+	0x69,0x97,0x90,0xDD,0x01,0xE0,0x54,0x04,
+
+	0x90,0x44,0xC5,0xF0,0x90,0x46,0x00,0xE0,
+
+	0x60,0x03,0x12,0x75,0xD6,0x12,0x75,0xD5,
+
+	0xE4,0x90,0x44,0xDE,0xF0,0x22,0x90,0xD8,
+
+	0x06,0xE0,0x54,0xFE,0x44,0x01,0xF0,0x22,
+
+	0x12,0x69,0x97,0x90,0x45,0x11,0xE0,0x30,
+
+	0xE6,0x09,0x90,0xDD,0xA7,0xE0,0x44,0x01,
+
+	0xF0,0x80,0x07,0x90,0xDD,0x00,0xE0,0x44,
+
+	0x80,0xF0,0xD2,0xAF,0xD2,0xDD,0x22,0x90,
+
+	0x45,0x12,0xE0,0x30,0xE0,0x07,0x90,0xDD,
+
+	0xA8,0xE0,0x30,0xE2,0xF9,0x22,0x90,0xDD,
+
+	0xA7,0xE0,0x30,0xE1,0x06,0xE0,0x54,0xFD,
+
+	0xF0,0x80,0x07,0x90,0xDD,0xA7,0xE0,0x44,
+
+	0x02,0xF0,0x90,0xDD,0xA8,0xE0,0x30,0xE1,
+
+	0x08,0x90,0xDD,0x00,0xE0,0x44,0x80,0xF0,
+
+	0x22,0x90,0xDD,0x00,0xE0,0x54,0x7F,0xF0,
+
+	0x22,0xE4,0x90,0x44,0x69,0xF0,0x12,0x5C,
+
+	0x62,0x90,0x44,0xC1,0xEF,0xF0,0x60,0x25,
+
+	0xE0,0xB4,0x05,0x03,0x7F,0x05,0x22,0x12,
+
+	0x5D,0xCF,0x90,0x44,0xC1,0xEF,0xF0,0x60,
+
+	0x14,0xE0,0xB4,0x05,0x03,0x7F,0x05,0x22,
+
+	0x12,0x5F,0x20,0x90,0x44,0xC1,0xEF,0xF0,
+
+	0x60,0x03,0xE0,0xFF,0x22,0x7F,0x00,0x22,
+
+	0x90,0x43,0x5B,0xE0,0xD3,0x94,0x00,0x40,
+
+	0x06,0x90,0x44,0x68,0xEF,0xF0,0x22,0x90,
+
+	0x43,0x5A,0xE0,0xFE,0xEF,0xC3,0x9E,0x50,
+
+	0x06,0x90,0x44,0x68,0xEF,0xF0,0x22,0x90,
+
+	0x44,0x68,0xEE,0xF0,0x22,0x90,0x44,0xC2,
+
+	0xEB,0xF0,0xA3,0xEA,0xF0,0xA3,0xE9,0xF0,
+
+	0xE4,0xFF,0x90,0x44,0x68,0xE0,0xD3,0x94,
+
+	0x00,0x40,0x04,0x7E,0x01,0x80,0x02,0x7E,
+
+	0x00,0xEF,0xC3,0x94,0x40,0x50,0x04,0x7D,
+
+	0x01,0x80,0x02,0x7D,0x00,0xED,0x5E,0x60,
+
+	0x33,0x90,0x44,0xC2,0xE0,0xFB,0xA3,0xE0,
+
+	0xFA,0xA3,0xE0,0xF9,0x90,0x44,0x69,0xE0,
+
+	0xF5,0x82,0x75,0x83,0x00,0x12,0x7C,0xD8,
+
+	0xFE,0x74,0x00,0x2F,0xF5,0x82,0xE4,0x34,
+
+	0xDE,0xF5,0x83,0xEE,0xF0,0x0F,0x90,0x44,
+
+	0x68,0xE0,0x14,0xF0,0x90,0x44,0x69,0xE0,
+
+	0x04,0xF0,0x80,0xAE,0x90,0xDD,0x85,0xEF,
+
+	0xF0,0x22,0x90,0xDD,0x13,0xE0,0x44,0x01,
+
+	0xF0,0x90,0xDD,0x1B,0x74,0x04,0xF0,0xE4,
+
+	0xFF,0x74,0x00,0x2F,0xF5,0x82,0xE4,0x34,
+
+	0xDF,0xF5,0x83,0xE0,0xFE,0x74,0x54,0x2F,
+
+	0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,0xEE,
+
+	0xF0,0x0F,0xEF,0xB4,0x08,0xE3,0x90,0xDD,
+
+	0x1B,0xE0,0x20,0xE2,0xD4,0x22,0x90,0xDD,
+
+	0x13,0x74,0x7B,0xF0,0x90,0xDD,0x80,0x74,
+
+	0xC0,0xF0,0xA3,0x74,0x00,0xF0,0xA3,0x74,
+
+	0x40,0xF0,0xA3,0x74,0x80,0xF0,0x12,0x5C,
+
+	0x55,0xE4,0x90,0x43,0x62,0xF0,0x90,0x43,
+
+	0x63,0xF0,0x90,0xDD,0x14,0x74,0x0B,0xF0,
+
+	0x90,0xDD,0x17,0x74,0x06,0xF0,0x90,0x45,
+
+	0x33,0xE0,0xB4,0x01,0x07,0x90,0xDD,0x17,
+
+	0xE0,0x44,0x01,0xF0,0x90,0xDD,0x15,0x74,
+
+	0x0B,0xF0,0x90,0xDD,0x0C,0x74,0x80,0xF0,
+
+	0x90,0xDD,0x8E,0xE4,0xF0,0xA3,0x74,0x03,
+
+	0xF0,0x90,0xDD,0x0E,0xE4,0xF0,0xA3,0x04,
+
+	0xF0,0x90,0xDD,0x13,0xE0,0x54,0x7F,0xF0,
+
+	0x90,0xDD,0x20,0xE0,0x54,0xFC,0x44,0x03,
+
+	0xF0,0x90,0xDD,0x11,0x74,0x8F,0xF0,0x90,
+
+	0x45,0x18,0xE0,0x64,0x01,0x70,0x27,0xC3,
+
+	0x74,0x03,0x94,0x89,0x90,0x43,0x82,0xF0,
+
+	0x90,0x44,0x6C,0xF0,0x90,0x43,0x84,0x74,
+
+	0x02,0xF0,0x90,0x44,0x6E,0xF0,0x90,0xDD,
+
+	0x15,0xE0,0x44,0x10,0xF0,0x90,0xDD,0x11,
+
+	0xE0,0x44,0x10,0xF0,0x80,0x17,0xC3,0x74,
+
+	0xEA,0x94,0x89,0x90,0x43,0x82,0xF0,0x90,
+
+	0x44,0x6C,0xF0,0x90,0x43,0x84,0x74,0x01,
+
+	0xF0,0x90,0x44,0x6E,0xF0,0x90,0x46,0x00,
+
+	0xE0,0x60,0x03,0x12,0x75,0xD6,0x90,0xDD,
+
+	0x0C,0x74,0x80,0xF0,0x90,0xDD,0x89,0x74,
+
+	0x03,0xF0,0x90,0xDD,0x88,0x74,0xDB,0xF0,
+
+	0x90,0xDD,0x13,0xE0,0x54,0xDF,0xF0,0x90,
+
+	0xF4,0x1A,0xE0,0x54,0xFE,0x44,0x01,0xF0,
+
+	0x22,0x90,0x43,0xE0,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0xD9,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0xD2,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0xCB,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0xB4,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0xAD,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0xA6,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x43,0x9F,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x22,0x90,0x43,0xE7,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0x22,0x8F,0x82,0x8E,0x83,0xE4,
+
+	0xFF,0xFE,0xED,0x4C,0x60,0x0F,0xED,0x60,
+
+	0x01,0x0C,0xE0,0xA3,0x2F,0xFF,0xE4,0x3E,
+
+	0xFE,0xDD,0xF7,0xDC,0xF5,0x22,0x80,0x02,
+
+	0x80,0xFE,0x90,0xF1,0x03,0x74,0x25,0xF0,
+
+	0x22,0x90,0x44,0xC6,0xEF,0xF0,0xA3,0xED,
+
+	0xF0,0xA3,0xEB,0xF0,0xA3,0xE0,0xFE,0xFD,
+
+	0x7C,0x00,0x90,0x44,0xCC,0xE0,0xFA,0xA3,
+
+	0xE0,0xFB,0x2D,0xFD,0xEC,0x3A,0xFC,0xD3,
+
+	0xED,0x94,0x00,0xEC,0x94,0x01,0x40,0x03,
+
+	0x7F,0x01,0x22,0xE4,0xB5,0x03,0x08,0xEA,
+
+	0xB4,0x01,0x04,0x7F,0x08,0x80,0x0B,0xEE,
+
+	0x54,0x07,0xFF,0xC3,0x74,0x08,0x9F,0x54,
+
+	0x07,0xFF,0x90,0x44,0xCE,0xEF,0xF0,0xC3,
+
+	0xEB,0x9F,0xEA,0x94,0x00,0x50,0x06,0x90,
+
+	0x44,0xCD,0xE0,0xA3,0xF0,0x90,0x44,0xCD,
+
+	0xE0,0xFF,0xA3,0xE0,0xFE,0xC3,0xEF,0x9E,
+
+	0x54,0x07,0xFE,0x90,0x44,0xD0,0xF0,0x90,
+
+	0x44,0xCE,0xE0,0xFD,0xC3,0xEF,0x9D,0xC3,
+
+	0x9E,0xA3,0xF0,0x90,0x44,0xCE,0xE0,0x90,
+
+	0x44,0xD1,0xF0,0xA3,0x74,0x08,0xF0,0x90,
+
+	0x44,0xD0,0xE0,0x90,0x44,0xD3,0xF0,0xE4,
+
+	0xA3,0xF0,0x90,0x44,0xD4,0xE0,0xFB,0x24,
+
+	0xCE,0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,
+
+	0xE0,0x70,0x03,0x02,0x6C,0x90,0x90,0x44,
+
+	0xC9,0xE0,0x90,0xF0,0x01,0xF0,0x90,0x44,
+
+	0xC8,0xE0,0x70,0x4E,0x7E,0xF0,0x7F,0x02,
+
+	0x90,0x44,0xCA,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0x74,0xD1,0x2B,0xF5,0x82,0xE4,0x34,0x44,
+
+	0xF5,0x83,0xE0,0xFB,0x12,0x56,0x9C,0x90,
+
+	0x44,0xC6,0xE0,0xFF,0xA3,0xE0,0xFD,0x90,
+
+	0x44,0xD4,0xE0,0x24,0xD1,0xF5,0x82,0xE4,
+
+	0x34,0x44,0xF5,0x83,0xE0,0x04,0xFB,0x90,
+
+	0x41,0xBD,0x74,0x01,0xF0,0x12,0x54,0xB6,
+
+	0xEF,0x60,0x03,0x7F,0x02,0x22,0x7F,0x35,
+
+	0x7E,0x82,0x12,0x56,0xC5,0x20,0x8D,0x60,
+
+	0x80,0xFB,0x90,0x44,0xC6,0xE0,0xFF,0xA3,
+
+	0xE0,0xFD,0x90,0x41,0xBD,0x74,0x01,0xF0,
+
+	0xFB,0x12,0x54,0xB6,0xEF,0x60,0x03,0x7F,
+
+	0x02,0x22,0x90,0x44,0xC6,0xE0,0xFF,0xA3,
+
+	0xE0,0x44,0x01,0xFD,0x90,0x44,0xD4,0xE0,
+
+	0x24,0xD1,0xF5,0x82,0xE4,0x34,0x44,0xF5,
+
+	0x83,0xE0,0xFB,0x90,0x41,0xBD,0x74,0x01,
+
+	0xF0,0x12,0x54,0xB6,0xEF,0x60,0x03,0x7F,
+
+	0x02,0x22,0x90,0x44,0xCA,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x7C,0xF0,0x7D,0x00,0x90,0x44,
+
+	0xD4,0xE0,0x24,0xD1,0xF5,0x82,0xE4,0x34,
+
+	0x44,0xF5,0x83,0xE0,0xFB,0x12,0x56,0x9C,
+
+	0x90,0x44,0xD4,0xE0,0xFF,0x24,0xD1,0xF5,
+
+	0x82,0xE4,0x34,0x44,0xF5,0x83,0xE0,0xFE,
+
+	0x90,0x44,0xC9,0xE0,0x2E,0xF0,0xEE,0xFD,
+
+	0x90,0x44,0xCB,0xE0,0x2D,0xF0,0x90,0x44,
+
+	0xCA,0xE0,0x34,0x00,0xF0,0x74,0xCE,0x2F,
+
+	0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,0xC0,
+
+	0x83,0xC0,0x82,0xE0,0xFF,0x90,0x44,0xD4,
+
+	0xE0,0x24,0xD1,0xF5,0x82,0xE4,0x34,0x44,
+
+	0xF5,0x83,0xE0,0xFE,0xC3,0xEF,0x9E,0xD0,
+
+	0x82,0xD0,0x83,0xF0,0x02,0x6B,0x73,0x90,
+
+	0x44,0xD4,0xE0,0x04,0xF0,0xE0,0xC3,0x94,
+
+	0x03,0x50,0x03,0x02,0x6B,0x73,0x7F,0x00,
+
+	0x22,0x90,0x44,0xD5,0xEF,0xF0,0xE4,0x90,
+
+	0x44,0xD6,0xF0,0x90,0x44,0xD6,0xE0,0xFE,
+
+	0xC3,0x94,0x10,0x50,0x1F,0x90,0x44,0xD5,
+
+	0xE0,0xFF,0xEE,0x44,0xA0,0xFD,0x90,0x41,
+
+	0xBD,0x74,0x01,0xF0,0xFB,0x12,0x54,0xB6,
+
+	0xEF,0x60,0x09,0x90,0x44,0xD6,0xE0,0x24,
+
+	0x02,0xF0,0x80,0xD7,0x90,0x44,0xD6,0xE0,
+
+	0xFF,0xC3,0x94,0x10,0x50,0x05,0xEF,0x44,
+
+	0xA0,0xFF,0x22,0x7F,0x01,0x22,0x90,0xDF,
+
+	0x82,0xE0,0x54,0xDF,0xF0,0xE4,0x90,0x44,
+
+	0xDE,0xF0,0x90,0x44,0xDD,0xF0,0x90,0x43,
+
+	0x43,0x04,0xF0,0x90,0x41,0x81,0xF0,0x90,
+
+	0x41,0xE1,0x74,0x32,0xF0,0x90,0x41,0xE3,
+
+	0x74,0x14,0xF0,0x90,0x41,0xE2,0x74,0x3E,
+
+	0xF0,0xE4,0x90,0x44,0xE0,0xF0,0x90,0x44,
+
+	0xEB,0xF0,0x90,0x44,0xEF,0xF0,0x90,0x44,
+
+	0xF1,0xF0,0xA3,0xF0,0x90,0x44,0xE1,0xF0,
+
+	0xA3,0xF0,0x90,0x44,0xEC,0xF0,0xA3,0xF0,
+
+	0x90,0x44,0xF7,0xF0,0x90,0xDF,0x80,0x74,
+
+	0x28,0xF0,0xA3,0x74,0x04,0xF0,0x75,0xCA,
+
+	0x01,0xE4,0xF5,0xCB,0xF5,0xC8,0xD2,0xAD,
+
+	0xD2,0xCA,0x22,0x90,0xDF,0x92,0x74,0x50,
+
+	0xF0,0x12,0x6C,0xE7,0x22,0x90,0x41,0xDF,
+
+	0x74,0x7F,0xF0,0xA3,0x74,0xFF,0xF0,0x90,
+
+	0xDF,0x90,0x74,0x50,0xF0,0xE4,0xA3,0xF0,
+
+	0xA3,0x74,0x96,0xF0,0xE4,0xA3,0xF0,0xA3,
+
+	0x74,0x2C,0xF0,0xA3,0x74,0x01,0xF0,0xA3,
+
+	0x74,0x90,0xF0,0xA3,0x74,0x01,0xF0,0xA3,
+
+	0x74,0xC2,0xF0,0xA3,0x74,0x01,0xF0,0xA3,
+
+	0x74,0x26,0xF0,0xA3,0x74,0x02,0xF0,0xE4,
+
+	0xA3,0xF0,0xA3,0x74,0x10,0xF0,0xE4,0xA3,
+
+	0xF0,0xA3,0x74,0x20,0xF0,0xE4,0xA3,0xF0,
+
+	0xA3,0x74,0x40,0xF0,0x12,0x6C,0xE7,0x22,
+
+	0xC0,0xE0,0xC0,0x83,0xC0,0x82,0xC0,0x85,
+
+	0xC0,0x84,0xC0,0x86,0x75,0x86,0x00,0xC0,
+
+	0xD0,0x75,0xD0,0x00,0xC0,0x07,0xC2,0xCF,
+
+	0x90,0x44,0xE1,0xE0,0x60,0x1A,0xA3,0xE0,
+
+	0x04,0xF0,0x90,0x41,0xE3,0xE0,0xFF,0x90,
+
+	0x44,0xE2,0xE0,0xD3,0x9F,0x40,0x10,0x90,
+
+	0x44,0xE1,0xE4,0xF0,0xA3,0xF0,0x80,0x07,
+
+	0x90,0x44,0xE1,0xE4,0xF0,0xA3,0xF0,0x90,
+
+	0x44,0xF1,0xE0,0x60,0x19,0xA3,0xE0,0x04,
+
+	0xF0,0x90,0x41,0xE2,0xE0,0xFF,0x90,0x44,
+
+	0xF2,0xE0,0xD3,0x9F,0x40,0x11,0xE4,0xF0,
+
+	0x90,0x44,0xF1,0xF0,0x80,0x09,0x90,0x44,
+
+	0xF2,0xE4,0xF0,0x90,0x44,0xF1,0xF0,0xD0,
+
+	0x07,0xD0,0xD0,0xD0,0x86,0xD0,0x84,0xD0,
+
+	0x85,0xD0,0x82,0xD0,0x83,0xD0,0xE0,0x32,
+
+	0x90,0xDF,0x82,0xE0,0x30,0xE0,0x14,0x74,
+
+	0x20,0xF0,0xE0,0x90,0x44,0xD7,0xF0,0xE4,
+
+	0x90,0xDF,0x82,0xF0,0x90,0x44,0xE0,0xF0,
+
+	0x7F,0x01,0x22,0x7F,0x00,0x22,0x12,0x6E,
+
+	0x21,0xEF,0x60,0x03,0x02,0x6F,0xCC,0x90,
+
+	0xDF,0x82,0xE0,0x30,0xE1,0x03,0x02,0x6F,
+
+	0xCC,0x90,0x44,0xD9,0xE5,0xE4,0xF0,0x90,
+
+	0x44,0xE0,0xE0,0x14,0x60,0x68,0x14,0x70,
+
+	0x03,0x02,0x6F,0x51,0x24,0x02,0x60,0x03,
+
+	0x02,0x6F,0xC2,0x90,0x44,0xD9,0xE0,0x64,
+
+	0xBC,0x70,0x3B,0x90,0x44,0xEB,0xF0,0x90,
+
+	0x44,0xED,0xF0,0x90,0x44,0xEC,0xF0,0x90,
+
+	0x44,0xEF,0xF0,0x90,0x44,0xD8,0xF0,0x90,
+
+	0x44,0xD8,0xE0,0xFF,0xC3,0x94,0x08,0x50,
+
+	0x14,0x74,0xE3,0x2F,0xF5,0x82,0xE4,0x34,
+
+	0x44,0xF5,0x83,0xE4,0xF0,0x90,0x44,0xD8,
+
+	0xE0,0x04,0xF0,0x80,0xE2,0x90,0x44,0xE0,
+
+	0x74,0x01,0xF0,0x02,0x6F,0xC2,0x90,0x44,
+
+	0xD9,0xE0,0xB4,0xAC,0x09,0x90,0x44,0xE0,
+
+	0x74,0x02,0xF0,0x02,0x6F,0xC2,0xE4,0x90,
+
+	0x44,0xE0,0xF0,0x02,0x6F,0xC2,0x90,0x44,
+
+	0xD9,0xE0,0xC3,0x94,0xE8,0x40,0x17,0x12,
+
+	0x72,0x67,0xE4,0x90,0x44,0xE0,0xF0,0x90,
+
+	0x44,0xED,0xF0,0x90,0x44,0xEC,0xF0,0x90,
+
+	0x44,0xEB,0xF0,0x02,0x6F,0xC2,0x90,0x44,
+
+	0xD9,0xE0,0xB4,0x98,0x1F,0x90,0x44,0xEC,
+
+	0xE0,0xFF,0x74,0x01,0xA8,0x07,0x08,0x80,
+
+	0x02,0xC3,0x33,0xD8,0xFC,0xFF,0x90,0x44,
+
+	0xED,0xE0,0x2F,0xF0,0x90,0x44,0xEC,0xE0,
+
+	0x04,0xF0,0x80,0x1A,0x90,0x44,0xD9,0xE0,
+
+	0xB4,0x88,0x08,0x90,0x44,0xEC,0xE0,0x04,
+
+	0xF0,0x80,0x0B,0xE4,0x90,0x44,0xE0,0xF0,
+
+	0x90,0x44,0xEC,0xE0,0x04,0xF0,0x90,0x44,
+
+	0xEC,0xE0,0x64,0x08,0x60,0x03,0x02,0x6F,
+
+	0xC2,0xA3,0xE0,0xFF,0x90,0x44,0xEB,0xE0,
+
+	0xFE,0x04,0xF0,0x74,0xE3,0x2E,0xF5,0x82,
+
+	0xE4,0x34,0x44,0xF5,0x83,0xEF,0xF0,0xE4,
+
+	0x90,0x44,0xEC,0xF0,0xA3,0xF0,0x80,0x71,
+
+	0x90,0x44,0xD9,0xE0,0xC3,0x94,0xF8,0x40,
+
+	0x68,0x90,0x44,0xEF,0xE0,0x04,0xF0,0x90,
+
+	0x44,0xDE,0xE0,0x70,0x41,0x90,0x41,0xE3,
+
+	0xE0,0x75,0xF0,0x05,0x84,0xFF,0x90,0x44,
+
+	0xEF,0xE0,0xB5,0x07,0x31,0xE4,0x90,0x44,
+
+	0xD8,0xF0,0x90,0x44,0xD8,0xE0,0xFF,0x24,
+
+	0xE3,0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,
+
+	0xE0,0xFE,0x74,0x80,0x2F,0xF5,0x82,0xE4,
+
+	0x34,0xDE,0xF5,0x83,0xEE,0xF0,0x90,0x44,
+
+	0xD8,0xE0,0x04,0xF0,0xE0,0xB4,0x08,0xDA,
+
+	0x90,0x44,0xDE,0x74,0x01,0xF0,0x90,0x41,
+
+	0xE3,0xE0,0x75,0xF0,0x05,0x84,0xFF,0x90,
+
+	0x44,0xEF,0xE0,0xB5,0x07,0x02,0xE4,0xF0,
+
+	0xE4,0x90,0x44,0xE0,0xF0,0x90,0x44,0xEB,
+
+	0xF0,0x90,0xDF,0x82,0xE0,0x20,0xE1,0x03,
+
+	0x02,0x6E,0x52,0x22,0x12,0x6E,0x21,0xEF,
+
+	0x60,0x03,0x02,0x72,0x66,0x90,0xDF,0x82,
+
+	0xE0,0x30,0xE1,0x03,0x02,0x72,0x66,0x90,
+
+	0x44,0xDA,0xE5,0xE4,0xF0,0x90,0x44,0xE0,
+
+	0xE0,0x14,0x60,0x3F,0x14,0x70,0x03,0x02,
+
+	0x71,0x33,0x24,0x02,0x60,0x03,0x02,0x72,
+
+	0x5C,0x90,0x44,0xDA,0xE0,0xB4,0x8C,0x23,
+
+	0xE4,0x90,0x44,0xEB,0xF0,0xA3,0xF0,0xA3,
+
+	0xF0,0xFF,0x7F,0x03,0x90,0x44,0xF3,0xE4,
+
+	0xF0,0xA3,0xDF,0xFC,0x7F,0x03,0x90,0x44,
+
+	0xE0,0x74,0x01,0xF0,0x90,0x44,0xF8,0xF0,
+
+	0x02,0x72,0x5C,0xE4,0x90,0x44,0xE0,0xF0,
+
+	0x02,0x72,0x5C,0x90,0x44,0xDA,0xE0,0x54,
+
+	0x0F,0xA3,0xF0,0x90,0x44,0xDA,0xE0,0xFF,
+
+	0xC4,0x54,0x0F,0x90,0x44,0xDC,0xF0,0x90,
+
+	0x44,0xF8,0xE0,0x24,0xFE,0x60,0x34,0x14,
+
+	0x60,0x52,0x14,0x60,0x70,0x14,0x70,0x03,
+
+	0x02,0x70,0xDF,0x24,0x04,0x60,0x03,0x02,
+
+	0x72,0x5C,0x90,0x44,0xDB,0xE0,0xB4,0x07,
+
+	0x0E,0xA3,0xE0,0xB4,0x07,0x09,0x90,0x44,
+
+	0xF8,0x74,0x02,0xF0,0x02,0x72,0x5C,0xE4,
+
+	0x90,0x44,0xE0,0xF0,0x90,0x44,0xF8,0xF0,
+
+	0x02,0x72,0x5C,0x90,0x44,0xDB,0xE0,0xB4,
+
+	0x07,0x0E,0xA3,0xE0,0xB4,0x07,0x09,0x90,
+
+	0x44,0xF8,0x74,0x03,0xF0,0x02,0x72,0x5C,
+
+	0xE4,0x90,0x44,0xE0,0xF0,0x90,0x44,0xF8,
+
+	0xF0,0x02,0x72,0x5C,0x90,0x44,0xDB,0xE0,
+
+	0xB4,0x07,0x0E,0xA3,0xE0,0xB4,0x08,0x09,
+
+	0x90,0x44,0xF8,0x74,0x04,0xF0,0x02,0x72,
+
+	0x5C,0xE4,0x90,0x44,0xE0,0xF0,0x90,0x44,
+
+	0xF8,0xF0,0x02,0x72,0x5C,0x90,0x44,0xDB,
+
+	0xE0,0xB4,0x07,0x0E,0xA3,0xE0,0xB4,0x08,
+
+	0x09,0x90,0x44,0xF8,0x74,0x05,0xF0,0x02,
+
+	0x72,0x5C,0xE4,0x90,0x44,0xE0,0xF0,0x90,
+
+	0x44,0xF8,0xF0,0x02,0x72,0x5C,0x90,0x44,
+
+	0xDB,0xE0,0x64,0x09,0x70,0x40,0x90,0x44,
+
+	0xF3,0x74,0x08,0xF0,0x90,0x44,0xDC,0xE0,
+
+	0xB4,0x08,0x0F,0x90,0x44,0xF4,0x74,0x88,
+
+	0xF0,0xA3,0xF0,0xE4,0xA3,0xF0,0xA3,0x74,
+
+	0x03,0xF0,0x90,0x44,0xDC,0xE0,0xB4,0x07,
+
+	0x0F,0x90,0x44,0xF4,0x74,0x88,0xF0,0xE4,
+
+	0xA3,0xF0,0xA3,0xF0,0xA3,0x74,0x02,0xF0,
+
+	0x90,0x44,0xE0,0x74,0x02,0xF0,0xE4,0x90,
+
+	0x44,0xF8,0xF0,0x02,0x72,0x5C,0xE4,0x90,
+
+	0x44,0xE0,0xF0,0x90,0x44,0xF8,0xF0,0x02,
+
+	0x72,0x5C,0x90,0x44,0xDA,0xE0,0x54,0x0F,
+
+	0xA3,0xF0,0x90,0x44,0xDA,0xE0,0xFF,0xC4,
+
+	0x54,0x0F,0x90,0x44,0xDC,0xF0,0x90,0x44,
+
+	0xDB,0xE0,0xB4,0x07,0x21,0x90,0x44,0xF7,
+
+	0xE0,0xFF,0x04,0xF0,0x74,0xF3,0x2F,0xF5,
+
+	0x82,0xE4,0x34,0x44,0xF5,0x83,0x74,0x08,
+
+	0xF0,0x90,0x44,0xF7,0xE0,0x64,0x04,0x70,
+
+	0x50,0x12,0x72,0xAA,0x80,0x4B,0x90,0x44,
+
+	0xDB,0xE0,0x64,0x08,0x70,0x3E,0x90,0x44,
+
+	0xF7,0xE0,0xFF,0x04,0xF0,0x74,0xF3,0x2F,
+
+	0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,0x74,
+
+	0x08,0xF0,0x90,0x44,0xF7,0xE0,0xB4,0x04,
+
+	0x03,0x12,0x72,0xAA,0x90,0x44,0xF7,0xE0,
+
+	0xFF,0x04,0xF0,0x74,0xF3,0x2F,0xF5,0x82,
+
+	0xE4,0x34,0x44,0xF5,0x83,0x74,0x08,0xF0,
+
+	0x90,0x44,0xF7,0xE0,0xB4,0x04,0x0A,0x12,
+
+	0x72,0xAA,0x80,0x05,0xE4,0x90,0x44,0xE0,
+
+	0xF0,0x90,0x44,0xDC,0xE0,0xC3,0x94,0x0C,
+
+	0x40,0x26,0x90,0x44,0xF7,0xE0,0x94,0x04,
+
+	0x50,0x14,0xE0,0xFF,0x04,0xF0,0x74,0xF3,
+
+	0x2F,0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,
+
+	0x74,0x88,0xF0,0x12,0x72,0xAA,0x12,0x72,
+
+	0x67,0xE4,0x90,0x44,0xE0,0xF0,0x80,0x73,
+
+	0x90,0x44,0xDC,0xE0,0xB4,0x07,0x21,0x90,
+
+	0x44,0xF7,0xE0,0xFF,0x04,0xF0,0x74,0xF3,
+
+	0x2F,0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,
+
+	0x74,0x88,0xF0,0x90,0x44,0xF7,0xE0,0x64,
+
+	0x04,0x70,0x50,0x12,0x72,0xAA,0x80,0x4B,
+
+	0x90,0x44,0xDC,0xE0,0x64,0x08,0x70,0x3E,
+
+	0x90,0x44,0xF7,0xE0,0xFF,0x04,0xF0,0x74,
+
+	0xF3,0x2F,0xF5,0x82,0xE4,0x34,0x44,0xF5,
+
+	0x83,0x74,0x88,0xF0,0x90,0x44,0xF7,0xE0,
+
+	0xB4,0x04,0x03,0x12,0x72,0xAA,0x90,0x44,
+
+	0xF7,0xE0,0xFF,0x04,0xF0,0x74,0xF3,0x2F,
+
+	0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,0x74,
+
+	0x88,0xF0,0x90,0x44,0xF7,0xE0,0xB4,0x04,
+
+	0x0A,0x12,0x72,0xAA,0x80,0x05,0xE4,0x90,
+
+	0x44,0xE0,0xF0,0x90,0xDF,0x82,0xE0,0x20,
+
+	0xE1,0x03,0x02,0x6F,0xE0,0x22,0x90,0x45,
+
+	0x18,0xE0,0xB4,0x01,0x0D,0x90,0x43,0x43,
+
+	0xE0,0xB4,0x01,0x06,0x12,0x73,0x64,0xEF,
+
+	0x60,0x2E,0x90,0x44,0xE1,0xE0,0x70,0x28,
+
+	0x7E,0xDE,0x7F,0x80,0x7C,0x44,0x7D,0xE3,
+
+	0x7B,0x08,0x12,0x56,0x9C,0x90,0x44,0xE1,
+
+	0x74,0x01,0xF0,0xE4,0xA3,0xF0,0x90,0x44,
+
+	0xDD,0xE0,0x60,0x06,0x90,0x44,0xDF,0xE0,
+
+	0x04,0xF0,0x90,0x44,0xDE,0x74,0x01,0xF0,
+
+	0x22,0xE4,0xFF,0xEF,0xC3,0x94,0x04,0x50,
+
+	0x65,0x74,0xF3,0x2F,0xF5,0x82,0xE4,0x34,
+
+	0x44,0xF5,0x83,0xE0,0xFE,0xB4,0x08,0x32,
+
+	0x74,0xF4,0x2F,0xF5,0x82,0xE4,0x34,0x44,
+
+	0xF5,0x83,0xE0,0xB4,0x88,0x24,0x90,0x44,
+
+	0xEC,0xE0,0xFD,0xC3,0x74,0x07,0x9D,0xFD,
+
+	0x74,0x01,0xA8,0x05,0x08,0x80,0x02,0xC3,
+
+	0x33,0xD8,0xFC,0xFD,0x90,0x44,0xED,0xE0,
+
+	0x2D,0xF0,0x90,0x44,0xEC,0xE0,0x04,0xF0,
+
+	0x80,0x20,0xEE,0xB4,0x88,0x16,0x74,0xF4,
+
+	0x2F,0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,
+
+	0xE0,0xB4,0x08,0x08,0x90,0x44,0xEC,0xE0,
+
+	0x04,0xF0,0x80,0x06,0x90,0x44,0xEC,0xE0,
+
+	0x04,0xF0,0x0F,0x0F,0x80,0x95,0xE4,0x90,
+
+	0x44,0xF7,0xF0,0x90,0x44,0xEC,0xE0,0x64,
+
+	0x08,0x70,0x3F,0xA3,0xE0,0xFF,0x90,0x44,
+
+	0xEB,0xE0,0xFE,0x04,0xF0,0x74,0xE3,0x2E,
+
+	0xF5,0x82,0xE4,0x34,0x44,0xF5,0x83,0xEF,
+
+	0xF0,0xE4,0x90,0x44,0xEC,0xF0,0xA3,0xF0,
+
+	0x90,0x44,0xEB,0xE0,0xB4,0x04,0x1B,0x90,
+
+	0x41,0xDF,0xE0,0xFF,0x90,0x44,0xE5,0xE0,
+
+	0x5F,0xF0,0x90,0x41,0xE0,0xE0,0xFF,0x90,
+
+	0x44,0xE6,0xE0,0x5F,0xF0,0xE4,0x90,0x44,
+
+	0xEB,0xF0,0x22,0xE4,0xFD,0xFC,0x90,0x41,
+
+	0xE1,0xE0,0x75,0xF0,0x07,0xA4,0xFF,0xC3,
+
+	0xED,0x9F,0xEC,0x95,0xF0,0x40,0x03,0x02,
+
+	0x75,0x01,0x74,0xE4,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFF,0x90,0x44,
+
+	0xE3,0xE0,0xFE,0xEF,0x6E,0x60,0x03,0x02,
+
+	0x74,0xF7,0x74,0xE5,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFF,0x90,0x44,
+
+	0xE4,0xE0,0xFE,0xEF,0x6E,0x60,0x03,0x02,
+
+	0x74,0xF7,0x74,0xE6,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFF,0x90,0x44,
+
+	0xE5,0xE0,0xFE,0xEF,0x6E,0x60,0x03,0x02,
+
+	0x74,0xF7,0x74,0xE7,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFF,0x90,0x44,
+
+	0xE6,0xE0,0xFE,0xEF,0x6E,0x60,0x03,0x02,
+
+	0x74,0xF7,0x74,0xEA,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFE,0x30,0xE7,
+
+	0x0B,0x90,0x44,0xF1,0x74,0x01,0xF0,0xE4,
+
+	0xA3,0xF0,0xFF,0x22,0x90,0x44,0xF1,0xE0,
+
+	0x60,0x3D,0xE4,0xF0,0xA3,0xF0,0xEE,0x64,
+
+	0x40,0x70,0x2B,0x90,0x44,0xE3,0xF0,0xA3,
+
+	0xF0,0x74,0xEF,0x2D,0xF5,0x82,0x74,0x41,
+
+	0x3C,0xF5,0x83,0xE0,0x90,0x44,0xE5,0xF0,
+
+	0xE4,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,
+
+	0xF0,0xA3,0xF0,0x90,0x44,0xF1,0x04,0xF0,
+
+	0xE4,0xA3,0xF0,0x7F,0x01,0x22,0xE4,0x90,
+
+	0x44,0xF1,0xF0,0xA3,0xF0,0xFF,0x22,0xE4,
+
+	0x90,0x44,0xE3,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0xA3,0xF0,0x74,0xE9,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFE,0x70,0x1F,
+
+	0x74,0xEA,0x2D,0xF5,0x82,0x74,0x41,0x3C,
+
+	0xF5,0x83,0xE0,0x70,0x12,0x74,0xE8,0x2D,
+
+	0xF5,0x82,0x74,0x41,0x3C,0xF5,0x83,0xE0,
+
+	0x90,0x44,0xE5,0xF0,0x7F,0x01,0x22,0xEE,
+
+	0x70,0x20,0x74,0xEA,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xB4,0x40,0x12,
+
+	0x74,0xE8,0x2D,0xF5,0x82,0x74,0x41,0x3C,
+
+	0xF5,0x83,0xE0,0x90,0x44,0xE5,0xF0,0x7F,
+
+	0x01,0x22,0x74,0xE9,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0xFF,0x60,0x16,
+
+	0x90,0x44,0xE3,0xF0,0x74,0xE8,0x2D,0xF5,
+
+	0x82,0x74,0x41,0x3C,0xF5,0x83,0xE0,0x90,
+
+	0x44,0xE5,0xF0,0x7F,0x01,0x22,0x74,0xEA,
+
+	0x2D,0xF5,0x82,0x74,0x41,0x3C,0xF5,0x83,
+
+	0xE0,0x30,0xE0,0x18,0x90,0x44,0xE5,0x74,
+
+	0x9A,0xF0,0x74,0xE8,0x2D,0xF5,0x82,0x74,
+
+	0x41,0x3C,0xF5,0x83,0xE0,0x90,0x44,0xE6,
+
+	0xF0,0x7F,0x01,0x22,0x74,0xE8,0x2D,0xF5,
+
+	0x82,0x74,0x41,0x3C,0xF5,0x83,0xE0,0x90,
+
+	0x44,0xE5,0xF0,0x7F,0x01,0x22,0x74,0x07,
+
+	0x2D,0xFD,0xE4,0x3C,0xFC,0x02,0x73,0x67,
+
+	0x7F,0x00,0x22,0xAE,0x07,0x90,0x41,0xDE,
+
+	0xE0,0xFD,0xB4,0x01,0x03,0x7F,0x03,0x22,
+
+	0xAF,0x06,0xE4,0x90,0x44,0xC9,0xF0,0x7A,
+
+	0x45,0x7B,0x00,0xA3,0x74,0x45,0xF0,0xA3,
+
+	0x74,0x00,0xF0,0xA3,0x74,0x01,0xF0,0xA3,
+
+	0xE4,0xF0,0x7B,0x01,0x12,0x6A,0xEA,0xEF,
+
+	0x60,0x03,0x7F,0x04,0x22,0x7E,0x45,0x7F,
+
+	0x02,0x90,0x45,0x02,0xE0,0xFD,0x7C,0x00,
+
+	0x12,0x6A,0xC4,0x90,0x45,0x00,0xE0,0x6E,
+
+	0x70,0x03,0xA3,0xE0,0x6F,0x60,0x03,0x7F,
+
+	0x05,0x22,0x7F,0x00,0x22,0x90,0x45,0x08,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x43,0x6C,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0x90,0x45,0x0A,0xE0,
+
+	0xFF,0xA3,0xE0,0x90,0x43,0x6E,0xCF,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x45,0x0C,0xE0,0xFF,
+
+	0xA3,0xE0,0x90,0x43,0x70,0xCF,0xF0,0xA3,
+
+	0xEF,0xF0,0x90,0x45,0x0E,0xE0,0x90,0x43,
+
+	0x72,0xF0,0x90,0x45,0x0F,0xE0,0x90,0x43,
+
+	0x73,0xF0,0x90,0x45,0x10,0xE0,0x90,0x43,
+
+	0x74,0xF0,0x90,0x45,0x15,0xE0,0x90,0x44,
+
+	0x02,0xF0,0x90,0x45,0x13,0xE0,0x90,0x43,
+
+	0x88,0xF0,0x90,0x45,0x11,0xE0,0xFF,0x90,
+
+	0x44,0x71,0xF0,0x90,0x43,0x87,0xF0,0x90,
+
+	0x45,0x14,0xE0,0x90,0x44,0x72,0xF0,0x90,
+
+	0x45,0x16,0xE0,0x90,0xF1,0x03,0xF0,0x90,
+
+	0x45,0x56,0xE0,0xF4,0x60,0x05,0xE0,0x90,
+
+	0xDD,0x93,0xF0,0x22,0x22,0x90,0x45,0x04,
+
+	0xE0,0x70,0x03,0x02,0x78,0x4A,0x90,0x45,
+
+	0x04,0xE0,0x75,0xF0,0x08,0xA4,0x90,0x44,
+
+	0xF9,0xF0,0xE0,0x24,0x01,0xF5,0x82,0xE4,
+
+	0x34,0x45,0xF5,0x83,0xE0,0x90,0x44,0xFC,
+
+	0xF0,0x90,0x44,0xFC,0xE0,0x70,0x03,0x02,
+
+	0x78,0x4A,0x90,0x44,0xF9,0xE0,0xFE,0x24,
+
+	0x02,0xA3,0xF0,0x74,0x00,0x2E,0xF5,0x82,
+
+	0xE4,0x34,0x45,0xF5,0x83,0xE0,0x90,0x44,
+
+	0xFB,0xF0,0xE0,0x54,0xC0,0xFF,0x70,0x06,
+
+	0x90,0x44,0xC5,0xE0,0x70,0x16,0xBF,0x40,
+
+	0x06,0x90,0x44,0xC5,0xE0,0x60,0x0D,0x90,
+
+	0x44,0xFB,0xE0,0x54,0xC0,0x64,0xC0,0x60,
+
+	0x03,0x02,0x77,0xD7,0x90,0x44,0xFB,0xE0,
+
+	0x54,0x03,0x14,0x60,0x54,0x14,0x70,0x03,
+
+	0x02,0x76,0xEF,0x14,0x70,0x03,0x02,0x77,
+
+	0x6D,0x24,0x03,0x60,0x03,0x02,0x77,0xD7,
+
+	0xE4,0x90,0x44,0xFD,0xF0,0x90,0x44,0xFC,
+
+	0xE0,0xFF,0xA3,0xE0,0xC3,0x9F,0x40,0x03,
+
+	0x02,0x77,0xD7,0x90,0x44,0xFA,0xE0,0xFE,
+
+	0x24,0x00,0xF5,0x82,0xE4,0x34,0x45,0xF5,
+
+	0x83,0xE0,0xFF,0x74,0x01,0x2E,0xF5,0x82,
+
+	0xE4,0x34,0x45,0xF5,0x83,0xE0,0xFD,0x12,
+
+	0x64,0xEF,0x90,0x44,0xFA,0xE0,0x24,0x02,
+
+	0xF0,0x90,0x44,0xFD,0xE0,0x04,0xF0,0x80,
+
+	0xC4,0xE4,0x90,0x44,0xFD,0xF0,0x90,0x44,
+
+	0xFC,0xE0,0xFF,0xA3,0xE0,0xC3,0x9F,0x40,
+
+	0x03,0x02,0x77,0xD7,0x90,0x44,0xFA,0xE0,
+
+	0xFF,0x24,0x02,0xF5,0x82,0xE4,0x34,0x45,
+
+	0xF5,0x83,0xE0,0xFD,0x74,0x00,0x2F,0xF5,
+
+	0x82,0xE4,0x34,0x45,0xF5,0x83,0xE0,0xFE,
+
+	0x90,0x44,0xFA,0xE0,0x24,0x01,0xF5,0x82,
+
+	0xE4,0x34,0x45,0xF5,0x83,0xE0,0xFB,0xEE,
+
+	0xEB,0xF5,0x82,0x8E,0x83,0xED,0xF0,0x90,
+
+	0x44,0xFA,0xE0,0x24,0x03,0xF0,0x90,0x44,
+
+	0xFD,0xE0,0x04,0xF0,0x80,0xB0,0x90,0x44,
+
+	0xFA,0xE0,0xFD,0x24,0x00,0xF5,0x82,0xE4,
+
+	0x34,0x45,0xF5,0x83,0xE0,0xFE,0x74,0x01,
+
+	0x2D,0xF5,0x82,0xE4,0x34,0x45,0xF5,0x83,
+
+	0xE0,0xFD,0xEE,0xED,0xFF,0x90,0x44,0xFE,
+
+	0xEE,0xF0,0xA3,0xEF,0xF0,0x90,0x44,0xFA,
+
+	0xE0,0x24,0x02,0xF0,0xE4,0x90,0x44,0xFD,
+
+	0xF0,0x90,0x44,0xFC,0xE0,0xFF,0xA3,0xE0,
+
+	0xC3,0x9F,0x40,0x03,0x02,0x77,0xD7,0x90,
+
+	0x44,0xFA,0xE0,0xFF,0x24,0x01,0xF5,0x82,
+
+	0xE4,0x34,0x45,0xF5,0x83,0xE0,0xFE,0x74,
+
+	0x00,0x2F,0xF5,0x82,0xE4,0x34,0x45,0xF5,
+
+	0x83,0xE0,0xFD,0x90,0x44,0xFF,0xE0,0x2D,
+
+	0xFD,0x90,0x44,0xFE,0xE0,0x34,0x00,0x8D,
+
+	0x82,0xF5,0x83,0xEE,0xF0,0x90,0x44,0xFA,
+
+	0xE0,0x24,0x02,0xF0,0x90,0x44,0xFD,0xE0,
+
+	0x04,0xF0,0x80,0xB5,0x90,0x44,0xFA,0xE0,
+
+	0xFD,0x24,0x00,0xF5,0x82,0xE4,0x34,0x45,
+
+	0xF5,0x83,0xE0,0xFE,0x74,0x01,0x2D,0xF5,
+
+	0x82,0xE4,0x34,0x45,0xF5,0x83,0xE0,0xFD,
+
+	0xEE,0xED,0xFF,0x90,0x44,0xFE,0xEE,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x44,0xFA,0xE0,0x24,
+
+	0x02,0xF0,0xE4,0x90,0x44,0xFD,0xF0,0x90,
+
+	0x44,0xFC,0xE0,0xFF,0xA3,0xE0,0xC3,0x9F,
+
+	0x50,0x2C,0x90,0x44,0xFA,0xE0,0xFF,0x04,
+
+	0xF0,0x74,0x00,0x2F,0xF5,0x82,0xE4,0x34,
+
+	0x45,0xF5,0x83,0xE0,0xFF,0x90,0x44,0xFE,
+
+	0xE4,0x75,0xF0,0x01,0x12,0x7D,0x82,0x85,
+
+	0xF0,0x82,0xF5,0x83,0xEF,0xF0,0x90,0x44,
+
+	0xFD,0xE0,0x04,0xF0,0x80,0xC9,0x90,0x44,
+
+	0xF9,0xE0,0x24,0x02,0xF0,0x90,0x44,0xFB,
+
+	0xE0,0x54,0x03,0x14,0x60,0x19,0x14,0x60,
+
+	0x27,0x14,0x60,0x38,0x24,0x03,0x70,0x44,
+
+	0x90,0x44,0xFC,0xE0,0x25,0xE0,0xFF,0x90,
+
+	0x44,0xF9,0xE0,0x2F,0xF0,0x80,0x35,0x90,
+
+	0x44,0xFC,0xE0,0x75,0xF0,0x03,0xA4,0xFF,
+
+	0x90,0x44,0xF9,0xE0,0x2F,0xF0,0x80,0x24,
+
+	0x90,0x44,0xF9,0xE0,0x24,0x02,0xFF,0x90,
+
+	0x44,0xFC,0xE0,0x25,0xE0,0x2F,0x90,0x44,
+
+	0xF9,0xF0,0x80,0x10,0x90,0x44,0xF9,0xE0,
+
+	0x24,0x02,0xFF,0x90,0x44,0xFC,0xE0,0x2F,
+
+	0x90,0x44,0xF9,0xF0,0x90,0x44,0xF9,0xE0,
+
+	0x24,0x01,0xF5,0x82,0xE4,0x34,0x45,0xF5,
+
+	0x83,0xE0,0x90,0x44,0xFC,0xF0,0x02,0x75,
+
+	0xFA,0x22,0x90,0x44,0xB8,0xE0,0x60,0x08,
+
+	0x90,0x46,0x01,0x74,0x01,0xF0,0x80,0x06,
+
+	0x90,0x46,0x01,0x74,0x03,0xF0,0x12,0x56,
+
+	0xBB,0x12,0x6A,0xDF,0x90,0xF1,0x03,0xE0,
+
+	0x90,0x41,0x91,0xF0,0x90,0xF6,0xB5,0xE0,
+
+	0x54,0xF7,0x44,0x08,0xF0,0xE0,0x54,0xF7,
+
+	0xF0,0x90,0x41,0x91,0xE0,0x90,0xF1,0x03,
+
+	0xF0,0x90,0x46,0x01,0xE0,0xFF,0x12,0x6C,
+
+	0xA2,0x90,0x41,0xDE,0xEF,0xF0,0x90,0x44,
+
+	0xB8,0xE0,0x60,0x03,0x12,0x5A,0x5A,0x90,
+
+	0x46,0x01,0xE0,0xFF,0x12,0x75,0x04,0xEF,
+
+	0x70,0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,
+
+	0x90,0x46,0x00,0xEF,0xF0,0x60,0x1C,0x90,
+
+	0x45,0x57,0xE0,0x60,0x16,0xE0,0x90,0xF6,
+
+	0x32,0xF0,0x90,0x45,0x57,0xE0,0x90,0xF6,
+
+	0x33,0xF0,0x90,0xF6,0x31,0xE0,0x54,0xFE,
+
+	0x44,0x01,0xF0,0x90,0x46,0x00,0xE0,0x60,
+
+	0x07,0x12,0x75,0x56,0x12,0x75,0xD6,0x22,
+
+	0x90,0x44,0xB8,0xE0,0x60,0x1E,0xE4,0x90,
+
+	0x45,0x31,0xF0,0x90,0x45,0x33,0xF0,0x90,
+
+	0x45,0x12,0xF0,0x90,0x45,0x18,0x74,0x05,
+
+	0xF0,0xE4,0x90,0x45,0x34,0xF0,0x90,0x45,
+
+	0x11,0x74,0x80,0xF0,0x22,0xE4,0x90,0x46,
+
+	0x06,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0xA3,0xF0,0x90,0xDF,0x84,0x74,0x64,0xF0,
+
+	0xE4,0x90,0xDF,0x85,0xF0,0x90,0xDF,0x86,
+
+	0x74,0x2C,0xF0,0x90,0xDF,0x87,0x74,0x01,
+
+	0xF0,0xE4,0x90,0xDF,0x88,0xF0,0x90,0xDF,
+
+	0x89,0x74,0x02,0xF0,0x12,0x6C,0xE7,0x90,
+
+	0xDF,0x82,0xE0,0x20,0xE1,0x08,0x90,0x46,
+
+	0x05,0xE5,0xE4,0xF0,0x80,0xF1,0x22,0x90,
+
+	0xDF,0x82,0xE0,0x30,0xE0,0x0E,0x74,0x20,
+
+	0xF0,0xE0,0x90,0x46,0x02,0xF0,0xE4,0x90,
+
+	0xDF,0x82,0xF0,0x22,0x90,0xDF,0x82,0xE0,
+
+	0x30,0xE1,0x03,0x02,0x7B,0x3D,0x90,0x46,
+
+	0x02,0xE5,0xE4,0xF0,0xE0,0x54,0x0F,0xA3,
+
+	0xF0,0x90,0x46,0x02,0xE0,0xFF,0xC4,0x54,
+
+	0x0F,0x90,0x46,0x04,0xF0,0x90,0x44,0xE0,
+
+	0xE0,0x14,0x70,0x03,0x02,0x7A,0x25,0x04,
+
+	0x60,0x03,0x02,0x7A,0x92,0x90,0x46,0x07,
+
+	0xE0,0x25,0xE0,0xF0,0x90,0x46,0x06,0xE0,
+
+	0x33,0xF0,0xA3,0xE0,0x44,0x01,0xF0,0xA3,
+
+	0xE0,0x04,0xF0,0x90,0x46,0x02,0xE0,0x24,
+
+	0xEF,0x70,0x03,0x02,0x7A,0x92,0x24,0xEF,
+
+	0x60,0x20,0x24,0x10,0x70,0x37,0x90,0x46,
+
+	0x07,0xE0,0x25,0xE0,0xF0,0x90,0x46,0x06,
+
+	0xE0,0x33,0xF0,0x90,0x46,0x08,0xE0,0x04,
+
+	0xF0,0x90,0x44,0xE0,0x74,0x01,0xF0,0x02,
+
+	0x7A,0x92,0x90,0x46,0x07,0xE0,0x25,0xE0,
+
+	0xF0,0x90,0x46,0x06,0xE0,0x33,0xF0,0x90,
+
+	0x46,0x08,0xE0,0x04,0xF0,0xE4,0x90,0x44,
+
+	0xE0,0xF0,0x02,0x7A,0x92,0x90,0x46,0x03,
+
+	0xE0,0xB4,0x02,0x13,0x90,0x46,0x07,0xE0,
+
+	0x25,0xE0,0xF0,0x90,0x46,0x06,0xE0,0x33,
+
+	0xF0,0x90,0x46,0x08,0xE0,0x04,0xF0,0x90,
+
+	0x46,0x04,0xE0,0xD3,0x94,0x02,0x40,0x14,
+
+	0x90,0x46,0x03,0xE0,0x64,0x01,0x60,0x04,
+
+	0xE0,0xB4,0x02,0x08,0x90,0x46,0x04,0x74,
+
+	0xFF,0xF0,0x80,0x75,0x90,0x46,0x04,0x74,
+
+	0xFE,0xF0,0x80,0x6D,0x90,0x46,0x02,0xE0,
+
+	0x24,0xDF,0x60,0x1F,0x24,0x10,0x70,0x35,
+
+	0x90,0x46,0x07,0xE0,0x25,0xE0,0xF0,0x90,
+
+	0x46,0x06,0xE0,0x33,0xF0,0x90,0x46,0x08,
+
+	0xE0,0x04,0xF0,0x90,0x44,0xE0,0x74,0x01,
+
+	0xF0,0x80,0x46,0x90,0x46,0x07,0xE0,0x25,
+
+	0xE0,0xF0,0x90,0x46,0x06,0xE0,0x33,0xF0,
+
+	0x90,0x46,0x08,0xE0,0x04,0xF0,0xE4,0x90,
+
+	0x44,0xE0,0xF0,0x80,0x2C,0x90,0x46,0x07,
+
+	0xE0,0x25,0xE0,0xF0,0x90,0x46,0x06,0xE0,
+
+	0x33,0xF0,0x90,0x46,0x08,0xE0,0x04,0xF0,
+
+	0x90,0x46,0x03,0xE0,0xB4,0x01,0x0C,0xA3,
+
+	0xE0,0xD3,0x94,0x02,0x40,0x05,0x74,0xFF,
+
+	0xF0,0x80,0x06,0x90,0x46,0x04,0x74,0xFE,
+
+	0xF0,0x90,0x46,0x04,0xE0,0xD3,0x94,0x0F,
+
+	0x50,0x03,0x02,0x79,0x55,0x90,0x46,0x08,
+
+	0xE0,0xFF,0xD3,0x94,0x10,0x50,0x7E,0xEF,
+
+	0x94,0x0A,0x40,0x79,0x90,0x46,0x04,0xE0,
+
+	0xF4,0x70,0x72,0xFF,0x7F,0x08,0x90,0x44,
+
+	0xE3,0xE4,0xF0,0xA3,0xDF,0xFC,0x7F,0x08,
+
+	0x90,0x45,0x34,0xE0,0xB4,0xFF,0x1A,0x90,
+
+	0x46,0x06,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x46,0x09,0xE0,0x6E,0x70,0x03,0xA3,0xE0,
+
+	0x6F,0x60,0x06,0x90,0x44,0xE3,0x74,0x01,
+
+	0xF0,0x90,0x46,0x06,0xE0,0xFF,0xA3,0xE0,
+
+	0x90,0x46,0x09,0xCF,0xF0,0xA3,0xEF,0xF0,
+
+	0x90,0x46,0x06,0xE0,0x54,0xF7,0xF0,0x90,
+
+	0x45,0x34,0xE0,0xB4,0xFF,0x12,0x90,0x46,
+
+	0x09,0xE0,0x90,0x44,0xE5,0xF0,0x90,0x46,
+
+	0x0A,0xE0,0x90,0x44,0xE6,0xF0,0x80,0x10,
+
+	0x90,0x46,0x06,0xE0,0x90,0x44,0xE5,0xF0,
+
+	0x90,0x46,0x07,0xE0,0x90,0x44,0xE6,0xF0,
+
+	0x12,0x72,0x67,0x80,0x07,0xE4,0x90,0x46,
+
+	0x09,0xF0,0xA3,0xF0,0xE4,0x90,0x46,0x06,
+
+	0xF0,0xA3,0xF0,0xA3,0xF0,0x90,0x44,0xE0,
+
+	0xF0,0x02,0x79,0x55,0x22,0x90,0x41,0x92,
+
+	0xE0,0x70,0x0A,0x90,0xF1,0x02,0xE0,0x54,
+
+	0xFE,0x44,0x01,0xF0,0x22,0x90,0x41,0x96,
+
+	0xE0,0x90,0xF1,0x03,0xF0,0x90,0x83,0xFE,
+
+	0xE0,0x54,0xFE,0x44,0x01,0xF0,0xE0,0x54,
+
+	0xFE,0xF0,0xE0,0x54,0xFE,0x44,0x01,0xF0,
+
+	0xE0,0x54,0xFE,0xF0,0x12,0x56,0xBB,0xC2,
+
+	0xAF,0x90,0x41,0x93,0xE0,0xFF,0x90,0xF1,
+
+	0x01,0xE0,0x8F,0xF0,0xA4,0xFF,0xAE,0xF0,
+
+	0x90,0x41,0x94,0xE0,0x7C,0x00,0x2F,0xF5,
+
+	0x17,0xEC,0x3E,0xF5,0x16,0xE4,0xF5,0x18,
+
+	0xF5,0x14,0xF5,0x15,0xC3,0xE5,0x15,0x95,
+
+	0x17,0xE5,0x14,0x95,0x16,0x50,0x6A,0xE5,
+
+	0x15,0x45,0x14,0x70,0x16,0x90,0xF1,0x02,
+
+	0xE0,0x54,0xFE,0x44,0x01,0xF0,0x90,0x83,
+
+	0xFE,0xE0,0x54,0xFE,0x44,0x01,0xF0,0xE0,
+
+	0x54,0xFE,0xF0,0xE5,0x18,0x25,0xE0,0x24,
+
+	0x99,0xF5,0x82,0xE4,0x34,0x41,0xF5,0x83,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x12,0x7C,0x73,
+
+	0x7E,0x00,0xE5,0x15,0x54,0x01,0x24,0x95,
+
+	0xF5,0x82,0xEE,0x34,0x41,0xF5,0x83,0xE0,
+
+	0x90,0xF1,0x03,0xF0,0x90,0x83,0xFE,0xE0,
+
+	0x54,0xFE,0x44,0x01,0xF0,0xE0,0x54,0xFE,
+
+	0xF0,0x05,0x15,0xE5,0x15,0x70,0x02,0x05,
+
+	0x14,0x74,0x0B,0x25,0x18,0xF5,0x82,0xE4,
+
+	0x34,0x46,0xF5,0x83,0xE0,0xF5,0x18,0x80,
+
+	0x8B,0xD2,0xAF,0xE4,0x22,0xE4,0xFF,0x90,
+
+	0x41,0x98,0xE0,0xFE,0x90,0x41,0x97,0xE0,
+
+	0xFD,0x2E,0x14,0xFE,0xEF,0xC3,0x9E,0x50,
+
+	0x12,0xEF,0x04,0xFE,0x74,0x0B,0x2F,0xF5,
+
+	0x82,0xE4,0x34,0x46,0xF5,0x83,0xEE,0xF0,
+
+	0x0F,0x80,0xDC,0x74,0x0B,0x2F,0xF5,0x82,
+
+	0xE4,0x34,0x46,0xF5,0x83,0xED,0xF0,0x22,
+
+	0xE4,0x90,0x41,0x92,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0xA3,0x14,0xF0,0xA3,0x74,0xFF,0xF0,
+
+	0xA3,0x74,0x07,0xF0,0xA3,0x74,0x01,0xF0,
+
+	0xA3,0x04,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x77,0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,
+
+	0x40,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x24,
+
+	0xF0,0x22,0xC0,0x07,0x85,0x06,0x07,0x12,
+
+	0x7C,0x8F,0xD0,0xE0,0xC0,0xE0,0xC4,0x54,
+
+	0x0F,0xFF,0x12,0x7C,0xAF,0xD0,0xE0,0x54,
+
+	0x0F,0xFF,0x12,0x7C,0xC0,0x22,0xEF,0x70,
+
+	0x02,0x80,0x0B,0x80,0x00,0xC0,0x07,0x12,
+
+	0x7C,0xA0,0xD0,0x07,0xDF,0xF7,0x22,0x7F,
+
+	0x0C,0x12,0x7C,0xAF,0x7F,0x04,0x90,0x7C,
+
+	0xA0,0xE0,0xDF,0xFD,0xE0,0x22,0xEF,0x70,
+
+	0x02,0x80,0x0B,0x80,0x00,0x90,0x7C,0xB6,
+
+	0xE0,0xE0,0xE0,0x04,0xDF,0xF7,0x22,0x90,
+
+	0x7C,0xC8,0xEF,0xF4,0x54,0x0F,0x73,0x04,
+
+	0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
+
+	0x04,0x04,0x04,0x04,0x04,0x04,0x22,0xBB,
+
+	0x01,0x0C,0xE5,0x82,0x29,0xF5,0x82,0xE5,
+
+	0x83,0x3A,0xF5,0x83,0xE0,0x22,0x50,0x06,
+
+	0xE9,0x25,0x82,0xF8,0xE6,0x22,0xBB,0xFE,
+
+	0x06,0xE9,0x25,0x82,0xF8,0xE2,0x22,0xE5,
+
+	0x82,0x29,0xF5,0x82,0xE5,0x83,0x3A,0xF5,
+
+	0x83,0xE4,0x93,0x22,0xEF,0x8D,0xF0,0xA4,
+
+	0xA8,0xF0,0xCF,0x8C,0xF0,0xA4,0x28,0xCE,
+
+	0x8D,0xF0,0xA4,0x2E,0xFE,0x22,0xBC,0x00,
+
+	0x0B,0xBE,0x00,0x29,0xEF,0x8D,0xF0,0x84,
+
+	0xFF,0xAD,0xF0,0x22,0xE4,0xCC,0xF8,0x75,
+
+	0xF0,0x08,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+
+	0xEC,0x33,0xFC,0xEE,0x9D,0xEC,0x98,0x40,
+
+	0x05,0xFC,0xEE,0x9D,0xFE,0x0F,0xD5,0xF0,
+
+	0xE9,0xE4,0xCE,0xFD,0x22,0xED,0xF8,0xF5,
+
+	0xF0,0xEE,0x84,0x20,0xD2,0x1C,0xFE,0xAD,
+
+	0xF0,0x75,0xF0,0x08,0xEF,0x2F,0xFF,0xED,
+
+	0x33,0xFD,0x40,0x07,0x98,0x50,0x06,0xD5,
+
+	0xF0,0xF2,0x22,0xC3,0x98,0xFD,0x0F,0xD5,
+
+	0xF0,0xEA,0x22,0xC5,0xF0,0xF8,0xA3,0xE0,
+
+	0x28,0xF0,0xC5,0xF0,0xF8,0xE5,0x82,0x15,
+
+	0x82,0x70,0x02,0x15,0x83,0xE0,0x38,0xF0,
+
+	0x22,0xA3,0xF8,0xE0,0xC5,0xF0,0x25,0xF0,
+
+	0xF0,0xE5,0x82,0x15,0x82,0x70,0x02,0x15,
+
+	0x83,0xE0,0xC8,0x38,0xF0,0xE8,0x22,0xE8,
+
+	0x8F,0xF0,0xA4,0xCC,0x8B,0xF0,0xA4,0x2C,
+
+	0xFC,0xE9,0x8E,0xF0,0xA4,0x2C,0xFC,0x8A,
+
+	0xF0,0xED,0xA4,0x2C,0xFC,0xEA,0x8E,0xF0,
+
+	0xA4,0xCD,0xA8,0xF0,0x8B,0xF0,0xA4,0x2D,
+
+	0xCC,0x38,0x25,0xF0,0xFD,0xE9,0x8F,0xF0,
+
+	0xA4,0x2C,0xCD,0x35,0xF0,0xFC,0xEB,0x8E,
+
+	0xF0,0xA4,0xFE,0xA9,0xF0,0xEB,0x8F,0xF0,
+
+	0xA4,0xCF,0xC5,0xF0,0x2E,0xCD,0x39,0xFE,
+
+	0xE4,0x3C,0xFC,0xEA,0xA4,0x2D,0xCE,0x35,
+
+	0xF0,0xFD,0xE4,0x3C,0xFC,0x22,0x75,0xF0,
+
+	0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+
+	0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+
+	0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+
+	0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+
+	0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+
+	0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+
+	0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+
+	0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+
+	0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+
+	0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+
+	0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+
+	0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+
+	0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+
+	0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+
+	0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+
+	0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+
+	0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+
+	0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+
+	0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+
+	0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+
+	0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+
+	0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+
+	0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+
+	0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+
+	0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+
+	0xE4,0xC8,0xF9,0x22,0xD0,0x83,0xD0,0x82,
+
+	0xF8,0xE4,0x93,0x70,0x12,0x74,0x01,0x93,
+
+	0x70,0x0D,0xA3,0xA3,0x93,0xF8,0x74,0x01,
+
+	0x93,0xF5,0x82,0x88,0x83,0xE4,0x73,0x74,
+
+	0x02,0x93,0x68,0x60,0xEF,0xA3,0xA3,0xA3,
+
+	0x80,0xDF,0x8A,0x83,0x89,0x82,0xE4,0x73,
+
+	0xE7,0x09,0xF6,0x08,0xDF,0xFA,0x80,0x46,
+
+	0xE7,0x09,0xF2,0x08,0xDF,0xFA,0x80,0x3E,
+
+	0x88,0x82,0x8C,0x83,0xE7,0x09,0xF0,0xA3,
+
+	0xDF,0xFA,0x80,0x32,0xE3,0x09,0xF6,0x08,
+
+	0xDF,0xFA,0x80,0x6E,0xE3,0x09,0xF2,0x08,
+
+	0xDF,0xFA,0x80,0x66,0x88,0x82,0x8C,0x83,
+
+	0xE3,0x09,0xF0,0xA3,0xDF,0xFA,0x80,0x5A,
+
+	0x89,0x82,0x8A,0x83,0xE0,0xA3,0xF6,0x08,
+
+	0xDF,0xFA,0x80,0x4E,0x89,0x82,0x8A,0x83,
+
+	0xE0,0xA3,0xF2,0x08,0xDF,0xFA,0x80,0x42,
+
+	0x80,0xD2,0x80,0xFA,0x80,0xC6,0x80,0xD4,
+
+	0x80,0x55,0x80,0xF2,0x80,0x29,0x80,0x10,
+
+	0x80,0xA6,0x80,0xEA,0x80,0x9A,0x80,0xA8,
+
+	0x80,0xDA,0x80,0xE2,0x80,0xCA,0x80,0x29,
+
+	0x88,0x84,0x8C,0x85,0x89,0x82,0x8A,0x83,
+
+	0xE4,0x93,0xA3,0x05,0x86,0xF0,0xA3,0x05,
+
+	0x86,0xDF,0xF5,0xDE,0xF3,0x80,0x0B,0x89,
+
+	0x82,0x8A,0x83,0xE4,0x93,0xA3,0xF6,0x08,
+
+	0xDF,0xF9,0xEC,0xFA,0xA9,0xF0,0xED,0xFB,
+
+	0x22,0x88,0x84,0x8C,0x85,0x89,0x82,0x8A,
+
+	0x83,0xE0,0xA3,0x05,0x86,0xF0,0xA3,0x05,
+
+	0x86,0xDF,0xF6,0xDE,0xF4,0x80,0xE3,0x89,
+
+	0x82,0x8A,0x83,0xE4,0x93,0xA3,0xF2,0x08,
+
+	0xDF,0xF9,0x80,0xD6,0x88,0xF0,0xEF,0x60,
+
+	0x01,0x0E,0x4E,0x60,0xCD,0x88,0xF0,0xED,
+
+	0x24,0x02,0xB4,0x04,0x00,0x50,0xC3,0xF5,
+
+	0x82,0xEB,0x24,0x02,0xB4,0x04,0x00,0x50,
+
+	0xB9,0x23,0x23,0x45,0x82,0x23,0x90,0x7F,
+
+	0x31,0x73,0x12,0x01,0x00,0x02,0x00,0x00,
+
+	0x00,0x40,0xA4,0x15,0x50,0x03,0x00,0x02,
+
+	0x00,0x00,0x00,0x01,0x0A,0x06,0x00,0x02,
+
+	0x00,0x00,0x00,0x40,0x01,0x00,0x09,0x07,
+
+	0x35,0x00,0x01,0x01,0x00,0x80,0xFA,0x09,
+
+	0x02,0x35,0x00,0x01,0x01,0x00,0x80,0xFA,
+
+	0x09,0x04,0x00,0x00,0x05,0xFF,0x00,0x00,
+
+	0x00,0x07,0x05,0x81,0x02,0x40,0x00,0x00,
+
+	0x07,0x05,0x02,0x02,0x40,0x00,0x00,0x07,
+
+	0x05,0x84,0x02,0x40,0x00,0x00,0x07,0x05,
+
+	0x85,0x02,0x40,0x00,0x00,0x07,0x05,0x86,
+
+	0x01,0x00,0x00,0x01,0x09,0x04,0x00,0x01,
+
+	0x05,0xFF,0x00,0x00,0x00,0x07,0x05,0x81,
+
+	0x02,0x40,0x00,0x00,0x07,0x05,0x02,0x02,
+
+	0x40,0x00,0x00,0x07,0x05,0x84,0x02,0x40,
+
+	0x00,0x00,0x07,0x05,0x85,0x02,0x40,0x00,
+
+	0x00,0x07,0x05,0x86,0x01,0x00,0x14,0x01,
+
+	0x09,0x04,0x01,0x00,0x01,0x03,0x00,0x01,
+
+	0x00,0x09,0x21,0x01,0x01,0x00,0x01,0x22,
+
+	0x41,0x00,0x07,0x05,0x83,0x03,0x40,0x00,
+
+	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x05,0x01,0x09,
+
+	0x06,0xA1,0x01,0x05,0x07,0x19,0xE0,0x29,
+
+	0xE7,0x15,0x00,0x25,0x01,0x95,0x08,0x75,
+
+	0x01,0x81,0x02,0x95,0x08,0x75,0x01,0x81,
+
+	0x01,0x05,0x08,0x19,0x01,0x29,0x03,0x95,
+
+	0x03,0x75,0x01,0x91,0x02,0x95,0x01,0x75,
+
+	0x05,0x91,0x01,0x05,0x07,0x19,0x00,0x2A,
+
+	0xFF,0x00,0x15,0x00,0x26,0xFF,0x00,0x95,
+
+	0x06,0x75,0x08,0x81,0x00,0xC0,
+
+	0x02,0x41,0x00,0x00,0x03,0xFA,0xBE,0x02,
+
+	0x99,0x14,
+
+	0x02,0x45,0x50,0x6A,0xAD,0x00,0x50,0x90,
+
+	0x43,0x66,0xE0,0xFE,0x90,0x44,0x02,0xF0,
+
+	0xE4,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,
+
+	0xF0,0xA3,0xF0,0xA3,0xCE,0xF0,0xE4,0xA3,
+
+	0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0x90,
+
+	0x44,0x02,0xE0,0x04,0xFF,0x90,0x41,0xEF,
+
+	0xE0,0xFE,0x2F,0x8E,0xF0,0x84,0xAF,0xF0,
+
+	0x90,0x44,0x02,0xEF,0xF0,0xA3,0xE0,0xFD,
+
+	0xA3,0xE0,0xA3,0xCD,0xF0,0xA3,0xED,0xF0,
+
+	0xEF,0x25,0xE0,0x24,0x58,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0x90,0x43,0x61,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xEF,0x2D,0xFF,0xEE,0x3C,0xFE,0x90,
+
+	0x43,0x66,0xE0,0x25,0xE0,0x24,0x58,0xF5,
+
+	0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFA,
+
+	0xA3,0xE0,0xFB,0xC3,0xEF,0x9B,0xFF,0xEE,
+
+	0x9A,0xFE,0xED,0x24,0x01,0xFD,0xE4,0x3C,
+
+	0xFC,0x12,0x4A,0x78,0x90,0x44,0x03,0xEC,
+
+	0xF0,0xA3,0xED,0xF0,0xD3,0x90,0x43,0x72,
+
+	0xE0,0x9D,0xEC,0x64,0x80,0xF8,0x90,0x43,
+
+	0x71,0xE0,0x64,0x80,0x98,0x50,0x80,0x90,
+
+	0x41,0xEF,0xE0,0xFD,0x7C,0x00,0x90,0x44,
+
+	0x08,0xE0,0x2D,0xFF,0x90,0x44,0x07,0xE0,
+
+	0x3C,0xCF,0x24,0xFF,0xCF,0x34,0xFF,0xFE,
+
+	0x12,0x4A,0x78,0xEC,0xF0,0xA3,0xED,0xF0,
+
+	0xA3,0xE0,0xFF,0xA3,0xE0,0xA3,0xCF,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x44,0x08,0xE0,0x25,
+
+	0xE0,0xFF,0x90,0x44,0x07,0xE0,0x33,0xFE,
+
+	0x74,0x58,0x2F,0xF5,0x82,0x74,0x43,0x3E,
+
+	0xF5,0x83,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x43,0x66,0xE0,0x25,0xE0,0x24,0x58,0xF5,
+
+	0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFC,
+
+	0xA3,0xE0,0xFD,0x90,0x43,0x61,0xE0,0xFA,
+
+	0xA3,0xE0,0xFB,0xED,0x2B,0xFD,0xEC,0x3A,
+
+	0xCD,0xC3,0x9F,0xFF,0xED,0x9E,0xFE,0xEB,
+
+	0x24,0x01,0xFD,0xE4,0x3A,0xFC,0x12,0x4A,
+
+	0x78,0x90,0x44,0x09,0xEC,0xF0,0xA3,0xED,
+
+	0xF0,0xD3,0x90,0x43,0x72,0xE0,0x9D,0xEC,
+
+	0x64,0x80,0xF8,0x90,0x43,0x71,0xE0,0x64,
+
+	0x80,0x98,0x40,0x03,0x02,0x45,0xF0,0x90,
+
+	0x44,0x05,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x44,0x0B,0xE0,0xFC,0xA3,0xE0,0xFD,0x9F,
+
+	0xEE,0x64,0x80,0xF8,0xEC,0x64,0x80,0x98,
+
+	0x40,0x08,0xA3,0xEC,0xF0,0xA3,0xED,0xF0,
+
+	0x80,0x08,0x90,0x44,0x0D,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0x90,0x44,0x03,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x44,0x09,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xC3,0x9F,0xEE,0x64,0x80,0xF8,
+
+	0xEC,0x64,0x80,0x98,0x50,0x2B,0x90,0x44,
+
+	0x0F,0xEC,0xF0,0xA3,0xED,0xF0,0x90,0x41,
+
+	0xEF,0xE0,0xFD,0x7C,0x00,0x90,0x44,0x08,
+
+	0xE0,0x2D,0xFF,0x90,0x44,0x07,0xE0,0x3C,
+
+	0xCF,0x24,0xFF,0xCF,0x34,0xFF,0xFE,0x12,
+
+	0x4A,0x78,0xEC,0xF0,0xA3,0xED,0xF0,0x80,
+
+	0x24,0x90,0x44,0x03,0xE0,0xFF,0xA3,0xE0,
+
+	0x90,0x44,0x0F,0xCF,0xF0,0xA3,0xEF,0xF0,
+
+	0x90,0x44,0x02,0xE0,0x04,0xFF,0x90,0x41,
+
+	0xEF,0xE0,0xFE,0x2F,0x8E,0xF0,0x84,0x90,
+
+	0x44,0x02,0xE5,0xF0,0xF0,0x90,0x44,0x0D,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x90,0x44,
+
+	0x10,0xE0,0x9F,0xFF,0x90,0x44,0x0F,0xE0,
+
+	0x9E,0x90,0x44,0x11,0xF0,0xA3,0xEF,0xF0,
+
+	0xE4,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0x90,
+
+	0x44,0x01,0xF0,0x90,0x43,0x69,0xE0,0x75,
+
+	0xF0,0x04,0xA4,0xFF,0xC3,0x90,0x44,0x12,
+
+	0xE0,0x9F,0xE5,0xF0,0x64,0x80,0xF8,0x90,
+
+	0x44,0x11,0xE0,0x64,0x80,0x98,0x40,0x03,
+
+	0x02,0x49,0x21,0x90,0x44,0x13,0xE0,0x60,
+
+	0x03,0x02,0x49,0x21,0x90,0x44,0x01,0xE0,
+
+	0x94,0x14,0x40,0x17,0x90,0xF5,0xE7,0xE4,
+
+	0xF0,0x90,0xF5,0xE1,0xF0,0xF5,0x13,0x7B,
+
+	0x01,0x7A,0x44,0x79,0x6A,0x7D,0x01,0xFC,
+
+	0x12,0xA1,0x83,0x90,0x44,0x01,0xE0,0x04,
+
+	0xF0,0x90,0x44,0x0F,0xE0,0xFF,0xA3,0xE0,
+
+	0x90,0x44,0x0D,0xCF,0xF0,0xA3,0xEF,0xF0,
+
+	0x90,0x44,0x02,0xE0,0x25,0xE0,0x24,0x58,
+
+	0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x43,0x61,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xEF,0x2D,0xFF,0xEE,
+
+	0x3C,0xFE,0x90,0x43,0x66,0xE0,0x25,0xE0,
+
+	0x24,0x58,0xF5,0x82,0xE4,0x34,0x43,0xF5,
+
+	0x83,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0xEF,
+
+	0x9B,0xFF,0xEE,0x9A,0xFE,0xED,0x24,0x01,
+
+	0xFD,0xE4,0x3C,0xFC,0x12,0x4A,0x78,0x90,
+
+	0x44,0x03,0xEC,0xF0,0xA3,0xED,0xF0,0x90,
+
+	0x44,0x08,0xE0,0x25,0xE0,0xFF,0x90,0x44,
+
+	0x07,0xE0,0x33,0xFE,0x74,0x58,0x2F,0xF5,
+
+	0x82,0x74,0x43,0x3E,0xF5,0x83,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x90,0x43,0x66,0xE0,0x25,
+
+	0xE0,0x24,0x58,0xF5,0x82,0xE4,0x34,0x43,
+
+	0xF5,0x83,0xE0,0xFC,0xA3,0xE0,0xFD,0x90,
+
+	0x43,0x61,0xE0,0xFA,0xA3,0xE0,0xFB,0xED,
+
+	0x2B,0xFD,0xEC,0x3A,0xCD,0xC3,0x9F,0xFF,
+
+	0xED,0x9E,0xFE,0xEB,0x24,0x01,0xFD,0xE4,
+
+	0x3A,0xFC,0x12,0x4A,0x78,0x90,0x44,0x09,
+
+	0xEC,0xF0,0xA3,0xED,0xF0,0x90,0x44,0x03,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x9D,0xEC,
+
+	0x64,0x80,0xF8,0xEE,0x64,0x80,0x98,0x50,
+
+	0x3F,0x90,0x44,0x0F,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x44,0x15,0xE0,0x60,0x03,0x02,
+
+	0x48,0xEE,0x90,0x43,0x66,0xE0,0xFF,0x90,
+
+	0x44,0x02,0xE0,0xFE,0xB5,0x07,0x04,0x7F,
+
+	0x01,0x80,0x02,0x7F,0x00,0x90,0x44,0x15,
+
+	0xEF,0xF0,0x70,0x69,0xEE,0x04,0xFF,0x90,
+
+	0x41,0xEF,0xE0,0xFE,0x2F,0x8E,0xF0,0x84,
+
+	0x90,0x44,0x02,0xE5,0xF0,0xF0,0x80,0x55,
+
+	0x90,0x44,0x09,0xE0,0xFF,0xA3,0xE0,0x90,
+
+	0x44,0x0F,0xCF,0xF0,0xA3,0xEF,0xF0,0x90,
+
+	0x44,0x14,0xE0,0x70,0x40,0x90,0x43,0x66,
+
+	0xE0,0xFF,0x7E,0x00,0x90,0x44,0x07,0xE0,
+
+	0xFA,0xA3,0xE0,0xFB,0xB5,0x07,0x08,0xEE,
+
+	0xB5,0x02,0x04,0x7F,0x01,0x80,0x02,0x7F,
+
+	0x00,0x90,0x44,0x14,0xEF,0xF0,0x70,0x1D,
+
+	0x90,0x41,0xEF,0xE0,0xFD,0x7C,0x00,0x2B,
+
+	0xFF,0xEC,0x3A,0xCF,0x24,0xFF,0xCF,0x34,
+
+	0xFF,0xFE,0x12,0x4A,0x78,0x90,0x44,0x07,
+
+	0xEC,0xF0,0xA3,0xED,0xF0,0x90,0x44,0x0D,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x90,0x44,
+
+	0x10,0xE0,0x9F,0xFF,0x90,0x44,0x0F,0xE0,
+
+	0x9E,0x90,0x44,0x11,0xF0,0xA3,0xEF,0xF0,
+
+	0x90,0x44,0x14,0xE0,0x60,0x08,0xA3,0xE0,
+
+	0x60,0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,
+
+	0x90,0x44,0x13,0xEF,0xF0,0x02,0x47,0x44,
+
+	0x90,0x44,0x13,0xE0,0x60,0x0F,0x90,0x43,
+
+	0x4D,0x74,0x07,0xF0,0x90,0x43,0x6E,0x74,
+
+	0x01,0xF0,0x02,0x49,0xDB,0x90,0x43,0x69,
+
+	0xE0,0xF9,0x25,0xE0,0xFF,0xE4,0x33,0xFE,
+
+	0x90,0x43,0x71,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0x90,0x44,0x0F,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xC3,0x9D,0xFD,0xEA,0x9C,0xFC,0xC3,0xED,
+
+	0x9F,0xEE,0x64,0x80,0xF8,0xEC,0x64,0x80,
+
+	0x98,0x50,0x22,0xE9,0x75,0xF0,0x02,0xA4,
+
+	0xFF,0x90,0x43,0x72,0xE0,0x2F,0xFF,0x90,
+
+	0x43,0x71,0xE0,0x35,0xF0,0xFE,0xC3,0xEB,
+
+	0x9F,0xFF,0xEA,0x9E,0x90,0x43,0x67,0xF0,
+
+	0xA3,0xEF,0xF0,0x80,0x55,0xE9,0x25,0xE0,
+
+	0xFF,0xE4,0x33,0xFE,0x90,0x44,0x0D,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0x90,0x43,0x71,0xE0,
+
+	0xFA,0xA3,0xE0,0xFB,0xC3,0x9D,0xFD,0xEA,
+
+	0x9C,0xFC,0xC3,0xED,0x9F,0xEE,0x64,0x80,
+
+	0xF8,0xEC,0x64,0x80,0x98,0x50,0x24,0xE9,
+
+	0x25,0xE0,0xFF,0xE4,0x33,0xFE,0xEB,0x2F,
+
+	0xFF,0xEA,0x3E,0xFE,0x90,0x44,0x0D,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xC3,0xEF,0x9D,0xFF,
+
+	0xEE,0x9C,0x90,0x43,0x67,0xF0,0xA3,0xEF,
+
+	0xF0,0x80,0x07,0xE4,0x90,0x43,0x67,0xF0,
+
+	0xA3,0xF0,0x90,0x43,0x6E,0x74,0x03,0xF0,
+
+	0x90,0xF5,0xE6,0xF0,0x90,0x43,0x67,0xE0,
+
+	0xA2,0xE7,0x13,0xF0,0xA3,0xE0,0x13,0xF0,
+
+	0x90,0x43,0x4D,0x74,0x07,0xF0,0x22,0xBB,
+
+	0x01,0x06,0x89,0x82,0x8A,0x83,0xE0,0x22,
+
+	0x50,0x02,0xE7,0x22,0xBB,0xFE,0x02,0xE3,
+
+	0x22,0x89,0x82,0x8A,0x83,0xE4,0x93,0x22,
+
+	0xEF,0x8D,0xF0,0xA4,0xA8,0xF0,0xCF,0x8C,
+
+	0xF0,0xA4,0x28,0xCE,0x8D,0xF0,0xA4,0x2E,
+
+	0xFE,0x22,0xBC,0x00,0x0B,0xBE,0x00,0x29,
+
+	0xEF,0x8D,0xF0,0x84,0xFF,0xAD,0xF0,0x22,
+
+	0xE4,0xCC,0xF8,0x75,0xF0,0x08,0xEF,0x2F,
+
+	0xFF,0xEE,0x33,0xFE,0xEC,0x33,0xFC,0xEE,
+
+	0x9D,0xEC,0x98,0x40,0x05,0xFC,0xEE,0x9D,
+
+	0xFE,0x0F,0xD5,0xF0,0xE9,0xE4,0xCE,0xFD,
+
+	0x22,0xED,0xF8,0xF5,0xF0,0xEE,0x84,0x20,
+
+	0xD2,0x1C,0xFE,0xAD,0xF0,0x75,0xF0,0x08,
+
+	0xEF,0x2F,0xFF,0xED,0x33,0xFD,0x40,0x07,
+
+	0x98,0x50,0x06,0xD5,0xF0,0xF2,0x22,0xC3,
+
+	0x98,0xFD,0x0F,0xD5,0xF0,0xEA,0x22,0xC2,
+
+	0xD5,0xEC,0x30,0xE7,0x09,0xB2,0xD5,0xE4,
+
+	0xC3,0x9D,0xFD,0xE4,0x9C,0xFC,0xEE,0x30,
+
+	0xE7,0x15,0xB2,0xD5,0xE4,0xC3,0x9F,0xFF,
+
+	0xE4,0x9E,0xFE,0x12,0x4A,0x23,0xC3,0xE4,
+
+	0x9D,0xFD,0xE4,0x9C,0xFC,0x80,0x03,0x12,
+
+	0x4A,0x23,0x30,0xD5,0x07,0xC3,0xE4,0x9F,
+
+	0xFF,0xE4,0x9E,0xFE,0x22,0xE8,0x8F,0xF0,
+
+	0xA4,0xCC,0x8B,0xF0,0xA4,0x2C,0xFC,0xE9,
+
+	0x8E,0xF0,0xA4,0x2C,0xFC,0x8A,0xF0,0xED,
+
+	0xA4,0x2C,0xFC,0xEA,0x8E,0xF0,0xA4,0xCD,
+
+	0xA8,0xF0,0x8B,0xF0,0xA4,0x2D,0xCC,0x38,
+
+	0x25,0xF0,0xFD,0xE9,0x8F,0xF0,0xA4,0x2C,
+
+	0xCD,0x35,0xF0,0xFC,0xEB,0x8E,0xF0,0xA4,
+
+	0xFE,0xA9,0xF0,0xEB,0x8F,0xF0,0xA4,0xCF,
+
+	0xC5,0xF0,0x2E,0xCD,0x39,0xFE,0xE4,0x3C,
+
+	0xFC,0xEA,0xA4,0x2D,0xCE,0x35,0xF0,0xFD,
+
+	0xE4,0x3C,0xFC,0x22,0xC3,0xE4,0x9F,0xFF,
+
+	0xE4,0x9E,0xFE,0xE4,0x9D,0xFD,0xE4,0x9C,
+
+	0xFC,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+
+	0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xEC,0x64,
+
+	0x80,0xC8,0x64,0x80,0x98,0x45,0xF0,0x22,
+
+	0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,0x42,0xF0,
+
+	0xE9,0x9D,0x42,0xF0,0xE8,0x9C,0x45,0xF0,
+
+	0x22,0xE8,0x60,0x0F,0xEC,0xC3,0x13,0xFC,
+
+	0xED,0x13,0xFD,0xEE,0x13,0xFE,0xEF,0x13,
+
+	0xFF,0xD8,0xF1,0x22,0xE8,0x60,0x10,0xEC,
+
+	0xA2,0xE7,0x13,0xFC,0xED,0x13,0xFD,0xEE,
+
+	0x13,0xFE,0xEF,0x13,0xFF,0xD8,0xF0,0x22,
+
+	0xE8,0x60,0x0F,0xEF,0xC3,0x33,0xFF,0xEE,
+
+	0x33,0xFE,0xED,0x33,0xFD,0xEC,0x33,0xFC,
+
+	0xD8,0xF1,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
+
+	0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0xA8,
+
+	0x82,0x85,0x83,0xF0,0xD0,0x83,0xD0,0x82,
+
+	0x12,0x4B,0x8F,0x12,0x4B,0x8F,0x12,0x4B,
+
+	0x8F,0x12,0x4B,0x8F,0xE4,0x73,0xE4,0x93,
+
+	0xA3,0xC5,0x83,0xC5,0xF0,0xC5,0x83,0xC8,
+
+	0xC5,0x82,0xC8,0xF0,0xA3,0xC5,0x83,0xC5,
+
+	0xF0,0xC5,0x83,0xC8,0xC5,0x82,0xC8,0x22,
+
+	0x8A,0x83,0x89,0x82,0xE4,0x73,0xBB,0x01,
+
+	0x0C,0xE5,0x82,0x29,0xF5,0x82,0xE5,0x83,
+
+	0x3A,0xF5,0x83,0xE0,0x22,0x50,0x06,0xE9,
+
+	0x25,0x82,0xF8,0xE6,0x22,0xBB,0xFE,0x06,
+
+	0xE9,0x25,0x82,0xF8,0xE2,0x22,0xE5,0x82,
+
+	0x29,0xF5,0x82,0xE5,0x83,0x3A,0xF5,0x83,
+
+	0xE4,0x93,0x22,0xF8,0xBB,0x01,0x0D,0xE5,
+
+	0x82,0x29,0xF5,0x82,0xE5,0x83,0x3A,0xF5,
+
+	0x83,0xE8,0xF0,0x22,0x50,0x06,0xE9,0x25,
+
+	0x82,0xC8,0xF6,0x22,0xBB,0xFE,0x05,0xE9,
+
+	0x25,0x82,0xC8,0xF2,0x22,0xBB,0x01,0x0A,
+
+	0x89,0x82,0x8A,0x83,0xE0,0xF5,0xF0,0xA3,
+
+	0xE0,0x22,0x50,0x06,0x87,0xF0,0x09,0xE7,
+
+	0x19,0x22,0xBB,0xFE,0x07,0xE3,0xF5,0xF0,
+
+	0x09,0xE3,0x19,0x22,0x89,0x82,0x8A,0x83,
+
+	0xE4,0x93,0xF5,0xF0,0x74,0x01,0x93,0x22,
+
+	0xBB,0x01,0x10,0xE5,0x82,0x29,0xF5,0x82,
+
+	0xE5,0x83,0x3A,0xF5,0x83,0xE0,0xF5,0xF0,
+
+	0xA3,0xE0,0x22,0x50,0x09,0xE9,0x25,0x82,
+
+	0xF8,0x86,0xF0,0x08,0xE6,0x22,0xBB,0xFE,
+
+	0x0A,0xE9,0x25,0x82,0xF8,0xE2,0xF5,0xF0,
+
+	0x08,0xE2,0x22,0xE5,0x83,0x2A,0xF5,0x83,
+
+	0xE9,0x93,0xF5,0xF0,0xA3,0xE9,0x93,0x22,
+
+	0xBB,0x01,0x0A,0x89,0x82,0x8A,0x83,0xF0,
+
+	0xE5,0xF0,0xA3,0xF0,0x22,0x50,0x06,0xF7,
+
+	0x09,0xA7,0xF0,0x19,0x22,0xBB,0xFE,0x06,
+
+	0xF3,0xE5,0xF0,0x09,0xF3,0x19,0x22,0xF8,
+
+	0xBB,0x01,0x11,0xE5,0x82,0x29,0xF5,0x82,
+
+	0xE5,0x83,0x3A,0xF5,0x83,0xE8,0xF0,0xE5,
+
+	0xF0,0xA3,0xF0,0x22,0x50,0x09,0xE9,0x25,
+
+	0x82,0xC8,0xF6,0x08,0xA6,0xF0,0x22,0xBB,
+
+	0xFE,0x09,0xE9,0x25,0x82,0xC8,0xF2,0xE5,
+
+	0xF0,0x08,0xF2,0x22,0x75,0xF0,0x08,0x75,
+
+	0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+
+	0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
+
+	0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
+
+	0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
+
+	0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
+
+	0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
+
+	0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
+
+	0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
+
+	0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
+
+	0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
+
+	0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
+
+	0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
+
+	0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
+
+	0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
+
+	0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
+
+	0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
+
+	0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
+
+	0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
+
+	0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
+
+	0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+
+	0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
+
+	0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
+
+	0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
+
+	0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
+
+	0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
+
+	0xF9,0x22,0x90,0x44,0x7E,0xEF,0xF0,0xA9,
+
+	0x05,0xE4,0x90,0x44,0x84,0xF0,0xFB,0x90,
+
+	0x43,0x60,0xE0,0xFD,0xEB,0xC3,0x9D,0x50,
+
+	0x4F,0x90,0xF5,0xF1,0xE0,0xFF,0xEB,0x25,
+
+	0xE0,0x24,0x50,0xF5,0x82,0xE4,0x34,0x43,
+
+	0xF5,0x83,0xEF,0xF0,0x90,0xF5,0xF0,0xE0,
+
+	0xFF,0xEB,0x25,0xE0,0x24,0x51,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xEF,0xF0,0x90,
+
+	0xF5,0xF1,0xE0,0xFF,0xEB,0x25,0xE0,0x24,
+
+	0x58,0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,
+
+	0xEF,0xF0,0x90,0xF5,0xF0,0xE0,0xFF,0xEB,
+
+	0x25,0xE0,0x24,0x59,0xF5,0x82,0xE4,0x34,
+
+	0x43,0xF5,0x83,0xEF,0xF0,0x0B,0x80,0xA7,
+
+	0x90,0x41,0xEF,0xED,0xF0,0x90,0x43,0x50,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xEE,0xC3,0x13,
+
+	0xFE,0xEF,0x13,0xFF,0x90,0x44,0x7F,0xEE,
+
+	0xF0,0xA3,0xEF,0xF0,0x7A,0x01,0x90,0x41,
+
+	0xEF,0xE0,0xFF,0xEA,0xC3,0x9F,0x50,0x4E,
+
+	0xEA,0x25,0xE0,0x24,0x50,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xE0,0xFE,0xA3,0xE0,
+
+	0x78,0x02,0xCE,0xC3,0x13,0xCE,0x13,0xD8,
+
+	0xF9,0xFD,0xAC,0x06,0xEA,0x25,0xE0,0x24,
+
+	0x50,0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xEE,0xC3,0x13,
+
+	0xFE,0xEF,0x13,0x2D,0xFF,0xEE,0x3C,0xFE,
+
+	0x90,0x44,0x7F,0xE0,0xFC,0xA3,0xE0,0xC3,
+
+	0x9F,0xEC,0x9E,0x50,0x06,0x90,0x43,0x4C,
+
+	0x74,0x01,0xF0,0x0A,0x80,0xA8,0x90,0x43,
+
+	0x78,0xE0,0xFE,0x70,0x14,0x90,0x41,0xEF,
+
+	0xE0,0x64,0x01,0x70,0x31,0x90,0x43,0x78,
+
+	0x04,0xF0,0x90,0xF5,0xE2,0xE9,0xF0,0x80,
+
+	0x25,0xEE,0xB4,0x01,0x17,0x90,0x41,0xEF,
+
+	0xE0,0xB4,0x01,0x08,0x90,0x43,0x78,0x74,
+
+	0x03,0xF0,0x80,0x12,0x90,0x43,0x78,0x74,
+
+	0x02,0xF0,0x80,0x0A,0x90,0x43,0x78,0xE0,
+
+	0xB4,0x02,0x03,0x74,0x03,0xF0,0x90,0x43,
+
+	0x78,0xE0,0xB4,0x03,0x0F,0x90,0x42,0x0F,
+
+	0xE0,0x14,0x90,0x43,0x77,0xF0,0x90,0x41,
+
+	0xEF,0x74,0x01,0xF0,0x90,0x44,0x7E,0xE0,
+
+	0x60,0x03,0x02,0x50,0xDD,0x7A,0x01,0x90,
+
+	0x43,0x60,0xE0,0xFF,0xEA,0xC3,0x9F,0x50,
+
+	0x34,0xEA,0x25,0xE0,0x24,0x58,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x43,0x58,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xC3,0xEF,0x9D,0xFF,0xEE,0x9C,
+
+	0xFE,0xEA,0x25,0xE0,0x24,0x77,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0x0A,0x80,0xC2,0x90,0x43,0x8A,
+
+	0xE0,0xFC,0x70,0x39,0xFA,0x90,0x43,0x60,
+
+	0xE0,0xFF,0xEA,0xC3,0x9F,0x50,0x25,0xEA,
+
+	0x25,0xE0,0x24,0x79,0xF5,0x82,0xE4,0x34,
+
+	0x43,0xF5,0x83,0xE0,0xFE,0xA3,0xE0,0xFF,
+
+	0xEA,0x25,0xE0,0x24,0x81,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x0A,0x80,0xD1,0x90,0x41,0xEF,0xE0,
+
+	0x90,0x43,0x8A,0xF0,0x22,0xEC,0x64,0x01,
+
+	0x70,0x03,0x02,0x50,0x96,0x90,0x44,0x83,
+
+	0x74,0x01,0xF0,0x90,0x44,0x82,0xF0,0xE4,
+
+	0xFA,0xF9,0xE9,0x25,0xE0,0x24,0x81,0xF5,
+
+	0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0xEA,0x25,0xE0,0x24,0x79,
+
+	0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,
+
+	0xFC,0xA3,0xE0,0xC3,0x9F,0xFF,0xEC,0x9E,
+
+	0xFE,0xC3,0x64,0x80,0x94,0x80,0x50,0x24,
+
+	0xC3,0xE4,0x9F,0xFF,0xE4,0x9E,0xFE,0x90,
+
+	0x43,0x60,0xE0,0x24,0xFE,0xFD,0xEA,0xC3,
+
+	0x9D,0x50,0x03,0x0A,0x80,0x06,0x90,0x44,
+
+	0x84,0x74,0x01,0xF0,0x90,0x44,0x81,0x74,
+
+	0x01,0xF0,0x80,0x1A,0xE4,0x90,0x44,0x81,
+
+	0xF0,0x90,0x43,0x8A,0xE0,0x24,0xFE,0xFD,
+
+	0xE9,0xC3,0x9D,0x50,0x03,0x09,0x80,0x06,
+
+	0x90,0x44,0x84,0x74,0x01,0xF0,0x90,0x42,
+
+	0x12,0xE0,0xFD,0xC3,0xEF,0x9D,0x74,0x80,
+
+	0xF8,0x6E,0x98,0x40,0x2A,0x90,0x43,0x50,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xEE,0x13,0xFE,
+
+	0xEF,0x13,0xFF,0x90,0x44,0x83,0xE0,0x25,
+
+	0xE0,0x24,0x50,0xF5,0x82,0xE4,0x34,0x43,
+
+	0xF5,0x83,0xE0,0xFC,0xA3,0xE0,0xD3,0x9F,
+
+	0xEC,0x9E,0x50,0x03,0x02,0x50,0x75,0x90,
+
+	0x44,0x83,0xE0,0xFC,0x25,0xE0,0x24,0x58,
+
+	0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x44,0x82,0xE0,
+
+	0xFD,0x25,0xE0,0x24,0x58,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0xEC,0x25,0xE0,0x24,0x50,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0xED,0x25,0xE0,0x24,0x50,0xF5,
+
+	0x82,0xE4,0x34,0x43,0xF5,0x83,0xEE,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x44,0x82,0xE0,0x04,
+
+	0xF0,0x90,0x44,0x81,0xE0,0xB4,0x01,0x17,
+
+	0x90,0x43,0x8A,0xE0,0x24,0xFE,0xFF,0xE9,
+
+	0xC3,0x9F,0x50,0x03,0x09,0x80,0x1D,0x90,
+
+	0x44,0x84,0x74,0x01,0xF0,0x80,0x15,0x90,
+
+	0x43,0x60,0xE0,0x24,0xFE,0xFF,0xEA,0xC3,
+
+	0x9F,0x50,0x03,0x0A,0x80,0x06,0x90,0x44,
+
+	0x84,0x74,0x01,0xF0,0x90,0x44,0x82,0xE0,
+
+	0x90,0x41,0xEF,0xF0,0xEA,0x04,0x90,0x44,
+
+	0x83,0xF0,0xA3,0xE0,0x64,0x01,0x60,0x03,
+
+	0x02,0x4F,0x4B,0x90,0x41,0xEF,0xE0,0x90,
+
+	0x43,0x8A,0xF0,0x80,0x06,0x90,0x41,0xEF,
+
+	0x74,0x01,0xF0,0x7B,0x01,0x90,0x43,0x8A,
+
+	0xE0,0x14,0xFF,0xEB,0xC3,0x9F,0x50,0x34,
+
+	0xEB,0x25,0xE0,0x24,0x58,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0x90,0x43,0x58,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xC3,0xEF,0x9D,0xFF,0xEE,0x9C,0xFE,
+
+	0xEB,0x25,0xE0,0x24,0x7F,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xEE,0xF0,0xA3,0xEF,
+
+	0xF0,0x0B,0x80,0xC1,0x22,0x90,0xF9,0x00,
+
+	0xE0,0x70,0x0A,0x90,0x42,0x72,0xF0,0xA3,
+
+	0x74,0x32,0xF0,0x80,0x1B,0x90,0xF9,0x00,
+
+	0xE0,0xB4,0x01,0x0B,0x90,0x42,0x72,0xE4,
+
+	0xF0,0xA3,0x74,0xC8,0xF0,0x80,0x09,0x90,
+
+	0x42,0x72,0xE4,0xF0,0xA3,0x74,0x64,0xF0,
+
+	0x90,0x41,0xE2,0x74,0x40,0xF0,0x12,0x5A,
+
+	0x62,0x7F,0x01,0x12,0xAE,0x43,0x90,0x42,
+
+	0x72,0xE4,0xF0,0xA3,0x74,0x1E,0xF0,0x90,
+
+	0x41,0xE2,0x74,0x50,0xF0,0x12,0x5A,0x62,
+
+	0x90,0xF4,0x0C,0xE0,0x60,0x5A,0x90,0xF1,
+
+	0xEB,0x74,0x01,0xF0,0xE4,0xF0,0x90,0xF9,
+
+	0x00,0xE0,0x70,0x0A,0x90,0x42,0x72,0xF0,
+
+	0xA3,0x74,0x96,0xF0,0x80,0x1D,0x90,0xF9,
+
+	0x00,0xE0,0xB4,0x01,0x0C,0x90,0x42,0x72,
+
+	0x74,0x02,0xF0,0xA3,0x74,0x58,0xF0,0x80,
+
+	0x0A,0x90,0x42,0x72,0x74,0x01,0xF0,0xA3,
+
+	0x74,0x2C,0xF0,0x7F,0x01,0x12,0xAE,0x43,
+
+	0x90,0x41,0xE2,0x74,0x60,0xF0,0x12,0x5A,
+
+	0x62,0x90,0x42,0x72,0xE4,0xF0,0xA3,0x74,
+
+	0x1E,0xF0,0x7F,0x01,0x12,0xAE,0x43,0x90,
+
+	0x41,0xE2,0x74,0x70,0xF0,0x12,0x5A,0x62,
+
+	0x90,0xF4,0x0C,0xE0,0x60,0x10,0x90,0x41,
+
+	0xD8,0x74,0x02,0xF0,0x90,0xF2,0x1C,0xF0,
+
+	0xE4,0x90,0x43,0xBB,0xF0,0x22,0x90,0x41,
+
+	0xD8,0x74,0x01,0xF0,0x90,0xF2,0x1C,0xF0,
+
+	0x90,0x43,0xBB,0xF0,0xE4,0x90,0x42,0x6E,
+
+	0xF0,0x90,0xF1,0xB5,0xE0,0x90,0x42,0x6F,
+
+	0xF0,0x90,0xF1,0xB4,0xE0,0x90,0x42,0x70,
+
+	0xF0,0x90,0xF1,0xB3,0xE0,0x90,0x42,0x71,
+
+	0xF0,0x90,0x42,0x6E,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x42,0x60,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,
+
+	0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0xEF,0x9B,
+
+	0xFF,0xEE,0x9A,0xFE,0xED,0x99,0xFD,0xEC,
+
+	0x98,0xFC,0x90,0x42,0x6E,0x12,0x4B,0x6C,
+
+	0x7F,0xFF,0x7E,0xFF,0x7D,0x3F,0x7C,0x00,
+
+	0x90,0x42,0x6E,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xD3,0x12,
+
+	0x4B,0x0B,0x40,0x21,0x90,0x42,0x6E,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0x24,0x00,0xFF,0xE4,0x3E,0xFE,0xED,
+
+	0x34,0x80,0xFD,0xEC,0x34,0xFF,0xFC,0x90,
+
+	0x42,0x6E,0x12,0x4B,0x6C,0x90,0x42,0x6E,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x78,0x09,0x12,0x4B,0x45,
+
+	0x90,0x42,0x6E,0x12,0x4B,0x6C,0x90,0x43,
+
+	0xE1,0xE0,0x60,0x04,0x7F,0x01,0x80,0x02,
+
+	0x7F,0x00,0x90,0x42,0x1F,0xE0,0x5F,0x70,
+
+	0x0F,0x90,0xF1,0x33,0xE0,0x70,0x09,0x90,
+
+	0xF1,0x35,0xE0,0x70,0x03,0x02,0x54,0x10,
+
+	0xE4,0x90,0x42,0x60,0xF0,0xA3,0xF0,0x90,
+
+	0xF1,0x0F,0xE0,0x90,0x42,0x62,0xF0,0x90,
+
+	0xF1,0x0E,0xE0,0x90,0x42,0x63,0xF0,0x90,
+
+	0x42,0x60,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x42,0x6E,
+
+	0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,
+
+	0xA3,0xE0,0x2F,0xFF,0xEA,0x3E,0xFE,0xE9,
+
+	0x3D,0xFD,0xE8,0x3C,0xFC,0x90,0x42,0x60,
+
+	0x12,0x4B,0x6C,0xE4,0xFF,0x7E,0x40,0xFD,
+
+	0xFC,0x90,0x42,0x60,0xE0,0xF8,0xA3,0xE0,
+
+	0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,
+
+	0x12,0x4B,0x0B,0x40,0x24,0x90,0x42,0x60,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,
+
+	0xA3,0xE0,0x24,0x00,0xFF,0xEE,0x34,0xC0,
+
+	0xFE,0xED,0x34,0xFF,0xFD,0xEC,0x34,0xFF,
+
+	0xFC,0x90,0x42,0x60,0x12,0x4B,0x6C,0x80,
+
+	0x39,0xE4,0xFF,0xFE,0xFD,0xFC,0x90,0x42,
+
+	0x60,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+
+	0xFA,0xA3,0xE0,0xFB,0xC3,0x12,0x4B,0x0B,
+
+	0x50,0x20,0x90,0x42,0x60,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0x24,
+
+	0x00,0xFF,0xEE,0x34,0x40,0xFE,0xE4,0x3D,
+
+	0xFD,0xE4,0x3C,0xFC,0x90,0x42,0x60,0x12,
+
+	0x4B,0x6C,0x90,0x42,0x63,0xE0,0x90,0xF1,
+
+	0x0E,0xF0,0x90,0x42,0x62,0xE0,0x90,0xF1,
+
+	0x0F,0xF0,0xE4,0x90,0x42,0x60,0xF0,0xA3,
+
+	0xF0,0x90,0xF1,0x13,0xE0,0x90,0x42,0x62,
+
+	0xF0,0x90,0xF1,0x12,0xE0,0x90,0x42,0x63,
+
+	0xF0,0x90,0x42,0x60,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x42,0x6E,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,
+
+	0xE0,0xFA,0xA3,0xE0,0x2F,0xFF,0xEA,0x3E,
+
+	0xFE,0xE9,0x3D,0xFD,0xE8,0x3C,0xFC,0x90,
+
+	0x42,0x60,0x12,0x4B,0x6C,0xE4,0xFF,0x7E,
+
+	0x40,0xFD,0xFC,0x90,0x42,0x60,0xE0,0xF8,
+
+	0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,
+
+	0xFB,0xC3,0x12,0x4B,0x0B,0x40,0x24,0x90,
+
+	0x42,0x60,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,
+
+	0xE0,0xFE,0xA3,0xE0,0x24,0x00,0xFF,0xEE,
+
+	0x34,0xC0,0xFE,0xED,0x34,0xFF,0xFD,0xEC,
+
+	0x34,0xFF,0xFC,0x90,0x42,0x60,0x12,0x4B,
+
+	0x6C,0x80,0x39,0xE4,0xFF,0xFE,0xFD,0xFC,
+
+	0x90,0x42,0x60,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0x12,
+
+	0x4B,0x0B,0x50,0x20,0x90,0x42,0x60,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0x24,0x00,0xFF,0xEE,0x34,0x40,0xFE,
+
+	0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x42,
+
+	0x60,0x12,0x4B,0x6C,0x90,0x42,0x63,0xE0,
+
+	0x90,0xF1,0x12,0xF0,0x90,0x42,0x62,0xE0,
+
+	0x90,0xF1,0x13,0xF0,0x90,0x43,0xDF,0xE0,
+
+	0x70,0x05,0x90,0xF1,0x0A,0x04,0xF0,0xE4,
+
+	0x90,0x42,0x60,0xF0,0x90,0xF1,0xB5,0xE0,
+
+	0x90,0x42,0x61,0xF0,0x90,0xF1,0xB4,0xE0,
+
+	0x90,0x42,0x62,0xF0,0x90,0xF1,0xB3,0xE0,
+
+	0x90,0x42,0x63,0xF0,0x22,0xE4,0x90,0x43,
+
+	0xEE,0xF0,0x90,0x43,0xE1,0xF0,0x90,0x42,
+
+	0x21,0xE0,0x90,0x44,0x8D,0xF0,0x90,0x42,
+
+	0x22,0xE0,0x90,0x44,0x8C,0xF0,0x90,0xF6,
+
+	0x25,0xE4,0xF0,0x90,0x42,0x20,0xE0,0x90,
+
+	0xF6,0x26,0xF0,0x90,0xF6,0x2B,0x74,0x02,
+
+	0xF0,0xA3,0xF0,0xA3,0xE4,0xF0,0x90,0xF6,
+
+	0x25,0x04,0xF0,0x90,0xF6,0x2F,0xF0,0x90,
+
+	0xF6,0x2F,0xE0,0xB4,0x01,0xF9,0x90,0xF6,
+
+	0x32,0xE0,0x90,0x43,0xF0,0xF0,0x90,0xF6,
+
+	0x33,0xE0,0x90,0x43,0xEF,0xF0,0x90,0x44,
+
+	0x8C,0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x90,
+
+	0x43,0xF0,0xE0,0x9F,0x90,0x43,0xEF,0xE0,
+
+	0x9E,0x40,0x03,0x02,0x57,0x34,0x90,0x44,
+
+	0x8C,0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x90,
+
+	0x43,0xF0,0xE0,0x9F,0x90,0x43,0xEF,0xE0,
+
+	0x9E,0x50,0x3A,0x90,0xF6,0x2C,0xE0,0xB4,
+
+	0x02,0x05,0x74,0x01,0xF0,0x80,0x0A,0x90,
+
+	0xF6,0x2B,0xE0,0x04,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0x90,0xF6,0x2F,0x74,0x01,0xF0,0x90,
+
+	0xF6,0x2F,0xE0,0xB4,0x01,0xF9,0x90,0xF6,
+
+	0x32,0xE0,0x90,0x43,0xF0,0xF0,0x90,0xF6,
+
+	0x33,0xE0,0x90,0x43,0xEF,0xF0,0x90,0xF6,
+
+	0x2B,0xE0,0xB4,0x0F,0xB1,0x90,0x42,0x23,
+
+	0xE0,0xFF,0x90,0xF6,0x2B,0xE0,0xC3,0x9F,
+
+	0x40,0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,
+
+	0x90,0x43,0xDF,0xEF,0xF0,0x60,0x5C,0x90,
+
+	0xF1,0x2F,0xE4,0xF0,0x90,0xF1,0x34,0x04,
+
+	0xF0,0x90,0xF1,0x37,0x74,0x10,0xF0,0xA3,
+
+	0x74,0x06,0xF0,0x90,0xF1,0x3B,0x74,0x60,
+
+	0xF0,0xA3,0x74,0x1A,0xF0,0x90,0xF1,0x3F,
+
+	0x74,0xC0,0xF0,0xA3,0x74,0x2D,0xF0,0x90,
+
+	0xF1,0x33,0x74,0x01,0xF0,0x90,0xF1,0x36,
+
+	0x74,0x0D,0xF0,0x90,0xF1,0x39,0x74,0x10,
+
+	0xF0,0xA3,0x74,0x18,0xF0,0x90,0xF1,0x3D,
+
+	0x74,0x60,0xF0,0xA3,0x74,0x1B,0xF0,0x90,
+
+	0xF1,0x41,0x74,0x40,0xF0,0xA3,0x74,0x3A,
+
+	0xF0,0x90,0xF1,0x35,0x74,0x01,0xF0,0x90,
+
+	0xF1,0x11,0xF0,0x90,0xF6,0x2B,0xE0,0x14,
+
+	0xF0,0xC2,0xAF,0x90,0xF6,0x2D,0x74,0x01,
+
+	0xF0,0x90,0xF6,0x2F,0xF0,0x90,0xF6,0x2F,
+
+	0xE0,0xB4,0x01,0xF9,0xD2,0xAF,0x90,0xF6,
+
+	0x4C,0xE0,0x90,0x44,0x8F,0xF0,0x90,0xF6,
+
+	0x4D,0xE0,0x90,0x44,0x90,0xF0,0x90,0xF6,
+
+	0x4E,0xE0,0x90,0x44,0x91,0xF0,0x90,0xF6,
+
+	0x4F,0xE0,0x90,0x44,0x92,0xF0,0x90,0x44,
+
+	0x90,0xE0,0xFF,0x90,0x44,0x8F,0xE0,0xFE,
+
+	0x6F,0x60,0x20,0x90,0x44,0x91,0xE0,0xFD,
+
+	0xEE,0x6D,0x60,0x17,0xA3,0xE0,0xFC,0xEE,
+
+	0x6C,0x60,0x10,0xEF,0x6D,0x60,0x0C,0x90,
+
+	0x44,0x90,0xE0,0x6C,0x60,0x05,0xA3,0xE0,
+
+	0xB5,0x04,0x06,0x90,0x43,0xEE,0x74,0x01,
+
+	0xF0,0x90,0x44,0x8E,0x74,0x04,0xF0,0x90,
+
+	0x44,0x8E,0xE0,0xFF,0xC3,0x94,0x06,0x40,
+
+	0x03,0x02,0x57,0x34,0x90,0xF6,0x4C,0xE0,
+
+	0x6F,0x70,0x4B,0x90,0x43,0xEE,0xE0,0xB4,
+
+	0x01,0x21,0x90,0x44,0x8E,0xE0,0xB4,0x05,
+
+	0x1A,0x90,0x43,0xE3,0x74,0xAC,0xF0,0x90,
+
+	0x43,0xE2,0x74,0x0D,0xF0,0x90,0x43,0xE5,
+
+	0x74,0x9F,0xF0,0x90,0x43,0xE4,0x74,0x1A,
+
+	0xF0,0x80,0x20,0x90,0xF6,0x34,0xE0,0x90,
+
+	0x43,0xE3,0xF0,0x90,0xF6,0x35,0xE0,0x90,
+
+	0x43,0xE2,0xF0,0x90,0xF6,0x36,0xE0,0x90,
+
+	0x43,0xE5,0xF0,0x90,0xF6,0x37,0xE0,0x90,
+
+	0x43,0xE4,0xF0,0x12,0x75,0xDF,0x90,0x44,
+
+	0x8E,0xE0,0xFF,0x90,0xF6,0x4D,0xE0,0x6F,
+
+	0x70,0x48,0x90,0x43,0xEE,0xE0,0xB4,0x01,
+
+	0x1E,0xEF,0xB4,0x05,0x1A,0x90,0x43,0xE3,
+
+	0x74,0xAC,0xF0,0x90,0x43,0xE2,0x74,0x0D,
+
+	0xF0,0x90,0x43,0xE5,0x74,0x9F,0xF0,0x90,
+
+	0x43,0xE4,0x74,0x1A,0xF0,0x80,0x20,0x90,
+
+	0xF6,0x3A,0xE0,0x90,0x43,0xE3,0xF0,0x90,
+
+	0xF6,0x3B,0xE0,0x90,0x43,0xE2,0xF0,0x90,
+
+	0xF6,0x3C,0xE0,0x90,0x43,0xE5,0xF0,0x90,
+
+	0xF6,0x3D,0xE0,0x90,0x43,0xE4,0xF0,0x12,
+
+	0x75,0xDF,0x90,0x44,0x8E,0xE0,0xFF,0x90,
+
+	0xF6,0x4E,0xE0,0x6F,0x70,0x48,0x90,0x43,
+
+	0xEE,0xE0,0xB4,0x01,0x1E,0xEF,0xB4,0x05,
+
+	0x1A,0x90,0x43,0xE3,0x74,0xAC,0xF0,0x90,
+
+	0x43,0xE2,0x74,0x0D,0xF0,0x90,0x43,0xE5,
+
+	0x74,0x9F,0xF0,0x90,0x43,0xE4,0x74,0x1A,
+
+	0xF0,0x80,0x20,0x90,0xF6,0x40,0xE0,0x90,
+
+	0x43,0xE3,0xF0,0x90,0xF6,0x41,0xE0,0x90,
+
+	0x43,0xE2,0xF0,0x90,0xF6,0x42,0xE0,0x90,
+
+	0x43,0xE5,0xF0,0x90,0xF6,0x43,0xE0,0x90,
+
+	0x43,0xE4,0xF0,0x12,0x75,0xDF,0x90,0x44,
+
+	0x8E,0xE0,0xFF,0x90,0xF6,0x4F,0xE0,0x6F,
+
+	0x70,0x48,0x90,0x43,0xEE,0xE0,0xB4,0x01,
+
+	0x1E,0xEF,0xB4,0x05,0x1A,0x90,0x43,0xE3,
+
+	0x74,0xAC,0xF0,0x90,0x43,0xE2,0x74,0x0D,
+
+	0xF0,0x90,0x43,0xE5,0x74,0x9F,0xF0,0x90,
+
+	0x43,0xE4,0x74,0x1A,0xF0,0x80,0x20,0x90,
+
+	0xF6,0x46,0xE0,0x90,0x43,0xE3,0xF0,0x90,
+
+	0xF6,0x47,0xE0,0x90,0x43,0xE2,0xF0,0x90,
+
+	0xF6,0x48,0xE0,0x90,0x43,0xE5,0xF0,0x90,
+
+	0xF6,0x49,0xE0,0x90,0x43,0xE4,0xF0,0x12,
+
+	0x75,0xDF,0x90,0x44,0x8E,0xE0,0x04,0xF0,
+
+	0x02,0x55,0xD0,0x90,0xF6,0x25,0xE4,0xF0,
+
+	0x90,0x43,0xDF,0xE0,0x70,0x0D,0x90,0x43,
+
+	0xE1,0xE0,0xB4,0x01,0x06,0x90,0xF1,0x0A,
+
+	0x74,0x01,0xF0,0x7F,0x01,0x12,0xAE,0x43,
+
+	0x22,0x90,0xF4,0xC1,0xE0,0xC3,0x94,0x01,
+
+	0x50,0x03,0x02,0x5A,0x4D,0x90,0x43,0x26,
+
+	0xE0,0x70,0x1E,0x90,0x43,0x12,0x12,0x4B,
+
+	0x78,0x00,0x00,0x00,0x00,0x90,0x43,0x16,
+
+	0x12,0x4B,0x78,0x00,0x00,0x00,0x00,0x90,
+
+	0x43,0x0E,0x12,0x4B,0x78,0x00,0x00,0x00,
+
+	0x00,0x90,0x43,0x25,0xE0,0x25,0xE0,0x24,
+
+	0x36,0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x43,0x23,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0x90,0xF9,0x00,0xE0,
+
+	0x70,0x19,0x90,0x43,0x23,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x7C,0x06,0x7D,0xA8,0x12,0x4A,
+
+	0x23,0x90,0x43,0x23,0xEC,0xF0,0xA3,0xED,
+
+	0xF0,0x80,0x1E,0x90,0xF9,0x00,0xE0,0xB4,
+
+	0x02,0x17,0x90,0x43,0x23,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x7C,0x0D,0x7D,0x50,0x12,0x4A,
+
+	0x23,0x90,0x43,0x23,0xEC,0xF0,0xA3,0xED,
+
+	0xF0,0x12,0xAC,0x5B,0x12,0x8E,0xE5,0x12,
+
+	0xAD,0x5A,0x90,0x42,0xFE,0xE0,0xFF,0xC4,
+
+	0x13,0x13,0x13,0x54,0x01,0x90,0x44,0xD5,
+
+	0xF0,0xE0,0xB4,0x01,0x31,0x90,0x43,0x12,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x90,0x42,0xFE,0xE0,0xF8,
+
+	0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,
+
+	0xFB,0xC3,0xEF,0x9B,0xFF,0xEE,0x9A,0xFE,
+
+	0xED,0x99,0xFD,0xEC,0x98,0xFC,0x90,0x43,
+
+	0x12,0x12,0x4B,0x6C,0x80,0x2E,0x90,0x43,
+
+	0x12,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x42,0xFE,0xE0,
+
+	0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+
+	0xE0,0xFB,0xEF,0x2B,0xFF,0xEE,0x3A,0xFE,
+
+	0xED,0x39,0xFD,0xEC,0x38,0xFC,0x90,0x43,
+
+	0x12,0x12,0x4B,0x6C,0x90,0x44,0xD5,0xE0,
+
+	0xB4,0x01,0x31,0x90,0x43,0x16,0xE0,0xFC,
+
+	0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0x90,0x43,0x02,0xE0,0xF8,0xA3,0xE0,
+
+	0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,
+
+	0xEF,0x9B,0xFF,0xEE,0x9A,0xFE,0xED,0x99,
+
+	0xFD,0xEC,0x98,0xFC,0x90,0x43,0x16,0x12,
+
+	0x4B,0x6C,0x80,0x2E,0x90,0x43,0x16,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x43,0x02,0xE0,0xF8,0xA3,
+
+	0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xEF,0x2B,0xFF,0xEE,0x3A,0xFE,0xED,0x39,
+
+	0xFD,0xEC,0x38,0xFC,0x90,0x43,0x16,0x12,
+
+	0x4B,0x6C,0x90,0x43,0x0E,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+
+	0x90,0x43,0x06,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xEF,0x2B,
+
+	0xFF,0xEE,0x3A,0xFE,0xED,0x39,0xFD,0xEC,
+
+	0x38,0xFC,0x90,0x43,0x0E,0x12,0x4B,0x6C,
+
+	0x90,0x43,0x26,0xE0,0x04,0xF0,0xE0,0xC3,
+
+	0x94,0x64,0x50,0x03,0x02,0x5A,0x61,0x90,
+
+	0x43,0x0E,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x43,0x12,
+
+	0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,
+
+	0xA3,0xE0,0xFB,0xEF,0x9B,0xFF,0xEE,0x9A,
+
+	0xFE,0xED,0x99,0xFD,0xEC,0x98,0xFC,0x90,
+
+	0x43,0x1A,0x12,0x4B,0x6C,0x90,0x43,0x1A,
+
+	0xE0,0xFF,0xC4,0x13,0x13,0x13,0x54,0x01,
+
+	0xFF,0xBF,0x01,0x14,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x12,
+
+	0x4A,0xFD,0x90,0x43,0x1A,0x12,0x4B,0x6C,
+
+	0x90,0x43,0x16,0xE0,0xFF,0xC4,0x13,0x13,
+
+	0x13,0x54,0x01,0xFF,0xBF,0x01,0x31,0x90,
+
+	0x43,0x1A,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x43,0x16,
+
+	0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,
+
+	0xA3,0xE0,0xFB,0xC3,0xEF,0x9B,0xFF,0xEE,
+
+	0x9A,0xFE,0xED,0x99,0xFD,0xEC,0x98,0xFC,
+
+	0x90,0x43,0x1A,0x12,0x4B,0x6C,0x80,0x2E,
+
+	0x90,0x43,0x1A,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x43,
+
+	0x16,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+
+	0xFA,0xA3,0xE0,0xFB,0xEF,0x2B,0xFF,0xEE,
+
+	0x3A,0xFE,0xED,0x39,0xFD,0xEC,0x38,0xFC,
+
+	0x90,0x43,0x1A,0x12,0x4B,0x6C,0x90,0x43,
+
+	0x1A,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x78,0x04,0x12,0x4B,
+
+	0x59,0x90,0x43,0x0E,0xE0,0xF8,0xA3,0xE0,
+
+	0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,
+
+	0x12,0x4B,0x21,0x50,0x06,0x90,0x43,0x27,
+
+	0xE0,0x04,0xF0,0x90,0x43,0x25,0xE0,0x04,
+
+	0xF0,0xE4,0xA3,0xF0,0x90,0x43,0x25,0xE0,
+
+	0xC3,0x94,0x08,0x40,0x6B,0x90,0x43,0x27,
+
+	0xE0,0xFF,0x70,0x1A,0x90,0x42,0x38,0xF0,
+
+	0x90,0xF7,0x07,0x74,0xFC,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0x74,0xC9,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0x74,0x5E,0xF0,0x80,0x26,0xEF,0xD3,
+
+	0x94,0x07,0x40,0x20,0x90,0x42,0x38,0x74,
+
+	0x01,0xF0,0x90,0xF7,0x07,0x74,0xFC,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0x7E,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x74,0x2F,0xF0,0x90,0x42,
+
+	0x39,0x74,0x01,0xF0,0x90,0x42,0xF7,0xE0,
+
+	0x04,0xF0,0xE4,0x90,0x43,0x25,0xF0,0x90,
+
+	0x43,0x27,0xF0,0x22,0x90,0xF7,0x07,0x74,
+
+	0xFC,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x7E,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x2F,0xF0,
+
+	0x22,0xE4,0x90,0x42,0x68,0xF0,0xA3,0xF0,
+
+	0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0x90,0xF5,0xB3,0x04,0xF0,0x90,0xF5,0xB1,
+
+	0xE4,0xF0,0x90,0xF5,0xB0,0xF0,0x90,0xF5,
+
+	0xC2,0x04,0xF0,0x90,0xF5,0xB0,0xF0,0x90,
+
+	0xF5,0xC2,0xE4,0xF0,0x90,0x42,0x74,0xF0,
+
+	0x90,0x42,0x5F,0xE0,0x70,0x05,0x90,0x42,
+
+	0x74,0x04,0xF0,0x90,0x42,0x64,0x12,0x4B,
+
+	0x78,0x00,0x00,0x00,0x00,0x90,0xF2,0x1B,
+
+	0x74,0x40,0xF0,0xE4,0x90,0x42,0x78,0xF0,
+
+	0x90,0x42,0x74,0xE0,0xFF,0x90,0x42,0x78,
+
+	0xE0,0xFE,0xD3,0x9F,0x40,0x03,0x02,0x5B,
+
+	0x8B,0x90,0xF5,0xB8,0xEE,0xF0,0x90,0x42,
+
+	0x72,0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0xE4,
+
+	0x9F,0xFF,0xE4,0x9E,0x90,0x42,0x75,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x42,0x72,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x90,0x42,0x75,0xE0,0xFC,
+
+	0xA3,0xE0,0xFD,0xD3,0x9F,0xEE,0x64,0x80,
+
+	0xF8,0xEC,0x64,0x80,0x98,0x40,0x03,0x02,
+
+	0x5B,0x82,0xE0,0x90,0xF4,0x11,0xF0,0xEC,
+
+	0xFF,0x33,0x95,0xE0,0xA3,0xEF,0xF0,0x90,
+
+	0xF5,0xB5,0x74,0x01,0xF0,0x90,0x42,0x78,
+
+	0xE0,0xFF,0x25,0xE0,0x24,0x41,0x90,0xF2,
+
+	0x1B,0xF0,0x7D,0x80,0x7C,0x3E,0xE4,0xFF,
+
+	0x12,0xAB,0xED,0x90,0x44,0xAA,0xE0,0xB4,
+
+	0x01,0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,
+
+	0x90,0xF5,0xB5,0xE0,0x64,0x01,0x60,0x04,
+
+	0x7E,0x01,0x80,0x02,0x7E,0x00,0xEE,0x5F,
+
+	0x70,0xE1,0x90,0xF5,0xB5,0xE0,0xB4,0x01,
+
+	0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,0x90,
+
+	0x42,0x77,0xEF,0xF0,0x90,0x41,0xF8,0xF0,
+
+	0x90,0x42,0x78,0xE0,0xFD,0x25,0xE0,0x24,
+
+	0x42,0x90,0xF2,0x1B,0xF0,0x90,0x42,0x75,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x12,0x9A,0x29,
+
+	0x90,0x42,0x76,0xE0,0x04,0xF0,0x70,0x06,
+
+	0x90,0x42,0x75,0xE0,0x04,0xF0,0x02,0x5A,
+
+	0xDC,0x90,0x42,0x78,0xE0,0x04,0xF0,0x02,
+
+	0x5A,0xB1,0x90,0x42,0x68,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0xD3,0x90,0x42,0x6B,0xE0,0x9F,
+
+	0x90,0x42,0x6A,0xE0,0x9E,0x50,0x03,0x02,
+
+	0x5C,0x86,0x90,0x41,0xE7,0xE0,0x64,0x01,
+
+	0xF0,0x90,0xF0,0x76,0xF0,0xE4,0x90,0x42,
+
+	0x6E,0xF0,0x90,0xF1,0xB5,0xE0,0x90,0x42,
+
+	0x6F,0xF0,0x90,0xF1,0xB4,0xE0,0x90,0x42,
+
+	0x70,0xF0,0x90,0xF1,0xB3,0xE0,0x90,0x42,
+
+	0x71,0xF0,0xE4,0xFF,0xFE,0x7D,0x40,0xFC,
+
+	0x90,0x42,0x6E,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0x12,0x4B,
+
+	0x0B,0x40,0x23,0x90,0x42,0x6E,0xE0,0xF8,
+
+	0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,
+
+	0xFB,0xE4,0x9B,0xFF,0xE4,0x9A,0xFE,0x74,
+
+	0x80,0x99,0xFD,0xE4,0x98,0xFC,0x90,0x42,
+
+	0x6E,0x12,0x4B,0x6C,0x80,0x17,0x90,0x42,
+
+	0x6E,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x12,0x4A,0xFD,0x90,
+
+	0x42,0x6E,0x12,0x4B,0x6C,0x90,0x42,0x60,
+
+	0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,
+
+	0xA3,0xE0,0xFB,0xC3,0xE4,0x9B,0xFF,0xE4,
+
+	0x9A,0xFE,0x74,0x80,0x99,0xFD,0xE4,0x98,
+
+	0xFC,0x90,0x42,0x60,0x12,0x4B,0x6C,0x90,
+
+	0xF1,0xEB,0x74,0x01,0xF0,0xE4,0xF0,0x90,
+
+	0x42,0x6F,0xE0,0x90,0xF1,0xA5,0xF0,0x90,
+
+	0x42,0x70,0xE0,0x90,0xF1,0xA4,0xF0,0x90,
+
+	0x42,0x71,0xE0,0x90,0xF1,0xA3,0xF0,0x90,
+
+	0xF1,0x14,0xE0,0x70,0x06,0x90,0xF1,0x10,
+
+	0xE0,0x60,0x1A,0x90,0xF1,0x0E,0xE0,0xF4,
+
+	0xF0,0xA3,0xE0,0xF4,0xF0,0x90,0xF1,0x12,
+
+	0xE0,0xF4,0xF0,0xA3,0xE0,0xF4,0xF0,0x90,
+
+	0xF1,0x0A,0x74,0x01,0xF0,0x90,0x42,0x6C,
+
+	0xE0,0xFF,0x33,0x95,0xE0,0x90,0xF4,0x0D,
+
+	0xEF,0xF0,0x90,0x42,0x6D,0xE0,0x90,0xF4,
+
+	0x0C,0xF0,0x90,0xF5,0xB6,0x74,0x01,0xF0,
+
+	0x90,0xF2,0x1B,0x74,0x45,0xF0,0x7D,0x80,
+
+	0x7C,0x3E,0xE4,0xFF,0x12,0xAB,0xED,0x90,
+
+	0x44,0xAA,0xE0,0xB4,0x01,0x04,0x7F,0x01,
+
+	0x80,0x02,0x7F,0x00,0x90,0xF5,0xB7,0xE0,
+
+	0x64,0x01,0x60,0x04,0x7E,0x01,0x80,0x02,
+
+	0x7E,0x00,0xEE,0x5F,0x70,0xE1,0x90,0xF5,
+
+	0xB7,0xE0,0xB4,0x01,0x04,0x7F,0x01,0x80,
+
+	0x02,0x7F,0x00,0x90,0x42,0x77,0xEF,0xF0,
+
+	0x90,0x41,0xFF,0xF0,0x90,0xF2,0x1B,0x74,
+
+	0x46,0xF0,0x04,0xF0,0x90,0xF5,0xB6,0xE4,
+
+	0xF0,0x90,0xF5,0xC2,0x04,0xF0,0x90,0xF5,
+
+	0xB0,0xE4,0xF0,0x90,0xF5,0xC2,0xF0,0x22,
+
+	0xE4,0x90,0x44,0x2F,0xF0,0xA3,0xF0,0x90,
+
+	0x44,0x33,0xF0,0xA3,0x04,0xF0,0xE4,0x90,
+
+	0x44,0xB1,0xF0,0x90,0xF5,0xAD,0xF0,0x90,
+
+	0x44,0x2D,0xF0,0xA3,0xF0,0x90,0x44,0x2D,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x94,0x03,
+
+	0xEE,0x94,0x00,0x40,0x03,0x02,0x5E,0xA1,
+
+	0xEF,0x4E,0x70,0x22,0x90,0xF4,0x61,0xF0,
+
+	0x90,0xF4,0x60,0xF0,0x90,0xF4,0x64,0x74,
+
+	0x02,0xF0,0x90,0xF4,0x63,0x74,0x06,0xF0,
+
+	0x90,0x43,0xDF,0xE0,0x60,0x5A,0x90,0xF4,
+
+	0x63,0x74,0x07,0xF0,0x80,0x52,0x90,0x44,
+
+	0x2D,0xE0,0x70,0x04,0xA3,0xE0,0x64,0x01,
+
+	0x70,0x22,0x90,0xF4,0x61,0x74,0x02,0xF0,
+
+	0x90,0xF4,0x60,0xF0,0x90,0xF4,0x6C,0xF0,
+
+	0x90,0xF4,0x6B,0x74,0x04,0xF0,0x90,0x43,
+
+	0xDF,0xE0,0x60,0x2C,0x90,0xF4,0x6B,0x74,
+
+	0x07,0xF0,0x80,0x24,0x90,0xF4,0x61,0x74,
+
+	0x01,0xF0,0x90,0xF4,0x60,0x74,0x04,0xF0,
+
+	0x90,0xF4,0x68,0x74,0x02,0xF0,0x90,0xF4,
+
+	0x65,0x74,0x05,0xF0,0x90,0x43,0xDF,0xE0,
+
+	0x60,0x06,0x90,0xF4,0x65,0x74,0x07,0xF0,
+
+	0x90,0xF5,0xAC,0x74,0x01,0xF0,0x90,0xF5,
+
+	0xAE,0xE0,0xB4,0x01,0xF9,0x90,0xF5,0xAE,
+
+	0x74,0x01,0xF0,0x90,0xF4,0x6F,0xE0,0xFE,
+
+	0x90,0xF4,0x6E,0xE0,0xFD,0xEE,0xED,0xFF,
+
+	0x90,0x44,0x31,0xEE,0xF0,0xA3,0xEF,0xF0,
+
+	0x90,0xF4,0x73,0xE0,0xFE,0x90,0xF4,0x72,
+
+	0xE0,0xFD,0xEE,0xED,0xFF,0x90,0x44,0x35,
+
+	0xEE,0xF0,0xA3,0xEF,0xF0,0x90,0x44,0x33,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xFB,0xAA,0x06,
+
+	0xE4,0xF9,0xF8,0x90,0x44,0x31,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0xE4,0xFC,0xFD,0x12,0x4A,
+
+	0xAE,0xC0,0x04,0xC0,0x05,0xC0,0x06,0xC0,
+
+	0x07,0x90,0x44,0x35,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0xFB,0xAA,0x06,0xE4,0xF9,0xF8,0x90,
+
+	0x44,0x2F,0xE0,0xFE,0xA3,0xE0,0xFF,0xE4,
+
+	0xFC,0xFD,0x12,0x4A,0xAE,0xA8,0x04,0xA9,
+
+	0x05,0xAA,0x06,0xAB,0x07,0xD0,0x07,0xD0,
+
+	0x06,0xD0,0x05,0xD0,0x04,0xC3,0x12,0x4B,
+
+	0x21,0x50,0x4F,0x90,0x44,0x31,0xE0,0xFF,
+
+	0xA3,0xE0,0x90,0x44,0x2F,0xCF,0xF0,0xA3,
+
+	0xEF,0xF0,0x90,0x44,0x35,0xE0,0xFF,0xA3,
+
+	0xE0,0x90,0x44,0x33,0xCF,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0xF4,0x74,0xE0,0x90,0x44,0x29,
+
+	0xF0,0x90,0xF4,0x75,0xE0,0x90,0x44,0x2A,
+
+	0xF0,0x90,0xF4,0x76,0xE0,0x90,0x44,0x2B,
+
+	0xF0,0x90,0xF4,0x77,0xE0,0x90,0x44,0x2C,
+
+	0xF0,0x90,0x44,0x2E,0xE0,0x25,0xE0,0xFF,
+
+	0x90,0x44,0x2D,0xE0,0x33,0x90,0x44,0xB1,
+
+	0xEF,0xF0,0x90,0xF5,0xAC,0xE4,0xF0,0x90,
+
+	0x44,0x2E,0xE0,0x04,0xF0,0x70,0x06,0x90,
+
+	0x44,0x2D,0xE0,0x04,0xF0,0x02,0x5D,0x1E,
+
+	0x90,0x44,0x2C,0xE0,0xFF,0x90,0x44,0x2B,
+
+	0xE0,0xC3,0x9F,0x50,0x0D,0x90,0x44,0x28,
+
+	0x74,0x03,0xF0,0x90,0x44,0x2B,0xEF,0xF0,
+
+	0x80,0x06,0x90,0x44,0x28,0x74,0x02,0xF0,
+
+	0x90,0x44,0x2A,0xE0,0xFF,0x90,0x44,0x29,
+
+	0xE0,0xC3,0x9F,0x50,0x0D,0x90,0x44,0xB2,
+
+	0x74,0x01,0xF0,0x90,0x44,0x29,0xEF,0xF0,
+
+	0x80,0x05,0xE4,0x90,0x44,0xB2,0xF0,0x90,
+
+	0x44,0x2B,0xE0,0xFF,0x90,0x44,0x29,0xE0,
+
+	0xC3,0x9F,0x50,0x08,0x90,0x44,0x28,0xE0,
+
+	0x90,0x44,0xB2,0xF0,0x90,0x44,0x9A,0xE0,
+
+	0xB4,0x01,0x1F,0x90,0x44,0x9C,0xE0,0xFF,
+
+	0x70,0x06,0x90,0x44,0xB1,0xF0,0x80,0x12,
+
+	0xEF,0xB4,0x01,0x08,0x90,0x44,0xB1,0x74,
+
+	0x02,0xF0,0x80,0x06,0x90,0x44,0xB1,0x74,
+
+	0x04,0xF0,0x90,0x44,0xB2,0xE0,0x90,0xF9,
+
+	0x01,0xF0,0x90,0x44,0xB1,0xE0,0xFF,0x70,
+
+	0x06,0x90,0xF9,0x00,0xF0,0x80,0x21,0xEF,
+
+	0xC3,0x94,0x04,0x40,0x0E,0x90,0xF9,0x00,
+
+	0x74,0x02,0xF0,0x90,0x44,0xB2,0xE0,0x04,
+
+	0xF0,0x80,0x0D,0x90,0xF9,0x00,0x74,0x01,
+
+	0xF0,0x90,0x44,0xB2,0xE0,0x24,0x02,0xF0,
+
+	0x90,0x44,0xB2,0xE0,0xFD,0x12,0xAF,0x75,
+
+	0x90,0x44,0xB2,0xE0,0x24,0x06,0xFF,0x74,
+
+	0x01,0x7E,0x00,0xA8,0x07,0x08,0x80,0x05,
+
+	0xC3,0x33,0xCE,0x33,0xCE,0xD8,0xF9,0x24,
+
+	0xF6,0xFF,0xEE,0x34,0xFF,0x90,0x44,0x2D,
+
+	0xF0,0xA3,0xEF,0xF0,0xE0,0x90,0xF4,0x69,
+
+	0xF0,0x90,0x44,0x2D,0xE0,0x90,0xF4,0x6A,
+
+	0xF0,0x90,0xF4,0x6D,0x74,0x14,0xF0,0x90,
+
+	0xF5,0xAC,0xE4,0xF0,0x22,0xE4,0x90,0x44,
+
+	0x99,0xF0,0x90,0xFE,0x01,0xE0,0x54,0x7F,
+
+	0xFB,0x90,0xFE,0x08,0xE0,0xFD,0xA3,0xE0,
+
+	0x90,0x44,0x97,0xCD,0xF0,0xA3,0xED,0xF0,
+
+	0xAF,0x03,0xEF,0x60,0x0F,0x90,0xFE,0x02,
+
+	0xE0,0xFD,0xA3,0xE0,0x90,0x44,0x97,0xCD,
+
+	0xF0,0xA3,0xED,0xF0,0x90,0x44,0x97,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xC3,0xEC,0x94,0x40,
+
+	0x50,0x12,0x90,0x41,0x8C,0xE0,0x2D,0xFE,
+
+	0x90,0x41,0x8B,0xE0,0x3C,0x90,0x44,0x97,
+
+	0xF0,0xA3,0xCE,0xF0,0x90,0xFE,0x00,0xE0,
+
+	0x64,0x03,0x70,0x29,0xEB,0x64,0x02,0x70,
+
+	0x24,0x04,0xF0,0x90,0x44,0x97,0xE0,0xFE,
+
+	0xA3,0xE0,0xF5,0x82,0x8E,0x83,0xE0,0x90,
+
+	0xFE,0x01,0xF0,0x90,0xFB,0x90,0x74,0x02,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xF0,0x90,0x44,
+
+	0x99,0xF0,0x02,0x61,0xC7,0x90,0xFE,0x00,
+
+	0xE0,0x64,0x04,0x70,0x42,0xAF,0x03,0xEB,
+
+	0x64,0x03,0x70,0x3B,0x90,0x41,0x8B,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x44,0x97,0xE0,
+
+	0xB5,0x06,0x11,0xA3,0xE0,0xB5,0x07,0x0C,
+
+	0x12,0xA1,0xB1,0x90,0x44,0x99,0x74,0x03,
+
+	0xF0,0x02,0x61,0xC7,0x90,0xFE,0x04,0xE0,
+
+	0xFF,0x90,0x44,0x97,0xE0,0xFC,0xA3,0xE0,
+
+	0xF5,0x82,0x8C,0x83,0xEF,0xF0,0x90,0x44,
+
+	0x99,0x74,0x02,0xF0,0x02,0x61,0xC7,0x90,
+
+	0x44,0x95,0x74,0xFE,0xF0,0xA3,0x74,0x0A,
+
+	0xF0,0x90,0xFE,0x00,0xE0,0xFF,0x24,0xFF,
+
+	0xF5,0x82,0xE4,0x34,0xFD,0xF5,0x83,0xE0,
+
+	0xFC,0xA3,0xE0,0xF4,0xFD,0xEC,0xF4,0x90,
+
+	0x44,0x93,0xF0,0xA3,0xED,0xF0,0xEF,0x24,
+
+	0xFE,0xFF,0x12,0xA2,0xC2,0x90,0x44,0x93,
+
+	0xE0,0x6E,0x70,0x03,0xA3,0xE0,0x6F,0x60,
+
+	0x09,0x90,0x44,0x99,0x74,0x02,0xF0,0x02,
+
+	0x61,0xC7,0x90,0x41,0x8B,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x44,0x97,0xE0,0xB5,0x06,
+
+	0x27,0xA3,0xE0,0xB5,0x07,0x22,0x12,0xA1,
+
+	0xB1,0x90,0x44,0x99,0x74,0x01,0xF0,0xE4,
+
+	0xFD,0xFF,0x12,0xAC,0xC0,0x90,0xFE,0x01,
+
+	0xE0,0xFE,0xA3,0xE0,0xF4,0xFF,0xEE,0xF4,
+
+	0xA3,0xF0,0xA3,0xEF,0xF0,0x02,0x61,0xC7,
+
+	0x90,0xFE,0x04,0xE0,0xFF,0xFC,0x90,0xFE,
+
+	0x01,0xE0,0x54,0x3F,0xFA,0xA3,0xE0,0xFB,
+
+	0xEA,0x60,0x03,0x02,0x62,0x27,0xEB,0x60,
+
+	0x57,0x24,0xF8,0x60,0x53,0x14,0x60,0x12,
+
+	0x24,0xFC,0x70,0x03,0x02,0x61,0xBE,0x24,
+
+	0xEB,0x60,0x7D,0x24,0x21,0x60,0x03,0x02,
+
+	0x62,0x27,0xEF,0x60,0x23,0x1F,0x90,0x44,
+
+	0x95,0xE0,0xFA,0xA3,0xE0,0x2F,0xF5,0x82,
+
+	0xE4,0x3A,0xF5,0x83,0xE0,0xFE,0x90,0x44,
+
+	0x97,0xE0,0xFA,0xA3,0xE0,0x2F,0xF5,0x82,
+
+	0xE4,0x3A,0xF5,0x83,0xEE,0xF0,0x80,0xDA,
+
+	0xE4,0xFD,0xFF,0x12,0xAC,0xC0,0x90,0xFE,
+
+	0x01,0xE0,0xFE,0xA3,0xE0,0xF4,0xFF,0xEE,
+
+	0xF4,0xA3,0xF0,0xA3,0xEF,0xF0,0x80,0x7E,
+
+	0xAF,0x04,0xE4,0xFD,0x12,0xAC,0xC0,0x90,
+
+	0x44,0x97,0xE0,0xFE,0xA3,0xE0,0xFF,0xAD,
+
+	0x04,0x12,0xA6,0x5B,0x90,0xFE,0x00,0xE0,
+
+	0x24,0xFE,0xFF,0x12,0xA2,0xC2,0xEF,0xF4,
+
+	0xFF,0xEE,0xF4,0xFE,0x90,0xFE,0x00,0xE0,
+
+	0x24,0xFF,0xF5,0x82,0xE4,0x34,0xFD,0xF5,
+
+	0x83,0xEE,0xF0,0xA3,0xEF,0xF0,0x80,0x46,
+
+	0xE4,0xFD,0x7F,0x04,0x12,0xAC,0xC0,0x90,
+
+	0xFE,0x03,0x74,0x04,0xF0,0xA3,0x74,0x15,
+
+	0xF0,0xA3,0x74,0x06,0xF0,0xA3,0x74,0xFB,
+
+	0xF0,0x90,0xFE,0x00,0xE0,0x24,0xFE,0xFF,
+
+	0x12,0xA2,0xC2,0xEF,0xF4,0xFF,0xEE,0xF4,
+
+	0xFE,0x90,0xFE,0x00,0xE0,0x24,0xFF,0xF5,
+
+	0x82,0xE4,0x34,0xFD,0xF5,0x83,0xEE,0xF0,
+
+	0xA3,0xEF,0xF0,0x80,0x09,0x90,0xFB,0x86,
+
+	0x74,0x01,0xF0,0x12,0xA6,0xD7,0x90,0xFB,
+
+	0x86,0x74,0x01,0xF0,0x90,0x44,0x99,0xE0,
+
+	0xFF,0x64,0x02,0x60,0x24,0xEF,0x64,0x03,
+
+	0x60,0x1F,0x90,0xF9,0x9F,0xE0,0x60,0x14,
+
+	0x90,0xFB,0x88,0xE0,0x64,0x01,0x60,0xF8,
+
+	0x90,0xFB,0x96,0xE4,0xF0,0x90,0xFB,0x88,
+
+	0x04,0xF0,0x80,0x05,0x90,0xFB,0x93,0xE4,
+
+	0xF0,0x90,0x44,0x99,0xE0,0xFF,0x64,0x01,
+
+	0x60,0x04,0xEF,0xB4,0x03,0x20,0xE4,0xF5,
+
+	0x13,0xC2,0xAF,0x7A,0xAF,0x79,0xA0,0x12,
+
+	0x4B,0xA9,0x7A,0xAF,0x79,0xA0,0x12,0x4B,
+
+	0xA9,0x7B,0x01,0x7A,0x44,0x79,0x6A,0x7D,
+
+	0x01,0x7C,0x00,0x12,0xA1,0x83,0x22,0x90,
+
+	0x44,0xBB,0xEF,0xF0,0xC2,0xEB,0xE4,0x90,
+
+	0x43,0x6A,0xF0,0xA3,0xF0,0x90,0xF9,0x01,
+
+	0xE0,0xD3,0x94,0x01,0x50,0x0A,0x90,0x43,
+
+	0x6A,0x74,0x05,0xF0,0xA3,0x74,0x55,0xF0,
+
+	0x90,0xF9,0x01,0xE0,0x24,0x06,0xFF,0x74,
+
+	0x01,0x7E,0x00,0xA8,0x07,0x08,0x80,0x05,
+
+	0xC3,0x33,0xCE,0x33,0xCE,0xD8,0xF9,0x90,
+
+	0x43,0x72,0xF0,0xEE,0x90,0x43,0x71,0xF0,
+
+	0x90,0xF9,0x00,0xE0,0x70,0x34,0x90,0x43,
+
+	0x61,0x74,0x02,0xF0,0xA3,0x74,0xAB,0xF0,
+
+	0x90,0x43,0x69,0x74,0x28,0xF0,0x90,0x44,
+
+	0xBD,0x74,0x05,0xF0,0x90,0xF5,0xEF,0x74,
+
+	0x28,0xF0,0x90,0x43,0x6A,0xE0,0xFE,0xA3,
+
+	0xE0,0x78,0x02,0xCE,0xC3,0x13,0xCE,0x13,
+
+	0xD8,0xF9,0xF0,0xEE,0x90,0x43,0x6A,0xF0,
+
+	0x80,0x6F,0x90,0xF9,0x00,0xE0,0xB4,0x01,
+
+	0x34,0x90,0x43,0x61,0x74,0x0A,0xF0,0xA3,
+
+	0x74,0xAB,0xF0,0x90,0x43,0x69,0x74,0x50,
+
+	0xF0,0x90,0x44,0xBD,0x74,0x12,0xF0,0x90,
+
+	0xF5,0xEF,0x74,0x50,0xF0,0x90,0x43,0x71,
+
+	0xE0,0xFE,0xA3,0xE0,0x78,0x02,0xC3,0x33,
+
+	0xCE,0x33,0xCE,0xD8,0xF9,0xF0,0xEE,0x90,
+
+	0x43,0x71,0xF0,0x80,0x34,0x90,0x43,0x61,
+
+	0x74,0x05,0xF0,0xA3,0x74,0x55,0xF0,0x90,
+
+	0x43,0x69,0x74,0x3C,0xF0,0x90,0x44,0xBD,
+
+	0x74,0x09,0xF0,0x90,0xF5,0xEF,0x74,0x3C,
+
+	0xF0,0x90,0x43,0x72,0xE0,0x25,0xE0,0xF0,
+
+	0x90,0x43,0x71,0xE0,0x33,0xF0,0x90,0x43,
+
+	0x6A,0xE0,0xC3,0x13,0xF0,0xA3,0xE0,0x13,
+
+	0xF0,0x90,0x43,0x6A,0xE0,0xFF,0xA3,0xE0,
+
+	0xA3,0xCF,0xF0,0xA3,0xEF,0xF0,0x90,0x43,
+
+	0x69,0xE0,0x90,0xF5,0xE2,0xF0,0x90,0x43,
+
+	0x71,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x43,
+
+	0x62,0xE0,0x2F,0xFF,0x90,0x43,0x61,0xE0,
+
+	0x3E,0xA2,0xE7,0x13,0xFE,0xEF,0x13,0xFF,
+
+	0x90,0xF5,0xFE,0xF0,0xEE,0xA3,0xF0,0xE4,
+
+	0x90,0x43,0x6F,0xF0,0xA3,0xF0,0x90,0xF5,
+
+	0x3B,0xF0,0x90,0xF5,0xBB,0xF0,0x90,0xF5,
+
+	0xB1,0xF0,0x90,0xF5,0xC8,0xF0,0x90,0xF5,
+
+	0xF8,0x04,0xF0,0x90,0xF5,0xDF,0x74,0xFB,
+
+	0xF0,0xA3,0xE4,0xF0,0x90,0xF5,0xE3,0x74,
+
+	0x09,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0xF0,
+
+	0x90,0xF5,0xFD,0xF0,0x90,0xF6,0x6D,0xE4,
+
+	0xF0,0x90,0xF5,0xF9,0x74,0x04,0xF0,0x90,
+
+	0x42,0x0E,0xE0,0xB4,0x01,0x1B,0x90,0x44,
+
+	0xBB,0xE0,0xB4,0x01,0x14,0x90,0xF5,0xE3,
+
+	0x74,0x01,0xF0,0x90,0xF5,0xF9,0xF0,0x90,
+
+	0xF5,0xFE,0x74,0xFF,0xF0,0xA3,0x74,0x0F,
+
+	0xF0,0xE4,0x90,0x44,0xBC,0xF0,0x90,0x43,
+
+	0x4B,0xE0,0xB4,0x01,0x22,0xE4,0x90,0x41,
+
+	0xEF,0xF0,0x90,0x43,0x8A,0xF0,0x90,0x43,
+
+	0x4C,0xF0,0x90,0x43,0x77,0xF0,0xA3,0xF0,
+
+	0x90,0xF0,0x2B,0xE0,0xB4,0x01,0x11,0x90,
+
+	0x42,0x12,0x74,0x25,0xF0,0x80,0x09,0x90,
+
+	0x42,0x0F,0xE0,0x14,0x90,0x43,0x77,0xF0,
+
+	0x90,0x42,0x0F,0xE0,0xFF,0x90,0x43,0x77,
+
+	0xE0,0xC3,0x9F,0x50,0x53,0x90,0x44,0xBC,
+
+	0xE0,0x04,0xF0,0x90,0xF5,0xE7,0xE4,0xF0,
+
+	0xA3,0x04,0xF0,0x90,0xF5,0xE1,0xE4,0xF0,
+
+	0x90,0xF5,0xE7,0x04,0xF0,0x90,0xF5,0xE8,
+
+	0xE0,0xB4,0x01,0xF9,0x90,0xF5,0xE1,0xE0,
+
+	0x90,0x43,0x4D,0xF0,0xE0,0xB4,0x05,0x20,
+
+	0x74,0x06,0xF0,0x90,0xF5,0xEA,0xE0,0x90,
+
+	0x43,0x60,0xF0,0x90,0x43,0x4D,0xE0,0x90,
+
+	0xF5,0xE1,0xF0,0x90,0x44,0xBB,0xE0,0xFF,
+
+	0x90,0x44,0xBD,0xE0,0xFD,0x12,0x4D,0x7B,
+
+	0x90,0x43,0x77,0xE0,0x04,0xF0,0x80,0xA0,
+
+	0x12,0x6C,0xF4,0xE4,0x90,0x43,0x4B,0xF0,
+
+	0x90,0x43,0x4D,0xE0,0xFF,0x64,0x0E,0x60,
+
+	0x47,0xEF,0xB4,0x06,0x05,0x12,0x45,0x50,
+
+	0x80,0xEE,0x90,0x43,0x4D,0xE0,0x64,0x07,
+
+	0x70,0x22,0x12,0x84,0x03,0x90,0xF5,0xE8,
+
+	0x74,0x01,0xF0,0x90,0x43,0x4D,0xE0,0x90,
+
+	0xF5,0xE1,0xF0,0x90,0xF5,0xE8,0xE0,0xB4,
+
+	0x01,0xF9,0x90,0xF5,0xE6,0xE4,0xF0,0x12,
+
+	0x8A,0xED,0x80,0xC4,0x90,0x43,0x4D,0xE0,
+
+	0xB4,0x0C,0xBD,0x90,0x44,0xBB,0xE0,0xFF,
+
+	0x12,0x81,0x24,0x12,0x9B,0x32,0x80,0xB0,
+
+	0x90,0xF5,0xE7,0xE4,0xF0,0x90,0xF5,0xE1,
+
+	0xF0,0xD2,0xEB,0x22,0xC2,0xE9,0xC2,0xEA,
+
+	0xD2,0xA8,0xD2,0xAF,0x90,0x43,0xB8,0xE0,
+
+	0x60,0x12,0x90,0xF9,0x57,0xE0,0x54,0xFD,
+
+	0x44,0x02,0xF0,0xE0,0x54,0xFD,0xF0,0xE4,
+
+	0x90,0x43,0xB8,0xF0,0x90,0xF5,0xA9,0x74,
+
+	0x01,0xF0,0x90,0xF0,0x71,0xE4,0xF0,0x90,
+
+	0xF1,0xE9,0xF0,0x90,0xF0,0xD5,0xF0,0x90,
+
+	0xF0,0xE3,0xF0,0x90,0xF0,0xE2,0xF0,0x90,
+
+	0xF1,0xEA,0xF0,0x90,0xF1,0xEF,0xF0,0x90,
+
+	0xF1,0xF2,0xF0,0x90,0xF1,0xF7,0xF0,0x90,
+
+	0xF1,0xFB,0xF0,0x90,0xF5,0xAF,0xF0,0xA3,
+
+	0xF0,0xA3,0xF0,0x90,0xF5,0xBB,0xF0,0x90,
+
+	0xF5,0xA8,0xF0,0x90,0xF5,0xAC,0xF0,0x90,
+
+	0xF5,0xC8,0xF0,0x90,0xF4,0x71,0xF0,0x90,
+
+	0xF9,0x0B,0xF0,0x90,0xF5,0xE7,0xF0,0x90,
+
+	0xF5,0xE1,0xF0,0x90,0xF4,0x71,0xF0,0x90,
+
+	0xF5,0xD7,0xF0,0x90,0xF6,0x25,0xF0,0x90,
+
+	0xFD,0xA2,0xF0,0x90,0xF1,0xE8,0x04,0xF0,
+
+	0x90,0xF0,0x6C,0xF0,0x90,0xF1,0x75,0xF0,
+
+	0x90,0xF1,0x31,0xF0,0xE4,0x90,0x43,0xDF,
+
+	0xF0,0x90,0xF1,0xF6,0x04,0xF0,0x90,0xF1,
+
+	0xFA,0xF0,0x90,0xF1,0xF3,0xF0,0x90,0xF1,
+
+	0xF0,0xF0,0x90,0xF0,0x7D,0xF0,0x90,0xF1,
+
+	0xEB,0xF0,0x90,0xF5,0xC2,0xF0,0x90,0xF5,
+
+	0xB3,0xF0,0x90,0xF5,0xBD,0xF0,0x90,0xF1,
+
+	0xE8,0xF0,0xE4,0xF0,0x90,0xF0,0x6C,0xF0,
+
+	0x90,0xF1,0x75,0xF0,0x90,0xF1,0x31,0xF0,
+
+	0x90,0xF1,0xFA,0xF0,0x90,0x41,0xBA,0xE0,
+
+	0x90,0xF1,0xA3,0xF0,0x90,0x41,0xBB,0xE0,
+
+	0x90,0xF1,0xA4,0xF0,0x90,0x41,0xBC,0xE0,
+
+	0x90,0xF1,0xA5,0xF0,0x90,0xF6,0x21,0x74,
+
+	0x02,0xF0,0x90,0xF6,0x23,0xF0,0x90,0xF5,
+
+	0xC6,0xE4,0xF0,0xA3,0xF0,0x90,0xF5,0xC3,
+
+	0xF0,0xA3,0xF0,0x90,0x41,0xB2,0xE0,0x90,
+
+	0xF1,0x54,0xF0,0x90,0x41,0xB3,0xE0,0x90,
+
+	0xF1,0x55,0xF0,0x90,0x41,0xB4,0xE0,0x90,
+
+	0xF1,0x52,0xF0,0x90,0x41,0xB5,0xE0,0x90,
+
+	0xF1,0x53,0xF0,0x90,0xF1,0x93,0xE4,0xF0,
+
+	0x90,0xF1,0x69,0x74,0x08,0xF0,0x90,0xF1,
+
+	0x5F,0x74,0x02,0xF0,0x90,0xF1,0x4E,0x74,
+
+	0x40,0xF0,0x74,0xFF,0xF0,0x90,0xF1,0x85,
+
+	0xE4,0xF0,0x90,0xF1,0x2F,0x04,0xF0,0x90,
+
+	0xFD,0x02,0xF0,0x90,0xF7,0x0F,0xE4,0xF0,
+
+	0x90,0xF7,0x8A,0x74,0x0F,0xF0,0x90,0xF7,
+
+	0x98,0x74,0x0D,0xF0,0x90,0xF7,0x8B,0x74,
+
+	0x01,0xF0,0x90,0xFD,0xA5,0xE4,0xF0,0x90,
+
+	0xF5,0x52,0x74,0x3F,0xF0,0xA3,0x74,0x05,
+
+	0xF0,0x90,0x44,0x9D,0x74,0x0A,0xF0,0x90,
+
+	0xF0,0x71,0x74,0x01,0xF0,0x90,0xF7,0x15,
+
+	0xF0,0x90,0xF9,0x0E,0xF0,0x90,0xF5,0x06,
+
+	0x74,0x04,0xF0,0x90,0xF7,0x3C,0xE0,0x70,
+
+	0x04,0x90,0xF7,0x2F,0xF0,0x12,0xAE,0x16,
+
+	0x90,0xF7,0x34,0xE4,0xF0,0x90,0xF7,0x33,
+
+	0xF0,0x90,0xF7,0x35,0x74,0x05,0xF0,0xA3,
+
+	0xF0,0x90,0xF7,0x39,0x74,0xFF,0xF0,0xA3,
+
+	0x74,0x9C,0xF0,0x90,0xF7,0x7E,0x74,0x01,
+
+	0xF0,0x90,0xFD,0x00,0xF0,0x90,0xFD,0x90,
+
+	0x74,0x03,0xF0,0x90,0xF2,0x17,0x74,0xFE,
+
+	0xF0,0x90,0xF0,0x42,0x04,0xF0,0xA3,0xF0,
+
+	0xA3,0x74,0x07,0xF0,0xA3,0xF0,0x90,0xF7,
+
+	0x74,0x74,0x01,0xF0,0x90,0xF7,0x6A,0xF0,
+
+	0x12,0xAB,0x75,0x90,0xF7,0x3E,0x74,0x01,
+
+	0xF0,0x90,0xF7,0x3C,0xE0,0x70,0x0B,0x90,
+
+	0x44,0x9B,0xF0,0xD2,0xEA,0x90,0xF7,0x76,
+
+	0x04,0xF0,0x90,0xF7,0x37,0x74,0xDC,0xF0,
+
+	0xA3,0x74,0x05,0xF0,0x90,0xFD,0xA2,0xE4,
+
+	0xF0,0xA3,0xF0,0xA3,0x74,0x05,0xF0,0x90,
+
+	0xF5,0x4D,0x74,0x01,0xF0,0x90,0xF5,0x41,
+
+	0xE4,0xF0,0xA3,0x74,0x02,0xF0,0x90,0xF6,
+
+	0x5C,0xE4,0xF0,0xA3,0xF0,0x90,0xF0,0x5F,
+
+	0x04,0xF0,0x90,0x42,0x0A,0xE0,0x90,0xF0,
+
+	0x06,0xF0,0x90,0xF0,0x58,0xE4,0xF0,0xF0,
+
+	0x90,0x42,0x2B,0xF0,0x90,0x42,0x38,0x74,
+
+	0xFF,0xF0,0x90,0x42,0xFC,0xF0,0x90,0x42,
+
+	0xF7,0xF0,0x90,0xF9,0xE5,0x74,0x1E,0xF0,
+
+	0xA3,0x74,0x05,0xF0,0xA3,0xE4,0xF0,0x90,
+
+	0x42,0x3D,0x74,0xFF,0xF0,0x22,0x90,0xF4,
+
+	0x60,0xE0,0x60,0x03,0x02,0x67,0xA0,0x90,
+
+	0x41,0x92,0xE0,0x90,0xF4,0x03,0xF0,0x90,
+
+	0x41,0x93,0xE0,0x90,0xF4,0x02,0xF0,0x90,
+
+	0x41,0x94,0xE0,0x90,0xF4,0x01,0xF0,0x90,
+
+	0x41,0x95,0xE0,0x90,0xF4,0x00,0xF0,0x90,
+
+	0x41,0x96,0xE0,0x90,0xF4,0x07,0xF0,0x90,
+
+	0x41,0x97,0xE0,0x90,0xF4,0x06,0xF0,0x90,
+
+	0x41,0x98,0xE0,0x90,0xF4,0x05,0xF0,0x90,
+
+	0x41,0x99,0xE0,0x90,0xF4,0x04,0xF0,0x12,
+
+	0xAE,0xA0,0x90,0xF9,0x01,0xE0,0x14,0x60,
+
+	0x16,0x14,0x60,0x1F,0x14,0x60,0x28,0x24,
+
+	0x03,0x70,0x2E,0x90,0xF5,0x59,0x74,0xFA,
+
+	0xF0,0xA3,0x74,0x54,0xF0,0x80,0x22,0x90,
+
+	0xF5,0x59,0x74,0x7A,0xF0,0xA3,0x74,0x52,
+
+	0xF0,0x80,0x16,0x90,0xF5,0x59,0x74,0xE5,
+
+	0xF0,0xA3,0x74,0x4D,0xF0,0x80,0x0A,0x90,
+
+	0xF5,0x59,0x74,0x1B,0xF0,0xA3,0x74,0x46,
+
+	0xF0,0x12,0xAF,0x0C,0x90,0xF7,0x37,0x74,
+
+	0xDC,0xF0,0xA3,0x74,0x05,0xF0,0x22,0x90,
+
+	0xF4,0x60,0xE0,0x64,0x04,0x60,0x03,0x02,
+
+	0x68,0x3B,0x90,0x41,0xAA,0xE0,0x90,0xF4,
+
+	0x03,0xF0,0x90,0x41,0xAB,0xE0,0x90,0xF4,
+
+	0x02,0xF0,0x90,0x41,0xAC,0xE0,0x90,0xF4,
+
+	0x01,0xF0,0x90,0x41,0xAD,0xE0,0x90,0xF4,
+
+	0x00,0xF0,0x90,0x41,0xAE,0xE0,0x90,0xF4,
+
+	0x07,0xF0,0x90,0x41,0xAF,0xE0,0x90,0xF4,
+
+	0x06,0xF0,0x90,0x41,0xB0,0xE0,0x90,0xF4,
+
+	0x05,0xF0,0x90,0x41,0xB1,0xE0,0x90,0xF4,
+
+	0x04,0xF0,0x12,0xAE,0xC0,0x90,0xF9,0x01,
+
+	0xE0,0x14,0x60,0x16,0x14,0x60,0x1F,0x14,
+
+	0x60,0x28,0x24,0x03,0x70,0x2E,0x90,0xF5,
+
+	0x59,0x74,0xA4,0xF0,0xA3,0x74,0x28,0xF0,
+
+	0x80,0x22,0x90,0xF5,0x59,0x74,0x72,0xF0,
+
+	0xA3,0x74,0x27,0xF0,0x80,0x16,0x90,0xF5,
+
+	0x59,0x74,0x41,0xF0,0xA3,0x74,0x25,0xF0,
+
+	0x80,0x0A,0x90,0xF5,0x59,0x74,0x87,0xF0,
+
+	0xA3,0x74,0x21,0xF0,0x12,0xAE,0xD0,0x90,
+
+	0xF7,0x37,0x74,0xB8,0xF0,0xA3,0x74,0x0B,
+
+	0xF0,0x22,0x90,0xF4,0x60,0xE0,0x24,0xFE,
+
+	0x60,0x29,0x14,0x60,0x48,0x24,0x02,0x70,
+
+	0x64,0x90,0x41,0x9A,0xE0,0x90,0xF4,0x03,
+
+	0xF0,0x90,0x41,0x9B,0xE0,0x90,0xF4,0x02,
+
+	0xF0,0x90,0x41,0x9C,0xE0,0x90,0xF4,0x01,
+
+	0xF0,0x90,0x41,0x9D,0xE0,0x90,0xF4,0x00,
+
+	0xF0,0x80,0x42,0x90,0x41,0x9E,0xE0,0x90,
+
+	0xF4,0x03,0xF0,0x90,0x41,0x9F,0xE0,0x90,
+
+	0xF4,0x02,0xF0,0x90,0x41,0xA0,0xE0,0x90,
+
+	0xF4,0x01,0xF0,0x90,0x41,0xA1,0xE0,0x90,
+
+	0xF4,0x00,0xF0,0x80,0x20,0x90,0x41,0xA2,
+
+	0xE0,0x90,0xF4,0x03,0xF0,0x90,0x41,0xA3,
+
+	0xE0,0x90,0xF4,0x02,0xF0,0x90,0x41,0xA4,
+
+	0xE0,0x90,0xF4,0x01,0xF0,0x90,0x41,0xA5,
+
+	0xE0,0x90,0xF4,0x00,0xF0,0x90,0x41,0xA6,
+
+	0xE0,0x90,0xF4,0x07,0xF0,0x90,0x41,0xA7,
+
+	0xE0,0x90,0xF4,0x06,0xF0,0x90,0x41,0xA8,
+
+	0xE0,0x90,0xF4,0x05,0xF0,0x90,0x41,0xA9,
+
+	0xE0,0x90,0xF4,0x04,0xF0,0x12,0xAE,0xB0,
+
+	0x90,0xF9,0x01,0xE0,0x14,0x60,0x16,0x14,
+
+	0x60,0x1F,0x14,0x60,0x28,0x24,0x03,0x70,
+
+	0x2E,0x90,0xF5,0x59,0x74,0x52,0xF0,0xA3,
+
+	0x74,0x14,0xF0,0x80,0x22,0x90,0xF5,0x59,
+
+	0x74,0xB9,0xF0,0xA3,0x74,0x13,0xF0,0x80,
+
+	0x16,0x90,0xF5,0x59,0x74,0xA1,0xF0,0xA3,
+
+	0x74,0x12,0xF0,0x80,0x0A,0x90,0xF5,0x59,
+
+	0x74,0xC4,0xF0,0xA3,0x74,0x10,0xF0,0x12,
+
+	0xAE,0x7E,0x90,0xF7,0x37,0x74,0xB8,0xF0,
+
+	0xA3,0x74,0x0B,0xF0,0x22,0x90,0x41,0xE8,
+
+	0xE0,0x60,0x03,0x02,0x69,0xEB,0x90,0xF0,
+
+	0x60,0xE0,0xC3,0x94,0xD5,0x50,0x27,0x90,
+
+	0x42,0x54,0xE0,0x90,0x44,0x45,0xF0,0x94,
+
+	0x00,0x40,0x06,0xE0,0x14,0x90,0x42,0x54,
+
+	0xF0,0x90,0xF0,0x60,0xE0,0xD3,0x94,0x60,
+
+	0x50,0x24,0x90,0x44,0x47,0x74,0x86,0xF0,
+
+	0x90,0xFB,0x28,0xF0,0x80,0x18,0x90,0xF0,
+
+	0x60,0xE0,0xD3,0x94,0xF7,0x40,0x0F,0xE0,
+
+	0x94,0xFF,0x40,0x0A,0x90,0x44,0x47,0x74,
+
+	0x82,0xF0,0x90,0xFB,0x28,0xF0,0x90,0x41,
+
+	0xE3,0xE0,0x60,0x47,0x90,0xF0,0x61,0xE0,
+
+	0xD3,0x94,0xBA,0x50,0x26,0x90,0x41,0xD5,
+
+	0xE0,0x60,0x38,0x90,0x44,0x46,0xE0,0x25,
+
+	0xE0,0xFF,0xE4,0x33,0xFE,0xEF,0x24,0xA0,
+
+	0xFF,0xE4,0x3E,0xFE,0x90,0xF0,0x61,0xE0,
+
+	0xD3,0x9F,0xEE,0x64,0x80,0xF8,0x74,0x80,
+
+	0x98,0x40,0x18,0x90,0x41,0xDC,0xE0,0xB4,
+
+	0x01,0x07,0x7F,0x02,0x12,0xAD,0x3C,0x80,
+
+	0x05,0x7F,0x0C,0x12,0xAD,0x3C,0xE4,0x90,
+
+	0x41,0xE3,0xF0,0x90,0x41,0xE3,0xE0,0x70,
+
+	0x24,0x90,0xF0,0x61,0xE0,0xC3,0x94,0x5A,
+
+	0x50,0x1B,0x90,0x41,0xDC,0xE0,0xB4,0x01,
+
+	0x07,0x7F,0x01,0x12,0xAD,0x3C,0x80,0x05,
+
+	0x7F,0x0B,0x12,0xAD,0x3C,0x90,0x41,0xE3,
+
+	0x74,0x01,0xF0,0x80,0x05,0x90,0xF0,0x60,
+
+	0xE0,0xFF,0x90,0x41,0xE9,0xE0,0x60,0x03,
+
+	0x02,0x6B,0x1A,0x12,0xA3,0x15,0x90,0x42,
+
+	0x13,0xE0,0xFE,0xEF,0xD3,0x9E,0x50,0x13,
+
+	0x12,0xA3,0x15,0x90,0x42,0x14,0xE0,0xFE,
+
+	0xEF,0xD3,0x9E,0x40,0x68,0x90,0x41,0xD5,
+
+	0xE0,0x60,0x62,0x90,0x42,0x54,0xE0,0xD3,
+
+	0x94,0x00,0x40,0x59,0xE0,0x14,0xF0,0xE0,
+
+	0x90,0x44,0x45,0xF0,0x90,0x41,0xE3,0xE0,
+
+	0x60,0x4B,0x90,0xF0,0x1C,0xE0,0xFE,0x90,
+
+	0xF0,0x1B,0xE0,0x7C,0x00,0x24,0x00,0xFF,
+
+	0xEC,0x3E,0x90,0x44,0x4E,0xF0,0xA3,0xEF,
+
+	0xF0,0xE0,0x24,0xF9,0xF0,0x90,0x44,0x4E,
+
+	0xE0,0x34,0xFF,0xF0,0x90,0xF0,0x0F,0xE0,
+
+	0xFE,0x90,0xF0,0x0E,0xE0,0x24,0x00,0xFF,
+
+	0xEC,0x3E,0x90,0x44,0x4A,0xF0,0xA3,0xEF,
+
+	0xF0,0xE0,0x24,0xF9,0xF0,0x90,0x44,0x4A,
+
+	0xE0,0x34,0xFF,0xF0,0x12,0xA9,0xA8,0x90,
+
+	0x44,0x46,0xE0,0x04,0xF0,0x12,0xA3,0x15,
+
+	0x90,0x42,0x15,0xE0,0xFE,0xEF,0xC3,0x9E,
+
+	0x50,0x06,0x90,0x41,0xD5,0xE0,0x60,0x10,
+
+	0x12,0xA3,0x15,0x90,0x42,0x16,0xE0,0xFE,
+
+	0xEF,0xC3,0x9E,0x40,0x03,0x02,0x6B,0x1A,
+
+	0x90,0x41,0xDC,0xE0,0xB4,0x01,0x04,0x7F,
+
+	0x0F,0x80,0x02,0x7F,0x0B,0x90,0x42,0x54,
+
+	0xE0,0xC3,0x9F,0x50,0x58,0xE0,0x04,0xF0,
+
+	0x90,0x44,0x46,0xE0,0x94,0x00,0x40,0x59,
+
+	0x90,0xF0,0x1C,0xE0,0xFE,0x90,0xF0,0x1B,
+
+	0xE0,0x7C,0x00,0x24,0x00,0xFF,0xEC,0x3E,
+
+	0x90,0x44,0x4E,0xF0,0xA3,0xEF,0xF0,0xE0,
+
+	0x24,0x07,0xF0,0x90,0x44,0x4E,0xE0,0x34,
+
+	0x00,0xF0,0x90,0xF0,0x0F,0xE0,0xFE,0x90,
+
+	0xF0,0x0E,0xE0,0x24,0x00,0xFF,0xEC,0x3E,
+
+	0x90,0x44,0x4A,0xF0,0xA3,0xEF,0xF0,0xE0,
+
+	0x24,0x07,0xF0,0x90,0x44,0x4A,0xE0,0x34,
+
+	0x00,0xF0,0x12,0xA9,0xA8,0x90,0x44,0x46,
+
+	0xE0,0x14,0xF0,0x80,0x0C,0x90,0x44,0x46,
+
+	0xE0,0xD3,0x94,0x00,0x40,0x03,0x12,0xAA,
+
+	0x3A,0x90,0x42,0x54,0xE0,0x90,0x44,0x45,
+
+	0xF0,0x22,0x90,0x41,0xD1,0xE0,0x60,0x6E,
+
+	0x90,0xF9,0x00,0xE0,0x90,0x44,0xB1,0xF0,
+
+	0x90,0xF9,0x01,0xE0,0x90,0x44,0xB2,0xF0,
+
+	0x90,0x44,0xB1,0xE0,0x70,0x0A,0xA3,0xE0,
+
+	0xFD,0xE4,0xFF,0x12,0xAF,0x75,0x80,0x22,
+
+	0x90,0x44,0xB1,0xE0,0xB4,0x02,0x0D,0xA3,
+
+	0xE0,0x04,0xF0,0xE0,0xFD,0x7F,0x04,0x12,
+
+	0xAF,0x75,0x80,0x0E,0x90,0x44,0xB2,0xE0,
+
+	0x24,0x02,0xF0,0xE0,0xFD,0x7F,0x02,0x12,
+
+	0xAF,0x75,0x90,0x44,0xB2,0xE0,0x24,0x06,
+
+	0xFF,0x74,0x01,0x7E,0x00,0xA8,0x07,0x08,
+
+	0x80,0x05,0xC3,0x33,0xCE,0x33,0xCE,0xD8,
+
+	0xF9,0x24,0xF6,0xFF,0xEE,0x34,0xFF,0xFE,
+
+	0xEF,0x90,0xF4,0x69,0xF0,0xEE,0xA3,0xF0,
+
+	0x90,0xF4,0x6D,0x74,0x14,0xF0,0x90,0xF4,
+
+	0x63,0x74,0x05,0xF0,0x90,0x43,0xDF,0xE0,
+
+	0x60,0x06,0x90,0xF4,0x63,0x74,0x07,0xF0,
+
+	0x90,0xF5,0xAD,0x74,0x01,0xF0,0x90,0xF5,
+
+	0xAC,0xE4,0xF0,0x04,0xF0,0x90,0xF5,0xAE,
+
+	0xE0,0xB4,0x01,0xF9,0x90,0xF5,0xAE,0x74,
+
+	0x01,0xF0,0x90,0xF4,0x83,0xE0,0x90,0x44,
+
+	0x52,0xF0,0x90,0xF4,0x82,0xE0,0x90,0x44,
+
+	0x53,0xF0,0x90,0xF4,0x81,0xE0,0x90,0x44,
+
+	0x54,0xF0,0x90,0xF4,0x80,0xE0,0x90,0x44,
+
+	0x55,0xF0,0x90,0xF4,0x86,0xE0,0x30,0xE2,
+
+	0x04,0x7F,0xFF,0x80,0x02,0x7F,0x00,0x90,
+
+	0x44,0x56,0xEF,0xF0,0xE0,0xB4,0xFF,0x09,
+
+	0x90,0xF4,0x86,0xE0,0x44,0xF8,0xFF,0x80,
+
+	0x07,0x90,0xF4,0x86,0xE0,0x54,0x07,0xFF,
+
+	0x90,0x44,0x57,0xEF,0xF0,0x90,0xF4,0x85,
+
+	0xE0,0x90,0x44,0x58,0xF0,0x90,0xF4,0x84,
+
+	0xE0,0x90,0x44,0x59,0xF0,0x90,0x44,0xB2,
+
+	0xE0,0x24,0x05,0xFF,0x74,0x01,0x7E,0x00,
+
+	0xA8,0x07,0x08,0x80,0x05,0xC3,0x33,0xCE,
+
+	0x33,0xCE,0xD8,0xF9,0x90,0x44,0xB0,0xF0,
+
+	0xEE,0x90,0x44,0xAF,0xF0,0x90,0x44,0x56,
+
+	0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,
+
+	0xA3,0xE0,0xFB,0x90,0x44,0x52,0xE0,0xFC,
+
+	0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0x12,0xA4,0xD1,0xA8,0x04,0xA9,0x05,
+
+	0xAA,0x06,0xAB,0x07,0x90,0x44,0xAF,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0xE4,0xFC,0xFD,0xEB,
+
+	0x2F,0xFF,0xEA,0x3E,0xFE,0xED,0x39,0xFD,
+
+	0xEC,0x38,0xFC,0x90,0x44,0x5A,0x12,0x4B,
+
+	0x6C,0x90,0x44,0xB0,0xE0,0x90,0xF5,0x3C,
+
+	0xF0,0x90,0x44,0xAF,0xE0,0x90,0xF5,0x3D,
+
+	0xF0,0xE4,0x7F,0xFF,0x7E,0x07,0xFD,0xFC,
+
+	0x90,0x44,0x5A,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xD3,0x12,
+
+	0x4B,0x0B,0x40,0x0C,0x90,0x44,0x5A,0x12,
+
+	0x4B,0x78,0x00,0x00,0x07,0xFF,0x80,0x26,
+
+	0x7F,0x00,0x7E,0xF8,0x7D,0xFF,0x7C,0xFF,
+
+	0x90,0x44,0x5A,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0x12,
+
+	0x4B,0x0B,0x50,0x0A,0x90,0x44,0x5A,0x12,
+
+	0x4B,0x78,0xFF,0xFF,0xF8,0x00,0x90,0x44,
+
+	0x5D,0xE0,0x90,0xF4,0x66,0xF0,0x90,0x44,
+
+	0x5C,0xE0,0x90,0xF4,0x67,0xF0,0x90,0xF4,
+
+	0x67,0xE0,0x70,0xFA,0x90,0xF4,0x66,0xE0,
+
+	0x70,0xF4,0x22,0x90,0x43,0x63,0x74,0x01,
+
+	0xF0,0x90,0x41,0xEF,0xE0,0xFF,0xD3,0x94,
+
+	0x01,0x40,0x05,0xEF,0x14,0xFF,0x80,0x02,
+
+	0x7F,0x01,0x90,0x43,0x64,0xEF,0xF0,0x90,
+
+	0xF6,0x6D,0x74,0x01,0xF0,0x90,0x41,0xEF,
+
+	0xE0,0x90,0xF6,0x6C,0xF0,0x90,0xF6,0x69,
+
+	0x74,0x01,0xF0,0xE4,0xF9,0x90,0x41,0xEF,
+
+	0xE0,0xFE,0xE9,0xC3,0x9E,0x50,0x47,0xE9,
+
+	0x25,0xE0,0x24,0x50,0xF5,0x82,0xE4,0x34,
+
+	0x43,0xF5,0x83,0xE0,0x90,0xF6,0x6B,0xF0,
+
+	0xE9,0x25,0xE0,0x24,0x51,0xF5,0x82,0xE4,
+
+	0x34,0x43,0xF5,0x83,0xE0,0x90,0xF6,0x6A,
+
+	0xF0,0xE9,0x25,0xE0,0x24,0x58,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xE0,0x90,0xF6,
+
+	0x6B,0xF0,0xE9,0x25,0xE0,0x24,0x59,0xF5,
+
+	0x82,0xE4,0x34,0x43,0xF5,0x83,0xE0,0x90,
+
+	0xF6,0x6A,0xF0,0x09,0x80,0xAF,0x90,0x42,
+
+	0x0E,0xE0,0xB4,0x01,0x46,0x90,0x43,0x47,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0xC3,0x90,0x43,
+
+	0x6B,0xE0,0x9D,0x90,0x43,0x6A,0xE0,0x9C,
+
+	0x50,0x0E,0x90,0x43,0x47,0xE0,0xA3,0xE0,
+
+	0x90,0x43,0x6A,0xEC,0xF0,0xA3,0xED,0xF0,
+
+	0x90,0x43,0x49,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0xC3,0x90,0x43,0x6D,0xE0,0x9D,0x90,0x43,
+
+	0x6C,0xE0,0x9C,0x50,0x0E,0x90,0x43,0x49,
+
+	0xE0,0xA3,0xE0,0x90,0x43,0x6C,0xEC,0xF0,
+
+	0xA3,0xED,0xF0,0x79,0x01,0x90,0x41,0xEF,
+
+	0xE0,0xFE,0xE9,0xC3,0x9E,0x50,0x79,0xE9,
+
+	0x25,0xE0,0x24,0x58,0xF5,0x82,0xE4,0x34,
+
+	0x43,0xF5,0x83,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0x90,0x43,0x58,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xC3,0xED,0x9B,0xFD,0xEC,0x9A,0xFC,0xD3,
+
+	0x90,0x43,0x6B,0xE0,0x9D,0x90,0x43,0x6A,
+
+	0xE0,0x9C,0x40,0x06,0xE9,0x04,0x90,0x43,
+
+	0x63,0xF0,0x90,0x43,0x61,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0x90,0x43,0x59,0xE0,0x2D,0xFD,
+
+	0x90,0x43,0x58,0xE0,0x3C,0xFC,0xC3,0xEE,
+
+	0x99,0xFF,0x25,0xE0,0x24,0x58,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFA,0xA3,
+
+	0xE0,0xFB,0xC3,0xED,0x9B,0xFD,0xEC,0x9A,
+
+	0xFC,0xD3,0x90,0x43,0x6D,0xE0,0x9D,0x90,
+
+	0x43,0x6C,0xE0,0x9C,0x40,0x06,0xEF,0x14,
+
+	0x90,0x43,0x64,0xF0,0x09,0x02,0x6D,0xC6,
+
+	0x90,0x43,0x64,0xE0,0xFF,0x90,0x43,0x63,
+
+	0xE0,0xFE,0xD3,0x9F,0x40,0x0F,0xEF,0x24,
+
+	0x01,0xFD,0xE4,0x33,0xFC,0xEE,0xB5,0x05,
+
+	0xE7,0xE4,0xB5,0x04,0xE3,0x90,0x41,0xEF,
+
+	0xE0,0xFF,0xB4,0x01,0x0C,0xE4,0x90,0x43,
+
+	0x65,0xF0,0x90,0x43,0x4D,0x74,0x0C,0xF0,
+
+	0x22,0x90,0x43,0x64,0xE0,0xF9,0x24,0x01,
+
+	0xFD,0xE4,0x33,0xFC,0x90,0x43,0x63,0xE0,
+
+	0xFE,0xB5,0x05,0x1E,0xE4,0xB5,0x04,0x1A,
+
+	0xEE,0xB5,0x07,0x07,0xE4,0x90,0x43,0x65,
+
+	0xF0,0x80,0x08,0x90,0x43,0x63,0xE0,0x90,
+
+	0x43,0x65,0xF0,0x90,0x43,0x4D,0x74,0x0C,
+
+	0xF0,0x22,0xE9,0xFF,0x90,0x43,0x63,0xE0,
+
+	0x2F,0xFF,0xE4,0x33,0xA2,0xE7,0x13,0xEF,
+
+	0x13,0x90,0x43,0x66,0xF0,0x90,0x43,0x4D,
+
+	0x74,0x06,0xF0,0x22,0x90,0x44,0x20,0x12,
+
+	0x4B,0x78,0x00,0x00,0x00,0x00,0x90,0x44,
+
+	0x24,0x12,0x4B,0x78,0x00,0x00,0x00,0x00,
+
+	0xE4,0x90,0x43,0xF5,0xF0,0xA3,0xF0,0x90,
+
+	0x43,0xF7,0xF0,0xA3,0xF0,0x90,0x43,0xE2,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x44,0x16,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0x90,0x43,0xE4,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0xD3,0x90,0x44,0x17,
+
+	0xE0,0x9F,0x90,0x44,0x16,0xE0,0x9E,0x40,
+
+	0x03,0x02,0x70,0x4D,0xA3,0xE0,0x90,0xF6,
+
+	0x67,0xF0,0x90,0x44,0x16,0xE0,0x90,0xF6,
+
+	0x68,0xF0,0x90,0xF6,0x66,0x74,0x01,0xF0,
+
+	0x90,0xF6,0x66,0xE0,0xB4,0x01,0xF9,0x90,
+
+	0xF6,0x30,0xE0,0x54,0x0F,0xFB,0xA3,0xE0,
+
+	0x75,0xF0,0x10,0xA4,0xFF,0x90,0xF6,0x30,
+
+	0xE0,0xFD,0xC4,0x54,0x0F,0x7C,0x00,0x2F,
+
+	0xFF,0xEC,0x35,0xF0,0xFE,0xE4,0xFD,0x90,
+
+	0x44,0x18,0x12,0x4B,0x6C,0xEB,0xB4,0x0F,
+
+	0x16,0x90,0x44,0x18,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x44,0x1C,0x12,0x4B,0x6C,0x80,0x25,0x90,
+
+	0x44,0x18,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,
+
+	0xE0,0xFE,0xA3,0xE0,0x24,0x00,0xFF,0xEE,
+
+	0x34,0x10,0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,
+
+	0xFC,0xA8,0x03,0x12,0x4B,0x59,0x90,0x44,
+
+	0x1C,0x12,0x4B,0x6C,0x90,0x44,0x20,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x44,0x1C,0xE0,0xF8,0xA3,
+
+	0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xD3,0x12,0x4B,0x21,0x40,0x48,0x90,0x44,
+
+	0x20,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x44,0x24,0x12,
+
+	0x4B,0x6C,0x90,0x43,0xF5,0xE0,0xFF,0xA3,
+
+	0xE0,0x90,0x43,0xF7,0xCF,0xF0,0xA3,0xEF,
+
+	0xF0,0x90,0x44,0x1C,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,
+
+	0x44,0x20,0x12,0x4B,0x6C,0x90,0x44,0x16,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x43,0xF5,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0x80,0x45,0x90,0x44,
+
+	0x24,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x44,0x1C,0xE0,
+
+	0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+
+	0xE0,0xFB,0xD3,0x12,0x4B,0x21,0x40,0x23,
+
+	0x90,0x44,0x1C,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x44,
+
+	0x24,0x12,0x4B,0x6C,0x90,0x44,0x16,0xE0,
+
+	0xFF,0xA3,0xE0,0x90,0x43,0xF7,0xCF,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x44,0x17,0xE0,0x04,
+
+	0xF0,0x70,0x06,0x90,0x44,0x16,0xE0,0x04,
+
+	0xF0,0x02,0x6E,0xF5,0x22,0x12,0xA5,0x58,
+
+	0x12,0x99,0xA0,0x12,0x88,0x66,0x12,0x79,
+
+	0x8A,0x90,0xF7,0x8E,0x74,0x01,0xF0,0x90,
+
+	0xF7,0x91,0xF0,0x90,0xF7,0x31,0xE0,0x60,
+
+	0x08,0x90,0xF5,0xA9,0xE0,0xFF,0x12,0xA3,
+
+	0xFB,0xE4,0x90,0x44,0xCF,0xF0,0x12,0x87,
+
+	0x8B,0x12,0x95,0x68,0x12,0xA8,0x4D,0x12,
+
+	0x78,0x57,0x90,0x42,0x1B,0xE0,0x64,0x01,
+
+	0x70,0x34,0x90,0xF1,0x33,0xE0,0x70,0x2E,
+
+	0x90,0xF1,0x35,0xE0,0x70,0x28,0x90,0xF4,
+
+	0xC1,0xE0,0x64,0x02,0x70,0x20,0x90,0xF9,
+
+	0x00,0xE0,0x60,0x1A,0x90,0xF0,0x2B,0xE0,
+
+	0x70,0x14,0x90,0x42,0xFD,0xE0,0x70,0x0E,
+
+	0x90,0x43,0x4C,0xE0,0x60,0x08,0x90,0xFD,
+
+	0xA2,0x74,0x01,0xF0,0x80,0x05,0x90,0xFD,
+
+	0xA2,0xE4,0xF0,0x90,0xF5,0x4E,0xE0,0x60,
+
+	0x36,0xA3,0xE0,0x60,0x32,0x90,0xF9,0x03,
+
+	0xE0,0xFF,0x90,0xF4,0xC1,0xE0,0x6F,0x70,
+
+	0x23,0x90,0xF9,0x05,0xE0,0xB4,0x01,0x0A,
+
+	0xA3,0xE0,0xFF,0x90,0xF4,0xC4,0xE0,0xB5,
+
+	0x07,0x12,0x90,0xF9,0x05,0xE0,0x70,0x0F,
+
+	0x90,0xF9,0x07,0xE0,0xFF,0x90,0xF4,0xC5,
+
+	0xE0,0x6F,0x60,0x03,0x12,0xAF,0x97,0x7D,
+
+	0x00,0x7C,0x07,0xE4,0xFF,0x12,0xAB,0xED,
+
+	0x90,0xF9,0x99,0xE0,0x60,0x0E,0x90,0xF2,
+
+	0x1B,0x74,0x0C,0xF0,0x90,0x42,0x5F,0x74,
+
+	0x01,0xF0,0x80,0x06,0x90,0xF2,0x1B,0x74,
+
+	0x0D,0xF0,0x90,0xFD,0x33,0xE4,0xF0,0x04,
+
+	0xF0,0x90,0xFD,0x36,0xE0,0xB4,0x01,0xF9,
+
+	0x12,0xA3,0xB2,0x12,0xA5,0x15,0x90,0x43,
+
+	0xBC,0xE0,0x64,0x01,0x60,0x1E,0x90,0x43,
+
+	0xDD,0xE0,0xFF,0x90,0xFD,0x54,0xE0,0xC3,
+
+	0x9F,0x50,0x08,0x90,0x44,0xCA,0x74,0x01,
+
+	0xF0,0x80,0x09,0x90,0x44,0xCA,0xE0,0xB4,
+
+	0x01,0x02,0xE4,0xF0,0x12,0x82,0x1E,0x90,
+
+	0x44,0xAA,0xE0,0xB4,0x01,0x08,0x12,0x9E,
+
+	0xF5,0x12,0x78,0x57,0x80,0xF1,0x90,0x43,
+
+	0xDE,0xE0,0xB4,0x01,0x11,0x90,0xF5,0x4E,
+
+	0xE0,0x64,0x01,0x60,0x09,0xA3,0xE0,0x64,
+
+	0x01,0x60,0x03,0x12,0xAF,0x97,0x90,0x44,
+
+	0xCF,0xE0,0x75,0xF0,0x50,0x84,0xE5,0xF0,
+
+	0x70,0x03,0x12,0x79,0x8A,0x12,0x99,0xA0,
+
+	0x12,0x88,0x66,0x90,0x44,0xCF,0xE0,0x04,
+
+	0xF0,0xE0,0xC3,0x94,0xFA,0x50,0x03,0x02,
+
+	0x70,0x77,0x90,0x43,0xDE,0x74,0x01,0xF0,
+
+	0x90,0x42,0x0D,0xE0,0x64,0x01,0x60,0x09,
+
+	0x90,0x43,0x8D,0xE0,0x70,0x03,0x12,0x7E,
+
+	0x10,0x90,0x43,0xBB,0x74,0x01,0xF0,0x22,
+
+	0x90,0x41,0xEF,0xE0,0xD3,0x94,0x01,0x40,
+
+	0x0E,0x90,0xFD,0x0F,0x74,0x07,0xF0,0x90,
+
+	0xFD,0x29,0x74,0x01,0xF0,0x80,0x0A,0x90,
+
+	0xFD,0x0F,0xE4,0xF0,0x90,0xFD,0x29,0x04,
+
+	0xF0,0x90,0x42,0x46,0xE0,0x60,0x03,0x02,
+
+	0x72,0xA0,0x90,0x44,0xA6,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x7C,0x00,0x7D,0x64,0x12,0x4A,
+
+	0x23,0xED,0x4C,0x60,0x03,0x02,0x72,0xA0,
+
+	0x90,0xF9,0x80,0xE0,0xB4,0x01,0x15,0x90,
+
+	0x42,0x4C,0xE0,0x70,0x0F,0x04,0xF0,0x90,
+
+	0xF9,0x80,0xE4,0xF0,0xFF,0x7E,0x05,0x12,
+
+	0xAF,0x5E,0x80,0x7B,0x90,0xF9,0x80,0xE0,
+
+	0xB4,0x01,0x17,0x90,0x42,0x4C,0xE0,0xB4,
+
+	0x01,0x10,0x74,0x01,0xF0,0x90,0xF9,0x80,
+
+	0xE4,0xF0,0xFF,0x7E,0x05,0x12,0xAF,0x5E,
+
+	0x80,0x5D,0x90,0xF9,0x80,0xE0,0x70,0x57,
+
+	0x90,0x42,0x4C,0xE0,0x64,0x01,0x70,0x4F,
+
+	0xA2,0xAF,0x33,0x90,0x44,0xCC,0xF0,0xE4,
+
+	0x90,0x42,0x4C,0xF0,0xC2,0xAF,0x90,0xF7,
+
+	0x14,0xF0,0x7F,0xD4,0x7E,0x27,0x12,0xAF,
+
+	0x5E,0x90,0xF9,0x9D,0x74,0x01,0xF0,0x90,
+
+	0xF7,0x16,0xF0,0x90,0xF7,0x11,0xE4,0xF0,
+
+	0x74,0xFF,0xFF,0xFE,0x12,0xAF,0x5E,0x90,
+
+	0xF9,0x9D,0xE4,0xF0,0x90,0xF7,0x14,0x04,
+
+	0xF0,0x90,0xF7,0x0D,0xF0,0x90,0xF7,0x86,
+
+	0xF0,0xA3,0xF0,0x90,0xF7,0x11,0xF0,0x90,
+
+	0x44,0xCC,0xE0,0x24,0xFF,0x92,0xAF,0x90,
+
+	0x44,0xA7,0xE0,0x04,0xF0,0x70,0x06,0x90,
+
+	0x44,0xA6,0xE0,0x04,0xF0,0x90,0x42,0x44,
+
+	0xE0,0x70,0x0B,0x90,0x42,0x56,0xE0,0x70,
+
+	0x05,0x12,0xAD,0xFF,0x80,0x09,0x90,0xF0,
+
+	0x01,0xE0,0x60,0x03,0x12,0x83,0x14,0x90,
+
+	0x44,0xA6,0xE0,0xFE,0xA3,0xE0,0xFF,0x7C,
+
+	0x00,0x7D,0x0A,0x12,0x4A,0x23,0xED,0x4C,
+
+	0x70,0x13,0x90,0x43,0xBE,0xE0,0x60,0x0D,
+
+	0x90,0x41,0xD7,0xE0,0xB4,0x23,0x03,0x12,
+
+	0x69,0x1E,0x12,0xA5,0x99,0x90,0xF9,0x99,
+
+	0xE0,0x90,0x41,0xCE,0xF0,0x90,0x42,0x42,
+
+	0xE0,0x70,0x06,0x90,0x42,0x43,0xE0,0x60,
+
+	0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,0x90,
+
+	0x41,0xCD,0xEF,0xF0,0x90,0x44,0xA6,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x7C,0x00,0x7D,0x32,
+
+	0x12,0x4A,0x23,0xED,0x4C,0x70,0x0E,0x12,
+
+	0x8A,0x18,0x12,0x89,0x40,0x90,0x43,0x8D,
+
+	0xE0,0x60,0x02,0x14,0xF0,0xC2,0xCF,0x22,
+
+	0xE4,0x90,0x43,0xDE,0xF0,0x12,0xAE,0xFD,
+
+	0xE4,0x90,0x42,0xFB,0xF0,0x90,0x42,0xF9,
+
+	0xF0,0xA3,0xF0,0x12,0x8E,0x1F,0x90,0x42,
+
+	0xF8,0x74,0x01,0xF0,0x90,0x43,0xDF,0xE0,
+
+	0x60,0x0A,0x90,0xF1,0x2F,0x74,0x01,0xF0,
+
+	0x90,0xF1,0x0A,0xF0,0x90,0xF7,0x3C,0xE0,
+
+	0x70,0x03,0xA3,0x04,0xF0,0x12,0x9A,0xAE,
+
+	0x12,0xAF,0x90,0x12,0x7B,0xDB,0xE4,0xFF,
+
+	0x12,0xA7,0xB4,0x90,0xFD,0x32,0xE0,0x90,
+
+	0xFD,0x92,0xF0,0x90,0xFD,0x31,0xE0,0x90,
+
+	0xFD,0x91,0xF0,0x90,0xF2,0x1B,0x74,0x09,
+
+	0xF0,0xE4,0xFF,0x12,0x62,0x28,0x90,0xF2,
+
+	0x1B,0x74,0x0A,0xF0,0x90,0xFD,0xA1,0xE0,
+
+	0x60,0x06,0x90,0xF7,0x81,0x74,0x40,0xF0,
+
+	0x7F,0x04,0x12,0xAE,0x43,0x90,0xF5,0x3B,
+
+	0x74,0x01,0xF0,0xE4,0xFF,0x12,0xA7,0xB4,
+
+	0x12,0x7F,0x1C,0x90,0x43,0xBD,0xE0,0x60,
+
+	0x21,0x90,0xF7,0x3C,0xE0,0x70,0x16,0x90,
+
+	0xF7,0x40,0xF0,0x90,0xF5,0x54,0x04,0xF0,
+
+	0xE4,0x90,0x44,0x9E,0xF0,0x90,0x44,0x9D,
+
+	0xE0,0x90,0xF5,0x52,0xF0,0xE4,0x90,0x43,
+
+	0xB9,0xF0,0x90,0x41,0xCD,0x74,0x01,0xF0,
+
+	0x90,0x42,0x42,0xF0,0x12,0x7E,0x10,0x12,
+
+	0xAD,0xCE,0x7F,0x0A,0x12,0xAE,0x43,0x90,
+
+	0xF5,0xC8,0x74,0x01,0xF0,0x90,0xF7,0x8E,
+
+	0xF0,0x90,0x44,0x3B,0xF0,0x90,0x42,0x41,
+
+	0xE0,0x64,0x01,0x70,0x6D,0x90,0x43,0xD0,
+
+	0xE0,0x64,0x01,0x70,0x65,0x90,0xF0,0x2B,
+
+	0xE0,0x64,0x01,0x70,0x5D,0x90,0xF6,0x08,
+
+	0xE0,0x70,0x57,0xC2,0xEB,0x90,0xF7,0x8B,
+
+	0x74,0x02,0xF0,0x7F,0x01,0x12,0x80,0x20,
+
+	0x90,0x42,0x33,0xE0,0x90,0x44,0xCE,0xF0,
+
+	0x90,0xFD,0xA5,0x74,0x01,0xF0,0x90,0x43,
+
+	0xBC,0xF0,0x7F,0x08,0x12,0xAE,0x43,0x7F,
+
+	0x01,0x12,0x80,0x20,0x90,0x42,0x33,0xE0,
+
+	0xFF,0x90,0x44,0xCE,0xE0,0xC3,0x9F,0x40,
+
+	0x0B,0x90,0xFD,0xA5,0xE4,0xF0,0x90,0x43,
+
+	0xBC,0xF0,0x80,0x0A,0x90,0xFD,0xA5,0x74,
+
+	0x01,0xF0,0x90,0x43,0xBC,0xF0,0xE4,0x90,
+
+	0x43,0xD0,0xF0,0x90,0xF7,0x8B,0x04,0xF0,
+
+	0xD2,0xEB,0x12,0xA5,0x15,0x90,0xF7,0x31,
+
+	0xE0,0x60,0x05,0x7F,0x01,0x12,0xA3,0xFB,
+
+	0xE4,0x90,0x43,0xC7,0xF0,0x90,0x42,0xFD,
+
+	0x04,0xF0,0x12,0xAF,0x36,0x90,0xF2,0x1B,
+
+	0x74,0x0B,0xF0,0x22,0x90,0x42,0x5C,0xE0,
+
+	0x70,0x1A,0xA3,0xE0,0x64,0x0C,0x60,0x05,
+
+	0xE0,0x64,0x0D,0x70,0x22,0x90,0xF5,0x68,
+
+	0xE0,0xB4,0x0A,0x1B,0x90,0x42,0x5C,0x74,
+
+	0x01,0xF0,0x80,0x13,0x90,0x42,0x5D,0xE0,
+
+	0xB4,0x0C,0x0C,0x90,0xF5,0x69,0xE0,0xB4,
+
+	0x05,0x05,0xE4,0x90,0x42,0x5C,0xF0,0x90,
+
+	0x42,0x5C,0xE0,0xB4,0x01,0x19,0xA3,0xE0,
+
+	0xB4,0x0C,0x14,0x90,0xF5,0xC1,0xE0,0xB4,
+
+	0x01,0x0D,0x90,0x42,0x5D,0x74,0x03,0xF0,
+
+	0x90,0xF5,0x66,0xF0,0x02,0x75,0x99,0x90,
+
+	0x42,0x5C,0xE0,0xB4,0x01,0x0F,0xA3,0xE0,
+
+	0xB4,0x0D,0x0A,0x74,0x03,0xF0,0x90,0xF5,
+
+	0x66,0xF0,0x02,0x75,0x99,0x90,0x42,0x5C,
+
+	0xE0,0x70,0x15,0xA3,0xE0,0xB4,0x0C,0x10,
+
+	0x90,0xF5,0xC1,0xE0,0xB4,0x01,0x09,0x90,
+
+	0xF5,0x66,0x74,0x0C,0xF0,0x02,0x75,0x99,
+
+	0x90,0x42,0x5C,0xE0,0x70,0x16,0xA3,0xE0,
+
+	0xB4,0x0C,0x11,0x90,0xF5,0x69,0xE0,0xC3,
+
+	0x94,0x05,0x50,0x08,0x90,0xF5,0x66,0x74,
+
+	0x0C,0xF0,0x80,0x64,0x90,0x42,0x5C,0xE0,
+
+	0x64,0x01,0x70,0x1C,0xA3,0xE0,0xB4,0x0C,
+
+	0x17,0x90,0xF5,0xC1,0xE0,0x70,0x11,0x90,
+
+	0xF5,0x68,0xE0,0xC3,0x94,0x0A,0x50,0x08,
+
+	0x90,0xF5,0x66,0x74,0x0C,0xF0,0x80,0x40,
+
+	0x90,0x42,0x5C,0xE0,0x64,0x01,0x70,0x1E,
+
+	0xA3,0xE0,0xB4,0x0C,0x19,0x90,0xF5,0xC1,
+
+	0xE0,0x70,0x13,0x90,0xF5,0x68,0xE0,0xB4,
+
+	0x0A,0x0C,0x90,0x42,0x5D,0x74,0x03,0xF0,
+
+	0x90,0xF5,0x66,0xF0,0x80,0x1A,0x90,0x42,
+
+	0x5D,0xE0,0xB4,0x0D,0x08,0x90,0xF5,0x66,
+
+	0x74,0x0D,0xF0,0x80,0x0B,0x90,0x42,0x5D,
+
+	0xE0,0x04,0xF0,0xE0,0x90,0xF5,0x66,0xF0,
+
+	0x90,0x42,0x5D,0xE0,0x25,0xE0,0x24,0xA3,
+
+	0xF5,0x82,0xE4,0x34,0x42,0xF5,0x83,0xE0,
+
+	0xA3,0xE0,0x90,0xF5,0x5B,0xF0,0x90,0x42,
+
+	0x5D,0xE0,0x25,0xE0,0x24,0xBF,0xF5,0x82,
+
+	0xE4,0x34,0x42,0xF5,0x83,0xE0,0xA3,0xE0,
+
+	0x90,0xF5,0x5C,0xF0,0x90,0x42,0x5D,0xE0,
+
+	0x25,0xE0,0x24,0xDB,0xF5,0x82,0xE4,0x34,
+
+	0x42,0xF5,0x83,0xE0,0xA3,0xE0,0x90,0xF5,
+
+	0x5D,0xF0,0xA3,0xE4,0xF0,0x22,0x74,0xFF,
+
+	0x90,0x44,0xB9,0xF0,0xA3,0xF0,0x90,0x43,
+
+	0xE2,0xE0,0xFE,0xA3,0xE0,0xFF,0xC3,0x90,
+
+	0x43,0xE5,0xE0,0x9F,0xFF,0x90,0x43,0xE4,
+
+	0xE0,0x9E,0xFE,0x90,0x42,0x1D,0xE0,0xFD,
+
+	0x7C,0x00,0x12,0x4A,0x11,0x90,0x42,0x1C,
+
+	0xE0,0xFD,0xEF,0xA8,0x05,0x08,0x80,0x05,
+
+	0xCE,0xC3,0x13,0xCE,0x13,0xD8,0xF9,0xFF,
+
+	0x90,0x42,0x1E,0xE0,0x2F,0x90,0x44,0xB7,
+
+	0xF0,0x90,0x43,0xE1,0xE0,0x70,0x34,0x90,
+
+	0x43,0xE4,0xE0,0xFF,0xA3,0xE0,0x90,0x43,
+
+	0xF3,0xCF,0xF0,0xA3,0xEF,0xF0,0x90,0x43,
+
+	0xE2,0xE0,0xFF,0xA3,0xE0,0x90,0x43,0xF1,
+
+	0xCF,0xF0,0xA3,0xEF,0xF0,0x12,0x6E,0xC5,
+
+	0x90,0x43,0xF5,0xE0,0xFE,0xA3,0xE0,0xFF,
+
+	0xE4,0xFC,0xFD,0x90,0x43,0xEA,0x12,0x4B,
+
+	0x6C,0x80,0x3F,0x90,0x43,0xE1,0xE0,0xB4,
+
+	0x01,0x16,0x12,0x6E,0xC5,0x90,0x43,0xF5,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xE4,0xFC,0xFD,
+
+	0x90,0x43,0xEA,0x12,0x4B,0x6C,0x80,0x22,
+
+	0x90,0x43,0xE4,0xE0,0xFE,0xA3,0xE0,0xFF,
+
+	0x90,0x43,0xE3,0xE0,0x2F,0xFF,0x90,0x43,
+
+	0xE2,0xE0,0x3E,0xC3,0x13,0xFE,0xEF,0x13,
+
+	0xFF,0xE4,0xFC,0xFD,0x90,0x43,0xEA,0x12,
+
+	0x4B,0x6C,0x12,0x86,0xAE,0x90,0x43,0xE3,
+
+	0xE0,0x24,0xB0,0xF0,0x90,0x43,0xE2,0xE0,
+
+	0x34,0x02,0xF0,0x90,0x43,0xE5,0xE0,0x24,
+
+	0xB0,0xF0,0x90,0x43,0xE4,0xE0,0x34,0x02,
+
+	0xF0,0x90,0x43,0xE1,0xE0,0xFF,0x70,0x20,
+
+	0x90,0x44,0xB7,0xE0,0xA3,0xF0,0x90,0xF1,
+
+	0x09,0xF0,0x90,0x43,0xE9,0xE0,0x90,0xF1,
+
+	0x0E,0xF0,0x90,0x43,0xE8,0xE0,0x90,0xF1,
+
+	0x0F,0xF0,0xA3,0x74,0x01,0xF0,0x80,0x34,
+
+	0xEF,0x64,0x01,0x70,0x2F,0x90,0x43,0xEE,
+
+	0xE0,0x70,0x0A,0x90,0x44,0xB7,0xE0,0x90,
+
+	0xF1,0x0B,0xF0,0x80,0x0B,0x90,0x44,0xB8,
+
+	0xE0,0xFF,0xC3,0x13,0x90,0xF1,0x0B,0xF0,
+
+	0x90,0x43,0xE9,0xE0,0x90,0xF1,0x12,0xF0,
+
+	0x90,0x43,0xE8,0xE0,0x90,0xF1,0x13,0xF0,
+
+	0xA3,0x74,0x01,0xF0,0x90,0x43,0xE1,0xE0,
+
+	0x04,0xF0,0x22,0x90,0x42,0x59,0xE0,0x70,
+
+	0x1A,0xA3,0xE0,0x64,0x0C,0x60,0x05,0xE0,
+
+	0x64,0x0D,0x70,0x22,0x90,0xF4,0x1B,0xE0,
+
+	0xB4,0x0A,0x1B,0x90,0x42,0x59,0x74,0x01,
+
+	0xF0,0x80,0x13,0x90,0x42,0x5A,0xE0,0xB4,
+
+	0x0C,0x0C,0x90,0xF4,0x1C,0xE0,0xB4,0x0A,
+
+	0x05,0xE4,0x90,0x42,0x59,0xF0,0x90,0x42,
+
+	0x59,0xE0,0xB4,0x01,0x19,0xA3,0xE0,0xB4,
+
+	0x0C,0x14,0x90,0xF5,0xBA,0xE0,0xB4,0x01,
+
+	0x0D,0x90,0x42,0x5A,0x74,0x03,0xF0,0x90,
+
+	0xF4,0x19,0xF0,0x02,0x78,0x20,0x90,0x42,
+
+	0x59,0xE0,0xB4,0x01,0x0F,0xA3,0xE0,0xB4,
+
+	0x0D,0x0A,0x74,0x03,0xF0,0x90,0xF4,0x19,
+
+	0xF0,0x02,0x78,0x20,0x90,0x42,0x59,0xE0,
+
+	0x70,0x15,0xA3,0xE0,0xB4,0x0C,0x10,0x90,
+
+	0xF5,0xBA,0xE0,0xB4,0x01,0x09,0x90,0xF4,
+
+	0x19,0x74,0x0C,0xF0,0x02,0x78,0x20,0x90,
+
+	0x42,0x59,0xE0,0x70,0x16,0xA3,0xE0,0xB4,
+
+	0x0C,0x11,0x90,0xF4,0x1C,0xE0,0xC3,0x94,
+
+	0x0A,0x50,0x08,0x90,0xF4,0x19,0x74,0x0C,
+
+	0xF0,0x80,0x64,0x90,0x42,0x59,0xE0,0x64,
+
+	0x01,0x70,0x1C,0xA3,0xE0,0xB4,0x0C,0x17,
+
+	0x90,0xF5,0xBA,0xE0,0x70,0x11,0x90,0xF4,
+
+	0x1B,0xE0,0xC3,0x94,0x0A,0x50,0x08,0x90,
+
+	0xF4,0x19,0x74,0x0C,0xF0,0x80,0x40,0x90,
+
+	0x42,0x59,0xE0,0x64,0x01,0x70,0x1E,0xA3,
+
+	0xE0,0xB4,0x0C,0x19,0x90,0xF5,0xBA,0xE0,
+
+	0x70,0x13,0x90,0xF4,0x1B,0xE0,0xB4,0x0A,
+
+	0x0C,0x90,0x42,0x5A,0x74,0x03,0xF0,0x90,
+
+	0xF4,0x19,0xF0,0x80,0x1A,0x90,0x42,0x5A,
+
+	0xE0,0xB4,0x0D,0x08,0x90,0xF4,0x19,0x74,
+
+	0x0D,0xF0,0x80,0x0B,0x90,0x42,0x5A,0xE0,
+
+	0x04,0xF0,0xE0,0x90,0xF4,0x19,0xF0,0x90,
+
+	0x42,0x5A,0xE0,0x24,0x79,0xF5,0x82,0xE4,
+
+	0x34,0x42,0xF5,0x83,0xE0,0x90,0xF4,0x08,
+
+	0xF0,0x90,0x42,0x5A,0xE0,0x24,0x87,0xF5,
+
+	0x82,0xE4,0x34,0x42,0xF5,0x83,0xE0,0x90,
+
+	0xF4,0x09,0xF0,0x90,0x42,0x5A,0xE0,0x24,
+
+	0x95,0xF5,0x82,0xE4,0x34,0x42,0xF5,0x83,
+
+	0xE0,0x90,0xF4,0x0A,0xF0,0x22,0x90,0x42,
+
+	0x34,0xE0,0x70,0x03,0x02,0x79,0x89,0x90,
+
+	0xF0,0x2B,0xE0,0x70,0x16,0x90,0xF5,0x3E,
+
+	0xE0,0xD3,0x94,0x20,0x40,0x0D,0x90,0xF2,
+
+	0x17,0x74,0xFE,0xF0,0x90,0xF7,0x87,0x74,
+
+	0x01,0xF0,0x22,0x90,0xF7,0x32,0xE0,0x64,
+
+	0x01,0x70,0x2D,0x90,0x42,0x33,0xE0,0xFE,
+
+	0x90,0x44,0x9F,0xE0,0xFD,0xD3,0x9E,0x40,
+
+	0x05,0xED,0x9E,0xFF,0x80,0x0C,0x90,0x44,
+
+	0x9F,0xE0,0xFE,0x90,0x42,0x33,0xE0,0xC3,
+
+	0x9E,0xFF,0xEF,0xC3,0x94,0x0A,0x50,0x08,
+
+	0x90,0x44,0x9F,0xE0,0x90,0x42,0x33,0xF0,
+
+	0x90,0x42,0x33,0xE0,0xFE,0xC3,0x94,0x23,
+
+	0x50,0x07,0x90,0xF2,0x17,0x74,0xFE,0xF0,
+
+	0x22,0xEE,0xC3,0x94,0x28,0x50,0x13,0x90,
+
+	0xF2,0x17,0xE0,0xB4,0xFE,0x05,0xE0,0x64,
+
+	0xA6,0x60,0x07,0x90,0xF2,0x17,0x74,0xFE,
+
+	0xF0,0x22,0x90,0x42,0x33,0xE0,0xC3,0x94,
+
+	0x2D,0x50,0x13,0x90,0xF2,0x17,0xE0,0xB4,
+
+	0xFE,0x05,0xE0,0x64,0xA6,0x60,0x07,0x90,
+
+	0xF2,0x17,0x74,0xA6,0xF0,0x22,0x90,0x42,
+
+	0x33,0xE0,0xFE,0xC3,0x94,0x37,0x50,0x07,
+
+	0x90,0xF2,0x17,0x74,0xA6,0xF0,0x22,0xEE,
+
+	0xC3,0x94,0x3C,0x50,0x13,0x90,0xF2,0x17,
+
+	0xE0,0xB4,0xA6,0x05,0xE0,0x64,0x26,0x60,
+
+	0x07,0x90,0xF2,0x17,0x74,0xA6,0xF0,0x22,
+
+	0x90,0x42,0x33,0xE0,0xC3,0x94,0x41,0x50,
+
+	0x13,0x90,0xF2,0x17,0xE0,0xB4,0xA6,0x05,
+
+	0xE0,0x64,0x26,0x60,0x07,0x90,0xF2,0x17,
+
+	0x74,0x26,0xF0,0x22,0x90,0x42,0x33,0xE0,
+
+	0xFE,0xC3,0x94,0x4B,0x50,0x07,0x90,0xF2,
+
+	0x17,0x74,0x26,0xF0,0x22,0xEE,0xC3,0x94,
+
+	0x50,0x50,0x13,0x90,0xF2,0x17,0xE0,0xB4,
+
+	0x26,0x05,0xE0,0x64,0x25,0x60,0x07,0x90,
+
+	0xF2,0x17,0x74,0x26,0xF0,0x22,0x90,0x42,
+
+	0x33,0xE0,0xC3,0x94,0x55,0x50,0x13,0x90,
+
+	0xF2,0x17,0xE0,0xB4,0x26,0x05,0xE0,0x64,
+
+	0x25,0x60,0x07,0x90,0xF2,0x17,0x74,0x25,
+
+	0xF0,0x22,0x90,0xF2,0x17,0x74,0x25,0xF0,
+
+	0x22,0x90,0xF6,0x08,0xE0,0x90,0x44,0xA3,
+
+	0xF0,0x90,0xFD,0x29,0xE0,0x90,0x44,0xA4,
+
+	0xF0,0xE4,0xA3,0xF0,0x90,0x41,0xD5,0xE0,
+
+	0x70,0x05,0x90,0x43,0xC7,0xF0,0x22,0x90,
+
+	0xF5,0x4C,0xE0,0xFF,0x90,0xF5,0x41,0xE0,
+
+	0x4F,0x70,0x03,0x02,0x7A,0xB2,0x90,0x44,
+
+	0x62,0x74,0x02,0xF0,0xA3,0x74,0x39,0xF0,
+
+	0xE4,0xFB,0xFA,0xFD,0xFF,0x12,0x7C,0xF8,
+
+	0x90,0x44,0xA2,0xEF,0xF0,0xD3,0x94,0x32,
+
+	0x40,0x04,0xE0,0xFF,0x80,0x02,0x7F,0xFF,
+
+	0x90,0x44,0xA2,0xEF,0xF0,0xFD,0x90,0x44,
+
+	0x62,0xE4,0xF0,0xA3,0x74,0x32,0xF0,0xE4,
+
+	0xFB,0xFA,0x7F,0x01,0x12,0x7C,0xF8,0x90,
+
+	0x44,0xA1,0xEF,0xF0,0xD3,0x94,0x0A,0x40,
+
+	0x58,0x90,0xF1,0x14,0xE0,0x70,0x1E,0x04,
+
+	0xF0,0x90,0x43,0xDC,0xE0,0x90,0xF1,0x12,
+
+	0xF0,0x90,0x43,0xDB,0xE0,0x90,0xF1,0x13,
+
+	0xF0,0x90,0xF1,0x0B,0xE4,0xF0,0x90,0xF1,
+
+	0x0A,0x04,0xF0,0x80,0x34,0x90,0xF1,0x10,
+
+	0xE0,0x70,0x2E,0x90,0x43,0xDC,0xE0,0xFF,
+
+	0x90,0xF1,0x12,0xE0,0x6F,0x60,0x22,0x90,
+
+	0x43,0xDB,0xE0,0xFE,0x90,0xF1,0x13,0xE0,
+
+	0x6E,0x60,0x16,0x90,0xF1,0x10,0x74,0x01,
+
+	0xF0,0x90,0xF1,0x0E,0xEF,0xF0,0xA3,0xEE,
+
+	0xF0,0x90,0xF1,0x09,0xE4,0xF0,0xA3,0x04,
+
+	0xF0,0x90,0x44,0xA2,0xE0,0xFD,0x90,0x44,
+
+	0x62,0x74,0x02,0xF0,0xA3,0x74,0x39,0xF0,
+
+	0x7B,0xF4,0x7A,0x01,0x7F,0x01,0x12,0x7C,
+
+	0xF8,0x90,0x44,0xA1,0xEF,0xF0,0xD3,0x94,
+
+	0x19,0x40,0x3E,0x90,0xF1,0x14,0xE0,0x70,
+
+	0x38,0x04,0xF0,0x90,0x43,0xDA,0xE0,0x90,
+
+	0xF1,0x12,0xF0,0x90,0x43,0xD9,0xE0,0x90,
+
+	0xF1,0x13,0xF0,0x90,0xF1,0x0B,0x74,0x15,
+
+	0xF0,0x90,0xF1,0x10,0x74,0x01,0xF0,0x90,
+
+	0x43,0xD8,0xE0,0x90,0xF1,0x0E,0xF0,0x90,
+
+	0x43,0xD7,0xE0,0x90,0xF1,0x0F,0xF0,0x90,
+
+	0xF1,0x09,0x74,0x10,0xF0,0xA3,0x74,0x01,
+
+	0xF0,0x22,0x7E,0x41,0x7F,0x91,0xD3,0xEF,
+
+	0x94,0x56,0xEE,0x94,0x42,0x50,0x0D,0x8F,
+
+	0x82,0x8E,0x83,0xE4,0xF0,0x0F,0xBF,0x00,
+
+	0x01,0x0E,0x80,0xEA,0x12,0xAA,0xC8,0x12,
+
+	0xAA,0xF5,0x90,0x41,0x8B,0x74,0x41,0xF0,
+
+	0xA3,0x74,0x91,0xF0,0xE4,0x90,0x43,0xBE,
+
+	0xF0,0xD2,0xAF,0xD2,0xA8,0xC2,0xDB,0xD2,
+
+	0xEC,0xF5,0x13,0xF5,0x14,0x90,0x43,0xCE,
+
+	0xF0,0xA3,0xF0,0x90,0x43,0xB8,0xF0,0x90,
+
+	0x41,0xD2,0x04,0xF0,0x90,0x42,0x0F,0x74,
+
+	0x04,0xF0,0x90,0x42,0x12,0x74,0x0A,0xF0,
+
+	0x90,0x41,0xE0,0x74,0x03,0xF0,0xE4,0x90,
+
+	0x41,0xE1,0xF0,0xF5,0xF8,0x75,0xB8,0x12,
+
+	0xD2,0x88,0xD2,0xEB,0x90,0x43,0xB6,0xF0,
+
+	0x90,0x41,0xD1,0xF0,0x90,0x43,0xBD,0x04,
+
+	0xF0,0xE4,0x90,0x41,0xE7,0xF0,0x90,0x41,
+
+	0xE6,0x04,0xF0,0x90,0x41,0xEB,0xF0,0x90,
+
+	0x41,0xEC,0x04,0xF0,0xE4,0x90,0x41,0xED,
+
+	0xF0,0x90,0x41,0xEE,0xF0,0x90,0x42,0x0E,
+
+	0x04,0xF0,0x90,0x41,0xCB,0x74,0x10,0xF0,
+
+	0x90,0x41,0xCC,0x74,0x27,0xF0,0x90,0x41,
+
+	0xF6,0x74,0x50,0xF0,0x90,0x41,0xCA,0x74,
+
+	0x01,0xF0,0x90,0x42,0x20,0x74,0x20,0xF0,
+
+	0x90,0x42,0x21,0x74,0x2C,0xF0,0x90,0x42,
+
+	0x22,0x74,0x01,0xF0,0x90,0x42,0x1C,0x74,
+
+	0x07,0xF0,0x90,0x42,0x1D,0xF0,0x90,0x42,
+
+	0x1E,0x14,0xF0,0xE4,0x90,0x43,0xE1,0xF0,
+
+	0x90,0xF6,0x2E,0x74,0x64,0xF0,0xE4,0x90,
+
+	0x42,0x3F,0xF0,0x90,0x41,0xDC,0x04,0xF0,
+
+	0x90,0x44,0x37,0x12,0x4B,0x78,0x00,0x00,
+
+	0x00,0x00,0xE4,0x90,0x41,0xF3,0xF0,0x90,
+
+	0x41,0xF4,0xF0,0x90,0x41,0xF5,0xF0,0x90,
+
+	0x41,0xC0,0x04,0xF0,0x90,0x41,0xC8,0x74,
+
+	0x10,0xF0,0x90,0x41,0xC9,0x74,0x27,0xF0,
+
+	0xE4,0x90,0x41,0xD9,0xF0,0x90,0x41,0xDA,
+
+	0xF0,0x90,0x41,0xDB,0xF0,0x90,0x43,0xC8,
+
+	0xF0,0x90,0x43,0x90,0xF0,0x90,0x41,0xE3,
+
+	0xF0,0x22,0x90,0xF4,0xC1,0xE0,0x14,0x60,
+
+	0x46,0x14,0x60,0x7C,0x24,0x02,0x60,0x03,
+
+	0x02,0x7C,0x97,0x90,0xFD,0x19,0x74,0xCA,
+
+	0xF0,0xA3,0x74,0x08,0xF0,0xA3,0x74,0x4A,
+
+	0xF0,0xA3,0x74,0x0A,0xF0,0xA3,0x74,0xCA,
+
+	0xF0,0xA3,0x74,0x0C,0xF0,0xA3,0x74,0x4A,
+
+	0xF0,0xA3,0x74,0x10,0xF0,0xA3,0x74,0xCA,
+
+	0xF0,0xA3,0x74,0x14,0xF0,0xA3,0x74,0x4A,
+
+	0xF0,0xA3,0x74,0x1A,0xF0,0xA3,0x74,0xCA,
+
+	0xF0,0xA3,0x74,0x20,0xF0,0x80,0x6F,0x90,
+
+	0xFD,0x19,0x74,0x80,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0xF0,0xA3,0x74,0x02,0xF0,0xA3,0x74,
+
+	0x20,0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,
+
+	0xE8,0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,
+
+	0xB0,0xF0,0xA3,0x74,0x04,0xF0,0xA3,0x74,
+
+	0xDC,0xF0,0xA3,0x74,0x05,0xF0,0xA3,0x74,
+
+	0x34,0xF0,0xA3,0x74,0x08,0xF0,0x80,0x36,
+
+	0x90,0xFD,0x19,0x74,0x7D,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0x74,0xB4,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0x74,0xC8,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0xFA,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x2C,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0x52,0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,
+
+	0x34,0xF0,0xA3,0x74,0x08,0xF0,0xE4,0xFD,
+
+	0xED,0x75,0xF0,0x02,0xA4,0x24,0x19,0xFF,
+
+	0xE5,0xF0,0x34,0xFD,0xFE,0x8F,0x82,0xF5,
+
+	0x83,0xE0,0xF9,0xA3,0xE0,0xFC,0x90,0xF9,
+
+	0x00,0xE0,0x70,0x18,0xEC,0x54,0x0F,0xFB,
+
+	0xC4,0x54,0xF0,0xFB,0xE9,0xC4,0x54,0x0F,
+
+	0x4B,0x8F,0x82,0x8E,0x83,0xF0,0xEC,0xC4,
+
+	0x54,0x0F,0xA3,0xF0,0x90,0xF9,0x00,0xE0,
+
+	0x64,0x02,0x70,0x1D,0xEC,0x54,0x0F,0xFB,
+
+	0x25,0xE0,0x25,0xE0,0xFB,0xAA,0x01,0xEA,
+
+	0x13,0x13,0x54,0x3F,0x4B,0x8F,0x82,0x8E,
+
+	0x83,0xF0,0xEC,0x13,0x13,0x54,0x3F,0xA3,
+
+	0xF0,0x0D,0xED,0xB4,0x07,0xA2,0x22,0x90,
+
+	0x44,0x5E,0xEF,0xF0,0xA3,0xED,0xF0,0xE4,
+
+	0x90,0x44,0x66,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0xA3,0xF0,0xAF,0x03,0x90,0x44,0x64,0xEA,
+
+	0xF0,0xA3,0xEF,0xF0,0x90,0x44,0x62,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0xA3,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xC3,0x9F,0xEC,0x9E,0x40,0x03,
+
+	0x02,0x7D,0xC4,0x90,0xF9,0x00,0xE0,0xB4,
+
+	0x02,0x0F,0x90,0x44,0x65,0xE0,0x25,0xE0,
+
+	0xFD,0x90,0x44,0x64,0xE0,0x33,0xFC,0x80,
+
+	0x1A,0x90,0xF9,0x00,0xE0,0xB4,0x01,0x13,
+
+	0x90,0x44,0x64,0xE0,0xFE,0xA3,0xE0,0x78,
+
+	0x02,0xC3,0x33,0xCE,0x33,0xCE,0xD8,0xF9,
+
+	0xFD,0xAC,0x06,0xED,0x90,0xF5,0x50,0xF0,
+
+	0xEC,0xA3,0xF0,0x90,0xF6,0x5B,0x74,0x01,
+
+	0xF0,0x7F,0x55,0x7E,0x0D,0x12,0xAF,0x5E,
+
+	0x20,0x8C,0xFD,0x90,0xF6,0x5F,0xE0,0xFF,
+
+	0x13,0x13,0x54,0x3F,0xFF,0x90,0x44,0x67,
+
+	0xE0,0x2F,0xF0,0x90,0x44,0x66,0xE0,0x34,
+
+	0x00,0xF0,0x90,0xF6,0x5F,0xE0,0xFF,0x90,
+
+	0x44,0x69,0xE0,0xC3,0x9F,0x50,0x08,0x90,
+
+	0xF6,0x5F,0xE0,0x90,0x44,0x69,0xF0,0x90,
+
+	0x44,0x5F,0xE0,0xFF,0x90,0xF6,0x5F,0xE0,
+
+	0xD3,0x9F,0x40,0x06,0x90,0x44,0x68,0xE0,
+
+	0x04,0xF0,0x90,0x44,0x65,0xE0,0x04,0xF0,
+
+	0x70,0x06,0x90,0x44,0x64,0xE0,0x04,0xF0,
+
+	0x02,0x7D,0x15,0x90,0x44,0x66,0xE0,0xFE,
+
+	0xA3,0xE0,0x78,0x07,0xCE,0xC3,0x13,0xCE,
+
+	0x13,0xD8,0xF9,0xFF,0x90,0x44,0x69,0xE0,
+
+	0xFE,0x13,0x13,0x54,0x3F,0xFD,0xEF,0xD3,
+
+	0x9D,0x40,0x13,0xEF,0x94,0x80,0x40,0x05,
+
+	0x74,0xFF,0xF0,0x80,0x10,0xEF,0x25,0xE0,
+
+	0x90,0x44,0x69,0xF0,0x80,0x07,0xEE,0xC3,
+
+	0x13,0x90,0x44,0x69,0xF0,0x90,0x44,0x5E,
+
+	0xE0,0x70,0x06,0x90,0x44,0x69,0xE0,0xFF,
+
+	0x22,0x90,0x44,0x68,0xE0,0xFF,0x22,0x90,
+
+	0x44,0xB3,0x74,0x01,0xF0,0xA3,0x04,0xF0,
+
+	0xA3,0xF0,0x90,0x43,0x91,0xE0,0x60,0x0A,
+
+	0x90,0x42,0x53,0xE0,0x60,0x04,0x7F,0x00,
+
+	0x80,0x05,0x90,0x42,0x1F,0xE0,0xFF,0x90,
+
+	0x44,0xB6,0xEF,0xF0,0x90,0x43,0xE0,0xE0,
+
+	0x14,0x70,0x03,0x02,0x7E,0xCC,0x04,0x60,
+
+	0x03,0x02,0x7E,0xFE,0x90,0x44,0xB6,0xE0,
+
+	0x60,0x09,0xE4,0xFD,0x7F,0x02,0x12,0xAF,
+
+	0x75,0x80,0x35,0x90,0x41,0xD1,0xE0,0xB4,
+
+	0x01,0x23,0x90,0xF9,0x01,0xE0,0x90,0x44,
+
+	0xB5,0xF0,0x90,0xF9,0x00,0xE0,0xFF,0x90,
+
+	0x44,0xB3,0xF0,0x60,0x0B,0xA3,0x74,0x02,
+
+	0xF0,0xA3,0xE0,0x24,0x02,0xF0,0x80,0x05,
+
+	0xE4,0x90,0x44,0xB4,0xF0,0x90,0x44,0xB4,
+
+	0xE0,0xFF,0xA3,0xE0,0xFD,0x12,0xAF,0x75,
+
+	0x90,0xF4,0x63,0xE4,0xF0,0x90,0xF4,0x69,
+
+	0x74,0xFB,0xF0,0xA3,0xE4,0xF0,0x90,0xF4,
+
+	0x6D,0x74,0x05,0xF0,0x7F,0x01,0x12,0xAD,
+
+	0x78,0x12,0x9C,0x33,0x90,0x44,0xB6,0xE0,
+
+	0xFF,0x60,0x08,0x90,0xF9,0x00,0x74,0x01,
+
+	0xF0,0x80,0x08,0x90,0x44,0xB3,0xE0,0x90,
+
+	0xF9,0x00,0xF0,0x90,0xF5,0xC2,0x74,0x01,
+
+	0xF0,0xE4,0xF0,0xEF,0x60,0x05,0x12,0x54,
+
+	0x2E,0x80,0x32,0x90,0xF1,0x57,0xE0,0x60,
+
+	0x08,0x90,0xF1,0x49,0x74,0x01,0xF0,0xE4,
+
+	0xF0,0x7D,0xFF,0x7C,0x7F,0xE4,0xFF,0x12,
+
+	0xAB,0xED,0x90,0xF1,0x82,0xE0,0x70,0x15,
+
+	0x90,0xF1,0x57,0xE0,0x60,0x0F,0x90,0x44,
+
+	0xAA,0xE0,0xB4,0x01,0x08,0x90,0xF1,0x7C,
+
+	0xE0,0x60,0xE7,0x80,0xE5,0xE4,0x90,0x42,
+
+	0x60,0xF0,0x90,0xF1,0xB5,0xE0,0x90,0x42,
+
+	0x61,0xF0,0x90,0xF1,0xB4,0xE0,0x90,0x42,
+
+	0x62,0xF0,0x90,0xF1,0xB3,0xE0,0x90,0x42,
+
+	0x63,0xF0,0x22,0x90,0xF5,0xC8,0xE4,0xF0,
+
+	0x90,0xF5,0x75,0xF0,0x90,0xF5,0x74,0xF0,
+
+	0x90,0xF1,0xD0,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0x90,0xF5,0x6E,0x74,0x0A,0xF0,0x90,0xF5,
+
+	0x71,0x74,0x02,0xF0,0xA3,0x74,0x27,0xF0,
+
+	0xA3,0xE4,0xF0,0x90,0x42,0x3F,0xE0,0x64,
+
+	0x01,0x60,0x03,0x02,0x7F,0xD4,0x90,0xF5,
+
+	0xF7,0xE0,0xFE,0x90,0xF5,0xF6,0xE0,0x7C,
+
+	0x00,0x24,0x00,0xFF,0xEC,0x3E,0xFE,0xEF,
+
+	0x78,0x06,0xCE,0xC3,0x13,0xCE,0x13,0xD8,
+
+	0xF9,0x90,0x44,0xCB,0xF0,0x90,0xF9,0x00,
+
+	0xE0,0xB4,0x01,0x0C,0x90,0x44,0xCB,0xE0,
+
+	0xFF,0x13,0x13,0x54,0x3F,0xF0,0x80,0x0F,
+
+	0x90,0xF9,0x00,0xE0,0xB4,0x02,0x08,0x90,
+
+	0x44,0xCB,0xE0,0xFF,0xC3,0x13,0xF0,0x90,
+
+	0x44,0xCB,0xE0,0xFF,0xC3,0x94,0x04,0x40,
+
+	0x05,0x74,0x03,0xF0,0x80,0x21,0xEF,0xC3,
+
+	0x94,0x02,0x40,0x08,0x90,0x44,0xCB,0x74,
+
+	0x02,0xF0,0x80,0x13,0xEF,0xC3,0x94,0x01,
+
+	0x40,0x08,0x90,0x44,0xCB,0x74,0x01,0xF0,
+
+	0x80,0x05,0xE4,0x90,0x44,0xCB,0xF0,0x90,
+
+	0x44,0xCB,0xE0,0xFF,0x90,0xF9,0x01,0xE0,
+
+	0xC3,0x9F,0x50,0x0F,0xE0,0x90,0x44,0xCB,
+
+	0xF0,0x80,0x08,0x90,0xF9,0x01,0xE0,0x90,
+
+	0x44,0xCB,0xF0,0x90,0x44,0xCB,0xE0,0x14,
+
+	0x60,0x0F,0x14,0x60,0x11,0x14,0x60,0x13,
+
+	0x24,0x03,0x70,0x12,0x12,0x92,0x9B,0x80,
+
+	0x0D,0x12,0x94,0xB7,0x80,0x08,0x12,0x90,
+
+	0x6C,0x80,0x03,0x12,0x94,0x05,0x90,0xF9,
+
+	0x01,0xE0,0x14,0x60,0x0E,0x14,0x60,0x0F,
+
+	0x14,0x60,0x10,0x24,0x03,0x70,0x0F,0x12,
+
+	0x9E,0x25,0x22,0x12,0x9E,0x8D,0x22,0x12,
+
+	0xA0,0x27,0x22,0x12,0xA0,0x8B,0x22,0xAA,
+
+	0x07,0xEA,0x70,0x10,0x90,0xF7,0x86,0x04,
+
+	0xF0,0xA3,0xF0,0xE4,0x90,0x44,0x41,0xF0,
+
+	0x90,0x44,0x3F,0xF0,0xEA,0x64,0x01,0x70,
+
+	0x1D,0x90,0x44,0x3F,0x04,0xF0,0x90,0xF7,
+
+	0x86,0xF0,0xA3,0xF0,0x90,0xF7,0x86,0xE0,
+
+	0x70,0x06,0x90,0xF7,0x32,0xE0,0x70,0xF4,
+
+	0x90,0xF7,0x87,0xE0,0x60,0xEE,0x90,0xF7,
+
+	0x86,0xE0,0x70,0x09,0x90,0xF7,0x31,0xE0,
+
+	0x70,0x03,0x02,0x81,0x1A,0x90,0x44,0x3B,
+
+	0xE0,0xC3,0x94,0x01,0x50,0x03,0x02,0x81,
+
+	0x1A,0x90,0xF7,0x87,0xE0,0x70,0x03,0x02,
+
+	0x81,0x1A,0x90,0xF9,0x00,0xE0,0x70,0x04,
+
+	0x7B,0x04,0x80,0x0D,0x90,0xF9,0x00,0xE0,
+
+	0xB4,0x01,0x04,0x7B,0x06,0x80,0x02,0x7B,
+
+	0x05,0x90,0xF9,0x03,0xE0,0xFF,0xC3,0xEB,
+
+	0x9F,0xFB,0x90,0xF7,0x92,0xE0,0x90,0x41,
+
+	0xBD,0xF0,0x90,0xF7,0x93,0xE0,0x90,0x41,
+
+	0xBE,0xF0,0x90,0xF7,0x94,0xE0,0x90,0x41,
+
+	0xBF,0xF0,0x90,0xF7,0x8B,0xE0,0x90,0x41,
+
+	0xC0,0xF0,0x90,0xF7,0x97,0xE0,0x90,0x44,
+
+	0x3C,0xF0,0x90,0xF7,0x96,0xE0,0x90,0x44,
+
+	0x3D,0xF0,0x90,0xF7,0x95,0xE0,0x90,0x44,
+
+	0x3E,0xF0,0x90,0x44,0x3C,0xE0,0x90,0x44,
+
+	0x42,0xF0,0x90,0x44,0x3D,0xE0,0x90,0x44,
+
+	0x43,0xF0,0xAF,0x03,0x12,0xA9,0xD9,0x90,
+
+	0x44,0x43,0xE0,0x90,0x42,0x33,0xF0,0x90,
+
+	0x41,0xBF,0xE0,0x90,0x44,0x42,0xF0,0x90,
+
+	0x41,0xBE,0xE0,0x90,0x44,0x43,0xF0,0xAF,
+
+	0x03,0x12,0xA9,0xD9,0x90,0x44,0x43,0xE0,
+
+	0x90,0x42,0x32,0xF0,0x90,0xF7,0x86,0x74,
+
+	0x01,0xF0,0xA3,0xF0,0xE4,0x90,0x44,0x41,
+
+	0xF0,0xEA,0xB4,0x01,0x05,0xE4,0x90,0x44,
+
+	0x3F,0xF0,0x22,0xAD,0x07,0x90,0x43,0x70,
+
+	0xE0,0x90,0xF5,0xDB,0xF0,0x90,0x43,0x6F,
+
+	0xE0,0xFF,0x33,0x95,0xE0,0x90,0xF5,0xDC,
+
+	0xEF,0xF0,0x90,0x43,0x65,0xE0,0x90,0xF5,
+
+	0xFA,0xF0,0x90,0xF5,0xE8,0xE4,0xF0,0x90,
+
+	0x43,0x4D,0xE0,0x90,0xF5,0xE1,0xF0,0x90,
+
+	0xF5,0xE8,0xE0,0xB4,0x01,0xF9,0x90,0xF5,
+
+	0xE8,0xE4,0xF0,0x90,0xF5,0xE1,0x74,0x0D,
+
+	0xF0,0x90,0xF5,0xE8,0xE0,0xB4,0x01,0xF9,
+
+	0x90,0x43,0x4D,0x74,0x0E,0xF0,0x90,0xF5,
+
+	0xDD,0xE0,0x90,0x44,0xBF,0xF0,0x90,0xF5,
+
+	0xDE,0xE0,0x90,0x44,0xBE,0xF0,0xE0,0xC3,
+
+	0x94,0x20,0x40,0x04,0xE0,0x24,0xC0,0xF0,
+
+	0xED,0xB4,0x01,0x1C,0x90,0x43,0x73,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0x90,0x44,0xBF,0xE0,
+
+	0x2F,0xFF,0x90,0x44,0xBE,0xE0,0x3E,0x90,
+
+	0x43,0x75,0xF0,0xA3,0xEF,0xF0,0x80,0x1F,
+
+	0x90,0x44,0xBE,0xE0,0xFF,0xA3,0xE0,0x90,
+
+	0x43,0x75,0xCF,0xF0,0xA3,0xEF,0xF0,0x90,
+
+	0xF5,0xFB,0xE0,0x90,0x43,0x74,0xF0,0x90,
+
+	0xF5,0xFC,0xE0,0x90,0x43,0x73,0xF0,0x90,
+
+	0x43,0x76,0xE0,0x90,0xF4,0x66,0xF0,0x90,
+
+	0x43,0x75,0xE0,0x90,0xF4,0x67,0xF0,0x90,
+
+	0xF6,0x08,0xE0,0xFF,0x13,0x13,0x13,0x54,
+
+	0x1F,0x90,0xFD,0xA1,0xF0,0x90,0xF5,0xFC,
+
+	0xE0,0xFE,0x90,0xF5,0xFB,0xE0,0x7C,0x00,
+
+	0x24,0x00,0xFF,0xEC,0x3E,0xAD,0x07,0xFC,
+
+	0x90,0xF5,0x3D,0xE0,0xFE,0x90,0xF5,0x3C,
+
+	0xE0,0x7A,0x00,0x24,0x00,0xFF,0xEA,0x3E,
+
+	0xFE,0xEF,0x2D,0xFD,0xEE,0x3C,0xFF,0x33,
+
+	0x95,0xE0,0xA3,0xEF,0xF0,0xAF,0x05,0xEF,
+
+	0x90,0xF5,0x3C,0xF0,0x22,0x90,0x42,0x37,
+
+	0xE0,0x70,0x03,0x02,0x83,0x10,0xE4,0x90,
+
+	0x44,0xD4,0xF0,0x90,0x44,0xD4,0xE0,0xF9,
+
+	0xC3,0x94,0x08,0x50,0x7E,0x90,0x42,0xFB,
+
+	0xE0,0x75,0xF0,0x05,0xA4,0x24,0x64,0xFB,
+
+	0xE4,0x35,0xF0,0xFA,0xE9,0xFF,0x7E,0x00,
+
+	0x7C,0x02,0x7D,0x58,0x12,0x4A,0x11,0xEF,
+
+	0x2B,0xFF,0xEE,0x3A,0xFE,0x90,0x43,0x21,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0x12,0x4A,0x23,
+
+	0xA3,0xEC,0xF0,0xA3,0xED,0xF0,0x12,0xAC,
+
+	0x5B,0x12,0xAD,0x5A,0x90,0x44,0xD4,0xE0,
+
+	0x70,0x03,0x12,0xA6,0x99,0x90,0x43,0x0A,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x78,0x04,0x12,0x4B,0x32,
+
+	0x90,0x43,0x06,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0x12,
+
+	0x4B,0x21,0x50,0x0E,0x90,0x42,0xFA,0xE0,
+
+	0x04,0xF0,0x70,0x06,0x90,0x42,0xF9,0xE0,
+
+	0x04,0xF0,0x90,0x44,0xD4,0xE0,0x04,0xF0,
+
+	0x02,0x82,0x2C,0x90,0x42,0xFB,0xE0,0x04,
+
+	0xF0,0xE0,0x64,0x64,0x70,0x51,0x90,0xF9,
+
+	0x00,0xE0,0x60,0x08,0x90,0x43,0x35,0x74,
+
+	0x28,0xF0,0x80,0x06,0x90,0x43,0x35,0x74,
+
+	0x3E,0xF0,0x90,0x42,0x2B,0x74,0x01,0xF0,
+
+	0x90,0x43,0x35,0xE0,0xFF,0xD3,0x90,0x42,
+
+	0xFA,0xE0,0x9F,0x90,0x42,0xF9,0xE0,0x94,
+
+	0x00,0x40,0x0B,0xE4,0x90,0x41,0xE4,0xF0,
+
+	0x90,0x41,0xE5,0xF0,0x80,0x0A,0x90,0x41,
+
+	0xE4,0x74,0x01,0xF0,0x90,0x41,0xE5,0xF0,
+
+	0x90,0x42,0xFC,0xE0,0x04,0xF0,0xE4,0x90,
+
+	0x42,0xF9,0xF0,0xA3,0xF0,0xA3,0xF0,0x12,
+
+	0xA7,0x80,0x22,0x90,0xF0,0x02,0xE0,0x90,
+
+	0x43,0x8C,0xF0,0x90,0xF0,0x03,0xE0,0x90,
+
+	0x43,0x8B,0xF0,0x90,0xF0,0x03,0xE0,0x60,
+
+	0x04,0x7F,0xFF,0x80,0x05,0x90,0xF0,0x02,
+
+	0xE0,0xFF,0x90,0x42,0x40,0xEF,0xF0,0x90,
+
+	0xF0,0x63,0xE0,0xFE,0x90,0xF0,0x62,0xE0,
+
+	0x7C,0x00,0x24,0x00,0xFF,0xEC,0x3E,0x90,
+
+	0x43,0x9A,0xF0,0xA3,0xEF,0xF0,0x90,0x43,
+
+	0xAA,0xE0,0xFB,0x7A,0x00,0x90,0x43,0x9B,
+
+	0xE0,0x2B,0xFE,0x90,0x43,0x9A,0xE0,0x3A,
+
+	0x90,0x43,0x96,0xF0,0xA3,0xCE,0xF0,0xC3,
+
+	0x90,0x43,0x9B,0xE0,0x9B,0xFE,0x90,0x43,
+
+	0x9A,0xE0,0x9A,0x90,0x43,0x98,0xF0,0xA3,
+
+	0xCE,0xF0,0x90,0x43,0x97,0xE0,0x25,0xE0,
+
+	0xFF,0x90,0x43,0x96,0xE0,0x33,0xFE,0xD3,
+
+	0x90,0x43,0x8C,0xE0,0x9F,0x90,0x43,0x8B,
+
+	0xE0,0x9E,0x40,0x08,0x90,0x43,0x9C,0x74,
+
+	0xFC,0xF0,0x80,0x5F,0x90,0x43,0x96,0xE0,
+
+	0xFE,0xA3,0xE0,0xFF,0xD3,0x90,0x43,0x8C,
+
+	0xE0,0x9F,0x90,0x43,0x8B,0xE0,0x9E,0x40,
+
+	0x08,0x90,0x43,0x9C,0x74,0xFF,0xF0,0x80,
+
+	0x42,0x90,0x43,0x98,0xE0,0xC3,0x13,0xFE,
+
+	0xA3,0xE0,0x13,0xFF,0xC3,0x90,0x43,0x8C,
+
+	0xE0,0x9F,0x90,0x43,0x8B,0xE0,0x9E,0x50,
+
+	0x08,0x90,0x43,0x9C,0x74,0x04,0xF0,0x80,
+
+	0x22,0x90,0x43,0x98,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0xC3,0x90,0x43,0x8C,0xE0,0x9F,0x90,
+
+	0x43,0x8B,0xE0,0x9E,0x50,0x08,0x90,0x43,
+
+	0x9C,0x74,0x01,0xF0,0x80,0x05,0xE4,0x90,
+
+	0x43,0x9C,0xF0,0x90,0xF0,0x01,0x74,0x01,
+
+	0xF0,0x22,0x90,0x43,0x6E,0xE0,0xF9,0xB4,
+
+	0x01,0x37,0x90,0x43,0x66,0xE0,0x25,0xE0,
+
+	0x24,0x58,0xF5,0x82,0xE4,0x34,0x43,0xF5,
+
+	0x83,0xE0,0xFC,0xA3,0xE0,0xFD,0x90,0x43,
+
+	0x6F,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0xED,
+
+	0x9B,0xFD,0xEC,0x9A,0xFC,0x90,0x43,0x68,
+
+	0xE0,0x2D,0xFE,0x90,0x43,0x67,0xE0,0x3C,
+
+	0x90,0x44,0xC0,0xF0,0xA3,0xCE,0xF0,0x80,
+
+	0x72,0xE9,0xB4,0x02,0x32,0x90,0x43,0x71,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x43,0x62,
+
+	0xE0,0x2F,0xFF,0x90,0x43,0x61,0xE0,0x3E,
+
+	0xFE,0x90,0x43,0x67,0xE0,0xFC,0xA3,0xE0,
+
+	0xFD,0xC3,0xEF,0x9D,0xFF,0xEE,0x9C,0xFE,
+
+	0xC3,0xE4,0x9F,0xFF,0xE4,0x9E,0x90,0x44,
+
+	0xC0,0xF0,0xA3,0xEF,0xF0,0x80,0x3C,0x90,
+
+	0x43,0x6E,0xE0,0xB4,0x03,0x35,0x90,0x43,
+
+	0x66,0xE0,0x25,0xE0,0x24,0x58,0xF5,0x82,
+
+	0xE4,0x34,0x43,0xF5,0x83,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x43,0x6F,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xC3,0xEF,0x9D,0xFF,0xEE,0x9C,
+
+	0xFE,0x90,0x43,0x68,0xE0,0x2F,0xFF,0x90,
+
+	0x43,0x67,0xE0,0x3E,0x90,0x44,0xC0,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x44,0xC0,0xE0,0xFE,
+
+	0xA3,0xE0,0xFF,0x90,0x43,0x70,0xE0,0x2F,
+
+	0xF0,0x90,0x43,0x6F,0xE0,0x3E,0xF0,0x90,
+
+	0x44,0xC1,0xE0,0x90,0xF4,0x66,0xF0,0x90,
+
+	0x44,0xC0,0xE0,0x90,0xF4,0x67,0xF0,0x90,
+
+	0x43,0x68,0xE0,0x90,0xF5,0xF4,0xF0,0x90,
+
+	0x43,0x67,0xE0,0x90,0xF5,0xF5,0xF0,0x90,
+
+	0x43,0x4D,0x74,0x08,0xF0,0x22,0xC2,0xAF,
+
+	0x90,0xF7,0x7D,0xE0,0x64,0x01,0x70,0x57,
+
+	0x90,0xF7,0x32,0xE0,0x60,0x03,0x12,0x96,
+
+	0xBA,0x90,0xF7,0x3C,0xE0,0x60,0x03,0x02,
+
+	0x85,0xBF,0x90,0xF5,0xA9,0xE0,0x60,0x03,
+
+	0x02,0x85,0xBF,0x90,0xF7,0x32,0xE0,0xB4,
+
+	0x01,0x10,0x90,0xF7,0x7B,0xE0,0xB4,0x01,
+
+	0x09,0x90,0x43,0xBA,0x74,0x02,0xF0,0x12,
+
+	0xA4,0x44,0x90,0xF7,0x31,0xE0,0x64,0x01,
+
+	0x60,0x03,0x02,0x85,0xBF,0x90,0xF7,0x7C,
+
+	0xE0,0x64,0x01,0x60,0x03,0x02,0x85,0xBF,
+
+	0x90,0x44,0x9A,0x04,0xF0,0x90,0xF7,0x49,
+
+	0xE0,0x90,0x44,0x9C,0xF0,0x80,0x6F,0x90,
+
+	0x44,0x9B,0xE0,0x64,0x01,0x70,0x67,0x90,
+
+	0xF5,0xB9,0xE0,0x64,0x01,0x70,0x29,0x90,
+
+	0xF5,0xB3,0x04,0xF0,0x90,0xF4,0x60,0xE0,
+
+	0x70,0x05,0x12,0xAE,0xA0,0x80,0x0F,0x90,
+
+	0xF4,0x60,0xE0,0xB4,0x01,0x05,0x12,0xAE,
+
+	0xB0,0x80,0x03,0x12,0xAE,0xC0,0x90,0xF5,
+
+	0xB3,0xE4,0xF0,0x90,0x42,0x58,0x04,0xF0,
+
+	0x90,0xF5,0xC0,0xE0,0x64,0x01,0x70,0x29,
+
+	0x90,0xF5,0xBD,0x04,0xF0,0x90,0xF4,0x60,
+
+	0xE0,0x70,0x05,0x12,0xAF,0x0C,0x80,0x0F,
+
+	0x90,0xF4,0x60,0xE0,0xB4,0x01,0x05,0x12,
+
+	0xAE,0x7E,0x80,0x03,0x12,0xAE,0xD0,0x90,
+
+	0xF5,0xBD,0xE4,0xF0,0x90,0x42,0x57,0x04,
+
+	0xF0,0xE4,0x90,0x44,0xCD,0xF0,0x12,0xAB,
+
+	0x75,0x53,0x91,0xBF,0xE4,0x90,0x44,0x9B,
+
+	0xF0,0xD2,0xEA,0xD2,0xE9,0xD2,0xAF,0x22,
+
+	0x12,0xAC,0x9F,0x12,0x8F,0xAB,0x12,0x7A,
+
+	0xB3,0x90,0x44,0x71,0x74,0x01,0xF0,0xFB,
+
+	0x7A,0x44,0x79,0x6A,0x12,0xA1,0x52,0xD2,
+
+	0xAF,0x90,0xF2,0x1B,0xE4,0xF0,0x90,0x44,
+
+	0x71,0xE0,0x70,0xFA,0x12,0xAD,0xCE,0xE5,
+
+	0x13,0xB4,0x0A,0x00,0x40,0x03,0x02,0x86,
+
+	0x9E,0x90,0x86,0x09,0xF8,0x28,0x28,0x73,
+
+	0x02,0x86,0x27,0x02,0x86,0x2C,0x02,0x86,
+
+	0x31,0x02,0x86,0x36,0x02,0x86,0x3B,0x02,
+
+	0x86,0x40,0x02,0x86,0x45,0x02,0x86,0x4A,
+
+	0x02,0x86,0x6A,0x02,0x86,0x99,0x12,0xAE,
+
+	0x6C,0x80,0x75,0x12,0x9B,0xB3,0x80,0x70,
+
+	0x12,0x8B,0xBB,0x80,0x6B,0x12,0xAA,0x6A,
+
+	0x80,0x66,0x12,0x9C,0x33,0x80,0x61,0x12,
+
+	0xA8,0xE4,0x80,0x5C,0x12,0xA4,0x8D,0x80,
+
+	0x57,0x90,0xF5,0x05,0x74,0x01,0xF0,0x90,
+
+	0x43,0x8E,0xF0,0x12,0xAF,0x7E,0x90,0x43,
+
+	0xBB,0xE0,0xB4,0x01,0x05,0x7F,0x01,0x12,
+
+	0xAD,0x78,0x7F,0x01,0x12,0xAE,0x43,0x80,
+
+	0x37,0x12,0xA0,0xEF,0x12,0x8D,0x56,0x90,
+
+	0xF5,0x05,0xE4,0xF0,0x90,0x43,0xBB,0xE0,
+
+	0xB4,0x01,0x06,0x12,0x73,0x31,0x12,0xA0,
+
+	0xEF,0x90,0x43,0xBB,0xE0,0xB4,0x01,0x06,
+
+	0xE5,0x13,0x64,0x08,0x60,0x12,0xE4,0x90,
+
+	0x42,0x42,0xF0,0x12,0xAD,0xCE,0x80,0x08,
+
+	0x12,0x70,0x4E,0x80,0x03,0x12,0xAF,0x87,
+
+	0x12,0x9F,0xC1,0x12,0x97,0xF3,0x12,0xAD,
+
+	0xCE,0x02,0x85,0xF8,0x22,0x90,0x41,0xB5,
+
+	0xE0,0xFE,0x90,0x41,0xB4,0xE0,0x7C,0x00,
+
+	0x24,0x00,0xFF,0xEC,0x3E,0x90,0x44,0xC2,
+
+	0xF0,0xA3,0xEF,0xF0,0xE4,0x7F,0x50,0x7E,
+
+	0x0D,0xFD,0x90,0x43,0xEA,0xE0,0xF8,0xA3,
+
+	0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xC3,0x12,0x4B,0x21,0x40,0x24,0x90,0x43,
+
+	0xEA,0xE0,0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,
+
+	0xFE,0xA3,0xE0,0x24,0xB0,0xFF,0xEE,0x34,
+
+	0xF2,0xFE,0xED,0x34,0xFF,0xFD,0xEC,0x34,
+
+	0xFF,0xFC,0x90,0x43,0xE6,0x12,0x4B,0x6C,
+
+	0x80,0x23,0x90,0x43,0xEA,0xE0,0xF8,0xA3,
+
+	0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xC3,0x74,0x50,0x9B,0xFF,0x74,0x0D,0x9A,
+
+	0xFE,0xE4,0x99,0xFD,0xE4,0x98,0xFC,0x90,
+
+	0x43,0xE6,0x12,0x4B,0x6C,0x90,0x44,0xC2,
+
+	0xE0,0xFE,0xA3,0xE0,0xFF,0xE4,0xFC,0xFD,
+
+	0x90,0x43,0xE6,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0x12,0x4A,
+
+	0xAE,0x78,0x09,0x12,0x4B,0x32,0x90,0x43,
+
+	0xE6,0x12,0x4B,0x6C,0xE4,0x7F,0x50,0x7E,
+
+	0x0D,0xFD,0xFC,0x90,0x43,0xEA,0xE0,0xF8,
+
+	0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,
+
+	0xFB,0xC3,0x12,0x4B,0x21,0x50,0x22,0x90,
+
+	0x43,0xE6,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,
+
+	0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0xE4,0x9B,
+
+	0xFF,0x74,0x40,0x9A,0xFE,0xE4,0x99,0xFD,
+
+	0xE4,0x98,0xFC,0x90,0x43,0xE6,0x12,0x4B,
+
+	0x6C,0x22,0xE4,0xFF,0xFE,0x90,0x44,0xD3,
+
+	0xF0,0x90,0x41,0xD7,0xE0,0xFD,0xB4,0x22,
+
+	0x07,0x90,0x42,0x04,0xE0,0x70,0x01,0x0F,
+
+	0xED,0xB4,0x28,0x08,0x90,0xF0,0x61,0xE0,
+
+	0x70,0x02,0x7F,0x01,0x90,0x41,0xD7,0xE0,
+
+	0xB4,0x22,0x19,0x90,0x43,0xAE,0xE0,0x24,
+
+	0xAB,0xF5,0x82,0xE4,0x34,0x43,0xF5,0x83,
+
+	0xE0,0xFD,0x90,0x42,0x04,0xE0,0xC3,0x9D,
+
+	0x50,0x02,0x7E,0x01,0x90,0x41,0xD7,0xE0,
+
+	0xB4,0x28,0x0B,0x90,0xF0,0x61,0xE0,0xC3,
+
+	0x94,0x70,0x50,0x02,0x7E,0x01,0x90,0x43,
+
+	0x8E,0xE0,0x64,0x03,0x60,0x08,0x90,0x42,
+
+	0x52,0xE0,0x64,0x01,0x60,0xF0,0x90,0x41,
+
+	0xE8,0xE0,0x70,0x70,0x90,0x41,0xE3,0xE0,
+
+	0x70,0x2C,0xEF,0x70,0x09,0x90,0x41,0xD5,
+
+	0xE0,0x60,0x61,0xEE,0x60,0x5E,0x90,0x41,
+
+	0xD7,0xE0,0xB4,0x22,0x06,0x90,0x43,0x8F,
+
+	0x74,0x14,0xF0,0x12,0xAB,0x20,0x90,0x43,
+
+	0x8D,0x74,0x32,0xF0,0x90,0x41,0xD5,0xE0,
+
+	0x60,0x42,0x12,0xAF,0x6A,0x22,0x90,0x41,
+
+	0xD7,0xE0,0xFF,0xB4,0x22,0x14,0x90,0x42,
+
+	0x04,0xE0,0xD3,0x94,0x40,0x40,0x0B,0x90,
+
+	0x41,0xD5,0xE0,0x70,0x05,0x90,0x44,0xD3,
+
+	0x04,0xF0,0xEF,0xB4,0x28,0x0F,0x90,0xF0,
+
+	0x61,0xE0,0xD3,0x94,0x90,0x40,0x06,0x90,
+
+	0x44,0xD3,0x74,0x01,0xF0,0x90,0x44,0xD3,
+
+	0xE0,0x60,0x09,0x90,0x43,0x8F,0x74,0x14,
+
+	0xF0,0x12,0xAB,0x4B,0x22,0xE4,0xFF,0x90,
+
+	0x43,0xCA,0xF0,0xA3,0xF0,0xA3,0xF0,0x90,
+
+	0xF9,0x00,0xE0,0x70,0x08,0x90,0x43,0xCD,
+
+	0x74,0x2D,0xF0,0x80,0x15,0x90,0xF9,0x00,
+
+	0xE0,0xB4,0x02,0x08,0x90,0x43,0xCD,0x74,
+
+	0x59,0xF0,0x80,0x06,0x90,0x43,0xCD,0x74,
+
+	0xB1,0xF0,0x90,0xF5,0x56,0xE4,0xF0,0xFF,
+
+	0x90,0x43,0xCD,0xE0,0xFE,0xEF,0xC3,0x9E,
+
+	0x40,0x03,0x02,0x89,0x39,0x90,0xF6,0x56,
+
+	0xEF,0xF0,0x90,0xF6,0x5A,0x74,0x01,0xF0,
+
+	0x90,0xF6,0x5A,0xE0,0x70,0xFA,0x90,0xF6,
+
+	0x5E,0xE0,0x90,0x43,0xC9,0xF0,0x90,0x43,
+
+	0xC7,0xE0,0xC3,0x94,0xC8,0x50,0x25,0x90,
+
+	0x41,0xD5,0xE0,0xB4,0x01,0x1E,0xEF,0xC3,
+
+	0x94,0x0E,0x40,0x0C,0x90,0x43,0xCD,0xE0,
+
+	0x24,0xF2,0xFE,0xEF,0xD3,0x9E,0x40,0x06,
+
+	0x90,0x43,0xC9,0x74,0x01,0xF0,0x90,0x43,
+
+	0xC7,0xE0,0x04,0xF0,0x90,0x43,0xC9,0xE0,
+
+	0x60,0x17,0x90,0x43,0xCB,0xE0,0xFE,0x74,
+
+	0x01,0xA8,0x06,0x08,0x80,0x02,0xC3,0x33,
+
+	0xD8,0xFC,0xFE,0x90,0x43,0xCA,0xE0,0x2E,
+
+	0xF0,0x90,0x43,0xCB,0xE0,0x04,0xF0,0xE0,
+
+	0x64,0x08,0x60,0x05,0xA3,0xE0,0xB4,0x16,
+
+	0x1B,0x90,0x43,0xCC,0xE0,0x90,0xF5,0x57,
+
+	0xF0,0x90,0x43,0xCA,0xE0,0x90,0xF5,0x55,
+
+	0xF0,0xE4,0x90,0x43,0xCA,0xF0,0xA3,0xF0,
+
+	0xA3,0xE0,0x04,0xF0,0x0F,0x02,0x88,0x99,
+
+	0x90,0xF5,0x56,0x74,0x01,0xF0,0x22,0x90,
+
+	0x44,0x44,0xE0,0x54,0x01,0xF0,0xC2,0xAF,
+
+	0x70,0x27,0x90,0xF7,0x02,0xE0,0x90,0xFB,
+
+	0x97,0xF0,0x90,0xF7,0x03,0xE0,0x90,0xFB,
+
+	0x98,0xF0,0x90,0xF7,0x04,0xE0,0x90,0xFB,
+
+	0x99,0xF0,0x90,0xF9,0x99,0xE0,0x90,0xFB,
+
+	0x9A,0xF0,0x7F,0x04,0x12,0xAD,0x3C,0x80,
+
+	0x53,0x90,0x44,0x44,0xE0,0x64,0x01,0x70,
+
+	0x4B,0x90,0x41,0xD7,0xE0,0xB4,0x22,0x0F,
+
+	0x90,0x42,0x04,0xE0,0x90,0xFB,0x97,0xF0,
+
+	0x7F,0x07,0x12,0xAD,0x3C,0x80,0x35,0x90,
+
+	0x43,0x8C,0xE0,0x90,0xFB,0x97,0xF0,0x90,
+
+	0x43,0x8B,0xE0,0x90,0xFB,0x98,0xF0,0x90,
+
+	0x42,0x2E,0xE0,0x90,0xFB,0x99,0xF0,0x90,
+
+	0x42,0x2F,0xE0,0x90,0xFB,0x9A,0xF0,0x90,
+
+	0xF0,0x60,0xE0,0x90,0xFB,0x9B,0xF0,0x90,
+
+	0xF0,0x61,0xE0,0x90,0xFB,0x9C,0xF0,0x7F,
+
+	0x05,0x12,0xAD,0x3C,0xD2,0xAF,0x90,0x44,
+
+	0x44,0xE0,0x04,0xF0,0x90,0xFB,0xA3,0xE0,
+
+	0x90,0x41,0xDA,0xF0,0x90,0xFB,0xA4,0xE0,
+
+	0x25,0xE0,0x25,0xE0,0x24,0x82,0x90,0x41,
+
+	0xDB,0xF0,0xE0,0xFF,0xC3,0x94,0x54,0x40,
+
+	0x06,0xE4,0x90,0x41,0xD9,0xF0,0x22,0xEF,
+
+	0xC3,0x94,0x32,0x40,0x12,0xEF,0x94,0x54,
+
+	0x50,0x0D,0xC3,0x74,0x53,0x9F,0x75,0xF0,
+
+	0x03,0xA4,0x90,0x41,0xD9,0xF0,0x22,0x90,
+
+	0x41,0xDB,0xE0,0xC3,0x94,0x32,0x50,0x06,
+
+	0x90,0x41,0xD9,0x74,0x64,0xF0,0x22,0x90,
+
+	0xF9,0x03,0xE0,0x90,0x41,0xC1,0xF0,0x90,
+
+	0xF9,0x00,0xE0,0x90,0x41,0xC2,0xF0,0x90,
+
+	0x44,0x41,0xE0,0x04,0xF0,0xE0,0xC3,0x94,
+
+	0x32,0x40,0x05,0xE4,0xFF,0x12,0x80,0x20,
+
+	0x90,0x44,0x3F,0xE0,0x70,0x05,0x7F,0x02,
+
+	0x12,0x80,0x20,0x90,0x44,0x40,0xE0,0x04,
+
+	0xF0,0xE0,0xC3,0x94,0x32,0x40,0x0B,0x90,
+
+	0xF7,0x0D,0x74,0x01,0xF0,0xE4,0x90,0x44,
+
+	0x40,0xF0,0x90,0xF7,0x0D,0xE0,0x60,0x5A,
+
+	0x90,0xF7,0x05,0xE0,0x90,0x41,0xC3,0xF0,
+
+	0x90,0xF7,0x06,0xE0,0x90,0x41,0xC4,0xF0,
+
+	0x90,0xF7,0x02,0xE0,0x90,0x41,0xC5,0xF0,
+
+	0x90,0xF7,0x03,0xE0,0x90,0x41,0xC6,0xF0,
+
+	0x90,0xF7,0x04,0xE0,0x90,0x41,0xC7,0xF0,
+
+	0x90,0xF7,0x00,0xE0,0x90,0x41,0xC8,0xF0,
+
+	0x90,0xF7,0x01,0xE0,0x90,0x41,0xC9,0xF0,
+
+	0x90,0xF7,0x0D,0x74,0x01,0xF0,0xE4,0x90,
+
+	0x44,0x40,0xF0,0x90,0x41,0xCF,0xE0,0x04,
+
+	0xF0,0xE0,0xFF,0x90,0x41,0xF6,0xE0,0xFE,
+
+	0xEF,0x8E,0xF0,0x84,0x90,0x41,0xCF,0xE5,
+
+	0xF0,0xF0,0x90,0xF7,0x00,0xE0,0xFF,0x90,
+
+	0x41,0xCB,0xE0,0xFE,0xB5,0x07,0x0C,0x90,
+
+	0xF7,0x01,0xE0,0xFF,0x90,0x41,0xCC,0xE0,
+
+	0x6F,0x60,0x18,0x90,0xF7,0x00,0xEE,0xF0,
+
+	0x90,0x41,0xCC,0xE0,0x90,0xF7,0x01,0xF0,
+
+	0x90,0xF7,0x0C,0x74,0x01,0xF0,0xE4,0xF0,
+
+	0xA3,0x04,0xF0,0x22,0x90,0xF5,0xEB,0xE0,
+
+	0x90,0x44,0xAC,0xF0,0x90,0xF5,0xEC,0xE0,
+
+	0x90,0x44,0xAB,0xF0,0x90,0xF5,0xED,0xE0,
+
+	0x90,0x44,0xAE,0xF0,0x90,0xF5,0xEE,0xE0,
+
+	0x90,0x44,0xAD,0xF0,0x90,0x43,0x6E,0xE0,
+
+	0xFF,0xB4,0x01,0x0A,0x74,0x02,0xF0,0x90,
+
+	0x43,0x4D,0x74,0x07,0xF0,0x22,0xEF,0x64,
+
+	0x02,0x60,0x08,0xEF,0x64,0x03,0x60,0x03,
+
+	0x02,0x8B,0xBA,0x90,0x43,0x64,0xE0,0xFF,
+
+	0x90,0x43,0x63,0xE0,0xFE,0x6F,0x70,0x2C,
+
+	0x90,0xF5,0xE9,0xE0,0x70,0x07,0x90,0x43,
+
+	0x65,0xEE,0xF0,0x80,0x18,0x90,0x41,0xEF,
+
+	0xE0,0x14,0xB5,0x06,0x07,0xE4,0x90,0x43,
+
+	0x65,0xF0,0x80,0x09,0x90,0x43,0x63,0xE0,
+
+	0x04,0x90,0x43,0x65,0xF0,0x90,0x43,0x4D,
+
+	0x74,0x0C,0xF0,0x22,0x90,0xF5,0xE9,0xE0,
+
+	0x70,0x18,0x90,0x43,0x63,0xE0,0xFF,0x90,
+
+	0x43,0x66,0xE0,0xB5,0x07,0x0C,0x90,0x43,
+
+	0x65,0xEF,0xF0,0x90,0x43,0x4D,0x74,0x0C,
+
+	0xF0,0x22,0x90,0xF5,0xE9,0xE0,0x70,0x0B,
+
+	0x90,0x43,0x66,0xE0,0x14,0x90,0x43,0x64,
+
+	0xF0,0x80,0x09,0x90,0x43,0x66,0xE0,0x04,
+
+	0x90,0x43,0x63,0xF0,0x90,0x43,0x64,0xE0,
+
+	0xFF,0x90,0x43,0x63,0xE0,0x2F,0xFF,0xC3,
+
+	0x13,0x90,0x43,0x66,0xF0,0x90,0x43,0x6E,
+
+	0x74,0x03,0xF0,0x90,0x43,0x4D,0x74,0x06,
+
+	0xF0,0x22,0x90,0xF0,0x2B,0xE4,0xF0,0x90,
+
+	0x42,0x44,0xE0,0x70,0x17,0x90,0xF1,0xE5,
+
+	0x04,0xF0,0x12,0xAE,0x59,0x12,0xAB,0x4B,
+
+	0x12,0x96,0x16,0x90,0x43,0xBB,0x74,0x01,
+
+	0xF0,0x02,0x8C,0x5E,0x90,0x44,0x47,0x74,
+
+	0x82,0xF0,0x90,0xFB,0x28,0xF0,0x12,0xAF,
+
+	0xA6,0x90,0x42,0x05,0xE0,0x90,0xF0,0x41,
+
+	0xF0,0x90,0xF0,0x2C,0x74,0x01,0xF0,0x90,
+
+	0xF1,0xE5,0xF0,0x75,0xF0,0x02,0xE5,0x13,
+
+	0xA4,0x24,0xC5,0xF5,0x82,0xE5,0xF0,0x34,
+
+	0xAF,0xF5,0x83,0xE4,0x93,0xFC,0x74,0x01,
+
+	0x93,0xFD,0xE4,0xFF,0x12,0xAB,0xED,0x90,
+
+	0x44,0xAA,0xE0,0xB4,0x01,0x04,0x7F,0x01,
+
+	0x80,0x02,0x7F,0x00,0x90,0xF1,0xE7,0xE0,
+
+	0x64,0x01,0x60,0x04,0x7E,0x01,0x80,0x02,
+
+	0x7E,0x00,0xEE,0x5F,0x70,0xE1,0x90,0xF1,
+
+	0xE7,0xE0,0xB4,0x01,0x04,0x7F,0x01,0x80,
+
+	0x02,0x7F,0x00,0x90,0x43,0xBB,0xEF,0xF0,
+
+	0xE0,0xB4,0x01,0x11,0x7D,0xFE,0x7C,0x27,
+
+	0xE4,0xFF,0x12,0xAB,0xED,0x90,0x44,0xAA,
+
+	0xE0,0x64,0x01,0x60,0xF8,0x90,0xF1,0x75,
+
+	0x74,0x01,0xF0,0x90,0x41,0xD7,0xE0,0xB4,
+
+	0x23,0x08,0x90,0x42,0x54,0xE0,0x90,0x44,
+
+	0x45,0xF0,0x12,0xAC,0x37,0x90,0xF0,0xD5,
+
+	0x74,0x01,0xF0,0x90,0xF0,0xE3,0xF0,0x90,
+
+	0xF0,0xE2,0xF0,0x90,0x43,0xBE,0xF0,0x22,
+
+	0x90,0x43,0xBD,0xE0,0x70,0x03,0x02,0x8D,
+
+	0x4F,0xC2,0xE9,0xE4,0x90,0x44,0x9B,0xF0,
+
+	0x90,0xF7,0x3C,0xE0,0xB4,0x01,0x04,0xC2,
+
+	0xEA,0x80,0x02,0xD2,0xEA,0x90,0xF7,0x0E,
+
+	0xE0,0xB4,0x01,0x20,0x90,0x43,0xB9,0xE0,
+
+	0xC3,0x94,0x02,0x50,0x11,0xE5,0x13,0xB4,
+
+	0x09,0x0C,0x12,0xAD,0xB2,0x90,0x43,0xB9,
+
+	0xE0,0x04,0xF0,0x02,0x8D,0x4F,0x12,0xA6,
+
+	0xD7,0x02,0x8D,0x4F,0x90,0xF5,0x54,0xE0,
+
+	0x64,0x01,0x70,0x7A,0x90,0xF0,0x2B,0xE0,
+
+	0x70,0x12,0x90,0x42,0x34,0xE0,0xB4,0x01,
+
+	0x0B,0x90,0xF2,0x17,0x74,0xFE,0xF0,0x90,
+
+	0x42,0x33,0x04,0xF0,0x90,0x44,0x9E,0xE0,
+
+	0xC3,0x94,0x02,0x50,0x18,0xE5,0x13,0xB4,
+
+	0x09,0x13,0x12,0xAD,0xB2,0x90,0x44,0x9D,
+
+	0xE0,0x90,0xF5,0x52,0xF0,0x90,0x44,0x9E,
+
+	0xE0,0x04,0xF0,0x80,0x41,0x90,0x43,0xBA,
+
+	0x74,0x02,0xF0,0x90,0xF7,0x0E,0xE0,0x64,
+
+	0x01,0x60,0x07,0x90,0xF7,0x40,0xE0,0xB4,
+
+	0x01,0x05,0x12,0xA6,0xD7,0x80,0x27,0x90,
+
+	0xF7,0x31,0xE0,0x60,0x0A,0xE4,0xFF,0x12,
+
+	0xA3,0xFB,0x12,0xAB,0xC7,0x80,0x11,0x90,
+
+	0xF7,0x3C,0xE0,0x70,0x03,0x12,0xAE,0x16,
+
+	0xE4,0x90,0x42,0x42,0xF0,0x12,0xAE,0xDF,
+
+	0x12,0xAE,0x8F,0x12,0xAD,0x95,0x12,0xAE,
+
+	0x8F,0x53,0x91,0x7F,0x22,0x90,0xF5,0xA8,
+
+	0xE4,0xF0,0x04,0xF0,0x75,0xF0,0x02,0xE5,
+
+	0x13,0xA4,0x24,0xC5,0xF5,0x82,0xE5,0xF0,
+
+	0x34,0xAF,0xF5,0x83,0xE4,0x93,0xFC,0x74,
+
+	0x01,0x93,0xFD,0xE4,0xFF,0x12,0xAB,0xED,
+
+	0x90,0x44,0xAA,0xE0,0xB4,0x01,0x04,0x7F,
+
+	0x01,0x80,0x02,0x7F,0x00,0x90,0xF5,0xA9,
+
+	0xE0,0x64,0x01,0x60,0x04,0x7E,0x01,0x80,
+
+	0x02,0x7E,0x00,0xEE,0x5F,0x70,0xE1,0x90,
+
+	0xF5,0xA9,0xE0,0xB4,0x01,0x04,0x7F,0x01,
+
+	0x80,0x02,0x7F,0x00,0x90,0x43,0xBB,0xEF,
+
+	0xF0,0xE0,0x64,0x01,0x70,0x40,0x90,0xF4,
+
+	0xCC,0xE0,0xFF,0x90,0xF9,0x08,0xF0,0x90,
+
+	0xF4,0xC1,0xE0,0xFF,0x90,0xF9,0x03,0xF0,
+
+	0x90,0xF4,0xC4,0xE0,0xFF,0x90,0xF9,0x06,
+
+	0xF0,0x90,0xF4,0xC5,0xE0,0xFF,0x90,0xF9,
+
+	0x07,0xF0,0x90,0xF4,0xC6,0xE0,0x54,0x03,
+
+	0xFF,0x90,0xF9,0x02,0xF0,0x70,0x05,0x90,
+
+	0xF9,0x05,0x04,0xF0,0x90,0x41,0xD1,0x74,
+
+	0x01,0xF0,0x90,0xF7,0x2F,0xF0,0x90,0xF1,
+
+	0x0F,0xE0,0xFE,0x90,0xF1,0x0E,0xE0,0x7C,
+
+	0x00,0x24,0x00,0xFF,0xEC,0x3E,0x90,0x43,
+
+	0xD1,0xF0,0xA3,0xEF,0xF0,0x90,0xF1,0x13,
+
+	0xE0,0xFE,0x90,0xF1,0x12,0xE0,0x24,0x00,
+
+	0xFF,0xEC,0x3E,0x90,0x43,0xD3,0xF0,0xA3,
+
+	0xEF,0xF0,0x12,0x95,0x68,0x22,0x90,0xF9,
+
+	0x00,0xE0,0xB4,0x01,0x10,0x90,0x43,0x20,
+
+	0x74,0x0C,0xF0,0xA3,0x74,0x1A,0xF0,0xA3,
+
+	0x74,0xA1,0xF0,0x80,0x24,0x90,0xF9,0x00,
+
+	0xE0,0x70,0x10,0x90,0x43,0x20,0x74,0x0A,
+
+	0xF0,0xA3,0x74,0x06,0xF0,0xA3,0x74,0xA9,
+
+	0xF0,0x80,0x0E,0x90,0x43,0x20,0x74,0x0B,
+
+	0xF0,0xA3,0x74,0x0D,0xF0,0xA3,0x74,0x51,
+
+	0xF0,0xE4,0xFF,0x7F,0x08,0x90,0x43,0x28,
+
+	0xE4,0xF0,0xA3,0xDF,0xFC,0x7F,0x08,0x90,
+
+	0xF4,0xC1,0xE0,0x14,0x60,0x12,0x14,0x60,
+
+	0x41,0x24,0x02,0x70,0x6E,0x90,0x43,0x1E,
+
+	0x74,0xB5,0xF0,0xA3,0x74,0x08,0xF0,0x22,
+
+	0x90,0xF4,0xC6,0xE0,0x14,0x60,0x0A,0x14,
+
+	0x60,0x12,0x14,0x60,0x1A,0x24,0x03,0x70,
+
+	0x52,0x90,0x43,0x1E,0x74,0xA2,0xF0,0xA3,
+
+	0x74,0x09,0xF0,0x22,0x90,0x43,0x1E,0x74,
+
+	0xE5,0xF0,0xA3,0x74,0x0A,0xF0,0x22,0x90,
+
+	0x43,0x1E,0x74,0x8E,0xF0,0xA3,0x74,0x0A,
+
+	0xF0,0x22,0x90,0xF4,0xC6,0xE0,0x14,0x60,
+
+	0x0A,0x14,0x60,0x12,0x14,0x60,0x1A,0x24,
+
+	0x03,0x70,0x20,0x90,0x43,0x1E,0x74,0x9E,
+
+	0xF0,0xA3,0x74,0x0A,0xF0,0x22,0x90,0x43,
+
+	0x1E,0x74,0x84,0xF0,0xA3,0x74,0x0A,0xF0,
+
+	0x22,0x90,0x43,0x1E,0x74,0xC5,0xF0,0xA3,
+
+	0x74,0x0B,0xF0,0x22,0x90,0xF5,0xCB,0xE0,
+
+	0xB4,0x01,0xF9,0x90,0xF5,0xD0,0xE0,0x90,
+
+	0x42,0xFF,0xF0,0x90,0xF5,0xCF,0xE0,0x90,
+
+	0x43,0x00,0xF0,0x90,0xF5,0xCE,0xE0,0x90,
+
+	0x43,0x01,0xF0,0x90,0x42,0xFE,0xE0,0xFC,
+
+	0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,
+
+	0xFF,0x78,0x0A,0x12,0x4B,0x59,0x78,0x0A,
+
+	0x12,0x4B,0x45,0x90,0x42,0xFE,0x12,0x4B,
+
+	0x6C,0x90,0x43,0x1E,0xE0,0xFF,0xE4,0xFC,
+
+	0xFD,0xFE,0x90,0x42,0xFE,0xE0,0xF8,0xA3,
+
+	0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0x12,0x4A,0xAE,0x90,0x43,0x1F,0xE0,0xF9,
+
+	0xF8,0x12,0x4B,0x45,0x90,0x42,0xFE,0x12,
+
+	0x4B,0x6C,0x90,0xF5,0xD3,0xE0,0x90,0x43,
+
+	0x03,0xF0,0x90,0xF5,0xD2,0xE0,0x90,0x43,
+
+	0x04,0xF0,0x90,0xF5,0xD1,0xE0,0x90,0x43,
+
+	0x05,0xF0,0x90,0x43,0x02,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+
+	0x78,0x0A,0x12,0x4B,0x59,0x78,0x0A,0x12,
+
+	0x4B,0x45,0x90,0x43,0x02,0x12,0x4B,0x6C,
+
+	0x90,0x43,0x1E,0xE0,0xFF,0xE4,0xFC,0xFD,
+
+	0xFE,0x90,0x43,0x02,0xE0,0xF8,0xA3,0xE0,
+
+	0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0x12,
+
+	0x4A,0xAE,0x90,0x43,0x1F,0xE0,0xF9,0xF8,
+
+	0x12,0x4B,0x45,0x90,0x43,0x02,0x12,0x4B,
+
+	0x6C,0x22,0xC2,0xAF,0x90,0x41,0x03,0x74,
+
+	0x02,0xF0,0xA3,0x74,0x91,0xF0,0xA3,0x74,
+
+	0x2C,0xF0,0x90,0x41,0x0B,0x74,0x02,0xF0,
+
+	0xA3,0x74,0x91,0xF0,0xA3,0x74,0x34,0xF0,
+
+	0x90,0x41,0x13,0x74,0x02,0xF0,0xA3,0x74,
+
+	0x91,0xF0,0xA3,0x74,0x3C,0xF0,0x90,0x41,
+
+	0x1B,0x74,0x02,0xF0,0xA3,0x74,0x91,0xF0,
+
+	0xA3,0x74,0x44,0xF0,0x90,0x41,0x23,0x74,
+
+	0x02,0xF0,0xA3,0x74,0x91,0xF0,0xA3,0x74,
+
+	0x4C,0xF0,0x90,0x41,0x2B,0x74,0x02,0xF0,
+
+	0xA3,0x74,0x91,0xF0,0xA3,0x74,0x54,0xF0,
+
+	0x90,0x41,0x33,0x74,0x02,0xF0,0xA3,0x74,
+
+	0x91,0xF0,0xA3,0x74,0x5C,0xF0,0x90,0x41,
+
+	0x3B,0x74,0x02,0xF0,0xA3,0x74,0x91,0xF0,
+
+	0xA3,0x74,0x64,0xF0,0x90,0x41,0x43,0x74,
+
+	0x02,0xF0,0xA3,0x74,0x91,0xF0,0xA3,0x74,
+
+	0x6C,0xF0,0x90,0x41,0x4B,0x74,0x02,0xF0,
+
+	0xA3,0x74,0x91,0xF0,0xA3,0x74,0x74,0xF0,
+
+	0x90,0x41,0x53,0x74,0x02,0xF0,0xA3,0x74,
+
+	0x91,0xF0,0xA3,0x74,0x7C,0xF0,0x90,0x41,
+
+	0x5B,0x74,0x02,0xF0,0xA3,0x74,0x91,0xF0,
+
+	0xA3,0x74,0x84,0xF0,0x90,0x41,0x63,0x74,
+
+	0x02,0xF0,0xA3,0x74,0x91,0xF0,0xA3,0x74,
+
+	0x8C,0xF0,0x90,0xAF,0xA0,0x74,0x32,0xF0,
+
+	0xD2,0xAF,0x22,0x90,0xF5,0x76,0x74,0xFF,
+
+	0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,0x9E,
+
+	0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,0x31,
+
+	0xF0,0xA3,0x74,0x02,0xF0,0xA3,0x74,0xB0,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x7B,0xF0,
+
+	0xA3,0x74,0x01,0xF0,0xA3,0x74,0x25,0xF0,
+
+	0xA3,0x74,0x03,0xF0,0xA3,0x74,0xEC,0xF0,
+
+	0xA3,0x74,0x02,0xF0,0xA3,0x74,0xE1,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0xB0,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x74,0x3A,0xF0,0xA3,0x74,
+
+	0x03,0xF0,0xA3,0x74,0xA2,0xF0,0xA3,0x74,
+
+	0x03,0xF0,0xA3,0x74,0x97,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0x74,0x26,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0x74,0x9C,0xF0,0xA3,0x74,0x03,0xF0,
+
+	0xA3,0x74,0xF9,0xF0,0xA3,0x74,0x03,0xF0,
+
+	0xA3,0x74,0x37,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0xFC,0xF0,0xA3,0x74,0x03,0xF0,0xA3,
+
+	0x74,0xE8,0xF0,0xA3,0x74,0x03,0xF0,0x90,
+
+	0xF5,0x6C,0xE4,0xF0,0xA3,0x74,0x05,0xF0,
+
+	0x90,0xF9,0x00,0xE0,0x70,0x0A,0x90,0xF5,
+
+	0x9E,0x74,0x19,0xF0,0xA3,0xE4,0xF0,0x22,
+
+	0x90,0xF9,0x00,0xE0,0xB4,0x01,0x0A,0x90,
+
+	0xF5,0x9E,0x74,0x65,0xF0,0xA3,0xE4,0xF0,
+
+	0x22,0x90,0xF5,0x9E,0x74,0x65,0xF0,0xA3,
+
+	0xE4,0xF0,0x22,0xC0,0xE0,0x75,0xE0,0x00,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x02,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x04,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x06,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x08,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x0A,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x0C,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x0E,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x10,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x12,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x14,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x16,
+
+	0x02,0x91,0x94,0xC0,0xE0,0x75,0xE0,0x18,
+
+	0x02,0x91,0x94,0xC0,0xD0,0x75,0xD0,0x00,
+
+	0xC0,0x86,0x75,0x86,0x00,0xC0,0x83,0xC0,
+
+	0x82,0xC0,0x85,0xC0,0x84,0xC0,0xF0,0xC0,
+
+	0x00,0xC0,0x01,0xC0,0x02,0xC0,0x03,0xC0,
+
+	0x04,0xC0,0x05,0xC0,0x06,0xC0,0x07,0x90,
+
+	0xAF,0xE3,0xF9,0x93,0xFA,0xE9,0x04,0x93,
+
+	0xF9,0x12,0x4B,0xA9,0xD0,0x07,0xD0,0x06,
+
+	0xD0,0x05,0xD0,0x04,0xD0,0x03,0xD0,0x02,
+
+	0xD0,0x01,0xD0,0x00,0xD0,0xF0,0xD0,0x84,
+
+	0xD0,0x85,0xD0,0x82,0xD0,0x83,0xD0,0x86,
+
+	0xD0,0xD0,0xD0,0xE0,0x32,0x4E,0x42,0x79,
+
+	0x99,0x46,0x01,0xE9,0x50,0x06,0xC6,0xB3,
+
+	0xB0,0xB0,0xAE,0xA8,0x9E,0x74,0x4E,0x42,
+
+	0x87,0x02,0x02,0x02,0x01,0x01,0x01,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4E,
+
+	0x42,0x95,0x00,0x00,0x00,0x03,0x05,0x08,
+
+	0x0C,0x0F,0x10,0x10,0x10,0x0D,0x0B,0x05,
+
+	0x5C,0x42,0xA3,0x00,0x00,0x00,0x99,0x00,
+
+	0x00,0x00,0xE8,0x00,0x4B,0x00,0xFC,0x00,
+
+	0xAE,0x00,0x8B,0x00,0x79,0x00,0x70,0x00,
+
+	0x6C,0x00,0x6B,0x00,0x6B,0x00,0x14,0x5C,
+
+	0x42,0xBF,0x00,0x03,0x00,0x02,0x00,0x02,
+
+	0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x42,
+
+	0xDB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+	0x01,0x00,0x01,0x00,0x02,0x00,0x03,0x00,
+
+	0x03,0x00,0x04,0x00,0x05,0x00,0x05,0x00,
+
+	0x06,0x00,0x06,0x00,0x03,0x43,0x43,0xAB,
+
+	0x3A,0x44,0x40,0x48,0x43,0x28,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x43,
+
+	0x36,0x02,0x39,0x04,0xEE,0x08,0xFB,0x0E,
+
+	0xAA,0x10,0xD5,0x13,0x0D,0x14,0xC9,0x18,
+
+	0xFE,0x00,0x90,0xF5,0x76,0x74,0x20,0xF0,
+
+	0xA3,0x74,0x01,0xF0,0xA3,0x74,0x22,0xF0,
+
+	0xA3,0x74,0x02,0xF0,0xA3,0x74,0xFF,0xF0,
+
+	0xA3,0x74,0x01,0xF0,0xA3,0x74,0x7E,0xF0,
+
+	0xA3,0x74,0x02,0xF0,0xA3,0x74,0xA0,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0x74,0x51,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0xF0,0xA3,0x74,0x03,0xF0,
+
+	0xA3,0x74,0x40,0xF0,0xA3,0x74,0x01,0xF0,
+
+	0xA3,0x74,0xED,0xF0,0xA3,0x74,0x02,0xF0,
+
+	0xA3,0x74,0xA1,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0xDF,0xF0,0xA3,0x74,0x03,0xF0,0xA3,
+
+	0x74,0xC1,0xF0,0xA3,0x74,0x03,0xF0,0xA3,
+
+	0x74,0x68,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x9F,0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,
+
+	0x3E,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0xE8,
+
+	0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,0xFF,
+
+	0xF0,0xA3,0x74,0x03,0xF0,0xA3,0x74,0x0A,
+
+	0xF0,0xA3,0xE4,0xF0,0x90,0xF9,0x00,0xE0,
+
+	0x70,0x0A,0x90,0xF5,0x9E,0x74,0x3F,0xF0,
+
+	0xA3,0xE4,0xF0,0x22,0x90,0xF9,0x00,0xE0,
+
+	0xB4,0x01,0x0A,0x90,0xF5,0x9E,0x74,0xFB,
+
+	0xF0,0xA3,0xE4,0xF0,0x22,0x90,0xF5,0x9E,
+
+	0x74,0x7D,0xF0,0xA3,0xE4,0xF0,0x22,0x90,
+
+	0x41,0xD7,0xE0,0x64,0x22,0x70,0x34,0x90,
+
+	0x41,0xD4,0xE0,0x70,0x06,0x90,0x41,0xD5,
+
+	0xE0,0x60,0x28,0x90,0x43,0x9C,0xE0,0x60,
+
+	0x22,0x90,0x42,0x0B,0xE0,0xFF,0x90,0x42,
+
+	0x04,0xE0,0xB5,0x07,0x16,0x7F,0x12,0x12,
+
+	0xAD,0x3C,0x90,0xFB,0xA2,0xE0,0x90,0x42,
+
+	0x04,0xF0,0x90,0x43,0x8F,0x74,0x14,0xF0,
+
+	0x12,0xA8,0x1A,0x90,0x42,0x04,0xE0,0x90,
+
+	0x43,0xA6,0xF0,0x90,0x43,0x9C,0xE0,0xFF,
+
+	0x60,0x42,0x90,0x43,0xA9,0xE0,0x60,0x02,
+
+	0x14,0xF0,0xEF,0x30,0xE7,0x0B,0x12,0xAD,
+
+	0xE8,0x90,0x43,0x9C,0xE0,0x04,0xF0,0x80,
+
+	0x09,0x12,0xAC,0xFE,0x90,0x43,0x9C,0xE0,
+
+	0x14,0xF0,0x90,0x41,0xD5,0xE0,0x60,0x17,
+
+	0x90,0x43,0xA7,0xE0,0xB4,0x03,0x15,0x12,
+
+	0xA8,0x1A,0xE4,0x90,0x43,0xA7,0xF0,0x90,
+
+	0x43,0xA9,0x74,0x20,0xF0,0x80,0x05,0x12,
+
+	0xAF,0x28,0x80,0xB7,0x90,0x42,0x04,0xE0,
+
+	0xFF,0x90,0x42,0x3D,0xF0,0x90,0x42,0x53,
+
+	0xE0,0x60,0x18,0x90,0x42,0x0B,0xE0,0xFE,
+
+	0xEF,0xB5,0x06,0x0F,0x90,0x43,0x9D,0xE0,
+
+	0xD3,0x94,0x40,0x50,0x06,0x90,0x43,0x90,
+
+	0x74,0x01,0xF0,0x22,0x90,0xF5,0x76,0x74,
+
+	0x06,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0xC1,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0xFF,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0xB8,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0x0C,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0x36,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x79,
+
+	0xF0,0xA3,0x74,0x03,0xF0,0xA3,0xF0,0xA3,
+
+	0xF0,0xA3,0x74,0xE7,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0xA3,0x74,0x18,0xF0,0xA3,0x74,0x03,
+
+	0xF0,0xA3,0x74,0x74,0xF0,0xA3,0x74,0x03,
+
+	0xF0,0xA3,0x74,0xD6,0xF0,0xA3,0x74,0x03,
+
+	0xF0,0xA3,0x74,0x1E,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0x74,0x41,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0x43,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x30,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x18,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x07,0xF0,
+
+	0xA3,0xE4,0xF0,0x90,0xF9,0x00,0xE0,0x70,
+
+	0x0A,0x90,0xF5,0x9E,0x74,0x19,0xF0,0xA3,
+
+	0xE4,0xF0,0x22,0x90,0xF9,0x00,0xE0,0xB4,
+
+	0x01,0x0A,0x90,0xF5,0x9E,0x74,0x65,0xF0,
+
+	0xA3,0xE4,0xF0,0x22,0x90,0xF5,0x9E,0x74,
+
+	0x32,0xF0,0xA3,0xE4,0xF0,0x22,0x90,0xF5,
+
+	0x76,0x74,0x72,0xF0,0xA3,0x74,0x01,0xF0,
+
+	0xA3,0xF0,0xA3,0x04,0xF0,0xA3,0x74,0x5C,
+
+	0xF0,0xA3,0x74,0x01,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0xF0,0xA3,0x74,0xCD,0xF0,0xA3,0x74,
+
+	0x02,0xF0,0xA3,0x74,0x8E,0xF0,0xA3,0x74,
+
+	0x01,0xF0,0xA3,0x04,0xF0,0xA3,0x04,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0xF0,0xA3,0x74,0xC3,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0x74,0x16,0xF0,
+
+	0xA3,0x74,0x03,0xF0,0xA3,0x74,0x89,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,
+
+	0x74,0xA9,0xF0,0xA3,0x74,0x03,0xF0,0xA3,
+
+	0x74,0x5D,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0xD0,0xF0,0xA3,0x74,0x03,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0xF0,0xA3,0x74,0x15,0xF0,0xA3,
+
+	0xE4,0xF0,0xA3,0x74,0xEF,0xF0,0xA3,0x74,
+
+	0x03,0xF0,0x90,0xF5,0x6C,0x74,0x80,0xF0,
+
+	0xA3,0x74,0x06,0xF0,0x90,0xF9,0x00,0xE0,
+
+	0x70,0x0A,0x90,0xF5,0x9E,0x74,0x3F,0xF0,
+
+	0xA3,0xE4,0xF0,0x22,0x90,0xF9,0x00,0xE0,
+
+	0xB4,0x01,0x0A,0x90,0xF5,0x9E,0x74,0xFB,
+
+	0xF0,0xA3,0xE4,0xF0,0x22,0x90,0xF5,0x9E,
+
+	0x74,0x7D,0xF0,0xA3,0xE4,0xF0,0x22,0x90,
+
+	0xF1,0x10,0xE0,0x64,0x01,0x60,0x03,0x02,
+
+	0x96,0x09,0x90,0xF1,0x14,0xE0,0x64,0x01,
+
+	0x60,0x03,0x02,0x96,0x09,0xD3,0x90,0x43,
+
+	0xD2,0xE0,0x94,0x10,0x90,0x43,0xD1,0xE0,
+
+	0x94,0x35,0x40,0x0C,0xA3,0xE0,0x94,0x30,
+
+	0x90,0x43,0xD1,0xE0,0x94,0x38,0x40,0x1B,
+
+	0xD3,0x90,0x43,0xD4,0xE0,0x94,0x10,0x90,
+
+	0x43,0xD3,0xE0,0x94,0x35,0x40,0x61,0xA3,
+
+	0xE0,0x94,0x30,0x90,0x43,0xD3,0xE0,0x94,
+
+	0x38,0x50,0x55,0x90,0xF4,0xC1,0xE0,0x64,
+
+	0x01,0x70,0x25,0x90,0xF9,0x00,0xE0,0x70,
+
+	0x0C,0x90,0xF5,0x4B,0x74,0x05,0xF0,0x90,
+
+	0xF6,0x55,0x74,0x20,0xF0,0x90,0xF9,0x00,
+
+	0xE0,0xB4,0x01,0x0C,0x90,0xF5,0x4B,0x74,
+
+	0x04,0xF0,0x90,0xF6,0x55,0x74,0x10,0xF0,
+
+	0x90,0xF4,0xC1,0xE0,0x64,0x02,0x70,0x2C,
+
+	0x90,0xF9,0x00,0xE0,0x70,0x06,0x90,0xF5,
+
+	0x4B,0x74,0x09,0xF0,0x90,0xF9,0x00,0xE0,
+
+	0xB4,0x01,0x06,0x90,0xF5,0x4B,0x74,0x08,
+
+	0xF0,0x90,0xF6,0x55,0x74,0x20,0xF0,0x22,
+
+	0x90,0xF5,0x4B,0x74,0x14,0xF0,0x90,0xF6,
+
+	0x55,0x74,0x20,0xF0,0x22,0xC2,0xAD,0x90,
+
+	0x41,0xD7,0xE0,0xB4,0x22,0x0B,0x7F,0x14,
+
+	0x12,0xAD,0x3C,0x90,0x43,0xAF,0x74,0x01,
+
+	0xF0,0x12,0xA7,0xE7,0x90,0x42,0x53,0xE0,
+
+	0x60,0x05,0xE4,0x90,0x43,0x8D,0xF0,0x90,
+
+	0xF0,0x01,0x74,0x01,0xF0,0xE4,0x90,0x44,
+
+	0xD2,0xF0,0x90,0xF0,0x01,0xE0,0xB4,0x01,
+
+	0xF9,0x12,0x83,0x14,0x90,0x43,0x9C,0xE0,
+
+	0x60,0x20,0x12,0x93,0x50,0x7D,0x33,0x7C,
+
+	0x01,0xE4,0xFF,0x12,0xAB,0xED,0x90,0x44,
+
+	0xAA,0xE0,0x64,0x01,0x60,0xF8,0x90,0x44,
+
+	0xD2,0xE0,0x04,0xF0,0xE0,0xC3,0x94,0x30,
+
+	0x40,0xD0,0xE4,0x90,0x43,0x94,0xF0,0xA3,
+
+	0xF0,0x90,0x43,0x92,0xF0,0xA3,0xF0,0x90,
+
+	0x42,0x04,0xE0,0x90,0x43,0x9D,0xF0,0xD2,
+
+	0xAD,0x90,0x41,0xD7,0xE0,0xB4,0x22,0x10,
+
+	0x90,0x42,0x4B,0xE0,0x60,0x0A,0x7F,0x15,
+
+	0x12,0xAD,0x3C,0xE4,0x90,0x43,0xAF,0xF0,
+
+	0x90,0x42,0x53,0xE0,0x60,0x12,0x90,0x42,
+
+	0x04,0xE0,0x70,0x0C,0x90,0x42,0x40,0xE0,
+
+	0xD3,0x94,0xD0,0x40,0x03,0x12,0xAB,0x20,
+
+	0x22,0x90,0xF7,0x66,0xE0,0x90,0x44,0xC8,
+
+	0xF0,0xE0,0xFF,0x90,0x42,0x43,0xF0,0x90,
+
+	0xF7,0x68,0xE0,0x90,0x44,0xA0,0xF0,0x90,
+
+	0xF5,0xA9,0xE0,0x70,0x09,0xEF,0x60,0x06,
+
+	0x90,0x44,0x9A,0xE0,0x60,0x04,0x7F,0x01,
+
+	0x80,0x02,0x7F,0x00,0x90,0x44,0x9A,0xEF,
+
+	0xF0,0x70,0x03,0x12,0xA4,0x44,0x90,0xF5,
+
+	0xA9,0xE0,0x70,0x2A,0x90,0xF7,0x63,0xE0,
+
+	0x90,0x42,0x2B,0xF0,0x90,0xF7,0x64,0xE0,
+
+	0x90,0x41,0xE4,0xF0,0x90,0xF7,0x65,0xE0,
+
+	0x90,0x44,0x9F,0xF0,0x12,0x9A,0xAE,0x90,
+
+	0x44,0xC8,0xE0,0x90,0x41,0xCD,0xF0,0xE4,
+
+	0x90,0x42,0x42,0xF0,0x80,0x0A,0x90,0x41,
+
+	0xCD,0x74,0x01,0xF0,0x90,0x42,0x42,0xF0,
+
+	0x12,0xA7,0x80,0xE4,0x90,0x44,0xC9,0xF0,
+
+	0x7F,0x00,0x7E,0x28,0x12,0xAF,0x5E,0x20,
+
+	0x8C,0xFD,0x90,0x44,0xC9,0xE0,0x04,0xF0,
+
+	0xE0,0xC3,0x94,0x05,0x40,0xEA,0x12,0xAD,
+
+	0xCE,0x90,0xF7,0x69,0xE0,0x70,0xFA,0x90,
+
+	0xF7,0x6B,0x74,0x01,0xF0,0xE4,0xF0,0x22,
+
+	0x90,0xF5,0xCC,0xE4,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0x90,0xF5,0xD4,0xE0,0x90,0x43,0x09,
+
+	0xF0,0x90,0xF5,0xCB,0xE0,0xB4,0x01,0xF9,
+
+	0x12,0xAD,0x5A,0x90,0xFD,0x33,0xE4,0xF0,
+
+	0x04,0xF0,0x90,0xFD,0x36,0xE0,0xB4,0x01,
+
+	0xF9,0x12,0xA6,0x99,0x90,0x43,0x06,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x43,0x0A,0xE0,0xF8,0xA3,
+
+	0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,
+
+	0xC3,0x12,0x4B,0x21,0x50,0x06,0x90,0x43,
+
+	0x33,0xE0,0x04,0xF0,0x90,0x43,0x06,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x78,0x02,0x12,0x4B,0x45,0x90,
+
+	0x43,0x06,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,
+
+	0xE0,0xFA,0xA3,0xE0,0x2F,0xFF,0xEA,0x3E,
+
+	0xFE,0xE9,0x3D,0xFD,0xE8,0x3C,0xFC,0x90,
+
+	0x43,0x0A,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,
+
+	0xE0,0xFA,0xA3,0xE0,0xFB,0xD3,0x12,0x4B,
+
+	0x21,0x40,0x06,0x90,0x43,0x32,0xE0,0x04,
+
+	0xF0,0x22,0x90,0x41,0xD2,0xE0,0x70,0x1D,
+
+	0x90,0xF9,0x57,0xE0,0x54,0xFD,0x44,0x02,
+
+	0xF0,0x90,0x41,0xD2,0x74,0x01,0xF0,0xE4,
+
+	0x90,0x43,0xB8,0xF0,0x90,0x43,0xB6,0xF0,
+
+	0xA3,0xF0,0xF5,0x13,0x22,0x90,0x43,0xB7,
+
+	0xE0,0x60,0x68,0x90,0x43,0xBB,0xE0,0xB4,
+
+	0x01,0x0C,0xE5,0x13,0x90,0xAF,0xA7,0x93,
+
+	0xF5,0x13,0xE4,0xF5,0x14,0x22,0xE5,0x13,
+
+	0x70,0x05,0xF5,0x13,0xF5,0x14,0x22,0xE5,
+
+	0x13,0x90,0xAF,0xD9,0x93,0xB5,0x14,0x1C,
+
+	0x90,0x43,0xCE,0xE0,0xB5,0x13,0x05,0x75,
+
+	0x13,0x01,0x80,0x0C,0x90,0x43,0xCE,0xE5,
+
+	0x13,0xF0,0x90,0xAF,0xBB,0x93,0xF5,0x13,
+
+	0xE4,0xF5,0x14,0x22,0xE5,0x13,0x90,0xAF,
+
+	0xB1,0x93,0xFF,0xB5,0x13,0x03,0x05,0x14,
+
+	0x22,0x90,0x43,0xCF,0xE0,0xB5,0x13,0x08,
+
+	0x90,0xAF,0xBB,0x93,0xF5,0x13,0x80,0x08,
+
+	0x90,0x43,0xCF,0xE5,0x13,0xF0,0x8F,0x13,
+
+	0xE4,0xF5,0x14,0x22,0xE4,0xFB,0xEB,0x25,
+
+	0xE0,0x24,0x36,0xF5,0x82,0xE4,0x34,0x43,
+
+	0xF5,0x83,0xE0,0xFF,0xA3,0xE0,0x90,0x43,
+
+	0x23,0xCF,0xF0,0xA3,0xEF,0xF0,0x12,0xA5,
+
+	0xDA,0x90,0xF5,0xD0,0xE0,0xFF,0xC4,0x13,
+
+	0x54,0x07,0xFF,0x90,0xF5,0xD3,0xE0,0xFE,
+
+	0xC4,0x13,0x54,0x07,0x6F,0x60,0x0D,0x74,
+
+	0x28,0x2B,0xF5,0x82,0xE4,0x34,0x43,0xF5,
+
+	0x83,0xE0,0x04,0xF0,0x0B,0xEB,0xB4,0x08,
+
+	0xBD,0x90,0x43,0x26,0xE0,0x04,0xF0,0xE0,
+
+	0xC3,0x94,0x13,0x40,0x3D,0xE4,0xFF,0xFB,
+
+	0x74,0x28,0x2B,0xF5,0x82,0xE4,0x34,0x43,
+
+	0xF5,0x83,0xE0,0xFE,0xD3,0x94,0x0E,0x50,
+
+	0x06,0xEE,0xC3,0x94,0x05,0x50,0x01,0x0F,
+
+	0x74,0x28,0x2B,0xF5,0x82,0xE4,0x34,0x43,
+
+	0xF5,0x83,0xE4,0xF0,0x0B,0xEB,0xB4,0x08,
+
+	0xD7,0xEF,0xD3,0x94,0x06,0x40,0x06,0x90,
+
+	0x42,0x38,0x74,0x01,0xF0,0xE4,0x90,0x43,
+
+	0x26,0xF0,0x22,0x78,0x7F,0xE4,0xF6,0xD8,
+
+	0xFD,0x75,0x81,0x14,0x02,0x99,0x5B,0x02,
+
+	0x85,0xD1,0xE4,0x93,0xA3,0xF8,0xE4,0x93,
+
+	0xA3,0x40,0x03,0xF6,0x80,0x01,0xF2,0x08,
+
+	0xDF,0xF4,0x80,0x29,0xE4,0x93,0xA3,0xF8,
+
+	0x54,0x07,0x24,0x0C,0xC8,0xC3,0x33,0xC4,
+
+	0x54,0x0F,0x44,0x20,0xC8,0x83,0x40,0x04,
+
+	0xF4,0x56,0x80,0x01,0x46,0xF6,0xDF,0xE4,
+
+	0x80,0x0B,0x01,0x02,0x04,0x08,0x10,0x20,
+
+	0x40,0x80,0x90,0x91,0xE6,0xE4,0x7E,0x01,
+
+	0x93,0x60,0xBC,0xA3,0xFF,0x54,0x3F,0x30,
+
+	0xE5,0x09,0x54,0x1F,0xFE,0xE4,0x93,0xA3,
+
+	0x60,0x01,0x0E,0xCF,0x54,0xC0,0x25,0xE0,
+
+	0x60,0xA8,0x40,0xB8,0xE4,0x93,0xA3,0xFA,
+
+	0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0xC8,
+
+	0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xF0,
+
+	0xA3,0xC8,0xC5,0x82,0xC8,0xCA,0xC5,0x83,
+
+	0xCA,0xDF,0xE9,0xDE,0xE7,0x80,0xBE,0x90,
+
+	0xF1,0x14,0xE0,0xFF,0x90,0x43,0xD6,0xE0,
+
+	0x6F,0x60,0x04,0x7F,0x01,0x80,0x02,0x7F,
+
+	0x00,0x90,0xF1,0x10,0xE0,0xFE,0x90,0x43,
+
+	0xD5,0xE0,0x6E,0x60,0x04,0x7E,0x01,0x80,
+
+	0x02,0x7E,0x00,0xEE,0x4F,0xFF,0x90,0x42,
+
+	0x2A,0xE0,0x64,0x01,0x70,0x3C,0x90,0xF5,
+
+	0x41,0xE0,0x60,0x03,0xEF,0x60,0x40,0x90,
+
+	0xF5,0x41,0xE4,0xF0,0x04,0xF0,0x90,0xF5,
+
+	0x4C,0xE0,0xB4,0x01,0xF9,0x90,0xF6,0x5D,
+
+	0x74,0x01,0xF0,0x90,0xF1,0x10,0xE0,0x70,
+
+	0x06,0x90,0xF1,0x14,0xE0,0x60,0x20,0x90,
+
+	0xF4,0xC1,0xE0,0x70,0x1A,0x90,0xF4,0xC4,
+
+	0xE0,0x70,0x14,0x90,0xF6,0x5C,0x04,0xF0,
+
+	0x80,0x0D,0x90,0xF5,0x41,0xE4,0xF0,0x90,
+
+	0xF6,0x5D,0xF0,0x90,0xF6,0x5C,0xF0,0x90,
+
+	0xF1,0x10,0xE0,0x90,0x43,0xD5,0xF0,0x90,
+
+	0xF1,0x14,0xE0,0x90,0x43,0xD6,0xF0,0x22,
+
+	0x90,0x44,0x85,0xEE,0xF0,0xA3,0xEF,0xF0,
+
+	0xA3,0xED,0xF0,0xE4,0xA3,0xF0,0xA3,0xF0,
+
+	0xA3,0xF0,0x90,0xF4,0x1D,0xE0,0x90,0x44,
+
+	0x8B,0xF0,0x90,0x42,0x64,0xE0,0xFC,0xA3,
+
+	0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+
+	0x90,0x44,0x88,0xE0,0xF8,0xA3,0xE0,0xF9,
+
+	0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0xC3,0x12,
+
+	0x4B,0x0B,0x40,0x48,0x90,0x44,0x88,0xE0,
+
+	0xFC,0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0x90,0x42,0x64,0x12,0x4B,0x6C,
+
+	0x90,0x44,0x85,0xE0,0xFF,0xA3,0xE0,0x90,
+
+	0x42,0x6C,0xCF,0xF0,0xA3,0xEF,0xF0,0x90,
+
+	0x44,0x87,0xE0,0x70,0x10,0x90,0x42,0x66,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x42,0x68,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0x22,0x90,0x42,0x66,
+
+	0xE0,0xFF,0xA3,0xE0,0x90,0x42,0x6A,0xCF,
+
+	0xF0,0xA3,0xEF,0xF0,0x22,0x90,0xF9,0x05,
+
+	0xE0,0x60,0x0A,0x90,0xF4,0xC4,0xE0,0x90,
+
+	0x44,0x74,0xF0,0x80,0x08,0x90,0xF4,0xC5,
+
+	0xE0,0x90,0x44,0x74,0xF0,0x90,0x44,0x74,
+
+	0xE0,0x14,0x60,0x20,0x14,0x60,0x2F,0x14,
+
+	0x60,0x3D,0x14,0x60,0x4B,0x24,0x04,0x70,
+
+	0x57,0x90,0xF7,0x7F,0x74,0xE0,0xF0,0xA3,
+
+	0x74,0x01,0xF0,0xA3,0x74,0xBB,0xF0,0xA3,
+
+	0x74,0x01,0xF0,0x22,0x90,0xF7,0x7F,0x74,
+
+	0x40,0xF0,0xA3,0x74,0x01,0xF0,0xA3,0x74,
+
+	0x55,0xF0,0xA3,0xE4,0xF0,0x22,0x90,0xF7,
+
+	0x7F,0x74,0xFA,0xF0,0xA3,0xE4,0xF0,0xA3,
+
+	0x74,0x30,0xF0,0xA3,0xE4,0xF0,0x22,0x90,
+
+	0xF7,0x7F,0x74,0xF5,0xF0,0xA3,0xE4,0xF0,
+
+	0xA3,0x74,0x15,0xF0,0xA3,0xE4,0xF0,0x22,
+
+	0x90,0xF7,0x7F,0x74,0xA0,0xF0,0xA3,0xE4,
+
+	0xF0,0xA3,0x74,0x15,0xF0,0xA3,0xE4,0xF0,
+
+	0x22,0xE4,0xFD,0x90,0xF5,0xF7,0xE0,0xFE,
+
+	0x90,0xF5,0xF6,0xE0,0x7A,0x00,0x24,0x00,
+
+	0xFF,0xEA,0x3E,0x90,0x43,0x4E,0xF0,0xA3,
+
+	0xEF,0xF0,0x90,0x43,0x4E,0xE0,0xFE,0xA3,
+
+	0xE0,0xFF,0xC3,0x94,0x40,0xEE,0x94,0x08,
+
+	0x40,0x0A,0xD3,0xEF,0x94,0x60,0xEE,0x94,
+
+	0x08,0x50,0x01,0x0D,0x90,0x41,0xEF,0xE0,
+
+	0x64,0x02,0x70,0x45,0xED,0x64,0x01,0x70,
+
+	0x40,0x90,0xF9,0x04,0xE0,0x64,0x01,0x70,
+
+	0x38,0x90,0xF9,0x01,0xE0,0x64,0x03,0x70,
+
+	0x30,0x90,0xF9,0x00,0xE0,0x64,0x01,0x70,
+
+	0x28,0x90,0xF9,0x03,0xE0,0x64,0x02,0x70,
+
+	0x20,0x90,0x43,0x65,0xE0,0xFF,0x70,0x0B,
+
+	0x90,0xF5,0x6C,0x74,0xE5,0xF0,0xA3,0x74,
+
+	0x01,0xF0,0x22,0xEF,0xB4,0x01,0x0A,0x90,
+
+	0xF5,0x6C,0x74,0x1B,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0x22,0x90,0x41,0xD6,0xE0,0xB4,0x01,
+
+	0x0B,0x90,0xF0,0x7F,0x74,0x01,0xF0,0xA3,
+
+	0xE4,0xF0,0x80,0x08,0x90,0xF0,0x7F,0xE4,
+
+	0xF0,0xA3,0x04,0xF0,0x90,0x43,0x4B,0x74,
+
+	0x01,0xF0,0xE4,0x90,0x41,0xD1,0xF0,0x90,
+
+	0xF7,0x3C,0xE0,0x60,0x09,0xE4,0x90,0x41,
+
+	0xCE,0xF0,0x90,0x41,0xCD,0xF0,0xE4,0x90,
+
+	0x43,0x47,0xF0,0xA3,0xF0,0x90,0x43,0x49,
+
+	0xF0,0xA3,0xF0,0x90,0x44,0x3B,0x04,0xF0,
+
+	0x12,0x64,0xA5,0x90,0x41,0xE6,0xE0,0x70,
+
+	0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,0x90,
+
+	0x42,0x5F,0xEF,0xF0,0x12,0xAA,0x3A,0x12,
+
+	0xAF,0x90,0x90,0x43,0xD0,0x74,0x01,0xF0,
+
+	0xE4,0x90,0x43,0xBE,0xF0,0x90,0xF7,0x31,
+
+	0xE0,0xB4,0x01,0x03,0x12,0xAC,0x7D,0xE4,
+
+	0x90,0x43,0xBC,0xF0,0x90,0x43,0xBB,0x04,
+
+	0xF0,0x22,0x7F,0xD4,0x7E,0x27,0x12,0xAF,
+
+	0x5E,0x20,0x8C,0xFD,0x90,0xF1,0x48,0x74,
+
+	0x01,0xF0,0x90,0xF0,0x92,0xE4,0xF0,0x90,
+
+	0xF0,0x91,0x04,0xF0,0x90,0xF0,0x94,0xF0,
+
+	0x90,0xF0,0x81,0xF0,0x90,0xF0,0x91,0xE4,
+
+	0xF0,0xA3,0x04,0xF0,0x90,0xF0,0x94,0xE0,
+
+	0xB4,0x01,0xF9,0x90,0xF1,0xFB,0xE4,0xF0,
+
+	0x90,0xF1,0xFA,0x04,0xF0,0x90,0xF1,0xFD,
+
+	0xF0,0x90,0xF1,0xFC,0xF0,0x90,0xF1,0xFA,
+
+	0xE4,0xF0,0xA3,0x04,0xF0,0x90,0xF1,0xFD,
+
+	0xE0,0xB4,0x01,0xF9,0x90,0xF1,0xF7,0xE4,
+
+	0xF0,0x90,0xF1,0xF6,0x04,0xF0,0x90,0xF1,
+
+	0xF9,0xF0,0x90,0xF1,0xF8,0x04,0xF0,0x90,
+
+	0xF2,0x14,0x14,0xF0,0x90,0xF1,0xF6,0xE4,
+
+	0xF0,0xA3,0x04,0xF0,0x90,0xF1,0xF9,0xE0,
+
+	0xB4,0x01,0xF9,0x90,0x43,0xBB,0x74,0x01,
+
+	0xF0,0x22,0x90,0xF1,0xEA,0xE4,0xF0,0x90,
+
+	0xF1,0xEF,0xF0,0x90,0xF1,0xF2,0xF0,0x90,
+
+	0xF0,0x7C,0xF0,0x90,0xF1,0xFB,0xF0,0x90,
+
+	0xF1,0xF7,0xF0,0x90,0xF1,0xE8,0x04,0xF0,
+
+	0x90,0xF1,0xEB,0xF0,0x90,0xF1,0xF0,0xF0,
+
+	0x90,0xF1,0xF3,0xF0,0x90,0xF0,0x7D,0xF0,
+
+	0x90,0xF1,0xFA,0xF0,0x90,0xF1,0xF6,0xF0,
+
+	0x90,0xF1,0xF8,0xE4,0xF0,0x90,0xF1,0xFC,
+
+	0x74,0x03,0xF0,0x90,0xF1,0xE8,0xE4,0xF0,
+
+	0x90,0xF1,0xEB,0xF0,0x90,0xF1,0xF0,0xF0,
+
+	0x90,0xF1,0xF3,0xF0,0x90,0xF0,0x7D,0xF0,
+
+	0x90,0xF1,0xFA,0xF0,0x90,0xF1,0xF6,0xF0,
+
+	0x90,0xF1,0xEA,0x04,0xF0,0x90,0xF1,0xEF,
+
+	0xF0,0x90,0xF1,0xF2,0xF0,0x90,0xF0,0x7C,
+
+	0xF0,0x90,0xF1,0xF7,0xF0,0x90,0xF1,0xFB,
+
+	0xF0,0x90,0xF5,0xC2,0xF0,0xE4,0xF0,0x22,
+
+	0xEF,0xB4,0x02,0x1B,0x90,0x43,0xD7,0x74,
+
+	0x0B,0xF0,0xA3,0x74,0xB3,0xF0,0xA3,0x74,
+
+	0x0A,0xF0,0xA3,0x74,0x73,0xF0,0xA3,0x74,
+
+	0x33,0xF0,0xA3,0x74,0xE5,0xF0,0x22,0xEF,
+
+	0xB4,0x04,0x1B,0x90,0x43,0xD7,0x74,0x0B,
+
+	0xF0,0xA3,0x74,0xE3,0xF0,0xA3,0x74,0x0A,
+
+	0xF0,0xA3,0x74,0x9D,0xF0,0xA3,0x74,0x33,
+
+	0xF0,0xA3,0x74,0xB3,0xF0,0x22,0xEF,0xB4,
+
+	0x05,0x1B,0x90,0x43,0xD7,0x74,0x0B,0xF0,
+
+	0xA3,0x74,0xA3,0xF0,0xA3,0x74,0x0A,0xF0,
+
+	0xA3,0x74,0x65,0xF0,0xA3,0x74,0x33,0xF0,
+
+	0xA3,0x74,0xF4,0xF0,0x22,0xEF,0xB4,0x0B,
+
+	0x1A,0x90,0x43,0xD7,0x74,0x0B,0xF0,0xA3,
+
+	0x74,0xD5,0xF0,0xA3,0x74,0x0A,0xF0,0xA3,
+
+	0x74,0x91,0xF0,0xA3,0x74,0x33,0xF0,0xA3,
+
+	0x74,0xC1,0xF0,0x22,0x90,0xF1,0x61,0xE0,
+
+	0xFE,0x90,0xF1,0x60,0xE0,0x7C,0x00,0x24,
+
+	0x00,0xFF,0xEC,0x3E,0x90,0x44,0xC6,0xF0,
+
+	0xA3,0xEF,0xF0,0x90,0x42,0x52,0xE0,0x60,
+
+	0x5A,0xE4,0x90,0x43,0x9E,0xF0,0xA3,0xF0,
+
+	0x90,0xF2,0x10,0xE0,0x90,0x43,0xA0,0xF0,
+
+	0x90,0xF2,0x0F,0xE0,0x90,0x43,0xA1,0xF0,
+
+	0x90,0x42,0x40,0xE0,0xFF,0xE4,0xFC,0xFD,
+
+	0xFE,0x90,0x43,0x9E,0xE0,0xF8,0xA3,0xE0,
+
+	0xF9,0xA3,0xE0,0xFA,0xA3,0xE0,0xFB,0x12,
+
+	0x4A,0xAE,0x90,0x43,0x9E,0x12,0x4B,0x6C,
+
+	0x90,0x43,0x9E,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0xF2,
+
+	0x11,0xE0,0xF9,0xF8,0x12,0x4B,0x32,0x90,
+
+	0x43,0xA3,0xE0,0x2F,0xF0,0x90,0x43,0xA2,
+
+	0xE0,0x3E,0xF0,0x22,0x90,0xF5,0x6C,0x74,
+
+	0x40,0xF0,0xA3,0x74,0x07,0xF0,0x90,0xF9,
+
+	0x00,0xE0,0x70,0x16,0x90,0xF5,0x6A,0xF0,
+
+	0xA3,0x74,0x05,0xF0,0x90,0xF5,0x70,0x74,
+
+	0x03,0xF0,0x90,0xF5,0x6F,0x74,0x01,0xF0,
+
+	0x80,0x32,0x90,0xF9,0x00,0xE0,0xB4,0x01,
+
+	0x16,0x90,0xF5,0x6A,0xE4,0xF0,0xA3,0x74,
+
+	0x04,0xF0,0x90,0xF5,0x70,0x04,0xF0,0x90,
+
+	0xF5,0x6F,0x74,0x03,0xF0,0x80,0x15,0x90,
+
+	0xF5,0x6A,0xE4,0xF0,0xA3,0x74,0x0A,0xF0,
+
+	0x90,0xF5,0x70,0x74,0x04,0xF0,0x90,0xF5,
+
+	0x6F,0x74,0x02,0xF0,0x90,0xFD,0x27,0x74,
+
+	0x03,0xF0,0x90,0xFD,0x31,0x74,0x40,0xF0,
+
+	0xA3,0xE4,0xF0,0x22,0x90,0xF5,0x6C,0x74,
+
+	0x80,0xF0,0xA3,0x74,0x06,0xF0,0x90,0xF9,
+
+	0x00,0xE0,0x70,0x16,0x90,0xF5,0x6A,0xF0,
+
+	0xA3,0x74,0x0A,0xF0,0x90,0xF5,0x70,0x74,
+
+	0x04,0xF0,0x90,0xF5,0x6F,0x74,0x02,0xF0,
+
+	0x80,0x32,0x90,0xF9,0x00,0xE0,0xB4,0x01,
+
+	0x17,0x90,0xF5,0x6A,0xE4,0xF0,0xA3,0x74,
+
+	0x08,0xF0,0x90,0xF5,0x70,0x74,0x06,0xF0,
+
+	0x90,0xF5,0x6F,0x74,0x04,0xF0,0x80,0x14,
+
+	0x90,0xF5,0x6A,0xE4,0xF0,0xA3,0x74,0x04,
+
+	0xF0,0x90,0xF5,0x70,0x04,0xF0,0x90,0xF5,
+
+	0x6F,0x74,0x03,0xF0,0x90,0xFD,0x27,0x74,
+
+	0x04,0xF0,0x90,0xFD,0x31,0x74,0x80,0xF0,
+
+	0xA3,0xE4,0xF0,0x22,0x90,0x42,0x36,0xE0,
+
+	0x64,0x01,0x70,0x5D,0x90,0x42,0x3C,0xE0,
+
+	0x70,0x04,0x90,0x42,0xF8,0xF0,0x90,0x42,
+
+	0x3D,0xE0,0x64,0x01,0x70,0x30,0x90,0x42,
+
+	0xF8,0xE0,0x64,0x01,0x70,0x28,0x90,0xFD,
+
+	0xA5,0x04,0xF0,0x90,0xF9,0x00,0xE0,0x60,
+
+	0x05,0x90,0xF9,0x00,0xE0,0xFF,0x12,0x98,
+
+	0x85,0x90,0x42,0x38,0xE0,0xB4,0x01,0x29,
+
+	0xE4,0x90,0x42,0xF8,0xF0,0x12,0xAE,0xFD,
+
+	0xE4,0x90,0x42,0x38,0xF0,0x22,0x90,0xFD,
+
+	0xA5,0xE4,0xF0,0x90,0x42,0xF8,0xE0,0xB4,
+
+	0x01,0x0C,0x12,0xAE,0xFD,0xE4,0x90,0x42,
+
+	0x38,0xF0,0x90,0x42,0xF8,0xF0,0x12,0x57,
+
+	0x52,0x22,0x90,0x42,0x4A,0xE0,0x60,0x06,
+
+	0x90,0xFB,0x2A,0x74,0x71,0xF0,0x90,0xFB,
+
+	0x97,0xE4,0xF0,0x7F,0x11,0x12,0xAD,0x3C,
+
+	0xE4,0x90,0x44,0xD6,0xF0,0x74,0xFF,0xFB,
+
+	0xFA,0xE4,0xFD,0x7F,0x01,0x12,0xAC,0x13,
+
+	0x90,0x44,0xD6,0xE0,0x04,0xF0,0xE0,0xC3,
+
+	0x94,0x02,0x40,0xE9,0x90,0xFB,0x08,0xE0,
+
+	0xFE,0x90,0xFB,0x07,0xE0,0x7C,0x00,0x24,
+
+	0x00,0xFF,0xEC,0x3E,0x90,0x44,0x50,0xF0,
+
+	0xA3,0xEF,0xF0,0xE0,0x90,0x41,0xFC,0xF0,
+
+	0x90,0xFB,0x97,0x74,0x01,0xF0,0x7F,0x11,
+
+	0x12,0xAD,0x3C,0x90,0x42,0x4A,0xE0,0x60,
+
+	0x06,0x90,0xFB,0x2A,0x74,0x75,0xF0,0x22,
+
+	0xE5,0x13,0x14,0xB4,0x08,0x00,0x50,0x5D,
+
+	0x90,0x9F,0xD7,0x75,0xF0,0x03,0xA4,0xC5,
+
+	0x83,0x25,0xF0,0xC5,0x83,0x73,0x02,0x9F,
+
+	0xEF,0x02,0x9F,0xF6,0x02,0x9F,0xFD,0x02,
+
+	0xA0,0x04,0x02,0xA0,0x0B,0x02,0xA0,0x12,
+
+	0x02,0xA0,0x19,0x02,0xA0,0x20,0x90,0xF2,
+
+	0x1B,0x74,0x01,0xF0,0x22,0x90,0xF2,0x1B,
+
+	0x74,0x02,0xF0,0x22,0x90,0xF2,0x1B,0x74,
+
+	0x03,0xF0,0x22,0x90,0xF2,0x1B,0x74,0x04,
+
+	0xF0,0x22,0x90,0xF2,0x1B,0x74,0x05,0xF0,
+
+	0x22,0x90,0xF2,0x1B,0x74,0x06,0xF0,0x22,
+
+	0x90,0xF2,0x1B,0x74,0x07,0xF0,0x22,0x90,
+
+	0xF2,0x1B,0x74,0x08,0xF0,0x22,0x90,0xF5,
+
+	0x6C,0xE4,0xF0,0xA3,0x74,0x05,0xF0,0x90,
+
+	0xF9,0x00,0xE0,0x70,0x15,0x90,0xF5,0x6A,
+
+	0xF0,0xA3,0x74,0x04,0xF0,0x90,0xF5,0x70,
+
+	0x04,0xF0,0x90,0xF5,0x6F,0x74,0x03,0xF0,
+
+	0x80,0x31,0x90,0xF9,0x00,0xE0,0xB4,0x01,
+
+	0x15,0x90,0xF5,0x6A,0xE4,0xF0,0xA3,0xF0,
+
+	0x90,0xF5,0x70,0x74,0x07,0xF0,0x90,0xF5,
+
+	0x6F,0x74,0x05,0xF0,0x80,0x15,0x90,0xF5,
+
+	0x6A,0xE4,0xF0,0xA3,0x74,0x08,0xF0,0x90,
+
+	0xF5,0x70,0x74,0x06,0xF0,0x90,0xF5,0x6F,
+
+	0x74,0x04,0xF0,0x90,0xFD,0x27,0x74,0x07,
+
+	0xF0,0x90,0xFD,0x31,0xE4,0xF0,0xA3,0x04,
+
+	0xF0,0x22,0x90,0xF5,0x6C,0xE4,0xF0,0xA3,
+
+	0x74,0x02,0xF0,0x90,0xF9,0x00,0xE0,0x70,
+
+	0x16,0x90,0xF5,0x6A,0xF0,0xA3,0x74,0x08,
+
+	0xF0,0x90,0xF5,0x70,0x74,0x04,0xF0,0x90,
+
+	0xF5,0x6F,0x74,0x02,0xF0,0x80,0x2F,0x90,
+
+	0xF9,0x00,0xE0,0xB4,0x01,0x15,0x90,0xF5,
+
+	0x6A,0xE4,0xF0,0xA3,0xF0,0x90,0xF5,0x70,
+
+	0x74,0x06,0xF0,0x90,0xF5,0x6F,0x74,0x04,
+
+	0xF0,0x80,0x13,0x90,0xF5,0x6A,0xE4,0xF0,
+
+	0xA3,0xF0,0x90,0xF5,0x70,0x74,0x05,0xF0,
+
+	0x90,0xF5,0x6F,0x74,0x03,0xF0,0x90,0xFD,
+
+	0x27,0x74,0x07,0xF0,0x90,0xFD,0x31,0xE4,
+
+	0xF0,0xA3,0x74,0x02,0xF0,0x22,0x90,0xF4,
+
+	0x1A,0x74,0x0D,0xF0,0x90,0xF4,0x10,0x74,
+
+	0x08,0xF0,0x90,0xF4,0x18,0xF0,0x90,0xF5,
+
+	0x61,0x74,0x06,0xF0,0xE4,0x90,0x44,0xCD,
+
+	0xF0,0x90,0x42,0x59,0xF0,0x90,0x42,0x5B,
+
+	0xF0,0x90,0x42,0x5C,0xF0,0x90,0x42,0x5E,
+
+	0xF0,0x90,0x42,0x5A,0xF0,0x90,0x42,0x5D,
+
+	0xF0,0x90,0x42,0x57,0x04,0xF0,0x90,0xF5,
+
+	0xBD,0xF0,0x90,0xF5,0xBB,0xF0,0x90,0xF5,
+
+	0xBD,0xE4,0xF0,0x90,0xF5,0xBF,0x04,0xF0,
+
+	0x90,0x42,0x58,0xF0,0x90,0xF5,0xB3,0xF0,
+
+	0x90,0xF5,0xB1,0xF0,0x90,0xF5,0xB3,0xE4,
+
+	0xF0,0x90,0xF5,0xB2,0x04,0xF0,0xD2,0xE9,
+
+	0x22,0xD0,0xE0,0xF5,0xF0,0xFC,0xD0,0xE0,
+
+	0xFD,0x12,0x4C,0x61,0x85,0x0F,0xF0,0xE5,
+
+	0x81,0x90,0x00,0x02,0x12,0x4C,0x80,0x85,
+
+	0x0E,0xF0,0xE5,0x0D,0x90,0x00,0x04,0x12,
+
+	0x4C,0x80,0xE5,0x10,0x90,0x00,0x06,0x12,
+
+	0x4B,0xDC,0x8D,0x82,0x8C,0x83,0xE4,0xFE,
+
+	0xFF,0x73,0xED,0xFF,0xEC,0xFE,0x12,0x4B,
+
+	0xFE,0xFC,0xAD,0xF0,0x90,0x00,0x02,0x12,
+
+	0x4C,0x29,0x85,0xF0,0x81,0xF5,0x0F,0x90,
+
+	0x00,0x04,0x12,0x4C,0x29,0xF5,0x0E,0x85,
+
+	0xF0,0x0D,0x90,0x00,0x06,0x12,0x4B,0xAF,
+
+	0xF5,0x10,0x8D,0x82,0x8C,0x83,0xE4,0x73,
+
+	0x12,0xAB,0xC7,0xE4,0x90,0x41,0xD8,0xF0,
+
+	0x90,0x41,0xE7,0xE0,0x90,0xF0,0x76,0xF0,
+
+	0x90,0x43,0xB6,0x74,0x01,0xF0,0x90,0x43,
+
+	0xBB,0xF0,0x90,0x43,0xB7,0xF0,0xE4,0x90,
+
+	0x43,0xBA,0xF0,0xF5,0x13,0x90,0x41,0xDD,
+
+	0xE0,0xB4,0x01,0x14,0x90,0x44,0x71,0x74,
+
+	0x01,0xF0,0x12,0x9B,0xB3,0x12,0xAF,0x51,
+
+	0x90,0xFB,0xA8,0x74,0x01,0xF0,0x80,0x16,
+
+	0x90,0xFB,0xA8,0xE4,0xF0,0x12,0xAF,0x1A,
+
+	0xE4,0x90,0x44,0x71,0xF0,0x90,0x42,0x47,
+
+	0xE0,0x60,0x03,0x12,0x9F,0x5B,0xE4,0x90,
+
+	0x41,0xDD,0xF0,0x22,0x90,0x41,0xD5,0xE0,
+
+	0x60,0x07,0x90,0xF0,0x2B,0xE4,0xF0,0x80,
+
+	0x39,0x90,0x42,0x01,0xE0,0xF9,0x90,0x42,
+
+	0x02,0xE0,0x89,0xF0,0xA4,0xFF,0x90,0x43,
+
+	0xB4,0xE0,0xFC,0xA3,0xE0,0xFD,0xD3,0x9F,
+
+	0xEC,0x95,0xF0,0x40,0x08,0x90,0xF0,0x2B,
+
+	0x74,0x01,0xF0,0x80,0x15,0x90,0x42,0x03,
+
+	0xE0,0x89,0xF0,0xA4,0xFF,0xC3,0xED,0x9F,
+
+	0xEC,0x95,0xF0,0x50,0x05,0x90,0xF0,0x2B,
+
+	0xE4,0xF0,0x90,0xF0,0x2B,0xE0,0x60,0x07,
+
+	0x90,0x43,0xAA,0x74,0x15,0xF0,0x22,0x90,
+
+	0x42,0x29,0xE0,0x90,0x43,0xAA,0xF0,0x22,
+
+	0xC2,0xAF,0x90,0x44,0xCD,0xE0,0x04,0xF0,
+
+	0x12,0x74,0x95,0x90,0xF5,0xBE,0x74,0x01,
+
+	0xF0,0x12,0x77,0x1C,0x90,0x44,0x9B,0x74,
+
+	0x01,0xF0,0x90,0x44,0xCD,0xE0,0x64,0xAF,
+
+	0x70,0x31,0x90,0xF5,0xC1,0xE0,0x70,0x04,
+
+	0x90,0x42,0x57,0xF0,0x90,0xF5,0xBA,0xE0,
+
+	0x70,0x04,0x90,0x42,0x58,0xF0,0x90,0x42,
+
+	0x58,0xE0,0x70,0x17,0x90,0x42,0x57,0xE0,
+
+	0x70,0x11,0x90,0xF5,0xB9,0x04,0xF0,0x90,
+
+	0xF5,0xC0,0xF0,0xD2,0xE9,0x90,0x44,0x9B,
+
+	0xF0,0xD2,0xEA,0x53,0x91,0xDF,0xD2,0xAF,
+
+	0x22,0xAD,0x07,0x75,0x0A,0x01,0x75,0x0B,
+
+	0xFE,0x75,0x0C,0x01,0xE4,0xF5,0x08,0xF5,
+
+	0x09,0xED,0x60,0x3B,0xB4,0x01,0x16,0xAB,
+
+	0x0A,0xAA,0x0B,0xA9,0x0C,0x12,0x49,0xF8,
+
+	0xFE,0xE4,0x25,0x09,0xF5,0x09,0xEE,0x35,
+
+	0x08,0xF5,0x08,0x80,0x22,0x85,0x0C,0x82,
+
+	0x85,0x0B,0x83,0xE0,0xFE,0xA3,0xE0,0x25,
+
+	0x09,0xF5,0x09,0xEE,0x35,0x08,0xF5,0x08,
+
+	0x74,0x02,0x25,0x0C,0xF5,0x0C,0xE4,0x35,
+
+	0x0B,0xF5,0x0B,0x1D,0x1D,0x80,0xC2,0xAE,
+
+	0x08,0xAF,0x09,0x22,0x90,0xFB,0x08,0xE0,
+
+	0xFE,0x90,0xFB,0x07,0xE0,0x7C,0x00,0x24,
+
+	0x00,0xFF,0xEC,0x3E,0xFE,0x90,0x44,0x50,
+
+	0xE0,0xFC,0xA3,0xE0,0xFD,0xC3,0xEF,0x9D,
+
+	0xFF,0xEE,0x9C,0xFE,0x90,0x42,0x45,0xE0,
+
+	0xFD,0xEF,0xA8,0x05,0x08,0x80,0x05,0xCE,
+
+	0xC3,0x13,0xCE,0x13,0xD8,0xF9,0xFF,0x90,
+
+	0xFB,0x28,0xE0,0xB4,0x86,0x13,0x90,0x42,
+
+	0x00,0xE0,0xFE,0xA8,0x05,0x08,0x80,0x02,
+
+	0xC3,0x13,0xD8,0xFC,0xFE,0xC3,0xEF,0x9E,
+
+	0xFF,0x90,0x41,0xFD,0xEF,0xF0,0x22,0x90,
+
+	0x42,0x52,0xE0,0x60,0x43,0x90,0x43,0x8E,
+
+	0xE0,0xFF,0xD3,0x94,0x01,0x50,0x07,0xEF,
+
+	0x60,0x36,0x74,0x02,0xF0,0x22,0x90,0x43,
+
+	0xA2,0xE0,0xFE,0xA3,0xE0,0xFF,0xA3,0xEE,
+
+	0xF0,0xA3,0xEF,0xF0,0xD3,0x94,0x50,0xEE,
+
+	0x94,0x07,0x40,0x08,0x90,0x41,0xD5,0x74,
+
+	0x01,0xF0,0x80,0x0E,0xC3,0xEF,0x94,0x50,
+
+	0xEE,0x94,0x05,0x50,0x05,0xE4,0x90,0x41,
+
+	0xD5,0xF0,0x90,0x43,0x8E,0x74,0x03,0xF0,
+
+	0x22,0x90,0x42,0x3B,0xE0,0x64,0x01,0x70,
+
+	0x40,0x90,0xFD,0x9D,0xE0,0xFE,0x90,0xFD,
+
+	0x9C,0xE0,0x7C,0x00,0x24,0x00,0xFF,0xEC,
+
+	0x3E,0xFE,0xC3,0xEF,0x94,0x46,0xEE,0x94,
+
+	0x00,0x50,0x26,0x90,0xFD,0x37,0xE0,0xB4,
+
+	0x07,0x1F,0xE4,0x90,0x42,0x39,0xF0,0x90,
+
+	0xFD,0x2B,0xF0,0x7D,0xFF,0x7C,0x7F,0xFF,
+
+	0x12,0xAB,0xED,0x90,0x44,0xAA,0xE0,0x64,
+
+	0x01,0x60,0xF8,0x90,0xFD,0x2B,0x74,0x01,
+
+	0xF0,0x22,0x90,0x42,0x2B,0xE0,0x90,0xF7,
+
+	0x5A,0xF0,0x90,0x41,0xE5,0xE0,0x90,0xF7,
+
+	0x5B,0xF0,0x90,0x42,0x33,0xE0,0x90,0xF7,
+
+	0x5C,0xF0,0xA3,0xEF,0xF0,0x90,0xF9,0x00,
+
+	0xE0,0x90,0xF7,0x5E,0xF0,0x90,0x41,0xDB,
+
+	0xE0,0x90,0xF7,0x5F,0xF0,0x90,0xF7,0x61,
+
+	0x74,0x01,0xF0,0x90,0xF7,0x60,0xF0,0x7F,
+
+	0x00,0x7E,0x28,0x12,0xAF,0x5E,0x20,0x8C,
+
+	0xFD,0x90,0xF7,0x61,0xE4,0xF0,0x90,0xF7,
+
+	0x60,0xF0,0x22,0x90,0x44,0x9A,0x74,0x01,
+
+	0xF0,0x90,0xF7,0x42,0xE0,0x90,0x44,0x9C,
+
+	0xF0,0xE0,0x90,0xF9,0x00,0xF0,0x90,0xF7,
+
+	0x44,0xE0,0xFF,0x90,0xF9,0x08,0xF0,0x90,
+
+	0xF7,0x43,0xE0,0xFF,0x90,0xF9,0x03,0xF0,
+
+	0x90,0xF7,0x46,0xE0,0xFF,0x90,0xF9,0x06,
+
+	0xF0,0x90,0xF7,0x47,0xE0,0xFF,0x90,0xF9,
+
+	0x07,0xF0,0x90,0xF7,0x45,0xE0,0x54,0x03,
+
+	0xFF,0x90,0xF9,0x02,0xF0,0x90,0xF9,0x05,
+
+	0x74,0x01,0xF0,0x22,0x75,0xF0,0x02,0xE5,
+
+	0x13,0xA4,0x24,0xC5,0xF5,0x82,0xE5,0xF0,
+
+	0x34,0xAF,0xF5,0x83,0xE4,0x93,0xFC,0x74,
+
+	0x01,0x93,0xFD,0xE4,0xFF,0x12,0xAB,0xED,
+
+	0x90,0xF1,0x48,0xE4,0xF0,0x90,0xF0,0x81,
+
+	0x74,0x03,0xF0,0x90,0xF1,0xFC,0xF0,0x90,
+
+	0xF5,0xAF,0xE4,0xF0,0x04,0xF0,0x90,0xF5,
+
+	0xB4,0xE0,0xB4,0x01,0xF9,0x90,0xF5,0xAF,
+
+	0xE4,0xF0,0x90,0x43,0xBB,0x04,0xF0,0x22,
+
+	0xC2,0xD5,0xE8,0x30,0xE7,0x0F,0xB2,0xD5,
+
+	0xE4,0xC3,0x9B,0xFB,0xE4,0x9A,0xFA,0xE4,
+
+	0x99,0xF9,0xE4,0x98,0xF8,0xEC,0x30,0xE7,
+
+	0x17,0xB2,0xD5,0x12,0xA5,0x07,0x12,0x4C,
+
+	0xE9,0xE4,0xC3,0x9B,0xFB,0xE4,0x9A,0xFA,
+
+	0xE4,0x99,0xF9,0xE4,0x98,0xF8,0x80,0x03,
+
+	0x12,0x4C,0xE9,0x30,0xD5,0x0D,0xE4,0xC3,
+
+	0x9F,0xFF,0xE4,0x9E,0xFE,0xE4,0x9D,0xFD,
+
+	0xE4,0x9C,0xFC,0x22,0xE4,0x90,0x43,0xDD,
+
+	0xF0,0x90,0xF9,0x00,0xE0,0x70,0x09,0x90,
+
+	0x42,0x26,0xE0,0x90,0x43,0xDD,0xF0,0x22,
+
+	0x90,0xF9,0x00,0xE0,0xB4,0x01,0x1F,0x90,
+
+	0x41,0xE5,0xE0,0xB4,0x01,0x09,0x90,0x42,
+
+	0x24,0xE0,0x90,0x43,0xDD,0xF0,0x22,0x90,
+
+	0xF0,0x2B,0xE0,0x70,0x11,0x90,0x42,0x27,
+
+	0xE0,0x90,0x43,0xDD,0xF0,0x22,0x90,0x42,
+
+	0x25,0xE0,0x90,0x43,0xDD,0xF0,0x22,0x90,
+
+	0x41,0xD7,0xE0,0x64,0x27,0x70,0x38,0x90,
+
+	0x43,0xB0,0xE0,0xB4,0x01,0x1B,0x90,0x41,
+
+	0xD5,0xE0,0x64,0x01,0x60,0x08,0x90,0x41,
+
+	0xDC,0xE0,0x64,0x01,0x60,0x0B,0xE4,0x90,
+
+	0x43,0xB0,0xF0,0x7F,0x17,0x12,0xAD,0x3C,
+
+	0x22,0x90,0x43,0xB0,0xE0,0x70,0x10,0x90,
+
+	0x41,0xD5,0xE0,0x70,0x0A,0x90,0x43,0xB0,
+
+	0x04,0xF0,0x7F,0x16,0x12,0xAD,0x3C,0x22,
+
+	0xE5,0x13,0xD3,0x94,0x02,0x40,0x39,0x90,
+
+	0x43,0xB1,0xE0,0xB4,0x01,0x03,0x12,0xAC,
+
+	0x37,0x90,0x43,0xB1,0xE0,0x70,0x29,0x90,
+
+	0x42,0x01,0xE0,0xFF,0x90,0x43,0xB2,0xE0,
+
+	0xC3,0x9F,0x50,0x0D,0x12,0xA6,0x1B,0x12,
+
+	0x9D,0xAD,0x90,0x43,0xB2,0xE0,0x04,0xF0,
+
+	0x22,0x90,0x43,0xB1,0x74,0x01,0xF0,0x12,
+
+	0xA3,0x68,0x12,0xA2,0x0D,0x12,0xAD,0x1D,
+
+	0x22,0x90,0xF9,0x00,0xE0,0x70,0x19,0x90,
+
+	0x43,0x23,0xE0,0xFE,0xA3,0xE0,0xFF,0x7C,
+
+	0x06,0x7D,0xA8,0x12,0x4A,0x23,0x90,0x43,
+
+	0x23,0xEC,0xF0,0xA3,0xED,0xF0,0x80,0x1E,
+
+	0x90,0xF9,0x00,0xE0,0xB4,0x02,0x17,0x90,
+
+	0x43,0x23,0xE0,0xFE,0xA3,0xE0,0xFF,0x7C,
+
+	0x0D,0x7D,0x50,0x12,0x4A,0x23,0x90,0x43,
+
+	0x23,0xEC,0xF0,0xA3,0xED,0xF0,0x12,0xAC,
+
+	0x5B,0x22,0x90,0x43,0xB2,0xE0,0xD3,0x94,
+
+	0x00,0x40,0x2E,0x90,0x42,0x40,0xE0,0xFE,
+
+	0x90,0x43,0xB3,0xE0,0xFD,0xD3,0x9E,0x40,
+
+	0x05,0xED,0x9E,0xFF,0x80,0x0C,0x90,0x43,
+
+	0xB3,0xE0,0xFE,0x90,0x42,0x40,0xE0,0xC3,
+
+	0x9E,0xFF,0xEF,0xFD,0x90,0x43,0xB5,0xE0,
+
+	0x2D,0xF0,0x90,0x43,0xB4,0xE0,0x34,0x00,
+
+	0xF0,0x90,0x42,0x40,0xE0,0x90,0x43,0xB3,
+
+	0xF0,0x22,0x90,0x44,0xC4,0xEE,0xF0,0xA3,
+
+	0xEF,0xF0,0x75,0x11,0xFE,0x75,0x12,0x03,
+
+	0xED,0x60,0x2C,0x90,0x44,0xC4,0xE0,0xFE,
+
+	0xA3,0xE0,0xF5,0x82,0x8E,0x83,0xE0,0x85,
+
+	0x12,0x82,0x85,0x11,0x83,0xF0,0x90,0x44,
+
+	0xC5,0xE0,0x04,0xF0,0x70,0x06,0x90,0x44,
+
+	0xC4,0xE0,0x04,0xF0,0x05,0x12,0xE5,0x12,
+
+	0x70,0x02,0x05,0x11,0x1D,0x80,0xD1,0x22,
+
+	0x90,0xFD,0x47,0xE0,0x90,0x43,0x0A,0xF0,
+
+	0x90,0xFD,0x46,0xE0,0x90,0x43,0x0B,0xF0,
+
+	0x90,0xFD,0x45,0xE0,0x90,0x43,0x0C,0xF0,
+
+	0x90,0xFD,0x44,0xE0,0x90,0x43,0x0D,0xF0,
+
+	0x90,0x43,0x0A,0xE0,0xFC,0xA3,0xE0,0xFD,
+
+	0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x43,
+
+	0x20,0xE0,0xF9,0xF8,0x12,0x4B,0x32,0x90,
+
+	0x43,0x0A,0x12,0x4B,0x6C,0x22,0x90,0xF7,
+
+	0x3C,0xE0,0x70,0x21,0x90,0xF7,0x31,0xE0,
+
+	0x60,0x07,0xE4,0xFF,0x12,0xA3,0xFB,0x80,
+
+	0x14,0x90,0xFB,0x88,0xE0,0x64,0x01,0x60,
+
+	0xF8,0x90,0xFB,0x96,0x74,0x0D,0xF0,0x90,
+
+	0xFB,0x88,0x74,0x01,0xF0,0x12,0xAB,0xC7,
+
+	0x12,0xAE,0x8F,0x90,0xF7,0x2F,0xE4,0xF0,
+
+	0x90,0x43,0xBA,0x04,0xF0,0x12,0xAD,0x95,
+
+	0x22,0x90,0xFB,0x86,0xE0,0x60,0x32,0x90,
+
+	0x44,0x72,0xE0,0x70,0x24,0x90,0xFE,0x00,
+
+	0xE0,0x24,0x01,0xFF,0xE4,0x33,0xFE,0x90,
+
+	0xFB,0x82,0xE0,0xC3,0x9F,0xEE,0x64,0x80,
+
+	0xF8,0x74,0x80,0x98,0x50,0x0B,0xE0,0xF4,
+
+	0x60,0x07,0x90,0xFB,0x86,0x74,0x01,0xF0,
+
+	0x22,0x90,0xFB,0x82,0xE4,0xF0,0x12,0x5F,
+
+	0x96,0x22,0x90,0xF7,0x14,0xE0,0x60,0x2E,
+
+	0x90,0xF7,0x32,0xE0,0x70,0x06,0x90,0xF7,
+
+	0x3C,0xE0,0x60,0x22,0xC2,0xAF,0x90,0xF7,
+
+	0x14,0xE4,0xF0,0x7B,0xD4,0x7A,0x27,0xFD,
+
+	0x7F,0x01,0x12,0xAC,0x13,0x90,0xF9,0x9D,
+
+	0x74,0x01,0xF0,0x90,0xF7,0x16,0xF0,0x90,
+
+	0xF7,0x11,0xE4,0xF0,0xD2,0xAF,0x22,0x90,
+
+	0x42,0x2B,0xE0,0x60,0x2D,0x90,0xF0,0x2B,
+
+	0xE0,0x70,0x1B,0x90,0x43,0x4C,0xE0,0x70,
+
+	0x06,0x90,0xF9,0x00,0xE0,0x70,0x0F,0x90,
+
+	0x41,0xE4,0xE0,0x70,0x09,0x90,0xF7,0x84,
+
+	0xF0,0x90,0xF7,0x83,0xF0,0x22,0x90,0xF7,
+
+	0x84,0x74,0x01,0xF0,0x90,0xF7,0x83,0x74,
+
+	0xFF,0xF0,0x22,0x90,0xFD,0x15,0x74,0x08,
+
+	0xF0,0xA3,0x74,0x10,0xF0,0xA3,0xE4,0xF0,
+
+	0x90,0xFD,0x05,0x04,0xF0,0x90,0xFD,0x2B,
+
+	0xF0,0x90,0xFD,0x2A,0xF0,0x90,0x44,0xCA,
+
+	0xEF,0xF0,0xE4,0x90,0x42,0x39,0xF0,0x90,
+
+	0xFD,0x2C,0x04,0xF0,0xFF,0x12,0xAE,0x43,
+
+	0x90,0xFD,0x2C,0xE4,0xF0,0x22,0x90,0x42,
+
+	0x06,0xE0,0xFF,0x90,0xF0,0x58,0xF0,0xEF,
+
+	0xF0,0x90,0x42,0x09,0xE0,0x90,0xF0,0x58,
+
+	0xF0,0x90,0x42,0x0C,0xE0,0x90,0x42,0x04,
+
+	0xF0,0xE4,0x90,0x43,0x8F,0xF0,0x90,0x43,
+
+	0x8E,0xF0,0x90,0x43,0xAE,0x74,0x02,0xF0,
+
+	0xE4,0x90,0x41,0xD5,0xF0,0x12,0xAF,0x28,
+
+	0x22,0x90,0x43,0xA8,0xE0,0x04,0xF0,0xE0,
+
+	0x54,0x01,0xF0,0x70,0x10,0x90,0x42,0x49,
+
+	0xE0,0xFF,0x90,0xF0,0x1F,0xF0,0x90,0xF0,
+
+	0x29,0xEF,0xF0,0x80,0x0E,0x90,0x42,0x48,
+
+	0xE0,0xFF,0x90,0xF0,0x1F,0xF0,0x90,0xF0,
+
+	0x29,0xEF,0xF0,0x90,0x43,0xA8,0xE0,0x90,
+
+	0x43,0xAE,0xF0,0x22,0x90,0x43,0x34,0xE0,
+
+	0xB4,0x64,0x22,0x90,0x43,0x33,0xE0,0xD3,
+
+	0x94,0x05,0x40,0x11,0x90,0x43,0x32,0xE0,
+
+	0xD3,0x94,0x05,0x40,0x08,0x90,0x42,0xFD,
+
+	0x74,0x01,0xF0,0x80,0x05,0xE4,0x90,0x42,
+
+	0xFD,0xF0,0x12,0xAF,0x36,0x90,0x43,0x34,
+
+	0xE0,0x04,0xF0,0x12,0x97,0x59,0x22,0x90,
+
+	0x43,0xAF,0xE0,0x60,0x23,0x12,0xA9,0x15,
+
+	0x90,0x43,0xA6,0xE0,0x54,0x0F,0x64,0x0F,
+
+	0x70,0x1E,0x90,0x42,0x04,0xE0,0x54,0x0F,
+
+	0x70,0x16,0x90,0x43,0xA9,0xE0,0x70,0x10,
+
+	0x90,0x43,0xA7,0xE0,0x44,0x01,0xF0,0x22,
+
+	0x90,0x42,0x04,0xE0,0xFF,0x12,0xAE,0xEE,
+
+	0x22,0x90,0x43,0xAF,0xE0,0x60,0x23,0x12,
+
+	0xA9,0x46,0x90,0x43,0xA6,0xE0,0x54,0x0F,
+
+	0x70,0x20,0x90,0x42,0x04,0xE0,0x54,0x0F,
+
+	0xFF,0xBF,0x0F,0x16,0x90,0x43,0xA9,0xE0,
+
+	0x70,0x10,0x90,0x43,0xA7,0xE0,0x44,0x02,
+
+	0xF0,0x22,0x90,0x42,0x04,0xE0,0xFF,0x12,
+
+	0xAE,0xEE,0x22,0x90,0x41,0xD1,0xE0,0x70,
+
+	0x04,0xFF,0x12,0xAD,0x78,0x12,0x67,0x07,
+
+	0x7F,0x01,0x12,0xAD,0x78,0x90,0xF6,0x24,
+
+	0xE0,0xD3,0x94,0x04,0x40,0x0F,0xE4,0x90,
+
+	0x41,0xD8,0xF0,0x90,0xF2,0x1C,0xF0,0x90,
+
+	0x43,0xBB,0x04,0xF0,0x22,0x90,0x43,0xBB,
+
+	0x74,0x01,0xF0,0x22,0x90,0x42,0x4A,0xE0,
+
+	0xFF,0x90,0xF5,0xA9,0xE0,0x5F,0x60,0x0E,
+
+	0x90,0xF0,0x68,0xE0,0x20,0xE0,0xF9,0x90,
+
+	0xF0,0x68,0xE0,0x30,0xE0,0xF9,0x90,0x42,
+
+	0x07,0xE0,0xFF,0x90,0xF0,0x58,0xF0,0xEF,
+
+	0xF0,0x90,0x42,0x09,0xE0,0xFF,0x90,0xF0,
+
+	0x58,0xF0,0xEF,0xF0,0x22,0x90,0x42,0x4A,
+
+	0xE0,0xFF,0x90,0xF5,0xA9,0xE0,0x5F,0x60,
+
+	0x0E,0x90,0xF0,0x68,0xE0,0x20,0xE0,0xF9,
+
+	0x90,0xF0,0x68,0xE0,0x30,0xE0,0xF9,0x90,
+
+	0x42,0x08,0xE0,0xFF,0x90,0xF0,0x58,0xF0,
+
+	0xEF,0xF0,0x90,0x42,0x09,0xE0,0xFF,0x90,
+
+	0xF0,0x58,0xF0,0xEF,0xF0,0x22,0x90,0x42,
+
+	0x53,0xE0,0x60,0x2A,0x7F,0x02,0x12,0xAD,
+
+	0x3C,0xE4,0x90,0x41,0xE3,0xF0,0x90,0x41,
+
+	0xD4,0xF0,0x90,0x42,0x04,0xE0,0xC3,0x94,
+
+	0x1A,0x50,0x04,0xE4,0xF0,0x80,0x07,0x90,
+
+	0x42,0x04,0xE0,0x24,0xE6,0xF0,0x90,0x42,
+
+	0x04,0xE0,0xFF,0x12,0xAB,0x9E,0x22,0x90,
+
+	0x44,0x4F,0xE0,0x90,0xF0,0x1B,0xF0,0x90,
+
+	0x44,0x4E,0xE0,0xFF,0x33,0x95,0xE0,0x90,
+
+	0xF0,0x1C,0xEF,0xF0,0x90,0x44,0x4B,0xE0,
+
+	0x90,0xF0,0x0E,0xF0,0x90,0x44,0x4A,0xE0,
+
+	0xFF,0x33,0x95,0xE0,0x90,0xF0,0x0F,0xEF,
+
+	0xF0,0x90,0xF0,0x2C,0x74,0x01,0xF0,0x22,
+
+	0x90,0x44,0x42,0xE0,0xFE,0xA3,0xE0,0xA8,
+
+	0x07,0x08,0x80,0x05,0xCE,0xC3,0x13,0xCE,
+
+	0x13,0xD8,0xF9,0xF0,0xEE,0x90,0x44,0x42,
+
+	0xF0,0xE0,0xFE,0xA3,0xE0,0xFF,0x90,0x41,
+
+	0xC0,0xE0,0xFD,0x7C,0x00,0x12,0x4A,0x23,
+
+	0x90,0x44,0x42,0xEE,0xF0,0xA3,0xEF,0xF0,
+
+	0x22,0x90,0x41,0xB3,0xE0,0xFE,0x90,0x41,
+
+	0xB2,0xE0,0x7C,0x00,0x24,0x00,0xFF,0xEC,
+
+	0x3E,0xFE,0xE4,0xFD,0x90,0x43,0xE6,0xE0,
+
+	0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+
+	0xE0,0xFB,0x12,0x4A,0xAE,0x78,0x09,0x12,
+
+	0x4B,0x32,0x90,0x43,0xEA,0x12,0x4B,0x6C,
+
+	0x22,0x90,0x42,0x17,0xE0,0x90,0xF0,0x0E,
+
+	0xF0,0x90,0x42,0x18,0xE0,0x90,0xF0,0x0F,
+
+	0xF0,0x90,0x42,0x19,0xE0,0x90,0xF0,0x1B,
+
+	0xF0,0x90,0x42,0x1A,0xE0,0x90,0xF0,0x1C,
+
+	0xF0,0x90,0xF0,0x2C,0x74,0x01,0xF0,0x90,
+
+	0xF1,0xE5,0xF0,0xE4,0x90,0x44,0x46,0xF0,
+
+	0x22,0x12,0x9C,0xB3,0x90,0xF1,0x4E,0x74,
+
+	0x3F,0xF0,0x90,0xF1,0x85,0xE4,0xF0,0x90,
+
+	0xF1,0x47,0xF0,0xA3,0xF0,0x90,0x42,0x0D,
+
+	0xE0,0x64,0x01,0x60,0x08,0xE4,0x90,0x43,
+
+	0xE0,0xF0,0x12,0x7E,0x10,0x90,0x43,0xE0,
+
+	0x74,0x01,0xF0,0x90,0x43,0xBB,0xF0,0x22,
+
+	0xC2,0xAF,0x90,0xF7,0x14,0xE0,0x70,0x24,
+
+	0x90,0xF7,0x32,0xE0,0x70,0x06,0x90,0xF7,
+
+	0x3C,0xE0,0x60,0x18,0x90,0xF9,0x9D,0xE4,
+
+	0xF0,0x90,0xF7,0x14,0x04,0xF0,0x90,0xF7,
+
+	0x0D,0xF0,0x90,0xF7,0x86,0xF0,0xA3,0xF0,
+
+	0x90,0xF7,0x11,0xF0,0xD2,0xAF,0x22,0x90,
+
+	0xFB,0x27,0xE0,0x54,0x1F,0xFF,0xC3,0x13,
+
+	0xFF,0x90,0x41,0xD6,0x74,0x01,0xF0,0x90,
+
+	0x44,0x47,0x74,0x82,0xF0,0x12,0xAF,0x1A,
+
+	0x90,0xFB,0x25,0x74,0x1F,0xF0,0xA3,0x74,
+
+	0x22,0xF0,0x90,0xFB,0x29,0x74,0x42,0xF0,
+
+	0x12,0x9D,0x31,0x22,0xC2,0x8C,0x43,0x8E,
+
+	0x08,0xE4,0x90,0x44,0xA6,0xF0,0xA3,0xF0,
+
+	0x90,0x44,0xA8,0xF0,0xA3,0xF0,0xD2,0xAD,
+
+	0xF5,0xC9,0xC2,0xC9,0xC2,0xCD,0xC2,0xCC,
+
+	0xC2,0xC8,0xC2,0xCE,0xC2,0xCB,0x75,0xCA,
+
+	0xAA,0x75,0xCB,0xF2,0xD2,0xCA,0x22,0x90,
+
+	0x43,0xAF,0xE0,0x90,0x44,0xD1,0xF0,0x90,
+
+	0x42,0x53,0xE0,0x60,0x1C,0x90,0x41,0xE3,
+
+	0x74,0x01,0xF0,0xFF,0x12,0xAD,0x3C,0x90,
+
+	0x41,0xD4,0x74,0x01,0xF0,0x90,0x42,0x04,
+
+	0xE0,0x24,0x1A,0xF0,0xE0,0xFF,0x12,0xAB,
+
+	0x9E,0x22,0x90,0x41,0xE8,0xE0,0x70,0x23,
+
+	0x90,0x43,0x90,0xE0,0xA3,0xF0,0x60,0x05,
+
+	0x12,0xAB,0x20,0x80,0x03,0x12,0xA9,0x77,
+
+	0x90,0x41,0xF9,0xE0,0xFF,0x90,0xF0,0x1F,
+
+	0xF0,0x90,0xF0,0x29,0xEF,0xF0,0xE4,0x90,
+
+	0x43,0x90,0xF0,0x22,0x90,0xF7,0x79,0x74,
+
+	0x01,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0x90,0xF7,0x6A,0xF0,0x90,0xF7,0x74,0xF0,
+
+	0x90,0xF0,0x09,0xF0,0x90,0xF7,0x7D,0xF0,
+
+	0x90,0xF5,0xB9,0xF0,0x90,0xF5,0xBE,0xF0,
+
+	0x90,0xF5,0xC0,0xF0,0x22,0x90,0x44,0xD0,
+
+	0xEF,0xF0,0x90,0x41,0xD7,0xE0,0xB4,0x22,
+
+	0x1C,0xC2,0xAF,0x7F,0x15,0x12,0xAD,0x3C,
+
+	0x90,0x44,0xD0,0xE0,0xFF,0x12,0xAE,0xEE,
+
+	0x90,0x43,0xAF,0xE0,0x60,0x05,0x7F,0x14,
+
+	0x12,0xAD,0x3C,0xD2,0xAF,0x22,0x90,0xF7,
+
+	0x3C,0xE0,0x70,0x03,0x12,0xAE,0x16,0xE4,
+
+	0x90,0x44,0x9A,0xF0,0x90,0x42,0x42,0xF0,
+
+	0x90,0x42,0x43,0xF0,0x12,0xAD,0xCE,0xE4,
+
+	0x90,0x41,0xCE,0xF0,0x90,0x41,0xCD,0xF0,
+
+	0x12,0xAE,0xDF,0x22,0xAB,0x07,0x90,0xF1,
+
+	0x1D,0x74,0x01,0xF0,0xE4,0xF0,0xED,0x90,
+
+	0xF1,0x18,0xF0,0xEC,0xA3,0xF0,0x90,0xF1,
+
+	0x1B,0xEB,0xF0,0xD2,0xAF,0xD2,0xE8,0x90,
+
+	0x44,0xAA,0x74,0x01,0xF0,0x90,0xF1,0x1A,
+
+	0xF0,0x22,0xC2,0xA9,0xEF,0x42,0x89,0xEA,
+
+	0xF4,0xF5,0x8C,0xEB,0xF4,0xF5,0x8A,0x53,
+
+	0x8E,0xF7,0xAF,0x05,0xEF,0x33,0x33,0x33,
+
+	0x54,0xF8,0x42,0x8E,0xD2,0x8C,0x30,0x8D,
+
+	0xFD,0xC2,0x8D,0xD2,0xA9,0x22,0x90,0x41,
+
+	0xF1,0xE0,0x70,0x10,0x90,0x43,0xB1,0xF0,
+
+	0xA3,0xF0,0x90,0x43,0xB4,0xF0,0xA3,0xF0,
+
+	0x90,0x43,0xB3,0xF0,0x90,0x42,0x52,0xE0,
+
+	0x60,0x07,0xE4,0x90,0x43,0xA2,0xF0,0xA3,
+
+	0xF0,0x22,0x90,0x43,0x24,0xE0,0x90,0xF5,
+
+	0xCC,0xF0,0x90,0x43,0x23,0xE0,0x54,0x1F,
+
+	0x90,0xF5,0xCD,0xF0,0x90,0xF5,0xD4,0xE0,
+
+	0x90,0x43,0x09,0xF0,0x90,0xF5,0xCB,0xE0,
+
+	0xB4,0x01,0xF9,0x22,0xE4,0xFF,0xFE,0xC3,
+
+	0xEF,0x94,0xFF,0xEE,0x64,0x80,0x94,0x7F,
+
+	0x50,0x13,0x74,0x58,0x2F,0xF5,0x82,0x74,
+
+	0xF7,0x3E,0xF5,0x83,0xE4,0xF0,0x0F,0xBF,
+
+	0x00,0x01,0x0E,0x80,0xE2,0x22,0x90,0xFB,
+
+	0x87,0xE0,0x60,0xFA,0x90,0xFB,0x9E,0xE0,
+
+	0xB4,0x04,0x05,0xA3,0xE0,0xFF,0x80,0x02,
+
+	0x7F,0x00,0x90,0x44,0x72,0xEF,0xF0,0x90,
+
+	0xFB,0x87,0xE4,0xF0,0xC2,0xDB,0x22,0xEF,
+
+	0x24,0x04,0x90,0xFE,0x00,0xF0,0x90,0xFE,
+
+	0x03,0xE0,0x90,0xFE,0x01,0xF0,0xA3,0xED,
+
+	0xF0,0xEF,0x24,0x05,0x90,0xFB,0x90,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0xF0,0x22,0xD2,0xAF,
+
+	0xD2,0xA9,0xEF,0x42,0x89,0xEA,0xF4,0xF5,
+
+	0x8C,0xEB,0xF4,0xF5,0x8A,0x53,0x8E,0xF7,
+
+	0xAF,0x05,0xEF,0x33,0x33,0x33,0x54,0xF8,
+
+	0x42,0x8E,0xD2,0x8C,0x22,0x90,0x42,0x0B,
+
+	0xE0,0xFF,0x90,0x42,0x04,0xE0,0xC3,0x9F,
+
+	0x50,0x11,0xE0,0x04,0xF0,0x90,0x41,0xD7,
+
+	0xE0,0xB4,0x22,0x04,0x12,0xA8,0x80,0x22,
+
+	0x12,0xA9,0x15,0x22,0x90,0xF0,0x2B,0xE0,
+
+	0x70,0x0E,0x90,0x43,0xBC,0xF0,0x90,0xFD,
+
+	0x74,0xF0,0x90,0xF1,0xE9,0x04,0xF0,0x22,
+
+	0x90,0xF1,0xE9,0xE4,0xF0,0x90,0xFD,0x74,
+
+	0x04,0xF0,0x22,0x90,0xFB,0x88,0xE0,0x64,
+
+	0x01,0x60,0xF8,0x90,0xFB,0x96,0xEF,0xF0,
+
+	0x90,0xFB,0x88,0x74,0x01,0xF0,0x90,0xFB,
+
+	0x88,0xE0,0x64,0x01,0x60,0xF8,0x7F,0x01,
+
+	0x22,0xE4,0x90,0x43,0x06,0xF0,0x90,0xF5,
+
+	0xD6,0xE0,0x90,0x43,0x07,0xF0,0x90,0xF5,
+
+	0xD5,0xE0,0x90,0x43,0x08,0xF0,0x90,0xF5,
+
+	0xD4,0xE0,0x90,0x43,0x09,0xF0,0x22,0x90,
+
+	0xF4,0x71,0xE4,0xF0,0x04,0xF0,0x90,0xF5,
+
+	0xAC,0xE4,0xF0,0xEF,0x70,0x05,0x12,0x5D,
+
+	0x01,0x80,0x03,0x12,0x6B,0x1B,0x90,0xF4,
+
+	0x71,0xE4,0xF0,0x22,0xE4,0xF5,0x13,0xC2,
+
+	0xAF,0x53,0x91,0x7F,0x7A,0xAF,0x79,0xA0,
+
+	0x12,0x4B,0xA9,0x7B,0x01,0x7A,0x44,0x79,
+
+	0x6A,0x7D,0x01,0x7C,0x00,0x12,0xA1,0x83,
+
+	0x22,0x90,0xF7,0x11,0xE4,0xF0,0x7F,0xFF,
+
+	0x7E,0x66,0x12,0xAF,0x5E,0x20,0x8C,0xFD,
+
+	0x90,0x44,0x9B,0x74,0x01,0xF0,0xD2,0xEA,
+
+	0x90,0xF7,0x11,0xF0,0x22,0x90,0x42,0x42,
+
+	0xE0,0x70,0x0C,0x90,0x42,0x43,0xE0,0x60,
+
+	0x0A,0x90,0x44,0x9A,0xE0,0x60,0x04,0x12,
+
+	0xAA,0x99,0x22,0x12,0xA7,0x4B,0x22,0x90,
+
+	0x42,0x04,0xE0,0x60,0x10,0x14,0xF0,0x90,
+
+	0x41,0xD7,0xE0,0xB4,0x22,0x04,0x12,0xA8,
+
+	0xB2,0x22,0x12,0xA9,0x46,0x22,0x90,0x43,
+
+	0x8F,0xE0,0x60,0x03,0x14,0xF0,0x22,0x90,
+
+	0xF0,0x01,0xE0,0xB4,0x01,0x06,0x12,0x83,
+
+	0x14,0x12,0x93,0x50,0x22,0xC2,0xAF,0x90,
+
+	0xF5,0xA8,0xE4,0xF0,0x90,0xF7,0x3D,0xF0,
+
+	0xFF,0x7E,0x28,0x12,0xAF,0x5E,0x20,0x8C,
+
+	0xFD,0xD2,0xAF,0x22,0xC2,0xAF,0xC2,0xDB,
+
+	0x90,0xFB,0x7F,0xE0,0x70,0x09,0x90,0xFB,
+
+	0x87,0xF0,0x90,0xFB,0xAF,0x04,0xF0,0xD2,
+
+	0xAF,0x22,0x90,0xF5,0x38,0xE0,0xFD,0xEF,
+
+	0x60,0x0D,0x90,0xF5,0x38,0xE0,0xFE,0x6D,
+
+	0x60,0xF5,0xAD,0x06,0x1F,0x80,0xF0,0x22,
+
+	0x90,0x41,0xD7,0xE0,0xB4,0x27,0x0B,0x7F,
+
+	0x16,0x12,0xAD,0x3C,0x90,0x43,0xB0,0x74,
+
+	0x01,0xF0,0x22,0x90,0x43,0xB6,0xE0,0x70,
+
+	0x05,0x90,0x43,0xBB,0xF0,0x22,0x90,0x43,
+
+	0xBB,0x74,0x01,0xF0,0x22,0x90,0xF5,0x5B,
+
+	0x74,0xFC,0xF0,0xA3,0xE4,0xF0,0xA3,0x74,
+
+	0x02,0xF0,0xA3,0xE4,0xF0,0x22,0x90,0xF5,
+
+	0x52,0x74,0x3F,0xF0,0x90,0xF5,0x54,0x74,
+
+	0x01,0xF0,0x90,0xF7,0x0E,0xF0,0x22,0x90,
+
+	0xF4,0x08,0x74,0x99,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xF0,0x22,0x90,
+
+	0xF4,0x08,0x74,0x99,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xF0,0x22,0x90,
+
+	0xF4,0x08,0x74,0x99,0xF0,0xA3,0x74,0x02,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xF0,0x22,0x90,
+
+	0xF5,0x5B,0xE4,0xF0,0xA3,0x74,0x03,0xF0,
+
+	0xA3,0xE4,0xF0,0xA3,0xF0,0x22,0xE4,0x90,
+
+	0x42,0x2B,0xF0,0x90,0xF7,0x83,0x74,0xAA,
+
+	0xF0,0xA3,0xE4,0xF0,0x22,0xC2,0xAF,0x90,
+
+	0xFB,0x97,0xEF,0xF0,0x7F,0x13,0x12,0xAD,
+
+	0x3C,0xD2,0xAF,0x22,0xE4,0x90,0x43,0x27,
+
+	0xF0,0x90,0x43,0x25,0xF0,0xA3,0xF0,0x12,
+
+	0x8E,0x1F,0x22,0x90,0xF5,0x5B,0x74,0x60,
+
+	0xF0,0xA3,0xE4,0xF0,0xA3,0xF0,0xA3,0xF0,
+
+	0x22,0x90,0xFB,0x24,0xE4,0xF0,0x90,0x44,
+
+	0x47,0xE0,0x90,0xFB,0x28,0xF0,0x22,0xE4,
+
+	0x90,0x43,0xA7,0xF0,0x90,0x43,0xA9,0xF0,
+
+	0x90,0x43,0xA8,0xF0,0x22,0xE4,0x90,0x43,
+
+	0x34,0xF0,0x90,0x43,0x33,0xF0,0x90,0x43,
+
+	0x32,0xF0,0x22,0xE4,0x90,0x44,0xAA,0xF0,
+
+	0x90,0xF1,0x1C,0xF0,0x53,0x91,0xEF,0x22,
+
+	0x90,0xFB,0x24,0x74,0x08,0xF0,0x90,0xFB,
+
+	0x28,0x74,0x74,0xF0,0x22,0xAB,0x07,0xAA,
+
+	0x06,0xE4,0xFD,0x7F,0x01,0x12,0xAC,0xDF,
+
+	0x22,0x90,0xF1,0x75,0x74,0x01,0xF0,0x90,
+
+	0xF1,0x0A,0xF0,0x22,0x90,0xF4,0x60,0xEF,
+
+	0xF0,0xA3,0xED,0xF0,0x22,0x90,0xF4,0x13,
+
+	0xE4,0xF0,0x12,0x50,0xDE,0x22,0x90,0x43,
+
+	0xBB,0x74,0x01,0xF0,0xF5,0x13,0x22,0x90,
+
+	0xF2,0x17,0x74,0xFE,0xF0,0x22,0xC2,0xAF,
+
+	0x12,0xA6,0xD7,0x22,0xC2,0x8C,0x22,0x22,
+
+	0x22,0x22,0x22,0x22,0x22,0x22,0x01,0x02,
+
+	0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x09,
+
+	0x00,0x01,0x02,0x03,0x04,0x05,0x05,0x03,
+
+	0x08,0x01,0x00,0x01,0x01,0x02,0x03,0x03,
+
+	0x01,0x01,0x01,0x01,0x3E,0x80,0x06,0x40,
+
+	0x7D,0x00,0x12,0xC0,0x12,0xC0,0xFA,0x00,
+
+	0x12,0xC0,0xBB,0x80,0x9C,0x40,0x00,0xA0,
+
+	0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,
+
+	0x01,0x01,0xA7,0x12,0xAF,0x9D,0xAF,0xA1,
+
+	0xAF,0xA2,0xAF,0xA3,0x71,0xC9,0xAF,0xA4,
+
+	0xAF,0xA5,0xAF,0x44,0xA2,0x69,0x84,0xEF,
+
+	0x8C,0x89,0xAE,0x2D
+
+};
+
+
+
+static Segment Firmware_segments[] = {
+
+	{	0x00,		0x0000000A		},
+
+	{	0x00,		0x00003A0E		},
+
+	{	0x00,		0x0000000A		},
+
+	{	0x00,		0x00006AB4		}
+
+};
+
+
+
+static Byte Firmware_partitions[] = {
+
+	0x04
+
+};
+
+
+
+
+
+#define Firmware_SCRIPTSETLENGTH	0x00000001
+
+
+
+
+
+static Word Firmware_scriptSets[] = {
+
+	0x6B
+
+};
+
+
+
+
+
+static ValueSet Firmware_scripts[] = {
+
+ {0xF905, 0x01},
+
+ {0xF40E, 0x0A},
+
+ {0xF40F, 0x40},
+
+ {0xF410, 0x08},
+
+ {0xF55F, 0x0A},
+
+ {0xF562, 0x20},
+
+ {0xF561, 0x15},
+
+ {0xF610, 0x32},
+
+ {0xF611, 0x10},
+
+ {0xF60F, 0x04},
+
+ {0xF60E, 0x00},
+
+ {0xF600, 0x05},
+
+ {0xF601, 0x08},
+
+ {0xF602, 0x0B},
+
+ {0xF603, 0x0E},
+
+ {0xF604, 0x11},
+
+ {0xF605, 0x14},
+
+ {0xF606, 0x17},
+
+ {0xF607, 0x1F},
+
+ {0xF5F8, 0x01},
+
+ {0xF5DF, 0xFB},
+
+ {0xF5E0, 0x00},
+
+ {0xF5E3, 0x09},
+
+ {0xF5E4, 0x01},
+
+ {0xF5E5, 0x01},
+
+ {0xF5FD, 0x01},
+
+ {0xF80F, 0x40},
+
+ {0xF810, 0x54},
+
+ {0xF811, 0x5a},
+
+ {0xF78B, 0x01},
+
+ {0xFB06, 0x3},
+
+ {0x00a0, 0xCF},
+
+ {0x009f, 0xE1},
+
+ {0x00a6, 0x01},
+
+ {0xFD8B, 0x00},
+
+ {0x00ad, 0x01},
+
+ {0x00a3, 0x01},
+
+ {0x00a4, 0x3C},
+
+ {0x00ab, 0x01},
+
+ {0x008e, 0x01},
+
+ {0x008a, 0x01},
+
+ {0x0099, 0x01},
+
+ {0x00a9, 0x00},
+
+ {0x00a5, 0x01},
+
+ {0x00aa, 0x01},
+
+ {0x0092, 0x06},
+
+ {0xF078, 0x00},
+
+ {0xF016, 0x10},
+
+ {0xF017, 0x04},
+
+ {0xF018, 0x05},
+
+ {0xF019, 0x04},
+
+ {0xF01A, 0x05},
+
+ {0xF021, 0x03},
+
+ {0xF022, 0x0A},
+
+ {0xF023, 0x0A},
+
+ {0xF02B, 0x00},
+
+ {0x0070, 0x0A},
+
+ {0xF1CB, 0xA0},
+
+ {0xF1CC, 0x01},
+
+ {0xF02C, 0x01},
+
+ {0x00b0, 0x01},
+
+ {0xF000, 0xF},
+
+ {0xF707, 0xFC},
+
+ {0xF708, 0x00},
+
+ {0xF709, 0x7E},
+
+ {0xF70A, 0x00},
+
+ {0xF70B, 0x2F},
+
+ {0xF1BC, 0x36},
+
+ {0xF1BD, 0x00},
+
+ {0xF214, 0x0},
+
+ {0xF204, 0x10},
+
+ {0xF087, 0x0},
+
+ {0xF064, 0x03},
+
+ {0xF067, 0x1},
+
+ {0xF065, 0xF9},
+
+ {0xF066, 0x03},
+
+ {0xF06F, 0xe0},
+
+ {0xF070, 0x3},
+
+ {0xF072, 0x0f},
+
+ {0xF073, 0x03},
+
+ {0xF144, 0x1a},
+
+ {0xF146, 0x00},
+
+ {0xF14A, 0x01},
+
+ {0xF14C, 0x00},
+
+ {0xF14D, 0x00},
+
+ {0xF14F, 0x04},
+
+ {0xF09F, 0x0c},
+
+ {0xF0A0, 0x00},
+
+ {0xF15A, 0x00},
+
+ {0xF15B, 0x08},
+
+ {0xF163, 0x05},
+
+ {0xF09B, 0x3f},
+
+ {0xF09C, 0x00},
+
+ {0xF168, 0x0f},
+
+ {0xF09D, 0x20},
+
+ {0xF09E, 0x00},
+
+ {0xF167, 0x40},
+
+ {0xF158, 0x7f},
+
+ {0xF166, 0x01},
+
+ {0xF15D, 0x03},
+
+ {0xF130, 0x04},
+
+ {0xF132, 0x04},
+
+ {0xF183, 0x01},
+
+ {0xF19D, 0x40},
+
+ {0xF15E, 0x05},
+
+ {0xF17A, 0x00},
+
+ {0xF17B, 0x00},
+
+};
+
+#endif
+
+// Warning: version numbers are manually altered.
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_inttype.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_inttype.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_inttype.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_inttype.h	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,41 @@
+#ifndef __INTTYPE_H__
+#define __INTTYPE_H__
+
+
+/**
+ * The type defination of SnrTable.
+ */
+typedef struct {
+    Dword errorCount;
+    Dword snr;
+    double errorRate;
+} SnrTable;
+
+
+/**
+ * The type defination of Statistic.
+ */
+typedef struct {
+    Word abortCount;
+    Dword postVitBitCount;
+    Dword postVitErrorCount;
+    /** float point */
+    Dword softBitCount;
+    Dword softErrorCount;
+    Dword preVitBitCount;
+    Dword preVitErrorCount;
+    double snr;
+} ChannelStatistic;
+
+
+/**
+ * The type defination of AgcVoltage.
+ */
+typedef struct {
+    double doSetVolt;
+    double doPuUpVolt;
+} AgcVoltage;
+
+
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_iocontrol.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_iocontrol.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_iocontrol.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_iocontrol.h	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,738 @@
+/**
+ *
+ * Copyright (c) 2006 Afa Corporation. All rights reserved.
+ *
+ * Module Name:
+ *   iocontrol.h
+ *
+ * Abstract:
+ *   The structure and IO code for IO control call.
+ *
+ */
+
+#ifndef __IOCONTROL_H__
+#define __IOCONTROL_H__
+
+#ifdef UNDER_CE
+#include <winioctl.h>
+#else
+#endif
+
+#include "a867_type.h"
+
+#define MEDIA_DEVICE_AFADEMOD       0x00000AFA
+
+typedef struct {
+    Byte                chipNumber;
+    Word                sawBandwidth;
+    StreamType          streamType;
+    Architecture        architecture;
+    Dword               error;
+    Byte                reserved[16];
+} InitializeRequest, *PInitializeRequest;
+
+typedef struct {
+    Dword               error;
+    Byte                reserved[16];
+} FinalizeRequest, *PFinalizeRequest;
+
+typedef struct {
+    StreamType          streamType;
+    Dword               error;
+    Byte                reserved[16];
+} SetStreamTypeRequest, *PSetStreamTypeRequest;
+
+typedef struct {
+    Architecture        architecture;
+    Dword               error;
+    Byte                reserved[16];
+} SetArchitectureRequest, *PSetArchitectureRequest;
+
+typedef struct {
+    Byte                chip;
+    ChannelModulation*  channelModulation;
+    Dword               error;
+    Byte                reserved[16];
+} GetChannelModulationRequest, *PGetChannelModulationRequest;
+
+typedef struct {
+    Processor           processor;
+    Dword*              version;
+    Dword               error;
+    Byte                reserved[16];
+} GetFirmwareVersionRequest, *PGetFirmwareVersionRequest;
+
+typedef struct {
+    Byte                chip;
+    Word                bandwidth;
+    Dword               frequency;
+    Dword               error;
+    Byte                reserved[16];
+} AcquireChannelRequest, *PAcquireChannelRequest;
+
+typedef struct {
+    Byte                chip;
+    Bool*               locked;
+    Dword               error;
+    Byte                reserved[16];
+} IsLockedRequest, *PIsLockedRequest;
+
+typedef struct {
+    Byte                chip;
+    Pid                 pid;
+    Dword               error;
+    Byte                reserved[16];
+} AddPidRequest, *PAddPidRequest;
+
+typedef struct {
+    Byte                chip;
+    Pid                 pid;
+    Dword               error;
+    Byte                reserved[16];
+} RemovePidRequest, *PRemovePidRequest;
+
+typedef struct {
+    Byte            chip;
+    Dword           error;
+    Byte            reserved[16];
+} ResetPidRequest, *PResetPidRequest;
+
+typedef struct {
+    Byte                chip;
+    Byte                superFrameCount;
+    Word                packetUnit;
+    Dword               error;
+    Byte                reserved[16];
+} SetStatisticRangeRequest, *PSetStatisticRangeRequest;
+
+typedef struct {
+    Byte                chip;
+    Byte*               superFrameCount;
+    Word*               packetUnit;
+    Dword               error;
+    Byte                reserved[16];
+} GetStatisticRangeRequest, *PGetStatisticRangeRequest;
+
+typedef struct {
+    Byte                chip;
+    ChannelStatistic*   channelStatistic;
+    Dword               error;
+    Byte                reserved[16];
+} GetChannelStatisticRequest, *PGetChannelStatisticRequest;
+
+typedef struct {
+    Byte                chip;
+    Statistic*          statistic;
+    Dword               error;
+    Byte                reserved[16];
+} GetStatisticRequest, *PGetStatisticRequest;
+
+typedef struct {
+    Dword*              bufferLength;
+    Byte*               buffer;
+    Dword               error;
+    Byte                reserved[16];
+} GetDatagramRequest, *PGetDatagramRequest;
+
+typedef struct {
+    Byte            chip;
+    Byte            control;
+    Dword           error;
+    Byte            reserved[16];
+} ControlPidFilterRequest, *PControlPidFilterRequest;
+
+typedef struct {
+    Byte                chip;
+    Byte                control;
+    Dword               error;
+    Byte                reserved[16];
+} ControlPowerSavingRequest, *PControlPowerSavingRequest;
+
+typedef struct {
+    Byte                DriverVerion[16];   /** XX.XX.XX.XX Ex., 1.2.3.4            */
+    Byte                APIVerion[32];      /** XX.XX.XXXXXXXX.XX Ex., 1.2.3.4  */
+    Byte                FWVerionLink[16];   /** XX.XX.XX.XX Ex., 1.2.3.4            */
+    Byte                FWVerionOFDM[16];   /** XX.XX.XX.XX Ex., 1.2.3.4            */
+    Byte                DateTime[24];       /** Ex.,"2004-12-20 18:30:00" or "DEC 20 2004 10:22:10" with compiler __DATE__ and __TIME__  definitions */
+    Byte                Company[8];         /** Ex.,"Afatech"                   */
+    Byte                SupportHWInfo[32];  /** Ex.,"Jupiter DVBT/DVBH"         */
+    Dword               error;
+    Byte                reserved[128];
+} DemodDriverInfo, *PDemodDriverInfo;
+
+typedef struct {
+    Ensemble*           ensemble;
+    Dword               error;
+    Byte                reserved[16];
+} AcquireEnsembleRequest, *PAcquireEnsembleRequest;
+
+typedef struct {
+    Byte*               serviceLength;
+    Service*            services;
+    Dword               error;
+    Byte                reserved[16];
+} AcquireServiceRequest, *PAcquireServiceRequest;
+
+typedef struct {
+    Service             service;
+    Byte*               componentLength;
+    Component*          components;
+    Dword               error;
+    Byte                reserved[16];
+} AcquireComponentRequest, *PAcquireComponentRequest;
+
+typedef struct {
+    Component           component;
+    Dword               error;
+    Byte                reserved[16];
+} AddComponentRequest, *PAddComponentRequest;
+
+typedef struct {
+    Component           component;
+    Dword               error;
+    Byte                reserved[16];
+} RemoveComponentRequest, *PRemoveComponentRequest;
+
+typedef struct {
+    Byte                figType;
+    Byte                figExtension;
+    Dword               error;
+    Byte                reserved[16];
+} AddFigRequest, *PAddFigRequest;
+
+typedef struct {
+    Byte                figType;
+    Byte                figExtension;
+    Dword               error;
+    Byte                reserved[16];
+} RemoveFigRequest, *PRemoveFigRequest;
+
+
+/**
+ * Demodulator API commands
+ */
+
+/**
+ * First, download firmware from host to demodulator. Actually, firmware is
+ * put in firmware.h as a part of source code. Therefore, in order to
+ * update firmware the host have to re-compile the source code.
+ * Second, setting all parameters which will be need at the beginning.
+ * Paramters: None
+ */
+#define IOCTL_AFA_DEMOD_INITIALIZE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x003, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Set the output stream type of chip. Because the device could output in
+ * many stream type, therefore host have to choose one type before receive
+ * data.
+ * Paramters:   DemodStreamType struct
+ */
+#define IOCTL_AFA_DEMOD_SETSTREAMTYPE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x004, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Set the output stream type of chip. Because the device could output in
+ * many stream type, therefore host have to choose one type before receive
+ * data.
+ * Paramters:   DemodStreamType struct
+ */
+#define IOCTL_AFA_DEMOD_SETARCHITECTURE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x006, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Set the output stream type of chip. Because the device could output in
+ * many stream type, therefore host have to choose one type before receive
+ * data.
+ * Paramters:   DemodStreamType struct
+ */
+#define IOCTL_AFA_DEMOD_GETCHANNELMODULATION \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x008, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Set the output stream type of chip. Because the device could output in
+ * many stream type, therefore host have to choose one type before receive
+ * data.
+ * Paramters:   DemodStreamType struct
+ */
+#define IOCTL_AFA_DEMOD_GETFIRMWAREVERSION \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x009, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Specify the bandwidth of channel and tune the channel to the specific
+ * frequency. Afterwards, host could use output parameter dvbH to determine
+ * if there is a DVB-H signal.
+ * In DVB-T mode, after calling this function output parameter dvbH should
+ * be False and host could use output parameter "locked" to indicate if the
+ * TS is correct.
+ * In DVB-H mode, after calling this function output parameter dvbH should
+ * be True and host could use Jupiter_acquirePlatorm to get platform.
+ * Paramters:   DemodAcqCh struct
+ */
+#define IOCTL_AFA_DEMOD_ACQUIRECHANNEL \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x00A, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get all the platforms found in current frequency.
+ * Paramters:   DemodAcqPlatform struct
+ */
+#define IOCTL_AFA_DEMOD_ISLOCKED \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x00B, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get all the platforms found in current frequency.
+ * Paramters:   DemodAcqPlatform struct
+ */
+#define IOCTL_AFA_DEMOD_ACQUIREPLATFORM \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x00C, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Change the current platform as the specified platform. If the target
+ * platform is locate in different frequency, this function will tune to
+ * that frequency before setting platform.
+ * Paramters:   DemodSetPlatform struct
+ */
+#define IOCTL_AFA_DEMOD_SETPLATFORM \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x00D, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Add IP to IP filter.
+ * Paramters:   DemodIp struct
+ */
+#define IOCTL_AFA_DEMOD_ADDIP \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x00E, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Remove IP from IP filter.
+ * Paramters:   DemodIp struct
+ */
+#define IOCTL_AFA_DEMOD_REMOVEIP \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x00F, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Add PID to PID filter.
+ * Paramters:   DemodPid struct
+ */
+#define IOCTL_AFA_DEMOD_ADDPID \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x010, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Remove PID from PID filter.
+ * Paramters:   DemodPid struct
+ */
+#define IOCTL_AFA_DEMOD_REMOVEPID \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x011, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Reset PID from PID filter.
+ * Paramters:   ResetPidRequest struct
+ */
+#define IOCTL_AFA_DEMOD_RESETPID \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x012, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get data of one single section
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_GETSECTION \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x013, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_SETSTATISTICRANGE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x014, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_GETSTATISTICRANGE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x015, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_GETCHANNELSTATISTIC \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x016, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_GETSTATISTIC \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_GETINTERRUPTS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x018, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_CLEARINTERRUPT \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x019, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ * Paramters:   DemodGetStat struct
+ */
+#define IOCTL_AFA_DEMOD_GETDATAGRAM \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x01A, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ *
+ * Paramters:   DemodControl struct
+ */
+#define IOCTL_AFA_DEMOD_GETDELTAT \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x01B, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Enable PID filter.
+ * Paramters:   EnablePidRequest struct
+ */
+#define IOCTL_AFA_DEMOD_CONTROLPIDFILTER \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x01C, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ *
+ * Paramters:   DemodControl struct
+ */
+#define IOCTL_AFA_DEMOD_CONTROLTIMESLICING \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x01D, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ *
+ * Paramters:   DemodControl struct
+ */
+#define IOCTL_AFA_DEMOD_CONTROLPOWERSAVING \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x01E, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Power off the demodulators.
+ * Paramters:   None
+ */
+#define IOCTL_AFA_DEMOD_FINALIZE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x01F, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get driver information.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_GETDRIVERINFO \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x020, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get ensemble.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_ACQUIREENSEMBLE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x021, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get service.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_ACQUIRESERVICE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x022, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Get component.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_ACQUIRECOMPONENT \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x023, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Add component.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_ADDCOMPONENT \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x024, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Remove component.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_REMOVECOMPONENT \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x025, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Add FIG.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_ADDFIG \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x026, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Remove FIG.
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_REMOVEFIG \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x027, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+
+/**
+ * Demodulator Misc API commands
+ */
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Dword           registerAddress;
+    Byte            bufferLength;
+    Byte            buffer[256];
+    Dword           error;
+    Byte            reserved[16];
+} WriteRegistersRequest, *PWriteRegistersRequest;
+
+typedef struct {
+    Byte            chip;
+    Word            registerAddress;
+    Byte            bufferLength;
+    Byte            buffer[256];
+    Dword           error;
+    Byte            reserved[16];
+} WriteTunerRegistersRequest, *PWriteTunerRegistersRequest;
+
+typedef struct {
+    Byte            chip;
+    Word            registerAddress;
+    Byte            bufferLength;
+    Byte            buffer[256];
+    Dword           error;
+    Byte            reserved[16];
+} WriteEepromValuesRequest, *PWriteEepromValuesRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Dword           registerAddress;
+    Byte            position;
+    Byte            length;
+    Byte            value;
+    Dword           error;
+    Byte            reserved[16];
+} WriteRegisterBitsRequest, *PWriteRegisterBitsRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Word            variableIndex;
+    Byte            bufferLength;
+    Byte            buffer[256];
+    Dword           error;
+    Byte            reserved[16];
+} SetVariablesRequest, *PSetVariablesRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Word            variableIndex;
+    Byte            position;
+    Byte            length;
+    Byte            value;
+    Dword           error;
+    Byte            reserved[16];
+} SetVariableBitsRequest, *PSetVariableBitsRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Dword           registerAddress;
+    Byte            bufferLength;
+    Byte*           buffer;
+    Dword           error;
+    Byte            reserved[16];
+} ReadRegistersRequest, *PReadRegistersRequest;
+
+typedef struct {
+    Byte            chip;
+    Word            registerAddress;
+    Byte            bufferLength;
+    Byte*           buffer;
+    Dword           error;
+    Byte            reserved[16];
+} ReadTunerRegistersRequest, *PReadTunerRegistersRequest;
+
+typedef struct {
+    Byte            chip;
+    Word            registerAddress;
+    Byte            bufferLength;
+    Byte*           buffer;
+    Dword           error;
+    Byte            reserved[16];
+} ReadEepromValuesRequest, *PReadEepromValuesRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Dword           registerAddress;
+    Byte            position;
+    Byte            length;
+    Byte*           value;
+    Dword           error;
+    Byte            reserved[16];
+} ReadRegisterBitsRequest, *PReadRegisterBitsRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Word            variableIndex;
+    Byte            bufferLength;
+    Byte*           buffer;
+    Dword           error;
+    Byte            reserved[16];
+} GetVariablesRequest, *PGetVariablesRequest;
+
+typedef struct {
+    Byte            chip;
+    Processor       processor;
+    Word            variableIndex;
+    Byte            position;
+    Byte            length;
+    Byte*           value;
+    Dword           error;
+    Byte            reserved[16];
+} GetVariableBitsRequest, *PGetVariableBitsRequest;
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in demodulator.
+ * Paramters:   DemodRegs struct
+ */
+#define IOCTL_AFA_DEMOD_WRITEREGISTERS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x101, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Write a sequence of bytes to the contiguous registers in tuner.
+ * Paramters:   DemodTunerRegs struct
+ */
+#define IOCTL_AFA_DEMOD_WRITETUNERREGISTERS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x102, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Write a sequence of bytes to the contiguous cells in the EEPROM.
+ * Paramters:   DemodEEPROMVaules struct
+ */
+#define IOCTL_AFA_DEMOD_WRITEEEPROMVALUES \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x103, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Write one byte to the contiguous registers in demodulator.
+ * Paramters:   DemodRegs struct
+ */
+#define IOCTL_AFA_DEMOD_WRITEREGISTERBITS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x104, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Write a sequence of bytes to the contiguous variables in demodulator.
+ * Paramters:   DemodVariables struct
+ */
+#define IOCTL_AFA_DEMOD_SETVARIABLES \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x105, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Write a sequence of bytes to the contiguous variables in demodulator.
+ * Paramters:   DemodVariables struct
+ */
+#define IOCTL_AFA_DEMOD_SETVARIABLEBITS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x106, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Read a sequence of bytes from the contiguous registers in demodulator.
+ * Paramters:   DemodRegs struct
+ */
+#define IOCTL_AFA_DEMOD_READREGISTERS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x108, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Read a sequence of bytes from the contiguous registers in tuner.
+ * Paramters:   DemodTunerRegs
+ */
+#define IOCTL_AFA_DEMOD_READTUNERREGISTERS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x109, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Read a sequence of bytes from the contiguous cells in the EEPROM.
+ * Paramters:   DemodEEPROMVaules struct
+ */
+#define IOCTL_AFA_DEMOD_READEEPROMVALUES \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x10A, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Read a sequence of bytes from the contiguous registers in demodulator.
+ * Paramters:   DemodRegs struct
+ */
+#define IOCTL_AFA_DEMOD_READREGISTERBITS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x10B, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Read a sequence of bytes from the contiguous variables in demodulator.
+ * Paramters:   DemodVariables struct
+ */
+#define IOCTL_AFA_DEMOD_GETVARIABLES \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x10C, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+/**
+ * Read a sequence of bytes from the contiguous variables in demodulator.
+ * Paramters:   DemodVariables struct
+ */
+#define IOCTL_AFA_DEMOD_GETVARIABLEBITS \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x10D, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+
+
+/**
+ * Demodulator Stream control API commands
+ */
+
+typedef struct {
+    Byte            chip;
+    Dword           error;
+    Byte            reserved[16];
+} StartCaptureRequest, *PStartCaptureRequest;
+
+typedef struct {
+    Byte            chip;
+    Dword           error;
+    Byte            reserved[16];
+} StopCaptureRequest, *PStopCaptureRequest;
+
+/**
+ * Start capture data stream
+ * Paramters: DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_STARTCAPTURE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x200, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+
+/**
+ * Stop capture data stream
+ * Paramters:   DemodDriverInfo struct
+ */
+#define IOCTL_AFA_DEMOD_STOPCAPTURE \
+    CTL_CODE( MEDIA_DEVICE_AFADEMOD, 0x201, METHOD_BUFFERED, FILE_ANY_ACCESS )
+
+
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.c	2012-02-27 00:02:35.878915017 +0100
@@ -0,0 +1,203 @@
+/**
+ * Maxlinear_MXL5007.cpp
+ *
+ * Interface btw Afa9035 and Mxl5007T
+ */
+
+#include "a867_Maxlinear_MXL5007.h"
+#include "a867_Maxlinear_MXL5007_Script.h"
+#include "a867_mxl5007t.h"
+#include "a867_af903x.h"
+
+//m100 todo MxL5007_TunerConfigS MxL5007_TunerConfig = 0;
+struct mxl5007t_config MxL5007_TunerConfig;
+
+Dword MXL5007_WriteI2C(
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Byte*			pAddress,
+	IN  Byte*			pData,
+	IN  Dword			count
+) {
+    Dword error = Error_NO_ERROR;                /* Status to be returned        */
+    Byte buffer[25];
+    //Byte numberOfRegisters = 9;
+    Byte i;
+
+/** single write */
+    for (i = 0; i < count; i++) {
+        buffer[0] = *(pAddress + i);
+        buffer[1] = *(pData + i);
+        //buffer[2] = 0xFE;  /** Latch CMD request by MXL5005 Confidential Datasheet */
+		error = Standard_writeTunerRegisters (demodulator, chip, buffer[0], 1, &buffer[1]);
+		if (error){
+			deb_data("MXL5007_WriteI2C failed");
+			goto exit;
+		}
+    }
+exit:
+    return (error);
+}
+
+
+UINT32 MxL_I2C_Write(UINT8 DeviceAddr, void* pArray, UINT32 ByteCount, struct mxl5007t_config* myTuner)
+{
+    Dword error = Error_NO_ERROR;                /* Status to be returned */
+    // Byte buffer[25];
+    // Byte i;
+	Byte* pData;
+	pData = (Byte*)pArray;
+    
+/** single write */
+    //buffer[2] = 0xFE;  /** Latch CMD request by MXL5005 Confidential Datasheet */
+	if (ByteCount == 1) 
+		error = Standard_writeTunerRegisters ((myTuner->demodulator), (myTuner->chip), pData[0], 0, NULL);
+	else if (ByteCount > 1)
+		error = Standard_writeTunerRegisters ((myTuner->demodulator), (myTuner->chip), pData[0], ByteCount - 1, &pData[1]);
+	else
+	{	
+		error = Error_INVALID_DATA_LENGTH;
+		deb_data("MxL_I2C_Write:: ByteCount = 0"); 
+	}
+
+	if (error){
+		deb_data("MxL_I2C_Write failed");
+		goto exit;
+	}
+
+exit:
+    return (error);
+}
+
+
+UINT32 MxL_I2C_Read(UINT8 DeviceAddr, UINT8 Addr, UINT8* mData, struct mxl5007t_config* myTuner)
+{
+	Dword error = Error_NO_ERROR;
+
+	error = Standard_writeTunerRegisters(myTuner->demodulator, myTuner->chip, 0xFB, 1, &Addr);
+	error = Standard_readTunerRegisters (myTuner->demodulator, myTuner->chip, 0xffff, 1, mData);
+
+	return (error);
+}
+
+void MxL_Delay(UINT32 mSec)
+{
+	User_delay(NULL, mSec);
+}
+
+
+Dword MXL5007_open (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+) {
+	Ganymede* ganymede;
+	ganymede = (Ganymede*) demodulator;
+	MxL5007_TunerConfig.demodulator = demodulator;
+	MxL5007_TunerConfig.chip = chip;
+
+	//MxL5007_TunerConfig.I2C_Addr = MxL_I2C_ADDR_096;	// 7-bit address
+	MxL5007_TunerConfig.I2C_Addr = ganymede->tunerDescription->tunerAddress; //Get from tunerDescription
+
+	//MxL5007_TunerConfig.IF_Freq = MxL_IF_4_57_MHZ;
+	switch( ganymede->tunerDescription->ifFrequency ) {
+	case 4000000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_4_MHZ; break;
+	case 4500000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_4_5_MHZ; break;
+	case 4570000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_4_57_MHZ; break;
+	case 5000000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_5_MHZ; break;
+	case 5380000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_5_38_MHZ; break;
+	case 6000000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_6_MHZ; break;
+	case 6280000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_6_28_MHZ; break;
+	case 9191500:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_9_1915_MHZ; break;
+	case 35250000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_35_25_MHZ; break;
+	case 36150000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_36_15_MHZ; break;
+	case 44000000:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_44_MHZ; break;
+	default:
+		MxL5007_TunerConfig.if_freq_hz = MxL_IF_4_57_MHZ;
+		printk("IF unsupported\n");
+		break;
+	}
+
+	//MxL5007_TunerConfig.IF_Spectrum = MxL_NORMAL_IF;
+	if (ganymede->tunerDescription->inversion == True)
+		MxL5007_TunerConfig.invert_if = 1; //Get from tunerDescription
+	else
+		MxL5007_TunerConfig.invert_if = 0;
+
+	MxL5007_TunerConfig.Mode = MxL_MODE_DVBT;
+	MxL5007_TunerConfig.if_diff_out_level = -8; //Setting for Cable mode only
+	MxL5007_TunerConfig.xtal_freq_hz = MxL_XTAL_24_MHZ;	//24Mhz
+	MxL5007_TunerConfig.clk_out_enable = 0;
+	MxL5007_TunerConfig.clk_out_amp = MxL_CLKOUT_AMP_0_94V;
+	
+	if( ganymede->booted )
+	a867_mxl5007t_attach(&MxL5007_TunerConfig);
+	deb_data("MxL5007 Open");
+
+    return (Error_NO_ERROR);
+}
+
+
+Dword MXL5007_close (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+) {
+	a867_mxl5007t_release(MxL5007_TunerConfig.state);
+    return (Error_NO_ERROR);
+}
+
+
+Dword MXL5007_set (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Word			bandwidth,
+	IN  Dword			frequency
+) {
+	// Dword status = 0;       
+
+	deb_data("MxL5007 Set");
+	if(	a867_mxl5007t_set_params(MxL5007_TunerConfig.state, (enum mxl5007t_bw_mhz) (bandwidth / 1000), frequency * 1000) ) {
+		deb_data("MxL5007 Set fail");
+		return (Error_WRITE_TUNER_FAIL);
+	}
+
+	return (Error_NO_ERROR);
+}
+
+
+Dword SwPowerCtrlMXL5007(
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+	IN  Byte			control			/** 0 for power down mode, 1 for normal operation mode */
+)
+{
+    return (Error_NO_ERROR);
+}
+
+
+
+TunerDescription tuner_MXL5007 = {
+    MXL5007_open,
+    MXL5007_close,
+    MXL5007_set,
+    MXL5007_scripts,
+    MXL5007_scriptSets,
+    0xC0,                           /** tuner i2c address */
+    1,                              /** length of tuner register address */
+    4570000,				                /* ref. mxl5007t.h/mxl5007t_if_freq */
+    False                           /** spectrum inverse */
+};
+
+
+
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007.h	2012-02-27 00:02:36.818915017 +0100
@@ -0,0 +1,60 @@
+/**
+ * Maxlinear_MXL5007.h
+ *
+ * Interface btw Afa9035 and Mxl5007T
+ */
+
+#ifndef __Maxlinear_MXL5007_H__
+#define __Maxlinear_MXL5007_H__
+
+#include "a867_type.h"
+#include "a867_error.h"
+#include "a867_user.h"
+#include "a867_register.h"
+#include "a867_standard.h"
+#include "a867_mxl5007t.h"
+#include "a867_Common.h"	//for Tuner_struct
+typedef unsigned int	UINT32;
+typedef unsigned char	UINT8;
+
+extern TunerDescription tuner_MXL5007;
+
+/**
+ *
+ */
+
+UINT32 MxL_I2C_Write(UINT8 DeviceAddr, void* pArray, UINT32 ByteCount, struct mxl5007t_config* myTuner);
+UINT32 MxL_I2C_Read(UINT8 DeviceAddr, UINT8 Addr, UINT8* mData, struct mxl5007t_config* myTuner);
+void MxL_Delay(UINT32 mSec);
+
+
+/**
+ *
+ */
+Dword MXL5007_open (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+
+/**
+ *
+ */
+Dword MXL5007_close (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip
+);
+
+
+/**
+ *
+ */
+Dword MXL5007_set (
+	IN  Demodulator*	demodulator,
+	IN  Byte			chip,
+    IN  Word			bandwidth,
+    IN  Dword			frequency
+);
+
+#endif //__Maxlinear_MXL5007_H__
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007_Script.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007_Script.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007_Script.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_Maxlinear_MXL5007_Script.h	2012-02-27 00:02:36.818915017 +0100
@@ -0,0 +1,64 @@
+/** script version */
+
+#define MXL5007_ADDRESS 0xC0
+#define MXL5007_SCRIPTSETLENGTH	0x00000001
+
+
+Word MXL5007_scriptSets[] = {
+	0x34
+};
+
+ValueSet MXL5007_scripts[] = {
+ {0x0046, 0x04},
+ {0x0057, 0x00},
+ {0x0058, 0x01},
+ {0x005f, 0x00},
+ {0x0060, 0x00},
+ {0x006e, 0x01},
+ {0x0071, 0x0A},
+ {0x0072, 0x02},
+ {0x0074, 0x01},
+ {0x0079, 0x01},
+ {0x0093, 0x00},
+ {0x0094, 0x00},
+ {0x0095, 0x00},
+ {0x0096, 0x00},
+ {0x009b, 0x20},
+ {0x009c, 0x66},
+ {0x00b3, 0x01},
+ {0x00c3, 0x0},
+ {0x00c4, 0x0},
+ {0x00c7, 0x59},
+ {0xF007, 0x00},
+ {0xF00A, 0x1B},
+ {0xF00B, 0x1B},
+ {0xF00C, 0x1B},
+ {0xF00D, 0x1B},
+ {0xF00E, 0xFF},
+ {0xF00F, 0x01},
+ {0xF010, 0x00},
+ {0xF011, 0x02},
+ {0xF012, 0xFF},
+ {0xF013, 0x01},
+ {0xF014, 0x00},
+ {0xF015, 0x02},
+ {0xF01B, 0xEF},
+ {0xF01C, 0x01},
+ {0xF01D, 0x0f},
+ {0xF01E, 0x02},
+ {0xF01F, 0x6e},
+ {0xF020, 0x00},
+ {0xF025, 0xDE},
+ {0xF026, 0x00},
+ {0xF027, 0x0A},
+ {0xF028, 0x03},
+ {0xF029, 0x6e},
+ {0xF02A, 0x00},
+ {0xF047, 0x00},
+ {0xF054, 0x0},
+ {0xF055, 0x0},
+ {0xF077, 0x02},
+ {0xF14F, 0x02},
+ {0xF1E6, 0x00},
+ {0xF163, 0x02},
+};
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.c	2012-02-27 00:02:36.818915017 +0100
@@ -0,0 +1,698 @@
+/*
+ *  mxl5007t.c - driver for the MaxLinear MxL5007T silicon tuner
+ *
+ *  Copyright (C) 2008, 2009 Michael Krufky <mkrufky@linuxtv.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * The code is modified to accommodate the AF903x source code on 2010/6/7
+ */
+
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/slab.h>
+#include "a867_mxl5007t.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define mxl_printk(kern, fmt, arg...) \
+	printk(kern "%s: " fmt "\n", __func__, ##arg)
+
+#define mxl_err(fmt, arg...) \
+	mxl_printk(KERN_ERR, "%d: " fmt, __LINE__, ##arg)
+
+#define mxl_warn(fmt, arg...) \
+	mxl_printk(KERN_WARNING, fmt, ##arg)
+
+#define mxl_info(fmt, arg...) \
+	mxl_printk(KERN_INFO, fmt, ##arg)
+
+#define mxl_debug(fmt, arg...)				\
+({							\
+	if (1)				\
+		mxl_printk(KERN_DEBUG, fmt, ##arg);	\
+})
+
+#define mxl_fail(ret)							\
+({									\
+	int __ret;							\
+	__ret = (ret < 0);						\
+	if (__ret)							\
+		mxl_printk(KERN_ERR, "error %d on line %d",		\
+			   ret, __LINE__);				\
+	__ret;								\
+})
+
+/* ------------------------------------------------------------------------- */
+
+#define MHz 1000000
+
+
+#include "a867_Maxlinear_MXL5007.h"
+
+
+struct reg_pair_t {
+	u8 reg;
+	u8 val;
+};
+
+/* ------------------------------------------------------------------------- */
+
+static struct reg_pair_t init_tab[] = {
+	{ 0x02, 0x06 },
+	{ 0x03, 0x48 },
+	{ 0x05, 0x04 },
+	{ 0x06, 0x10 },
+	{ 0x2e, 0x15 }, /* OVERRIDE */
+	{ 0x30, 0x10 }, /* OVERRIDE */
+	{ 0x45, 0x58 }, /* OVERRIDE */
+	{ 0x48, 0x19 }, /* OVERRIDE */
+	{ 0x52, 0x03 }, /* OVERRIDE */
+	{ 0x53, 0x44 }, /* OVERRIDE */
+	{ 0x6a, 0x4b }, /* OVERRIDE */
+	{ 0x76, 0x00 }, /* OVERRIDE */
+	{ 0x78, 0x18 }, /* OVERRIDE */
+	{ 0x7a, 0x17 }, /* OVERRIDE */
+	{ 0x85, 0x06 }, /* OVERRIDE */
+	{ 0x01, 0x01 }, /* TOP_MASTER_ENABLE */
+	{ 0, 0 }
+};
+
+static struct reg_pair_t init_tab_cable[] = {
+	{ 0x02, 0x06 },
+	{ 0x03, 0x48 },
+	{ 0x05, 0x04 },
+	{ 0x06, 0x10 },
+	{ 0x09, 0x3f },
+	{ 0x0a, 0x3f },
+	{ 0x0b, 0x3f },
+	{ 0x2e, 0x15 }, /* OVERRIDE */
+	{ 0x30, 0x10 }, /* OVERRIDE */
+	{ 0x45, 0x58 }, /* OVERRIDE */
+	{ 0x48, 0x19 }, /* OVERRIDE */
+	{ 0x52, 0x03 }, /* OVERRIDE */
+	{ 0x53, 0x44 }, /* OVERRIDE */
+	{ 0x6a, 0x4b }, /* OVERRIDE */
+	{ 0x76, 0x00 }, /* OVERRIDE */
+	{ 0x78, 0x18 }, /* OVERRIDE */
+	{ 0x7a, 0x17 }, /* OVERRIDE */
+	{ 0x85, 0x06 }, /* OVERRIDE */
+	{ 0x01, 0x01 }, /* TOP_MASTER_ENABLE */
+	{ 0, 0 }
+};
+
+/* ------------------------------------------------------------------------- */
+
+static struct reg_pair_t reg_pair_rftune[] = {
+	{ 0x0f, 0x00 }, /* abort tune */
+	{ 0x0c, 0x15 },
+	{ 0x0d, 0x40 },
+	{ 0x0e, 0x0e },
+	{ 0x1f, 0x87 }, /* OVERRIDE */
+	{ 0x20, 0x1f }, /* OVERRIDE */
+	{ 0x21, 0x87 }, /* OVERRIDE */
+	{ 0x22, 0x1f }, /* OVERRIDE */
+	{ 0x80, 0x01 }, /* freq dependent */
+	{ 0x0f, 0x01 }, /* start tune */
+	{ 0, 0 }
+};
+
+/* ------------------------------------------------------------------------- */
+
+
+
+/* ------------------------------------------------------------------------- */
+
+/* called by _init and _rftun to manipulate the register arrays */
+
+static void set_reg_bits(struct reg_pair_t *reg_pair, u8 reg, u8 mask, u8 val)
+{
+	unsigned int i = 0;
+
+	while (reg_pair[i].reg || reg_pair[i].val) {
+		if (reg_pair[i].reg == reg) {
+			reg_pair[i].val &= ~mask;
+			reg_pair[i].val |= val;
+		}
+		i++;
+
+	}
+	return;
+}
+
+static void copy_reg_bits(struct reg_pair_t *reg_pair1,
+			  struct reg_pair_t *reg_pair2)
+{
+	unsigned int i, j;
+
+	i = j = 0;
+
+	while (reg_pair1[i].reg || reg_pair1[i].val) {
+		while (reg_pair2[j].reg || reg_pair2[j].val) {
+			if (reg_pair1[i].reg != reg_pair2[j].reg) {
+				j++;
+				continue;
+			}
+			reg_pair2[j].val = reg_pair1[i].val;
+			break;
+		}
+		i++;
+	}
+	return;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void mxl5007t_set_mode_bits(struct mxl5007t_state *state,
+				   enum mxl5007t_mode mode,
+				   s32 if_diff_out_level)
+{
+	switch (mode) {
+	case MxL_MODE_ATSC:
+		set_reg_bits(state->tab_init, 0x06, 0x1f, 0x12);
+		break;
+	case MxL_MODE_DVBT:
+		set_reg_bits(state->tab_init, 0x06, 0x1f, 0x11);
+		break;
+	case MxL_MODE_ISDBT:
+		set_reg_bits(state->tab_init, 0x06, 0x1f, 0x10);
+		break;
+	case MxL_MODE_CABLE:
+		set_reg_bits(state->tab_init_cable, 0x09, 0xff, 0xc1);
+		set_reg_bits(state->tab_init_cable, 0x0a, 0xff,
+			     8 - if_diff_out_level);
+		set_reg_bits(state->tab_init_cable, 0x0b, 0xff, 0x17);
+		break;
+	default:
+		mxl_fail(-EINVAL);
+	}
+	return;
+}
+
+static void mxl5007t_set_if_freq_bits(struct mxl5007t_state *state,
+				      enum mxl5007t_if_freq if_freq,
+				      int invert_if)
+{
+	u8 val;
+
+	switch (if_freq) {
+	case MxL_IF_4_MHZ:
+		val = 0x00;
+		break;
+	case MxL_IF_4_5_MHZ:
+		val = 0x02;
+		break;
+	case MxL_IF_4_57_MHZ:
+		val = 0x03;
+		break;
+	case MxL_IF_5_MHZ:
+		val = 0x04;
+		break;
+	case MxL_IF_5_38_MHZ:
+		val = 0x05;
+		break;
+	case MxL_IF_6_MHZ:
+		val = 0x06;
+		break;
+	case MxL_IF_6_28_MHZ:
+		val = 0x07;
+		break;
+	case MxL_IF_9_1915_MHZ:
+		val = 0x08;
+		break;
+	case MxL_IF_35_25_MHZ:
+		val = 0x09;
+		break;
+	case MxL_IF_36_15_MHZ:
+		val = 0x0a;
+		break;
+	case MxL_IF_44_MHZ:
+		val = 0x0b;
+		break;
+	default:
+		mxl_fail(-EINVAL);
+		return;
+	}
+	set_reg_bits(state->tab_init, 0x02, 0x0f, val);
+
+	/* set inverted IF or normal IF */
+	set_reg_bits(state->tab_init, 0x02, 0x10, invert_if ? 0x10 : 0x00);
+
+	return;
+}
+
+static void mxl5007t_set_xtal_freq_bits(struct mxl5007t_state *state,
+					enum mxl5007t_xtal_freq xtal_freq)
+{
+	switch (xtal_freq) {
+	case MxL_XTAL_16_MHZ:
+		/* select xtal freq & ref freq */
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x00);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x00);
+		break;
+	case MxL_XTAL_20_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x10);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x01);
+		break;
+	case MxL_XTAL_20_25_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x20);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x02);
+		break;
+	case MxL_XTAL_20_48_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x30);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x03);
+		break;
+	case MxL_XTAL_24_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x40);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x04);
+		break;
+	case MxL_XTAL_25_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x50);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x05);
+		break;
+	case MxL_XTAL_25_14_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x60);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x06);
+		break;
+	case MxL_XTAL_27_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x70);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x07);
+		break;
+	case MxL_XTAL_28_8_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x80);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x08);
+		break;
+	case MxL_XTAL_32_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0x90);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x09);
+		break;
+	case MxL_XTAL_40_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0xa0);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x0a);
+		break;
+	case MxL_XTAL_44_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0xb0);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x0b);
+		break;
+	case MxL_XTAL_48_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0xc0);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x0c);
+		break;
+	case MxL_XTAL_49_3811_MHZ:
+		set_reg_bits(state->tab_init, 0x03, 0xf0, 0xd0);
+		set_reg_bits(state->tab_init, 0x05, 0x0f, 0x0d);
+		break;
+	default:
+		mxl_fail(-EINVAL);
+		return;
+	}
+
+	return;
+}
+
+static struct reg_pair_t *mxl5007t_calc_init_regs(struct mxl5007t_state *state,
+						  enum mxl5007t_mode mode)
+{
+	struct mxl5007t_config *cfg = state->config;
+
+	memcpy(state->tab_init, init_tab, sizeof(init_tab));
+	memcpy(state->tab_init_cable, init_tab_cable, sizeof(init_tab_cable));
+
+	mxl5007t_set_mode_bits(state, mode, cfg->if_diff_out_level);
+	mxl5007t_set_if_freq_bits(state, cfg->if_freq_hz, cfg->invert_if);
+	mxl5007t_set_xtal_freq_bits(state, cfg->xtal_freq_hz);
+
+	set_reg_bits(state->tab_init, 0x04, 0x01, cfg->loop_thru_enable);
+	set_reg_bits(state->tab_init, 0x03, 0x08, cfg->clk_out_enable << 3);
+	set_reg_bits(state->tab_init, 0x03, 0x07, cfg->clk_out_amp);
+
+	if (mode >= MxL_MODE_CABLE) {
+		copy_reg_bits(state->tab_init, state->tab_init_cable);
+		return state->tab_init_cable;
+	} else
+		return state->tab_init;
+}
+
+static void mxl5007t_set_bw_bits(struct mxl5007t_state *state,
+				 enum mxl5007t_bw_mhz bw)
+{
+	u8 val;
+
+	switch (bw) {
+	case MxL_BW_6MHz:
+		val = 0x15; /* set DIG_MODEINDEX, DIG_MODEINDEX_A,
+			     * and DIG_MODEINDEX_CSF */
+		break;
+	case MxL_BW_7MHz:
+		val = 0x2a;
+		break;
+	case MxL_BW_8MHz:
+		val = 0x3f;
+		break;
+	default:
+		mxl_fail(-EINVAL);
+		return;
+	}
+	set_reg_bits(state->tab_rftune, 0x0c, 0x3f, val);
+
+	return;
+}
+
+static struct
+reg_pair_t *mxl5007t_calc_rf_tune_regs(struct mxl5007t_state *state,
+				       u32 rf_freq, enum mxl5007t_bw_mhz bw)
+{
+	u32 dig_rf_freq = 0;
+	u32 temp;
+	u32 frac_divider = 1000000;
+	unsigned int i;
+
+	memcpy(state->tab_rftune, reg_pair_rftune, sizeof(reg_pair_rftune));
+
+	mxl5007t_set_bw_bits(state, bw);
+
+	/* Convert RF frequency into 16 bits =>
+	 * 10 bit integer (MHz) + 6 bit fraction */
+	dig_rf_freq = rf_freq / MHz;
+
+	temp = rf_freq % MHz;
+
+	for (i = 0; i < 6; i++) {
+		dig_rf_freq <<= 1;
+		frac_divider /= 2;
+		if (temp > frac_divider) {
+			temp -= frac_divider;
+			dig_rf_freq++;
+		}
+	}
+
+	/* add to have shift center point by 7.8124 kHz */
+	if (temp > 7812)
+		dig_rf_freq++;
+
+	set_reg_bits(state->tab_rftune, 0x0d, 0xff, (u8) dig_rf_freq);
+	set_reg_bits(state->tab_rftune, 0x0e, 0xff, (u8) (dig_rf_freq >> 8));
+
+	if (rf_freq >= 333000000)
+		set_reg_bits(state->tab_rftune, 0x80, 0x40, 0x40);
+
+	return state->tab_rftune;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static int mxl5007t_write_reg(struct mxl5007t_state *state, u8 reg, u8 val)
+{
+	u8 buf[] = { reg, val };
+	int ret = MxL_I2C_Write(state->config->I2C_Addr, buf, 2, state->config);
+	if (ret) {
+		mxl_err("failed!");
+		return -EREMOTEIO;
+	}
+	
+	return ret;
+}
+
+static int mxl5007t_write_regs(struct mxl5007t_state *state,
+			       struct reg_pair_t *reg_pair)
+{
+	unsigned int i = 0;
+	int ret = 0;
+
+	while ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {
+		ret = mxl5007t_write_reg(state,
+		reg_pair[i].reg, reg_pair[i].val);
+		i++;
+	}
+
+	return ret;
+}
+
+/* unused
+static int mxl5007t_read_reg(struct mxl5007t_state *state, u8 reg, u8 *val)
+{
+	int ret = MxL_I2C_Read(state->config->I2C_Addr, reg, val, state->config);
+
+	if (ret) {
+		mxl_err("failed!");
+		return -EREMOTEIO;
+	}
+	return ret;
+}
+
+*/
+
+static int mxl5007t_soft_reset(struct mxl5007t_state *state)
+{
+	u8 d = 0xff;
+	
+	int ret = MxL_I2C_Write(state->config->I2C_Addr, &d, 1, state->config);
+	if (ret) {
+		mxl_err("failed!");
+		return -EREMOTEIO;
+	}
+	return ret;
+}
+
+static int mxl5007t_tuner_init(struct mxl5007t_state *state,
+			       enum mxl5007t_mode mode)
+{
+	struct reg_pair_t *init_regs;
+	int ret;
+
+	ret = mxl5007t_soft_reset(state);
+	if (mxl_fail(ret))
+		goto fail;
+
+	/* calculate initialization reg array */
+	init_regs = mxl5007t_calc_init_regs(state, mode);
+
+	ret = mxl5007t_write_regs(state, init_regs);
+	if (mxl_fail(ret))
+		goto fail;
+	mdelay(1);
+fail:
+	return ret;
+}
+
+static int mxl5007t_tuner_rf_tune(struct mxl5007t_state *state, u32 rf_freq_hz,
+				  enum mxl5007t_bw_mhz bw)
+{
+	struct reg_pair_t *rf_tune_regs;
+	int ret;
+
+	/* calculate channel change reg array */
+	rf_tune_regs = mxl5007t_calc_rf_tune_regs(state, rf_freq_hz, bw);
+
+	ret = mxl5007t_write_regs(state, rf_tune_regs);
+	if (mxl_fail(ret))
+		goto fail;
+	msleep(3);
+fail:
+	return ret;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* unused
+static int mxl5007t_synth_lock_status(struct mxl5007t_state *state,
+				      int *rf_locked, int *ref_locked)
+{
+	u8 d;
+	int ret;
+
+	*rf_locked = 0;
+	*ref_locked = 0;
+
+	ret = mxl5007t_read_reg(state, 0xd8, &d);
+	if (mxl_fail(ret))
+		goto fail;
+
+	if ((d & 0x0c) == 0x0c)
+		*rf_locked = 1;
+
+	if ((d & 0x03) == 0x03)
+		*ref_locked = 1;
+fail:
+	return ret;
+}
+*/
+
+/* ------------------------------------------------------------------------- */
+
+int a867_mxl5007t_set_params(struct mxl5007t_state *state, enum mxl5007t_bw_mhz bw, u32 freq)
+{
+	int ret;
+
+	mutex_lock(&state->lock);
+
+	ret = mxl5007t_tuner_init(state, state->config->Mode);
+	if (mxl_fail(ret))
+		goto fail;
+
+	ret = mxl5007t_tuner_rf_tune(state, freq, bw);
+	if (mxl_fail(ret))
+		goto fail;
+
+	state->frequency = freq;	//hz
+	state->bandwidth = bw;		//6, 7 ,8
+fail:
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* unused
+static int mxl5007t_init(struct mxl5007t_state *state)
+{
+	int ret;
+
+	// wake from standby 
+	ret = mxl5007t_write_reg(state, 0x01, 0x01);
+	mxl_fail(ret);
+
+	return ret;
+}
+
+*/
+
+/* unused
+static int mxl5007t_sleep(struct mxl5007t_state *state)
+{
+	int ret;
+
+	// enter standby mode 
+	ret = mxl5007t_write_reg(state, 0x01, 0x00);
+	mxl_fail(ret);
+	ret = mxl5007t_write_reg(state, 0x0f, 0x00);
+	mxl_fail(ret);
+
+	return ret;
+}
+*/
+
+/* ------------------------------------------------------------------------- */
+
+/* unused
+static int mxl5007t_get_frequency(struct mxl5007t_state *state, u32 *frequency)
+{
+	*frequency = state->frequency;
+	return 0;
+}
+
+*/
+
+/* unused
+static int mxl5007t_get_bandwidth(struct mxl5007t_state *state, u32 *bandwidth)
+{
+	*bandwidth = state->bandwidth;
+	return 0;
+}
+*/
+
+void a867_mxl5007t_release(struct mxl5007t_state *state)
+{
+	if( state ) {
+		if( state->tab_init ) kfree(state->tab_init);
+		if( state->tab_init_cable ) kfree(state->tab_init_cable);
+		if( state->tab_rftune ) kfree(state->tab_rftune);
+		state->config->state = NULL;
+		kfree(state);
+	}
+}
+
+/* unused
+static int mxl5007t_get_chip_id(struct mxl5007t_state *state)
+{
+	char *name;
+	int ret;
+	u8 id;
+
+	ret = mxl5007t_read_reg(state, 0xd9, &id);
+	if (mxl_fail(ret))
+		goto fail;
+
+	switch (id) {
+	case MxL_5007_V1_F1:
+		name = "MxL5007.v1.f1";
+		break;
+	case MxL_5007_V1_F2:
+		name = "MxL5007.v1.f2";
+		break;
+	case MxL_5007_V2_100_F1:
+		name = "MxL5007.v2.100.f1";
+		break;
+	case MxL_5007_V2_100_F2:
+		name = "MxL5007.v2.100.f2";
+		break;
+	case MxL_5007_V2_200_F1:
+		name = "MxL5007.v2.200.f1";
+		break;
+	case MxL_5007_V2_200_F2:
+		name = "MxL5007.v2.200.f2";
+		break;
+	case MxL_5007_V4:
+		name = "MxL5007T.v4";
+		break;
+	default:
+		name = "MxL5007T";
+		printk(KERN_WARNING "%s: unknown rev (%02x)\n", __func__, id);
+		id = MxL_UNKNOWN_ID;
+	}
+	state->chip_id = id;
+	return 0;
+
+fail:
+	state->chip_id = MxL_UNKNOWN_ID;
+	return ret;
+}
+*/
+
+void a867_mxl5007t_attach(struct mxl5007t_config *cfg)
+{
+	struct mxl5007t_state *state;
+
+	state = kzalloc(sizeof(struct mxl5007t_state), GFP_KERNEL);
+	if( state == NULL ) return;
+
+	mutex_init(&state->lock);
+
+	state->config = cfg;
+	cfg->state = state;
+	state->tab_init = kzalloc(sizeof(init_tab), GFP_KERNEL);
+	if( !state->tab_init ) goto error;
+
+	state->tab_init_cable = kzalloc(sizeof(init_tab_cable), GFP_KERNEL);
+	if( !state->tab_init_cable ) goto error;
+
+	state->tab_rftune = kzalloc(sizeof(reg_pair_rftune), GFP_KERNEL);
+	if( !state->tab_rftune ) goto error;
+	return;
+error:
+	printk("fail to allocate memory\n");
+	return;
+}
+
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_mxl5007t.h	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,135 @@
+/*
+ *  mxl5007t.h - driver for the MaxLinear MxL5007T silicon tuner
+ *
+ *  Copyright (C) 2008 Michael Krufky <mkrufky@linuxtv.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * =============> modified from that in linux-2.6.34
+ */
+
+#ifndef __MXL5007T_H__
+#define __MXL5007T_H__
+
+#include "a867_type.h"
+/* ------------------------------------------------------------------------- */
+
+enum mxl5007t_if_freq {
+	MxL_IF_4_MHZ,      /*  4000000 */
+	MxL_IF_4_5_MHZ,    /*  4500000 */
+	MxL_IF_4_57_MHZ,   /*  4570000 */
+	MxL_IF_5_MHZ,      /*  5000000 */
+	MxL_IF_5_38_MHZ,   /*  5380000 */
+	MxL_IF_6_MHZ,      /*  6000000 */
+	MxL_IF_6_28_MHZ,   /*  6280000 */
+	MxL_IF_9_1915_MHZ, /*  9191500 */
+	MxL_IF_35_25_MHZ,  /* 35250000 */
+	MxL_IF_36_15_MHZ,  /* 36150000 */
+	MxL_IF_44_MHZ,     /* 44000000 */
+};
+
+enum mxl5007t_xtal_freq {
+	MxL_XTAL_16_MHZ,      /* 16000000 */
+	MxL_XTAL_20_MHZ,      /* 20000000 */
+	MxL_XTAL_20_25_MHZ,   /* 20250000 */
+	MxL_XTAL_20_48_MHZ,   /* 20480000 */
+	MxL_XTAL_24_MHZ,      /* 24000000 */
+	MxL_XTAL_25_MHZ,      /* 25000000 */
+	MxL_XTAL_25_14_MHZ,   /* 25140000 */
+	MxL_XTAL_27_MHZ,      /* 27000000 */
+	MxL_XTAL_28_8_MHZ,    /* 28800000 */
+	MxL_XTAL_32_MHZ,      /* 32000000 */
+	MxL_XTAL_40_MHZ,      /* 40000000 */
+	MxL_XTAL_44_MHZ,      /* 44000000 */
+	MxL_XTAL_48_MHZ,      /* 48000000 */
+	MxL_XTAL_49_3811_MHZ, /* 49381100 */
+};
+
+enum mxl5007t_clkout_amp {
+	MxL_CLKOUT_AMP_0_94V = 0,
+	MxL_CLKOUT_AMP_0_53V = 1,
+	MxL_CLKOUT_AMP_0_37V = 2,
+	MxL_CLKOUT_AMP_0_28V = 3,
+	MxL_CLKOUT_AMP_0_23V = 4,
+	MxL_CLKOUT_AMP_0_20V = 5,
+	MxL_CLKOUT_AMP_0_17V = 6,
+	MxL_CLKOUT_AMP_0_15V = 7,
+};
+
+enum mxl5007t_mode {
+	MxL_MODE_ISDBT     =    0,
+	MxL_MODE_DVBT      =    1,
+	MxL_MODE_ATSC      =    2,
+	MxL_MODE_CABLE     = 0x10,
+};
+
+enum mxl5007t_bw_mhz {
+	MxL_BW_6MHz = 6,
+	MxL_BW_7MHz = 7,
+	MxL_BW_8MHz = 8,
+};
+
+struct mxl5007t_config;
+enum mxl5007t_chip_version {
+	MxL_UNKNOWN_ID     = 0x00,
+	MxL_5007_V1_F1     = 0x11,
+	MxL_5007_V1_F2     = 0x12,
+	MxL_5007_V4        = 0x14,
+	MxL_5007_V2_100_F1 = 0x21,
+	MxL_5007_V2_100_F2 = 0x22,
+	MxL_5007_V2_200_F1 = 0x23,
+	MxL_5007_V2_200_F2 = 0x24,
+};
+
+struct mxl5007t_state {
+	struct mutex lock;
+	struct mxl5007t_config *config;
+	enum mxl5007t_chip_version chip_id;
+	struct reg_pair_t *tab_init;
+	struct reg_pair_t *tab_init_cable;
+	struct reg_pair_t *tab_rftune;
+	u32 frequency;
+	u32 bandwidth;
+};
+
+struct mxl5007t_config {
+	Demodulator*	demodulator;	//AF9035 instance //todo include
+	unsigned char			chip;			//AF9035 instance
+	unsigned char			I2C_Addr;
+	enum mxl5007t_mode	Mode;
+	struct mxl5007t_state *state;
+	s32 if_diff_out_level;
+	enum mxl5007t_clkout_amp clk_out_amp;
+	enum mxl5007t_xtal_freq xtal_freq_hz;
+	enum mxl5007t_if_freq if_freq_hz;
+	unsigned int invert_if:1;
+	unsigned int loop_thru_enable:1;
+	unsigned int clk_out_enable:1;
+};
+
+extern void a867_mxl5007t_attach(struct mxl5007t_config *cfg);
+extern void a867_mxl5007t_release(struct mxl5007t_state *state);
+extern int a867_mxl5007t_set_params(struct mxl5007t_state *state, enum mxl5007t_bw_mhz bw, u32 freq);
+
+#endif /* __MXL5007T_H__ */
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_ofdm.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_ofdm.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_ofdm.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_ofdm.h	2012-02-27 00:02:35.928915017 +0100
@@ -0,0 +1,18 @@
+
+#define DVB_LL_VERSION1 10
+
+#define DVB_LL_VERSION2 10
+
+#define DVB_LL_VERSION3 3
+
+#define DVB_LL_VERSION4 0
+
+
+#define DVB_OFDM_VERSION1 4
+
+#define DVB_OFDM_VERSION2 21
+
+#define DVB_OFDM_VERSION3 6
+
+#define DVB_OFDM_VERSION4 251
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_register.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_register.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_register.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_register.h	2012-02-27 00:02:36.248915017 +0100
@@ -0,0 +1,13519 @@
+#ifndef _TD_BIU_REG_H_
+#define _TD_BIU_REG_H_
+// biu_reg.h 6-27-2007
+// gen_biu Ver 1.0 generated by
+#define xd_p_reg_p_aagc_log_2_acc   (*(volatile byte xdata *) 0xF000)
+#define    p_reg_p_aagc_log_2_acc   0xF000
+#define reg_p_aagc_log_2_acc_pos 0
+#define reg_p_aagc_log_2_acc_len 4
+#define reg_p_aagc_log_2_acc_lsb 0
+#define xd_p_reg_p_aagc_signal_level_rdy    (*(volatile byte xdata *) 0xF001)
+#define    p_reg_p_aagc_signal_level_rdy    0xF001
+#define reg_p_aagc_signal_level_rdy_pos 0
+#define reg_p_aagc_signal_level_rdy_len 1
+#define reg_p_aagc_signal_level_rdy_lsb 0
+#define xd_r_reg_r_aagc_signal_level_7_0    (*(volatile byte xdata *) 0xF002)
+#define    r_reg_r_aagc_signal_level_7_0    0xF002
+#define reg_r_aagc_signal_level_7_0_pos 0
+#define reg_r_aagc_signal_level_7_0_len 8
+#define reg_r_aagc_signal_level_7_0_lsb 0
+#define xd_r_reg_r_aagc_signal_level_9_8    (*(volatile byte xdata *) 0xF003)
+#define    r_reg_r_aagc_signal_level_9_8    0xF003
+#define reg_r_aagc_signal_level_9_8_pos 0
+#define reg_r_aagc_signal_level_9_8_len 2
+#define reg_r_aagc_signal_level_9_8_lsb 8
+#define xd_p_reg_p_aagc_rf_if_swap  (*(volatile byte xdata *) 0xF004)
+#define    p_reg_p_aagc_rf_if_swap  0xF004
+#define reg_p_aagc_rf_if_swap_pos 0
+#define reg_p_aagc_rf_if_swap_len 1
+#define reg_p_aagc_rf_if_swap_lsb 0
+#define xd_p_reg_p_pwm_rf_if_from_hw    (*(volatile byte xdata *) 0xF006)
+#define    p_reg_p_pwm_rf_if_from_hw    0xF006
+#define reg_p_pwm_rf_if_from_hw_pos 0
+#define reg_p_pwm_rf_if_from_hw_len 1
+#define reg_p_pwm_rf_if_from_hw_lsb 0
+#define xd_p_reg_aagc_out_if_inv    (*(volatile byte xdata *) 0xF007)
+#define    p_reg_aagc_out_if_inv    0xF007
+#define reg_aagc_out_if_inv_pos 0
+#define reg_aagc_out_if_inv_len 1
+#define reg_aagc_out_if_inv_lsb 0
+#define xd_p_reg_aagc_int_en    (*(volatile byte xdata *) 0xF008)
+#define    p_reg_aagc_int_en    0xF008
+#define reg_aagc_int_en_pos 0
+#define reg_aagc_int_en_len 1
+#define reg_aagc_int_en_lsb 0
+#define xd_p_reg_aagc_lock_change_flag  (*(volatile byte xdata *) 0xF009)
+#define    p_reg_aagc_lock_change_flag  0xF009
+#define reg_aagc_lock_change_flag_pos 0
+#define reg_aagc_lock_change_flag_len 1
+#define reg_aagc_lock_change_flag_lsb 0
+#define xd_p_reg_aagc_rf_loop_bw_scale_acquire  (*(volatile byte xdata *) 0xF00A)
+#define    p_reg_aagc_rf_loop_bw_scale_acquire  0xF00A
+#define reg_aagc_rf_loop_bw_scale_acquire_pos 0
+#define reg_aagc_rf_loop_bw_scale_acquire_len 5
+#define reg_aagc_rf_loop_bw_scale_acquire_lsb 0
+#define xd_p_reg_aagc_rf_loop_bw_scale_track    (*(volatile byte xdata *) 0xF00B)
+#define    p_reg_aagc_rf_loop_bw_scale_track    0xF00B
+#define reg_aagc_rf_loop_bw_scale_track_pos 0
+#define reg_aagc_rf_loop_bw_scale_track_len 5
+#define reg_aagc_rf_loop_bw_scale_track_lsb 0
+#define xd_p_reg_aagc_if_loop_bw_scale_acquire  (*(volatile byte xdata *) 0xF00C)
+#define    p_reg_aagc_if_loop_bw_scale_acquire  0xF00C
+#define reg_aagc_if_loop_bw_scale_acquire_pos 0
+#define reg_aagc_if_loop_bw_scale_acquire_len 5
+#define reg_aagc_if_loop_bw_scale_acquire_lsb 0
+#define xd_p_reg_aagc_if_loop_bw_scale_track    (*(volatile byte xdata *) 0xF00D)
+#define    p_reg_aagc_if_loop_bw_scale_track    0xF00D
+#define reg_aagc_if_loop_bw_scale_track_pos 0
+#define reg_aagc_if_loop_bw_scale_track_len 5
+#define reg_aagc_if_loop_bw_scale_track_lsb 0
+#define xd_p_reg_aagc_max_rf_agc_7_0    (*(volatile byte xdata *) 0xF00E)
+#define    p_reg_aagc_max_rf_agc_7_0    0xF00E
+#define reg_aagc_max_rf_agc_7_0_pos 0
+#define reg_aagc_max_rf_agc_7_0_len 8
+#define reg_aagc_max_rf_agc_7_0_lsb 0
+#define xd_p_reg_aagc_max_rf_agc_9_8    (*(volatile byte xdata *) 0xF00F)
+#define    p_reg_aagc_max_rf_agc_9_8    0xF00F
+#define reg_aagc_max_rf_agc_9_8_pos 0
+#define reg_aagc_max_rf_agc_9_8_len 2
+#define reg_aagc_max_rf_agc_9_8_lsb 8
+#define xd_p_reg_aagc_min_rf_agc_7_0    (*(volatile byte xdata *) 0xF010)
+#define    p_reg_aagc_min_rf_agc_7_0    0xF010
+#define reg_aagc_min_rf_agc_7_0_pos 0
+#define reg_aagc_min_rf_agc_7_0_len 8
+#define reg_aagc_min_rf_agc_7_0_lsb 0
+#define xd_p_reg_aagc_min_rf_agc_9_8    (*(volatile byte xdata *) 0xF011)
+#define    p_reg_aagc_min_rf_agc_9_8    0xF011
+#define reg_aagc_min_rf_agc_9_8_pos 0
+#define reg_aagc_min_rf_agc_9_8_len 2
+#define reg_aagc_min_rf_agc_9_8_lsb 8
+#define xd_p_reg_aagc_max_if_agc_7_0    (*(volatile byte xdata *) 0xF012)
+#define    p_reg_aagc_max_if_agc_7_0    0xF012
+#define reg_aagc_max_if_agc_7_0_pos 0
+#define reg_aagc_max_if_agc_7_0_len 8
+#define reg_aagc_max_if_agc_7_0_lsb 0
+#define xd_p_reg_aagc_max_if_agc_9_8    (*(volatile byte xdata *) 0xF013)
+#define    p_reg_aagc_max_if_agc_9_8    0xF013
+#define reg_aagc_max_if_agc_9_8_pos 0
+#define reg_aagc_max_if_agc_9_8_len 2
+#define reg_aagc_max_if_agc_9_8_lsb 8
+#define xd_p_reg_aagc_min_if_agc_7_0    (*(volatile byte xdata *) 0xF014)
+#define    p_reg_aagc_min_if_agc_7_0    0xF014
+#define reg_aagc_min_if_agc_7_0_pos 0
+#define reg_aagc_min_if_agc_7_0_len 8
+#define reg_aagc_min_if_agc_7_0_lsb 0
+#define xd_p_reg_aagc_min_if_agc_9_8    (*(volatile byte xdata *) 0xF015)
+#define    p_reg_aagc_min_if_agc_9_8    0xF015
+#define reg_aagc_min_if_agc_9_8_pos 0
+#define reg_aagc_min_if_agc_9_8_len 2
+#define reg_aagc_min_if_agc_9_8_lsb 8
+#define xd_p_reg_aagc_lock_sample_scale (*(volatile byte xdata *) 0xF016)
+#define    p_reg_aagc_lock_sample_scale 0xF016
+#define reg_aagc_lock_sample_scale_pos 0
+#define reg_aagc_lock_sample_scale_len 5
+#define reg_aagc_lock_sample_scale_lsb 0
+#define xd_p_reg_aagc_rf_agc_lock_scale_acquire (*(volatile byte xdata *) 0xF017)
+#define    p_reg_aagc_rf_agc_lock_scale_acquire 0xF017
+#define reg_aagc_rf_agc_lock_scale_acquire_pos 0
+#define reg_aagc_rf_agc_lock_scale_acquire_len 3
+#define reg_aagc_rf_agc_lock_scale_acquire_lsb 0
+#define xd_p_reg_aagc_rf_agc_lock_scale_track   (*(volatile byte xdata *) 0xF018)
+#define    p_reg_aagc_rf_agc_lock_scale_track   0xF018
+#define reg_aagc_rf_agc_lock_scale_track_pos 0
+#define reg_aagc_rf_agc_lock_scale_track_len 3
+#define reg_aagc_rf_agc_lock_scale_track_lsb 0
+#define xd_p_reg_aagc_if_agc_lock_scale_acquire (*(volatile byte xdata *) 0xF019)
+#define    p_reg_aagc_if_agc_lock_scale_acquire 0xF019
+#define reg_aagc_if_agc_lock_scale_acquire_pos 0
+#define reg_aagc_if_agc_lock_scale_acquire_len 3
+#define reg_aagc_if_agc_lock_scale_acquire_lsb 0
+#define xd_p_reg_aagc_if_agc_lock_scale_track   (*(volatile byte xdata *) 0xF01A)
+#define    p_reg_aagc_if_agc_lock_scale_track   0xF01A
+#define reg_aagc_if_agc_lock_scale_track_pos 0
+#define reg_aagc_if_agc_lock_scale_track_len 3
+#define reg_aagc_if_agc_lock_scale_track_lsb 0
+#define xd_p_reg_aagc_rf_top_numerator_s_7_0    (*(volatile byte xdata *) 0xF01B)
+#define    p_reg_aagc_rf_top_numerator_s_7_0    0xF01B
+#define reg_aagc_rf_top_numerator_s_7_0_pos 0
+#define reg_aagc_rf_top_numerator_s_7_0_len 8
+#define reg_aagc_rf_top_numerator_s_7_0_lsb 0
+#define xd_p_reg_aagc_rf_top_numerator_s_9_8    (*(volatile byte xdata *) 0xF01C)
+#define    p_reg_aagc_rf_top_numerator_s_9_8    0xF01C
+#define reg_aagc_rf_top_numerator_s_9_8_pos 0
+#define reg_aagc_rf_top_numerator_s_9_8_len 2
+#define reg_aagc_rf_top_numerator_s_9_8_lsb 8
+#define xd_p_reg_aagc_if_top_numerator_s_7_0    (*(volatile byte xdata *) 0xF01D)
+#define    p_reg_aagc_if_top_numerator_s_7_0    0xF01D
+#define reg_aagc_if_top_numerator_s_7_0_pos 0
+#define reg_aagc_if_top_numerator_s_7_0_len 8
+#define reg_aagc_if_top_numerator_s_7_0_lsb 0
+#define xd_p_reg_aagc_if_top_numerator_s_9_8    (*(volatile byte xdata *) 0xF01E)
+#define    p_reg_aagc_if_top_numerator_s_9_8    0xF01E
+#define reg_aagc_if_top_numerator_s_9_8_pos 0
+#define reg_aagc_if_top_numerator_s_9_8_len 2
+#define reg_aagc_if_top_numerator_s_9_8_lsb 8
+#define xd_p_reg_aagc_adc_out_desired_s_7_0 (*(volatile byte xdata *) 0xF01F)
+#define    p_reg_aagc_adc_out_desired_s_7_0 0xF01F
+#define reg_aagc_adc_out_desired_s_7_0_pos 0
+#define reg_aagc_adc_out_desired_s_7_0_len 8
+#define reg_aagc_adc_out_desired_s_7_0_lsb 0
+#define xd_p_reg_aagc_adc_out_desired_s_8   (*(volatile byte xdata *) 0xF020)
+#define    p_reg_aagc_adc_out_desired_s_8   0xF020
+#define reg_aagc_adc_out_desired_s_8_pos 0
+#define reg_aagc_adc_out_desired_s_8_len 1
+#define reg_aagc_adc_out_desired_s_8_lsb 8
+#define xd_p_reg_aagc_lock_count_th (*(volatile byte xdata *) 0xF021)
+#define    p_reg_aagc_lock_count_th 0xF021
+#define reg_aagc_lock_count_th_pos 0
+#define reg_aagc_lock_count_th_len 4
+#define reg_aagc_lock_count_th_lsb 0
+#define xd_p_reg_aagc_rf_agc_unlock_numerator   (*(volatile byte xdata *) 0xF022)
+#define    p_reg_aagc_rf_agc_unlock_numerator   0xF022
+#define reg_aagc_rf_agc_unlock_numerator_pos 0
+#define reg_aagc_rf_agc_unlock_numerator_len 6
+#define reg_aagc_rf_agc_unlock_numerator_lsb 0
+#define xd_p_reg_aagc_if_agc_unlock_numerator   (*(volatile byte xdata *) 0xF023)
+#define    p_reg_aagc_if_agc_unlock_numerator   0xF023
+#define reg_aagc_if_agc_unlock_numerator_pos 0
+#define reg_aagc_if_agc_unlock_numerator_len 6
+#define reg_aagc_if_agc_unlock_numerator_lsb 0
+#define xd_p_reg_aagc_rf_top_numerator_m_7_0    (*(volatile byte xdata *) 0xF025)
+#define    p_reg_aagc_rf_top_numerator_m_7_0    0xF025
+#define reg_aagc_rf_top_numerator_m_7_0_pos 0
+#define reg_aagc_rf_top_numerator_m_7_0_len 8
+#define reg_aagc_rf_top_numerator_m_7_0_lsb 0
+#define xd_p_reg_aagc_rf_top_numerator_m_9_8    (*(volatile byte xdata *) 0xF026)
+#define    p_reg_aagc_rf_top_numerator_m_9_8    0xF026
+#define reg_aagc_rf_top_numerator_m_9_8_pos 0
+#define reg_aagc_rf_top_numerator_m_9_8_len 2
+#define reg_aagc_rf_top_numerator_m_9_8_lsb 8
+#define xd_p_reg_aagc_if_top_numerator_m_7_0    (*(volatile byte xdata *) 0xF027)
+#define    p_reg_aagc_if_top_numerator_m_7_0    0xF027
+#define reg_aagc_if_top_numerator_m_7_0_pos 0
+#define reg_aagc_if_top_numerator_m_7_0_len 8
+#define reg_aagc_if_top_numerator_m_7_0_lsb 0
+#define xd_p_reg_aagc_if_top_numerator_m_9_8    (*(volatile byte xdata *) 0xF028)
+#define    p_reg_aagc_if_top_numerator_m_9_8    0xF028
+#define reg_aagc_if_top_numerator_m_9_8_pos 0
+#define reg_aagc_if_top_numerator_m_9_8_len 2
+#define reg_aagc_if_top_numerator_m_9_8_lsb 8
+#define xd_p_reg_aagc_adc_out_desired_m_7_0 (*(volatile byte xdata *) 0xF029)
+#define    p_reg_aagc_adc_out_desired_m_7_0 0xF029
+#define reg_aagc_adc_out_desired_m_7_0_pos 0
+#define reg_aagc_adc_out_desired_m_7_0_len 8
+#define reg_aagc_adc_out_desired_m_7_0_lsb 0
+#define xd_p_reg_aagc_adc_out_desired_m_8   (*(volatile byte xdata *) 0xF02A)
+#define    p_reg_aagc_adc_out_desired_m_8   0xF02A
+#define reg_aagc_adc_out_desired_m_8_pos 0
+#define reg_aagc_adc_out_desired_m_8_len 1
+#define reg_aagc_adc_out_desired_m_8_lsb 8
+#define xd_p_reg_aagc_mobile_sel    (*(volatile byte xdata *) 0xF02B)
+#define    p_reg_aagc_mobile_sel    0xF02B
+#define reg_aagc_mobile_sel_pos 0
+#define reg_aagc_mobile_sel_len 1
+#define reg_aagc_mobile_sel_lsb 0
+#define xd_p_reg_aagc_top_reload    (*(volatile byte xdata *) 0xF02C)
+#define    p_reg_aagc_top_reload    0xF02C
+#define reg_aagc_top_reload_pos 0
+#define reg_aagc_top_reload_len 1
+#define reg_aagc_top_reload_lsb 0
+#define xd_p_reg_aagc_rf_delta_voltage_en   (*(volatile byte xdata *) 0xF02D)
+#define    p_reg_aagc_rf_delta_voltage_en   0xF02D
+#define reg_aagc_rf_delta_voltage_en_pos 0
+#define reg_aagc_rf_delta_voltage_en_len 1
+#define reg_aagc_rf_delta_voltage_en_lsb 0
+#define xd_p_reg_aagc_rf_voltage_inc    (*(volatile byte xdata *) 0xF02E)
+#define    p_reg_aagc_rf_voltage_inc    0xF02E
+#define reg_aagc_rf_voltage_inc_pos 0
+#define reg_aagc_rf_voltage_inc_len 1
+#define reg_aagc_rf_voltage_inc_lsb 0
+#define xd_p_reg_aagc_if_delta_voltage_en   (*(volatile byte xdata *) 0xF02F)
+#define    p_reg_aagc_if_delta_voltage_en   0xF02F
+#define reg_aagc_if_delta_voltage_en_pos 0
+#define reg_aagc_if_delta_voltage_en_len 1
+#define reg_aagc_if_delta_voltage_en_lsb 0
+#define xd_p_reg_aagc_if_voltage_inc    (*(volatile byte xdata *) 0xF030)
+#define    p_reg_aagc_if_voltage_inc    0xF030
+#define reg_aagc_if_voltage_inc_pos 0
+#define reg_aagc_if_voltage_inc_len 1
+#define reg_aagc_if_voltage_inc_lsb 0
+#define xd_p_reg_aagc_rf_delta_voltage_7_0  (*(volatile byte xdata *) 0xF032)
+#define    p_reg_aagc_rf_delta_voltage_7_0  0xF032
+#define reg_aagc_rf_delta_voltage_7_0_pos 0
+#define reg_aagc_rf_delta_voltage_7_0_len 8
+#define reg_aagc_rf_delta_voltage_7_0_lsb 0
+#define xd_p_reg_aagc_rf_delta_voltage_15_8 (*(volatile byte xdata *) 0xF033)
+#define    p_reg_aagc_rf_delta_voltage_15_8 0xF033
+#define reg_aagc_rf_delta_voltage_15_8_pos 0
+#define reg_aagc_rf_delta_voltage_15_8_len 8
+#define reg_aagc_rf_delta_voltage_15_8_lsb 8
+#define xd_p_reg_aagc_rf_delta_voltage_23_16    (*(volatile byte xdata *) 0xF034)
+#define    p_reg_aagc_rf_delta_voltage_23_16    0xF034
+#define reg_aagc_rf_delta_voltage_23_16_pos 0
+#define reg_aagc_rf_delta_voltage_23_16_len 8
+#define reg_aagc_rf_delta_voltage_23_16_lsb 16
+#define xd_p_reg_aagc_rf_delta_voltage_29_24    (*(volatile byte xdata *) 0xF035)
+#define    p_reg_aagc_rf_delta_voltage_29_24    0xF035
+#define reg_aagc_rf_delta_voltage_29_24_pos 0
+#define reg_aagc_rf_delta_voltage_29_24_len 6
+#define reg_aagc_rf_delta_voltage_29_24_lsb 24
+#define xd_p_reg_aagc_if_delta_voltage_7_0  (*(volatile byte xdata *) 0xF036)
+#define    p_reg_aagc_if_delta_voltage_7_0  0xF036
+#define reg_aagc_if_delta_voltage_7_0_pos 0
+#define reg_aagc_if_delta_voltage_7_0_len 8
+#define reg_aagc_if_delta_voltage_7_0_lsb 0
+#define xd_p_reg_aagc_if_delta_voltage_15_8 (*(volatile byte xdata *) 0xF037)
+#define    p_reg_aagc_if_delta_voltage_15_8 0xF037
+#define reg_aagc_if_delta_voltage_15_8_pos 0
+#define reg_aagc_if_delta_voltage_15_8_len 8
+#define reg_aagc_if_delta_voltage_15_8_lsb 8
+#define xd_p_reg_aagc_if_delta_voltage_23_16    (*(volatile byte xdata *) 0xF038)
+#define    p_reg_aagc_if_delta_voltage_23_16    0xF038
+#define reg_aagc_if_delta_voltage_23_16_pos 0
+#define reg_aagc_if_delta_voltage_23_16_len 8
+#define reg_aagc_if_delta_voltage_23_16_lsb 16
+#define xd_p_reg_aagc_if_delta_voltage_29_24    (*(volatile byte xdata *) 0xF039)
+#define    p_reg_aagc_if_delta_voltage_29_24    0xF039
+#define reg_aagc_if_delta_voltage_29_24_pos 0
+#define reg_aagc_if_delta_voltage_29_24_len 6
+#define reg_aagc_if_delta_voltage_29_24_lsb 24
+#define xd_p_reg_aagc_delta_voltage_hold_time   (*(volatile byte xdata *) 0xF03A)
+#define    p_reg_aagc_delta_voltage_hold_time   0xF03A
+#define reg_aagc_delta_voltage_hold_time_pos 0
+#define reg_aagc_delta_voltage_hold_time_len 8
+#define reg_aagc_delta_voltage_hold_time_lsb 0
+#define xd_p_reg_aagc_top_th_dis    (*(volatile byte xdata *) 0xF041)
+#define    p_reg_aagc_top_th_dis    0xF041
+#define reg_aagc_top_th_dis_pos 0
+#define reg_aagc_top_th_dis_len 1
+#define reg_aagc_top_th_dis_lsb 0
+#define xd_p_reg_p_aagc_rf_floor_dca    (*(volatile byte xdata *) 0xF042)
+#define    p_reg_p_aagc_rf_floor_dca    0xF042
+#define reg_p_aagc_rf_floor_dca_pos 0
+#define reg_p_aagc_rf_floor_dca_len 8
+#define reg_p_aagc_rf_floor_dca_lsb 0
+#define xd_p_reg_p_aagc_if_floor_dca    (*(volatile byte xdata *) 0xF043)
+#define    p_reg_p_aagc_if_floor_dca    0xF043
+#define reg_p_aagc_if_floor_dca_pos 0
+#define reg_p_aagc_if_floor_dca_len 8
+#define reg_p_aagc_if_floor_dca_lsb 0
+#define xd_p_reg_p_aagc_rf_gain_scale_dca   (*(volatile byte xdata *) 0xF044)
+#define    p_reg_p_aagc_rf_gain_scale_dca   0xF044
+#define reg_p_aagc_rf_gain_scale_dca_pos 0
+#define reg_p_aagc_rf_gain_scale_dca_len 3
+#define reg_p_aagc_rf_gain_scale_dca_lsb 0
+#define xd_p_reg_p_aagc_if_gain_scale_dca   (*(volatile byte xdata *) 0xF045)
+#define    p_reg_p_aagc_if_gain_scale_dca   0xF045
+#define reg_p_aagc_if_gain_scale_dca_pos 0
+#define reg_p_aagc_if_gain_scale_dca_len 3
+#define reg_p_aagc_if_gain_scale_dca_lsb 0
+#define xd_r_reg_r_aagc_ufl_gain    (*(volatile byte xdata *) 0xF046)
+#define    r_reg_r_aagc_ufl_gain    0xF046
+#define reg_r_aagc_ufl_gain_pos 0
+#define reg_r_aagc_ufl_gain_len 8
+#define reg_r_aagc_ufl_gain_lsb 0
+#define xd_p_reg_aagc_out_rf_inv    (*(volatile byte xdata *) 0xF047)
+#define    p_reg_aagc_out_rf_inv    0xF047
+#define reg_aagc_out_rf_inv_pos 0
+#define reg_aagc_out_rf_inv_len 1
+#define reg_aagc_out_rf_inv_lsb 0
+#define xd_p_reg_p_aagc_save_agc_control    (*(volatile byte xdata *) 0xF048)
+#define    p_reg_p_aagc_save_agc_control    0xF048
+#define reg_p_aagc_save_agc_control_pos 0
+#define reg_p_aagc_save_agc_control_len 1
+#define reg_p_aagc_save_agc_control_lsb 0
+#define xd_p_reg_aagc_fw_sel    (*(volatile byte xdata *) 0xF049)
+#define    p_reg_aagc_fw_sel    0xF049
+#define reg_aagc_fw_sel_pos 0
+#define reg_aagc_fw_sel_len 1
+#define reg_aagc_fw_sel_lsb 0
+#define xd_r_reg_r_aagc_rf_control_7_0  (*(volatile byte xdata *) 0xF04A)
+#define    r_reg_r_aagc_rf_control_7_0  0xF04A
+#define reg_r_aagc_rf_control_7_0_pos 0
+#define reg_r_aagc_rf_control_7_0_len 8
+#define reg_r_aagc_rf_control_7_0_lsb 0
+#define xd_r_reg_r_aagc_rf_control_9_8  (*(volatile byte xdata *) 0xF04B)
+#define    r_reg_r_aagc_rf_control_9_8  0xF04B
+#define reg_r_aagc_rf_control_9_8_pos 0
+#define reg_r_aagc_rf_control_9_8_len 2
+#define reg_r_aagc_rf_control_9_8_lsb 8
+#define xd_r_reg_r_aagc_if_control_7_0  (*(volatile byte xdata *) 0xF04C)
+#define    r_reg_r_aagc_if_control_7_0  0xF04C
+#define reg_r_aagc_if_control_7_0_pos 0
+#define reg_r_aagc_if_control_7_0_len 8
+#define reg_r_aagc_if_control_7_0_lsb 0
+#define xd_r_reg_r_aagc_if_control_9_8  (*(volatile byte xdata *) 0xF04D)
+#define    r_reg_r_aagc_if_control_9_8  0xF04D
+#define reg_r_aagc_if_control_9_8_pos 0
+#define reg_r_aagc_if_control_9_8_len 2
+#define reg_r_aagc_if_control_9_8_lsb 8
+#define xd_p_reg_aagc_adc_out_desired_from_fw_7_0   (*(volatile byte xdata *) 0xF04E)
+#define    p_reg_aagc_adc_out_desired_from_fw_7_0   0xF04E
+#define reg_aagc_adc_out_desired_from_fw_7_0_pos 0
+#define reg_aagc_adc_out_desired_from_fw_7_0_len 8
+#define reg_aagc_adc_out_desired_from_fw_7_0_lsb 0
+#define xd_p_reg_aagc_adc_out_desired_from_fw_8 (*(volatile byte xdata *) 0xF04F)
+#define    p_reg_aagc_adc_out_desired_from_fw_8 0xF04F
+#define reg_aagc_adc_out_desired_from_fw_8_pos 0
+#define reg_aagc_adc_out_desired_from_fw_8_len 1
+#define reg_aagc_adc_out_desired_from_fw_8_lsb 8
+#define xd_p_reg_aagc_init_rf_agc_7_0   (*(volatile byte xdata *) 0xF050)
+#define    p_reg_aagc_init_rf_agc_7_0   0xF050
+#define reg_aagc_init_rf_agc_7_0_pos 0
+#define reg_aagc_init_rf_agc_7_0_len 8
+#define reg_aagc_init_rf_agc_7_0_lsb 0
+#define xd_p_reg_aagc_init_rf_agc_9_8   (*(volatile byte xdata *) 0xF051)
+#define    p_reg_aagc_init_rf_agc_9_8   0xF051
+#define reg_aagc_init_rf_agc_9_8_pos 0
+#define reg_aagc_init_rf_agc_9_8_len 2
+#define reg_aagc_init_rf_agc_9_8_lsb 8
+#define xd_p_reg_aagc_init_if_agc_7_0   (*(volatile byte xdata *) 0xF052)
+#define    p_reg_aagc_init_if_agc_7_0   0xF052
+#define reg_aagc_init_if_agc_7_0_pos 0
+#define reg_aagc_init_if_agc_7_0_len 8
+#define reg_aagc_init_if_agc_7_0_lsb 0
+#define xd_p_reg_aagc_init_if_agc_9_8   (*(volatile byte xdata *) 0xF053)
+#define    p_reg_aagc_init_if_agc_9_8   0xF053
+#define reg_aagc_init_if_agc_9_8_pos 0
+#define reg_aagc_init_if_agc_9_8_len 2
+#define reg_aagc_init_if_agc_9_8_lsb 8
+#define xd_p_reg_p_pwm_if_high_unit_num (*(volatile byte xdata *) 0xF054)
+#define    p_reg_p_pwm_if_high_unit_num 0xF054
+#define reg_p_pwm_if_high_unit_num_pos 0
+#define reg_p_pwm_if_high_unit_num_len 8
+#define reg_p_pwm_if_high_unit_num_lsb 0
+#define xd_p_reg_p_pwm_rf_high_unit_num (*(volatile byte xdata *) 0xF055)
+#define    p_reg_p_pwm_rf_high_unit_num 0xF055
+#define reg_p_pwm_rf_high_unit_num_pos 0
+#define reg_p_pwm_rf_high_unit_num_len 8
+#define reg_p_pwm_rf_high_unit_num_lsb 0
+#define xd_p_reg_p_pwm_rf_gpio  (*(volatile byte xdata *) 0xF058)
+#define    p_reg_p_pwm_rf_gpio  0xF058
+#define reg_p_pwm_rf_gpio_pos 0
+#define reg_p_pwm_rf_gpio_len 1
+#define reg_p_pwm_rf_gpio_lsb 0
+#define xd_p_reg_p_pwm_if_gpio  (*(volatile byte xdata *) 0xF058)
+#define    p_reg_p_pwm_if_gpio  0xF058
+#define reg_p_pwm_if_gpio_pos 1
+#define reg_p_pwm_if_gpio_len 1
+#define reg_p_pwm_if_gpio_lsb 0
+#define xd_p_reg_aagc_in_sat_cnt_7_0    (*(volatile byte xdata *) 0xF05A)
+#define    p_reg_aagc_in_sat_cnt_7_0    0xF05A
+#define reg_aagc_in_sat_cnt_7_0_pos 0
+#define reg_aagc_in_sat_cnt_7_0_len 8
+#define reg_aagc_in_sat_cnt_7_0_lsb 0
+#define xd_p_reg_aagc_in_sat_cnt_15_8   (*(volatile byte xdata *) 0xF05B)
+#define    p_reg_aagc_in_sat_cnt_15_8   0xF05B
+#define reg_aagc_in_sat_cnt_15_8_pos 0
+#define reg_aagc_in_sat_cnt_15_8_len 8
+#define reg_aagc_in_sat_cnt_15_8_lsb 8
+#define xd_p_reg_aagc_in_sat_cnt_23_16  (*(volatile byte xdata *) 0xF05C)
+#define    p_reg_aagc_in_sat_cnt_23_16  0xF05C
+#define reg_aagc_in_sat_cnt_23_16_pos 0
+#define reg_aagc_in_sat_cnt_23_16_len 8
+#define reg_aagc_in_sat_cnt_23_16_lsb 16
+#define xd_p_reg_aagc_in_sat_cnt_31_24  (*(volatile byte xdata *) 0xF05D)
+#define    p_reg_aagc_in_sat_cnt_31_24  0xF05D
+#define reg_aagc_in_sat_cnt_31_24_pos 0
+#define reg_aagc_in_sat_cnt_31_24_len 8
+#define reg_aagc_in_sat_cnt_31_24_lsb 24
+#define xd_p_reg_p_pwm_cycle_unit   (*(volatile byte xdata *) 0xF05E)
+#define    p_reg_p_pwm_cycle_unit   0xF05E
+#define reg_p_pwm_cycle_unit_pos 0
+#define reg_p_pwm_cycle_unit_len 4
+#define reg_p_pwm_cycle_unit_lsb 0
+#define xd_p_reg_p_pwm_en   (*(volatile byte xdata *) 0xF05F)
+#define    p_reg_p_pwm_en   0xF05F
+#define reg_p_pwm_en_pos 0
+#define reg_p_pwm_en_len 1
+#define reg_p_pwm_en_lsb 0
+#define xd_r_reg_aagc_rf_gain   (*(volatile byte xdata *) 0xF060)
+#define    r_reg_aagc_rf_gain   0xF060
+#define reg_aagc_rf_gain_pos 0
+#define reg_aagc_rf_gain_len 8
+#define reg_aagc_rf_gain_lsb 0
+#define xd_r_reg_aagc_if_gain   (*(volatile byte xdata *) 0xF061)
+#define    r_reg_aagc_if_gain   0xF061
+#define reg_aagc_if_gain_pos 0
+#define reg_aagc_if_gain_len 8
+#define reg_aagc_if_gain_lsb 0
+#define xd_r_reg_aagc_current_desired_level_7_0 (*(volatile byte xdata *) 0xF062)
+#define    r_reg_aagc_current_desired_level_7_0 0xF062
+#define reg_aagc_current_desired_level_7_0_pos 0
+#define reg_aagc_current_desired_level_7_0_len 8
+#define reg_aagc_current_desired_level_7_0_lsb 0
+#define xd_r_reg_aagc_current_desired_level_8   (*(volatile byte xdata *) 0xF063)
+#define    r_reg_aagc_current_desired_level_8   0xF063
+#define reg_aagc_current_desired_level_8_pos 0
+#define reg_aagc_current_desired_level_8_len 1
+#define reg_aagc_current_desired_level_8_lsb 8
+#define xd_p_reg_tinr_fifo_size (*(volatile byte xdata *) 0xF064)
+#define    p_reg_tinr_fifo_size 0xF064
+#define reg_tinr_fifo_size_pos 0
+#define reg_tinr_fifo_size_len 5
+#define reg_tinr_fifo_size_lsb 0
+#define xd_p_reg_tinr_saturation_th_7_0 (*(volatile byte xdata *) 0xF065)
+#define    p_reg_tinr_saturation_th_7_0 0xF065
+#define reg_tinr_saturation_th_7_0_pos 0
+#define reg_tinr_saturation_th_7_0_len 8
+#define reg_tinr_saturation_th_7_0_lsb 0
+#define xd_p_reg_tinr_saturation_th_9_8 (*(volatile byte xdata *) 0xF066)
+#define    p_reg_tinr_saturation_th_9_8 0xF066
+#define reg_tinr_saturation_th_9_8_pos 0
+#define reg_tinr_saturation_th_9_8_len 2
+#define reg_tinr_saturation_th_9_8_lsb 8
+#define xd_p_reg_tinr_saturation_cnt_th (*(volatile byte xdata *) 0xF067)
+#define    p_reg_tinr_saturation_cnt_th 0xF067
+#define reg_tinr_saturation_cnt_th_pos 0
+#define reg_tinr_saturation_cnt_th_len 4
+#define reg_tinr_saturation_cnt_th_lsb 0
+#define xd_r_reg_tinr_counter_7_0   (*(volatile byte xdata *) 0xF068)
+#define    r_reg_tinr_counter_7_0   0xF068
+#define reg_tinr_counter_7_0_pos 0
+#define reg_tinr_counter_7_0_len 8
+#define reg_tinr_counter_7_0_lsb 0
+#define xd_r_reg_tinr_counter_15_8  (*(volatile byte xdata *) 0xF069)
+#define    r_reg_tinr_counter_15_8  0xF069
+#define reg_tinr_counter_15_8_pos 0
+#define reg_tinr_counter_15_8_len 8
+#define reg_tinr_counter_15_8_lsb 8
+#define xd_p_reg_tinr_counter_rst   (*(volatile byte xdata *) 0xF06C)
+#define    p_reg_tinr_counter_rst   0xF06C
+#define reg_tinr_counter_rst_pos 0
+#define reg_tinr_counter_rst_len 1
+#define reg_tinr_counter_rst_lsb 0
+#define xd_p_reg_tinr_ins_th_7_0    (*(volatile byte xdata *) 0xF06F)
+#define    p_reg_tinr_ins_th_7_0    0xF06F
+#define reg_tinr_ins_th_7_0_pos 0
+#define reg_tinr_ins_th_7_0_len 8
+#define reg_tinr_ins_th_7_0_lsb 0
+#define xd_p_reg_tinr_ins_th_9_8    (*(volatile byte xdata *) 0xF070)
+#define    p_reg_tinr_ins_th_9_8    0xF070
+#define reg_tinr_ins_th_9_8_pos 0
+#define reg_tinr_ins_th_9_8_len 2
+#define reg_tinr_ins_th_9_8_lsb 8
+#define xd_p_reg_tinr_ins_en    (*(volatile byte xdata *) 0xF071)
+#define    p_reg_tinr_ins_en    0xF071
+#define reg_tinr_ins_en_pos 0
+#define reg_tinr_ins_en_len 1
+#define reg_tinr_ins_en_lsb 0
+#define xd_p_reg_tinr_ins_size  (*(volatile byte xdata *) 0xF072)
+#define    p_reg_tinr_ins_size  0xF072
+#define reg_tinr_ins_size_pos 0
+#define reg_tinr_ins_size_len 4
+#define reg_tinr_ins_size_lsb 0
+#define xd_p_reg_tinr_ins_hnum  (*(volatile byte xdata *) 0xF073)
+#define    p_reg_tinr_ins_hnum  0xF073
+#define reg_tinr_ins_hnum_pos 0
+#define reg_tinr_ins_hnum_len 4
+#define reg_tinr_ins_hnum_lsb 0
+#define xd_r_reg_tinr_ins_hcnt_7_0  (*(volatile byte xdata *) 0xF074)
+#define    r_reg_tinr_ins_hcnt_7_0  0xF074
+#define reg_tinr_ins_hcnt_7_0_pos 0
+#define reg_tinr_ins_hcnt_7_0_len 8
+#define reg_tinr_ins_hcnt_7_0_lsb 0
+#define xd_r_reg_tinr_ins_hcnt_15_8 (*(volatile byte xdata *) 0xF075)
+#define    r_reg_tinr_ins_hcnt_15_8 0xF075
+#define reg_tinr_ins_hcnt_15_8_pos 0
+#define reg_tinr_ins_hcnt_15_8_len 8
+#define reg_tinr_ins_hcnt_15_8_lsb 8
+#define xd_p_reg_tinr_in_conj   (*(volatile byte xdata *) 0xF076)
+#define    p_reg_tinr_in_conj   0xF076
+#define reg_tinr_in_conj_pos 0
+#define reg_tinr_in_conj_len 1
+#define reg_tinr_in_conj_lsb 0
+#define xd_p_reg_tinr_in_zero_if    (*(volatile byte xdata *) 0xF077)
+#define    p_reg_tinr_in_zero_if    0xF077
+#define reg_tinr_in_zero_if_pos 0
+#define reg_tinr_in_zero_if_len 2
+#define reg_tinr_in_zero_if_lsb 0
+#define xd_p_reg_tinr_in_shift  (*(volatile byte xdata *) 0xF078)
+#define    p_reg_tinr_in_shift  0xF078
+#define reg_tinr_in_shift_pos 0
+#define reg_tinr_in_shift_len 1
+#define reg_tinr_in_shift_lsb 0
+#define xd_p_reg_tinr_in_conj_sat_counter_rst   (*(volatile byte xdata *) 0xF079)
+#define    p_reg_tinr_in_conj_sat_counter_rst   0xF079
+#define reg_tinr_in_conj_sat_counter_rst_pos 0
+#define reg_tinr_in_conj_sat_counter_rst_len 1
+#define reg_tinr_in_conj_sat_counter_rst_lsb 0
+#define xd_r_reg_tinr_in_conj_sat_counter_7_0   (*(volatile byte xdata *) 0xF07A)
+#define    r_reg_tinr_in_conj_sat_counter_7_0   0xF07A
+#define reg_tinr_in_conj_sat_counter_7_0_pos 0
+#define reg_tinr_in_conj_sat_counter_7_0_len 8
+#define reg_tinr_in_conj_sat_counter_7_0_lsb 0
+#define xd_r_reg_tinr_in_conj_sat_counter_14_8  (*(volatile byte xdata *) 0xF07B)
+#define    r_reg_tinr_in_conj_sat_counter_14_8  0xF07B
+#define reg_tinr_in_conj_sat_counter_14_8_pos 0
+#define reg_tinr_in_conj_sat_counter_14_8_len 7
+#define reg_tinr_in_conj_sat_counter_14_8_lsb 8
+#define xd_p_reg_p_antif_en (*(volatile byte xdata *) 0xF07C)
+#define    p_reg_p_antif_en 0xF07C
+#define reg_p_antif_en_pos 0
+#define reg_p_antif_en_len 1
+#define reg_p_antif_en_lsb 0
+#define xd_p_reg_p_antif_rst    (*(volatile byte xdata *) 0xF07D)
+#define    p_reg_p_antif_rst    0xF07D
+#define reg_p_antif_rst_pos 0
+#define reg_p_antif_rst_len 1
+#define reg_p_antif_rst_lsb 0
+#define xd_p_reg_p_antif_byp    (*(volatile byte xdata *) 0xF07E)
+#define    p_reg_p_antif_byp    0xF07E
+#define reg_p_antif_byp_pos 0
+#define reg_p_antif_byp_len 1
+#define reg_p_antif_byp_lsb 0
+#define xd_p_reg_p_antif_mode   (*(volatile byte xdata *) 0xF07F)
+#define    p_reg_p_antif_mode   0xF07F
+#define reg_p_antif_mode_pos 0
+#define reg_p_antif_mode_len 1
+#define reg_p_antif_mode_lsb 0
+#define xd_p_reg_p_ds_byp   (*(volatile byte xdata *) 0xF080)
+#define    p_reg_p_ds_byp   0xF080
+#define reg_p_ds_byp_pos 0
+#define reg_p_ds_byp_len 1
+#define reg_p_ds_byp_lsb 0
+#define xd_p_reg_p_antif_dagc5_mode (*(volatile byte xdata *) 0xF081)
+#define    p_reg_p_antif_dagc5_mode 0xF081
+#define reg_p_antif_dagc5_mode_pos 0
+#define reg_p_antif_dagc5_mode_len 2
+#define reg_p_antif_dagc5_mode_lsb 0
+#define xd_p_reg_p_antif_dagc5_desired_level_7_0    (*(volatile byte xdata *) 0xF082)
+#define    p_reg_p_antif_dagc5_desired_level_7_0    0xF082
+#define reg_p_antif_dagc5_desired_level_7_0_pos 0
+#define reg_p_antif_dagc5_desired_level_7_0_len 8
+#define reg_p_antif_dagc5_desired_level_7_0_lsb 0
+#define xd_p_reg_p_antif_dagc5_desired_level_8  (*(volatile byte xdata *) 0xF083)
+#define    p_reg_p_antif_dagc5_desired_level_8  0xF083
+#define reg_p_antif_dagc5_desired_level_8_pos 0
+#define reg_p_antif_dagc5_desired_level_8_len 1
+#define reg_p_antif_dagc5_desired_level_8_lsb 8
+#define xd_p_reg_p_antif_dagc5_apply_delay  (*(volatile byte xdata *) 0xF084)
+#define    p_reg_p_antif_dagc5_apply_delay  0xF084
+#define reg_p_antif_dagc5_apply_delay_pos 0
+#define reg_p_antif_dagc5_apply_delay_len 7
+#define reg_p_antif_dagc5_apply_delay_lsb 0
+#define xd_p_reg_p_antif_dagc5_fixed_gain_7_0   (*(volatile byte xdata *) 0xF085)
+#define    p_reg_p_antif_dagc5_fixed_gain_7_0   0xF085
+#define reg_p_antif_dagc5_fixed_gain_7_0_pos 0
+#define reg_p_antif_dagc5_fixed_gain_7_0_len 8
+#define reg_p_antif_dagc5_fixed_gain_7_0_lsb 0
+#define xd_p_reg_p_antif_dagc5_fixed_gain_11_8  (*(volatile byte xdata *) 0xF086)
+#define    p_reg_p_antif_dagc5_fixed_gain_11_8  0xF086
+#define reg_p_antif_dagc5_fixed_gain_11_8_pos 0
+#define reg_p_antif_dagc5_fixed_gain_11_8_len 4
+#define reg_p_antif_dagc5_fixed_gain_11_8_lsb 8
+#define xd_p_reg_p_antif_dagc5_use_despow   (*(volatile byte xdata *) 0xF087)
+#define    p_reg_p_antif_dagc5_use_despow   0xF087
+#define reg_p_antif_dagc5_use_despow_pos 0
+#define reg_p_antif_dagc5_use_despow_len 1
+#define reg_p_antif_dagc5_use_despow_lsb 0
+#define xd_p_reg_p_antif_dagc5_log_2_accumulate_num (*(volatile byte xdata *) 0xF088)
+#define    p_reg_p_antif_dagc5_log_2_accumulate_num 0xF088
+#define reg_p_antif_dagc5_log_2_accumulate_num_pos 0
+#define reg_p_antif_dagc5_log_2_accumulate_num_len 5
+#define reg_p_antif_dagc5_log_2_accumulate_num_lsb 0
+#define xd_p_reg_p_antif_dagc5_in_sat_cnt_7_0   (*(volatile byte xdata *) 0xF089)
+#define    p_reg_p_antif_dagc5_in_sat_cnt_7_0   0xF089
+#define reg_p_antif_dagc5_in_sat_cnt_7_0_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_7_0_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_7_0_lsb 0
+#define xd_p_reg_p_antif_dagc5_in_sat_cnt_15_8  (*(volatile byte xdata *) 0xF08A)
+#define    p_reg_p_antif_dagc5_in_sat_cnt_15_8  0xF08A
+#define reg_p_antif_dagc5_in_sat_cnt_15_8_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_15_8_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_15_8_lsb 8
+#define xd_p_reg_p_antif_dagc5_in_sat_cnt_23_16 (*(volatile byte xdata *) 0xF08B)
+#define    p_reg_p_antif_dagc5_in_sat_cnt_23_16 0xF08B
+#define reg_p_antif_dagc5_in_sat_cnt_23_16_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_23_16_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_23_16_lsb 16
+#define xd_p_reg_p_antif_dagc5_in_sat_cnt_31_24 (*(volatile byte xdata *) 0xF08C)
+#define    p_reg_p_antif_dagc5_in_sat_cnt_31_24 0xF08C
+#define reg_p_antif_dagc5_in_sat_cnt_31_24_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_31_24_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_31_24_lsb 24
+#define xd_p_reg_p_antif_dagc5_out_sat_cnt_7_0  (*(volatile byte xdata *) 0xF08D)
+#define    p_reg_p_antif_dagc5_out_sat_cnt_7_0  0xF08D
+#define reg_p_antif_dagc5_out_sat_cnt_7_0_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_7_0_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_7_0_lsb 0
+#define xd_p_reg_p_antif_dagc5_out_sat_cnt_15_8 (*(volatile byte xdata *) 0xF08E)
+#define    p_reg_p_antif_dagc5_out_sat_cnt_15_8 0xF08E
+#define reg_p_antif_dagc5_out_sat_cnt_15_8_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_15_8_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_15_8_lsb 8
+#define xd_p_reg_p_antif_dagc5_out_sat_cnt_23_16    (*(volatile byte xdata *) 0xF08F)
+#define    p_reg_p_antif_dagc5_out_sat_cnt_23_16    0xF08F
+#define reg_p_antif_dagc5_out_sat_cnt_23_16_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_23_16_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_23_16_lsb 16
+#define xd_p_reg_p_antif_dagc5_out_sat_cnt_31_24    (*(volatile byte xdata *) 0xF090)
+#define    p_reg_p_antif_dagc5_out_sat_cnt_31_24    0xF090
+#define reg_p_antif_dagc5_out_sat_cnt_31_24_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_31_24_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_31_24_lsb 24
+#define xd_p_reg_p_antif_dagc5_rst  (*(volatile byte xdata *) 0xF091)
+#define    p_reg_p_antif_dagc5_rst  0xF091
+#define reg_p_antif_dagc5_rst_pos 0
+#define reg_p_antif_dagc5_rst_len 1
+#define reg_p_antif_dagc5_rst_lsb 0
+#define xd_p_reg_p_antif_dagc5_en   (*(volatile byte xdata *) 0xF092)
+#define    p_reg_p_antif_dagc5_en   0xF092
+#define reg_p_antif_dagc5_en_pos 0
+#define reg_p_antif_dagc5_en_len 1
+#define reg_p_antif_dagc5_en_lsb 0
+#define xd_p_reg_p_antif_sc_mode    (*(volatile byte xdata *) 0xF093)
+#define    p_reg_p_antif_sc_mode    0xF093
+#define reg_p_antif_sc_mode_pos 0
+#define reg_p_antif_sc_mode_len 4
+#define reg_p_antif_sc_mode_lsb 0
+#define xd_p_reg_p_antif_dagc5_done (*(volatile byte xdata *) 0xF094)
+#define    p_reg_p_antif_dagc5_done 0xF094
+#define reg_p_antif_dagc5_done_pos 0
+#define reg_p_antif_dagc5_done_len 1
+#define reg_p_antif_dagc5_done_lsb 0
+#define xd_r_reg_r_antif_sc_7_0 (*(volatile byte xdata *) 0xF095)
+#define    r_reg_r_antif_sc_7_0 0xF095
+#define reg_r_antif_sc_7_0_pos 0
+#define reg_r_antif_sc_7_0_len 8
+#define reg_r_antif_sc_7_0_lsb 0
+#define xd_r_reg_r_antif_sc_15_8    (*(volatile byte xdata *) 0xF096)
+#define    r_reg_r_antif_sc_15_8    0xF096
+#define reg_r_antif_sc_15_8_pos 0
+#define reg_r_antif_sc_15_8_len 8
+#define reg_r_antif_sc_15_8_lsb 8
+#define xd_r_reg_r_antif_dagc5_multiplier_7_0   (*(volatile byte xdata *) 0xF097)
+#define    r_reg_r_antif_dagc5_multiplier_7_0   0xF097
+#define reg_r_antif_dagc5_multiplier_7_0_pos 0
+#define reg_r_antif_dagc5_multiplier_7_0_len 8
+#define reg_r_antif_dagc5_multiplier_7_0_lsb 0
+#define xd_r_reg_r_antif_dagc5_multiplier_15_8  (*(volatile byte xdata *) 0xF098)
+#define    r_reg_r_antif_dagc5_multiplier_15_8  0xF098
+#define reg_r_antif_dagc5_multiplier_15_8_pos 0
+#define reg_r_antif_dagc5_multiplier_15_8_len 8
+#define reg_r_antif_dagc5_multiplier_15_8_lsb 8
+#define xd_r_reg_r_antif_dagc5_right_shift_bits (*(volatile byte xdata *) 0xF099)
+#define    r_reg_r_antif_dagc5_right_shift_bits 0xF099
+#define reg_r_antif_dagc5_right_shift_bits_pos 0
+#define reg_r_antif_dagc5_right_shift_bits_len 4
+#define reg_r_antif_dagc5_right_shift_bits_lsb 0
+#define xd_p_reg_p_antif_dagc5_bypass_scale_ctl (*(volatile byte xdata *) 0xF09A)
+#define    p_reg_p_antif_dagc5_bypass_scale_ctl 0xF09A
+#define reg_p_antif_dagc5_bypass_scale_ctl_pos 0
+#define reg_p_antif_dagc5_bypass_scale_ctl_len 3
+#define reg_p_antif_dagc5_bypass_scale_ctl_lsb 0
+#define xd_p_reg_mccid_ccirunno_7_0 (*(volatile byte xdata *) 0xF09B)
+#define    p_reg_mccid_ccirunno_7_0 0xF09B
+#define reg_mccid_ccirunno_7_0_pos 0
+#define reg_mccid_ccirunno_7_0_len 8
+#define reg_mccid_ccirunno_7_0_lsb 0
+#define xd_p_reg_mccid_ccirunno_8   (*(volatile byte xdata *) 0xF09C)
+#define    p_reg_mccid_ccirunno_8   0xF09C
+#define reg_mccid_ccirunno_8_pos 0
+#define reg_mccid_ccirunno_8_len 1
+#define reg_mccid_ccirunno_8_lsb 8
+#define xd_p_reg_mccid_acirunno_7_0 (*(volatile byte xdata *) 0xF09D)
+#define    p_reg_mccid_acirunno_7_0 0xF09D
+#define reg_mccid_acirunno_7_0_pos 0
+#define reg_mccid_acirunno_7_0_len 8
+#define reg_mccid_acirunno_7_0_lsb 0
+#define xd_p_reg_mccid_acirunno_8   (*(volatile byte xdata *) 0xF09E)
+#define    p_reg_mccid_acirunno_8   0xF09E
+#define reg_mccid_acirunno_8_pos 0
+#define reg_mccid_acirunno_8_len 1
+#define reg_mccid_acirunno_8_lsb 8
+#define xd_p_reg_mccid_maxtonenearrange_7_0 (*(volatile byte xdata *) 0xF09F)
+#define    p_reg_mccid_maxtonenearrange_7_0 0xF09F
+#define reg_mccid_maxtonenearrange_7_0_pos 0
+#define reg_mccid_maxtonenearrange_7_0_len 8
+#define reg_mccid_maxtonenearrange_7_0_lsb 0
+#define xd_p_reg_mccid_maxtonenearrange_8   (*(volatile byte xdata *) 0xF0A0)
+#define    p_reg_mccid_maxtonenearrange_8   0xF0A0
+#define reg_mccid_maxtonenearrange_8_pos 0
+#define reg_mccid_maxtonenearrange_8_len 1
+#define reg_mccid_maxtonenearrange_8_lsb 8
+#define xd_r_reg_mccid_maxacipower_7_0  (*(volatile byte xdata *) 0xF0A1)
+#define    r_reg_mccid_maxacipower_7_0  0xF0A1
+#define reg_mccid_maxacipower_7_0_pos 0
+#define reg_mccid_maxacipower_7_0_len 8
+#define reg_mccid_maxacipower_7_0_lsb 0
+#define xd_r_reg_mccid_maxacipower_15_8 (*(volatile byte xdata *) 0xF0A2)
+#define    r_reg_mccid_maxacipower_15_8 0xF0A2
+#define reg_mccid_maxacipower_15_8_pos 0
+#define reg_mccid_maxacipower_15_8_len 8
+#define reg_mccid_maxacipower_15_8_lsb 8
+#define xd_r_reg_mccid_maxacipower_19_16    (*(volatile byte xdata *) 0xF0A3)
+#define    r_reg_mccid_maxacipower_19_16    0xF0A3
+#define reg_mccid_maxacipower_19_16_pos 0
+#define reg_mccid_maxacipower_19_16_len 4
+#define reg_mccid_maxacipower_19_16_lsb 16
+#define xd_p_reg_p_dcoe_en  (*(volatile byte xdata *) 0xF0D5)
+#define    p_reg_p_dcoe_en  0xF0D5
+#define reg_p_dcoe_en_pos 0
+#define reg_p_dcoe_en_len 1
+#define reg_p_dcoe_en_lsb 0
+#define xd_p_reg_p_dcoe_rst (*(volatile byte xdata *) 0xF0D6)
+#define    p_reg_p_dcoe_rst 0xF0D6
+#define reg_p_dcoe_rst_pos 0
+#define reg_p_dcoe_rst_len 1
+#define reg_p_dcoe_rst_lsb 0
+#define xd_p_reg_p_dcoe_clear   (*(volatile byte xdata *) 0xF0D7)
+#define    p_reg_p_dcoe_clear   0xF0D7
+#define reg_p_dcoe_clear_pos 0
+#define reg_p_dcoe_clear_len 1
+#define reg_p_dcoe_clear_lsb 0
+#define xd_p_reg_p_dcoe_applyloc_7_0    (*(volatile byte xdata *) 0xF0D8)
+#define    p_reg_p_dcoe_applyloc_7_0    0xF0D8
+#define reg_p_dcoe_applyloc_7_0_pos 0
+#define reg_p_dcoe_applyloc_7_0_len 8
+#define reg_p_dcoe_applyloc_7_0_lsb 0
+#define xd_p_reg_p_dcoe_applyloc_12_8   (*(volatile byte xdata *) 0xF0D9)
+#define    p_reg_p_dcoe_applyloc_12_8   0xF0D9
+#define reg_p_dcoe_applyloc_12_8_pos 0
+#define reg_p_dcoe_applyloc_12_8_len 5
+#define reg_p_dcoe_applyloc_12_8_lsb 8
+#define xd_p_reg_p_dcoe_accnums (*(volatile byte xdata *) 0xF0DA)
+#define    p_reg_p_dcoe_accnums 0xF0DA
+#define reg_p_dcoe_accnums_pos 0
+#define reg_p_dcoe_accnums_len 3
+#define reg_p_dcoe_accnums_lsb 0
+#define xd_p_reg_p_dcoe_accweightsum_sh (*(volatile byte xdata *) 0xF0DB)
+#define    p_reg_p_dcoe_accweightsum_sh 0xF0DB
+#define reg_p_dcoe_accweightsum_sh_pos 0
+#define reg_p_dcoe_accweightsum_sh_len 3
+#define reg_p_dcoe_accweightsum_sh_lsb 0
+#define xd_p_reg_p_dcoe_accweightcurr   (*(volatile byte xdata *) 0xF0DC)
+#define    p_reg_p_dcoe_accweightcurr   0xF0DC
+#define reg_p_dcoe_accweightcurr_pos 0
+#define reg_p_dcoe_accweightcurr_len 8
+#define reg_p_dcoe_accweightcurr_lsb 0
+#define xd_p_reg_dcoe_apply_rd  (*(volatile byte xdata *) 0xF0DF)
+#define    p_reg_dcoe_apply_rd  0xF0DF
+#define reg_dcoe_apply_rd_pos 0
+#define reg_dcoe_apply_rd_len 1
+#define reg_dcoe_apply_rd_lsb 0
+#define xd_r_reg_dcoe_apply_i   (*(volatile byte xdata *) 0xF0E0)
+#define    r_reg_dcoe_apply_i   0xF0E0
+#define reg_dcoe_apply_i_pos 0
+#define reg_dcoe_apply_i_len 8
+#define reg_dcoe_apply_i_lsb 0
+#define xd_r_reg_dcoe_apply_q   (*(volatile byte xdata *) 0xF0E1)
+#define    r_reg_dcoe_apply_q   0xF0E1
+#define reg_dcoe_apply_q_pos 0
+#define reg_dcoe_apply_q_len 8
+#define reg_dcoe_apply_q_lsb 0
+#define xd_p_reg_p_dcrm_en  (*(volatile byte xdata *) 0xF0E2)
+#define    p_reg_p_dcrm_en  0xF0E2
+#define reg_p_dcrm_en_pos 0
+#define reg_p_dcrm_en_len 1
+#define reg_p_dcrm_en_lsb 0
+#define xd_p_reg_p_dcrm_fir (*(volatile byte xdata *) 0xF0E3)
+#define    p_reg_p_dcrm_fir 0xF0E3
+#define reg_p_dcrm_fir_pos 0
+#define reg_p_dcrm_fir_len 1
+#define reg_p_dcrm_fir_lsb 0
+#define xd_p_reg_p_dcrm_log2_firlen (*(volatile byte xdata *) 0xF0E4)
+#define    p_reg_p_dcrm_log2_firlen 0xF0E4
+#define reg_p_dcrm_log2_firlen_pos 0
+#define reg_p_dcrm_log2_firlen_len 3
+#define reg_p_dcrm_log2_firlen_lsb 0
+#define xd_r_reg_dcoe_apply_fir_i   (*(volatile byte xdata *) 0xF0E5)
+#define    r_reg_dcoe_apply_fir_i   0xF0E5
+#define reg_dcoe_apply_fir_i_pos 0
+#define reg_dcoe_apply_fir_i_len 8
+#define reg_dcoe_apply_fir_i_lsb 0
+#define xd_r_reg_dcoe_apply_fir_q   (*(volatile byte xdata *) 0xF0E6)
+#define    r_reg_dcoe_apply_fir_q   0xF0E6
+#define reg_dcoe_apply_fir_q_pos 0
+#define reg_dcoe_apply_fir_q_len 8
+#define reg_dcoe_apply_fir_q_lsb 0
+#define xd_p_reg_p_dcrm_force_en    (*(volatile byte xdata *) 0xF0E7)
+#define    p_reg_p_dcrm_force_en    0xF0E7
+#define reg_p_dcrm_force_en_pos 0
+#define reg_p_dcrm_force_en_len 1
+#define reg_p_dcrm_force_en_lsb 0
+#define xd_p_reg_p_dcrm_force_value_i   (*(volatile byte xdata *) 0xF0E8)
+#define    p_reg_p_dcrm_force_value_i   0xF0E8
+#define reg_p_dcrm_force_value_i_pos 0
+#define reg_p_dcrm_force_value_i_len 8
+#define reg_p_dcrm_force_value_i_lsb 0
+#define xd_p_reg_p_dcrm_force_value_q   (*(volatile byte xdata *) 0xF0E9)
+#define    p_reg_p_dcrm_force_value_q   0xF0E9
+#define reg_p_dcrm_force_value_q_pos 0
+#define reg_p_dcrm_force_value_q_len 8
+#define reg_p_dcrm_force_value_q_lsb 0
+#define xd_p_reg_p_iqip_en  (*(volatile byte xdata *) 0xF0EA)
+#define    p_reg_p_iqip_en  0xF0EA
+#define reg_p_iqip_en_pos 0
+#define reg_p_iqip_en_len 1
+#define reg_p_iqip_en_lsb 0
+#define xd_p_reg_p_iqip_rst (*(volatile byte xdata *) 0xF0EB)
+#define    p_reg_p_iqip_rst 0xF0EB
+#define reg_p_iqip_rst_pos 0
+#define reg_p_iqip_rst_len 1
+#define reg_p_iqip_rst_lsb 0
+#define xd_p_reg_iqip_mu_ld (*(volatile byte xdata *) 0xF0EC)
+#define    p_reg_iqip_mu_ld 0xF0EC
+#define reg_iqip_mu_ld_pos 0
+#define reg_iqip_mu_ld_len 1
+#define reg_iqip_mu_ld_lsb 0
+#define xd_p_reg_p_iqip_mu_7_0  (*(volatile byte xdata *) 0xF0ED)
+#define    p_reg_p_iqip_mu_7_0  0xF0ED
+#define reg_p_iqip_mu_7_0_pos 0
+#define reg_p_iqip_mu_7_0_len 8
+#define reg_p_iqip_mu_7_0_lsb 0
+#define xd_p_reg_p_iqip_mu_11_8 (*(volatile byte xdata *) 0xF0EE)
+#define    p_reg_p_iqip_mu_11_8 0xF0EE
+#define reg_p_iqip_mu_11_8_pos 0
+#define reg_p_iqip_mu_11_8_len 4
+#define reg_p_iqip_mu_11_8_lsb 8
+#define xd_p_reg_iqip_gs_ld (*(volatile byte xdata *) 0xF0EF)
+#define    p_reg_iqip_gs_ld 0xF0EF
+#define reg_iqip_gs_ld_pos 0
+#define reg_iqip_gs_ld_len 1
+#define reg_iqip_gs_ld_lsb 0
+#define xd_p_reg_p_iqip_gsnums  (*(volatile byte xdata *) 0xF0F0)
+#define    p_reg_p_iqip_gsnums  0xF0F0
+#define reg_p_iqip_gsnums_pos 0
+#define reg_p_iqip_gsnums_len 4
+#define reg_p_iqip_gsnums_lsb 0
+#define xd_p_reg_p_iqip_gsites_7_0  (*(volatile byte xdata *) 0xF0F1)
+#define    p_reg_p_iqip_gsites_7_0  0xF0F1
+#define reg_p_iqip_gsites_7_0_pos 0
+#define reg_p_iqip_gsites_7_0_len 8
+#define reg_p_iqip_gsites_7_0_lsb 0
+#define xd_p_reg_p_iqip_gsites_15_8 (*(volatile byte xdata *) 0xF0F2)
+#define    p_reg_p_iqip_gsites_15_8 0xF0F2
+#define reg_p_iqip_gsites_15_8_pos 0
+#define reg_p_iqip_gsites_15_8_len 8
+#define reg_p_iqip_gsites_15_8_lsb 8
+#define xd_p_reg_iqip_w_ld  (*(volatile byte xdata *) 0xF0F3)
+#define    p_reg_iqip_w_ld  0xF0F3
+#define reg_iqip_w_ld_pos 0
+#define reg_iqip_w_ld_len 1
+#define reg_iqip_w_ld_lsb 0
+#define xd_p_reg_p_iqip_w_re_7_0    (*(volatile byte xdata *) 0xF0F4)
+#define    p_reg_p_iqip_w_re_7_0    0xF0F4
+#define reg_p_iqip_w_re_7_0_pos 0
+#define reg_p_iqip_w_re_7_0_len 8
+#define reg_p_iqip_w_re_7_0_lsb 0
+#define xd_p_reg_p_iqip_w_re_15_8   (*(volatile byte xdata *) 0xF0F5)
+#define    p_reg_p_iqip_w_re_15_8   0xF0F5
+#define reg_p_iqip_w_re_15_8_pos 0
+#define reg_p_iqip_w_re_15_8_len 8
+#define reg_p_iqip_w_re_15_8_lsb 8
+#define xd_p_reg_p_iqip_w_re_16 (*(volatile byte xdata *) 0xF0F6)
+#define    p_reg_p_iqip_w_re_16 0xF0F6
+#define reg_p_iqip_w_re_16_pos 0
+#define reg_p_iqip_w_re_16_len 1
+#define reg_p_iqip_w_re_16_lsb 16
+#define xd_p_reg_p_iqip_w_im_7_0    (*(volatile byte xdata *) 0xF0F7)
+#define    p_reg_p_iqip_w_im_7_0    0xF0F7
+#define reg_p_iqip_w_im_7_0_pos 0
+#define reg_p_iqip_w_im_7_0_len 8
+#define reg_p_iqip_w_im_7_0_lsb 0
+#define xd_p_reg_p_iqip_w_im_15_8   (*(volatile byte xdata *) 0xF0F8)
+#define    p_reg_p_iqip_w_im_15_8   0xF0F8
+#define reg_p_iqip_w_im_15_8_pos 0
+#define reg_p_iqip_w_im_15_8_len 8
+#define reg_p_iqip_w_im_15_8_lsb 8
+#define xd_p_reg_p_iqip_w_im_16 (*(volatile byte xdata *) 0xF0F9)
+#define    p_reg_p_iqip_w_im_16 0xF0F9
+#define reg_p_iqip_w_im_16_pos 0
+#define reg_p_iqip_w_im_16_len 1
+#define reg_p_iqip_w_im_16_lsb 16
+#define xd_p_reg_iqip_accnums_rd    (*(volatile byte xdata *) 0xF0FA)
+#define    p_reg_iqip_accnums_rd    0xF0FA
+#define reg_iqip_accnums_rd_pos 0
+#define reg_iqip_accnums_rd_len 1
+#define reg_iqip_accnums_rd_lsb 0
+#define xd_p_reg_p_iqip_accnums (*(volatile byte xdata *) 0xF0FB)
+#define    p_reg_p_iqip_accnums 0xF0FB
+#define reg_p_iqip_accnums_pos 0
+#define reg_p_iqip_accnums_len 2
+#define reg_p_iqip_accnums_lsb 0
+#define xd_p_reg_iqip_accnums_rdy   (*(volatile byte xdata *) 0xF0FC)
+#define    p_reg_iqip_accnums_rdy   0xF0FC
+#define reg_iqip_accnums_rdy_pos 0
+#define reg_iqip_accnums_rdy_len 1
+#define reg_iqip_accnums_rdy_lsb 0
+#define xd_r_reg_r_iqip_wacc_re_7_0 (*(volatile byte xdata *) 0xF0FD)
+#define    r_reg_r_iqip_wacc_re_7_0 0xF0FD
+#define reg_r_iqip_wacc_re_7_0_pos 0
+#define reg_r_iqip_wacc_re_7_0_len 8
+#define reg_r_iqip_wacc_re_7_0_lsb 0
+#define xd_r_reg_r_iqip_wacc_re_15_8    (*(volatile byte xdata *) 0xF0FE)
+#define    r_reg_r_iqip_wacc_re_15_8    0xF0FE
+#define reg_r_iqip_wacc_re_15_8_pos 0
+#define reg_r_iqip_wacc_re_15_8_len 8
+#define reg_r_iqip_wacc_re_15_8_lsb 8
+#define xd_r_reg_r_iqip_wacc_re_16  (*(volatile byte xdata *) 0xF0FF)
+#define    r_reg_r_iqip_wacc_re_16  0xF0FF
+#define reg_r_iqip_wacc_re_16_pos 0
+#define reg_r_iqip_wacc_re_16_len 1
+#define reg_r_iqip_wacc_re_16_lsb 16
+#define xd_r_reg_r_iqip_wacc_im_7_0 (*(volatile byte xdata *) 0xF100)
+#define    r_reg_r_iqip_wacc_im_7_0 0xF100
+#define reg_r_iqip_wacc_im_7_0_pos 0
+#define reg_r_iqip_wacc_im_7_0_len 8
+#define reg_r_iqip_wacc_im_7_0_lsb 0
+#define xd_r_reg_r_iqip_wacc_im_15_8    (*(volatile byte xdata *) 0xF101)
+#define    r_reg_r_iqip_wacc_im_15_8    0xF101
+#define reg_r_iqip_wacc_im_15_8_pos 0
+#define reg_r_iqip_wacc_im_15_8_len 8
+#define reg_r_iqip_wacc_im_15_8_lsb 8
+#define xd_r_reg_r_iqip_wacc_im_16  (*(volatile byte xdata *) 0xF102)
+#define    r_reg_r_iqip_wacc_im_16  0xF102
+#define reg_r_iqip_wacc_im_16_pos 0
+#define reg_r_iqip_wacc_im_16_len 1
+#define reg_r_iqip_wacc_im_16_lsb 16
+#define xd_r_reg_r_iqip_out2cacc_re_7_0 (*(volatile byte xdata *) 0xF103)
+#define    r_reg_r_iqip_out2cacc_re_7_0 0xF103
+#define reg_r_iqip_out2cacc_re_7_0_pos 0
+#define reg_r_iqip_out2cacc_re_7_0_len 8
+#define reg_r_iqip_out2cacc_re_7_0_lsb 0
+#define xd_r_reg_r_iqip_out2cacc_re_15_8    (*(volatile byte xdata *) 0xF104)
+#define    r_reg_r_iqip_out2cacc_re_15_8    0xF104
+#define reg_r_iqip_out2cacc_re_15_8_pos 0
+#define reg_r_iqip_out2cacc_re_15_8_len 8
+#define reg_r_iqip_out2cacc_re_15_8_lsb 8
+#define xd_r_reg_r_iqip_out2cacc_re_21_16   (*(volatile byte xdata *) 0xF105)
+#define    r_reg_r_iqip_out2cacc_re_21_16   0xF105
+#define reg_r_iqip_out2cacc_re_21_16_pos 0
+#define reg_r_iqip_out2cacc_re_21_16_len 6
+#define reg_r_iqip_out2cacc_re_21_16_lsb 16
+#define xd_r_reg_r_iqip_out2cacc_im_7_0 (*(volatile byte xdata *) 0xF106)
+#define    r_reg_r_iqip_out2cacc_im_7_0 0xF106
+#define reg_r_iqip_out2cacc_im_7_0_pos 0
+#define reg_r_iqip_out2cacc_im_7_0_len 8
+#define reg_r_iqip_out2cacc_im_7_0_lsb 0
+#define xd_r_reg_r_iqip_out2cacc_im_15_8    (*(volatile byte xdata *) 0xF107)
+#define    r_reg_r_iqip_out2cacc_im_15_8    0xF107
+#define reg_r_iqip_out2cacc_im_15_8_pos 0
+#define reg_r_iqip_out2cacc_im_15_8_len 8
+#define reg_r_iqip_out2cacc_im_15_8_lsb 8
+#define xd_r_reg_r_iqip_out2cacc_im_21_16   (*(volatile byte xdata *) 0xF108)
+#define    r_reg_r_iqip_out2cacc_im_21_16   0xF108
+#define reg_r_iqip_out2cacc_im_21_16_pos 0
+#define reg_r_iqip_out2cacc_im_21_16_len 6
+#define reg_r_iqip_out2cacc_im_21_16_lsb 16
+#define xd_p_reg_mccid_ccif0_scstrobe   (*(volatile byte xdata *) 0xF109)
+#define    p_reg_mccid_ccif0_scstrobe   0xF109
+#define reg_mccid_ccif0_scstrobe_pos 0
+#define reg_mccid_ccif0_scstrobe_len 7
+#define reg_mccid_ccif0_scstrobe_lsb 0
+#define xd_p_reg_mccid_cciftrigger  (*(volatile byte xdata *) 0xF10A)
+#define    p_reg_mccid_cciftrigger  0xF10A
+#define reg_mccid_cciftrigger_pos 0
+#define reg_mccid_cciftrigger_len 1
+#define reg_mccid_cciftrigger_lsb 0
+#define xd_p_reg_mccid_ccif1_scstrobe   (*(volatile byte xdata *) 0xF10B)
+#define    p_reg_mccid_ccif1_scstrobe   0xF10B
+#define reg_mccid_ccif1_scstrobe_pos 0
+#define reg_mccid_ccif1_scstrobe_len 7
+#define reg_mccid_ccif1_scstrobe_lsb 0
+#define xd_p_reg_mccid_ccif0_fcwccif_7_0    (*(volatile byte xdata *) 0xF10E)
+#define    p_reg_mccid_ccif0_fcwccif_7_0    0xF10E
+#define reg_mccid_ccif0_fcwccif_7_0_pos 0
+#define reg_mccid_ccif0_fcwccif_7_0_len 8
+#define reg_mccid_ccif0_fcwccif_7_0_lsb 0
+#define xd_p_reg_mccid_ccif0_fcwccif_13_8   (*(volatile byte xdata *) 0xF10F)
+#define    p_reg_mccid_ccif0_fcwccif_13_8   0xF10F
+#define reg_mccid_ccif0_fcwccif_13_8_pos 0
+#define reg_mccid_ccif0_fcwccif_13_8_len 6
+#define reg_mccid_ccif0_fcwccif_13_8_lsb 8
+#define xd_p_reg_mccid_ccif0_state  (*(volatile byte xdata *) 0xF110)
+#define    p_reg_mccid_ccif0_state  0xF110
+#define reg_mccid_ccif0_state_pos 0
+#define reg_mccid_ccif0_state_len 1
+#define reg_mccid_ccif0_state_lsb 0
+#define xd_p_reg_mccid_ccif0_acistate   (*(volatile byte xdata *) 0xF111)
+#define    p_reg_mccid_ccif0_acistate   0xF111
+#define reg_mccid_ccif0_acistate_pos 0
+#define reg_mccid_ccif0_acistate_len 1
+#define reg_mccid_ccif0_acistate_lsb 0
+#define xd_p_reg_mccid_ccif1_fcwccif_7_0    (*(volatile byte xdata *) 0xF112)
+#define    p_reg_mccid_ccif1_fcwccif_7_0    0xF112
+#define reg_mccid_ccif1_fcwccif_7_0_pos 0
+#define reg_mccid_ccif1_fcwccif_7_0_len 8
+#define reg_mccid_ccif1_fcwccif_7_0_lsb 0
+#define xd_p_reg_mccid_ccif1_fcwccif_13_8   (*(volatile byte xdata *) 0xF113)
+#define    p_reg_mccid_ccif1_fcwccif_13_8   0xF113
+#define reg_mccid_ccif1_fcwccif_13_8_pos 0
+#define reg_mccid_ccif1_fcwccif_13_8_len 6
+#define reg_mccid_ccif1_fcwccif_13_8_lsb 8
+#define xd_p_reg_mccid_ccif1_state  (*(volatile byte xdata *) 0xF114)
+#define    p_reg_mccid_ccif1_state  0xF114
+#define reg_mccid_ccif1_state_pos 0
+#define reg_mccid_ccif1_state_len 1
+#define reg_mccid_ccif1_state_lsb 0
+#define xd_p_reg_mccid_ccif1_acistate   (*(volatile byte xdata *) 0xF115)
+#define    p_reg_mccid_ccif1_acistate   0xF115
+#define reg_mccid_ccif1_acistate_pos 0
+#define reg_mccid_ccif1_acistate_len 1
+#define reg_mccid_ccif1_acistate_lsb 0
+#define xd_r_reg_r_acif_saturate    (*(volatile byte xdata *) 0xF117)
+#define    r_reg_r_acif_saturate    0xF117
+#define reg_r_acif_saturate_pos 0
+#define reg_r_acif_saturate_len 8
+#define reg_r_acif_saturate_lsb 0
+#define xd_p_reg_tmr_timer0_threshold_7_0   (*(volatile byte xdata *) 0xF118)
+#define    p_reg_tmr_timer0_threshold_7_0   0xF118
+#define reg_tmr_timer0_threshold_7_0_pos 0
+#define reg_tmr_timer0_threshold_7_0_len 8
+#define reg_tmr_timer0_threshold_7_0_lsb 0
+#define xd_p_reg_tmr_timer0_threshold_15_8  (*(volatile byte xdata *) 0xF119)
+#define    p_reg_tmr_timer0_threshold_15_8  0xF119
+#define reg_tmr_timer0_threshold_15_8_pos 0
+#define reg_tmr_timer0_threshold_15_8_len 8
+#define reg_tmr_timer0_threshold_15_8_lsb 8
+#define xd_p_reg_tmr_timer0_enable  (*(volatile byte xdata *) 0xF11A)
+#define    p_reg_tmr_timer0_enable  0xF11A
+#define reg_tmr_timer0_enable_pos 0
+#define reg_tmr_timer0_enable_len 1
+#define reg_tmr_timer0_enable_lsb 0
+#define xd_p_reg_tmr_timer0_clk_sel (*(volatile byte xdata *) 0xF11B)
+#define    p_reg_tmr_timer0_clk_sel 0xF11B
+#define reg_tmr_timer0_clk_sel_pos 0
+#define reg_tmr_timer0_clk_sel_len 1
+#define reg_tmr_timer0_clk_sel_lsb 0
+#define xd_p_reg_tmr_timer0_int (*(volatile byte xdata *) 0xF11C)
+#define    p_reg_tmr_timer0_int 0xF11C
+#define reg_tmr_timer0_int_pos 0
+#define reg_tmr_timer0_int_len 1
+#define reg_tmr_timer0_int_lsb 0
+#define xd_p_reg_tmr_timer0_rst (*(volatile byte xdata *) 0xF11D)
+#define    p_reg_tmr_timer0_rst 0xF11D
+#define reg_tmr_timer0_rst_pos 0
+#define reg_tmr_timer0_rst_len 1
+#define reg_tmr_timer0_rst_lsb 0
+#define xd_r_reg_tmr_timer0_count_7_0   (*(volatile byte xdata *) 0xF11E)
+#define    r_reg_tmr_timer0_count_7_0   0xF11E
+#define reg_tmr_timer0_count_7_0_pos 0
+#define reg_tmr_timer0_count_7_0_len 8
+#define reg_tmr_timer0_count_7_0_lsb 0
+#define xd_r_reg_tmr_timer0_count_15_8  (*(volatile byte xdata *) 0xF11F)
+#define    r_reg_tmr_timer0_count_15_8  0xF11F
+#define reg_tmr_timer0_count_15_8_pos 0
+#define reg_tmr_timer0_count_15_8_len 8
+#define reg_tmr_timer0_count_15_8_lsb 8
+#define xd_p_reg_suspend    (*(volatile byte xdata *) 0xF120)
+#define    p_reg_suspend    0xF120
+#define reg_suspend_pos 0
+#define reg_suspend_len 1
+#define reg_suspend_lsb 0
+#define xd_p_reg_suspend_rdy    (*(volatile byte xdata *) 0xF121)
+#define    p_reg_suspend_rdy    0xF121
+#define reg_suspend_rdy_pos 0
+#define reg_suspend_rdy_len 1
+#define reg_suspend_rdy_lsb 0
+#define xd_p_reg_resume (*(volatile byte xdata *) 0xF122)
+#define    p_reg_resume 0xF122
+#define reg_resume_pos 0
+#define reg_resume_len 1
+#define reg_resume_lsb 0
+#define xd_p_reg_resume_rdy (*(volatile byte xdata *) 0xF123)
+#define    p_reg_resume_rdy 0xF123
+#define reg_resume_rdy_pos 0
+#define reg_resume_rdy_len 1
+#define reg_resume_rdy_lsb 0
+#define xd_p_reg_gp_trigger (*(volatile byte xdata *) 0xF124)
+#define    p_reg_gp_trigger 0xF124
+#define reg_gp_trigger_pos 0
+#define reg_gp_trigger_len 1
+#define reg_gp_trigger_lsb 0
+#define xd_p_reg_trigger_sel    (*(volatile byte xdata *) 0xF125)
+#define    p_reg_trigger_sel    0xF125
+#define reg_trigger_sel_pos 0
+#define reg_trigger_sel_len 2
+#define reg_trigger_sel_lsb 0
+#define xd_p_reg_debug_ofdm (*(volatile byte xdata *) 0xF126)
+#define    p_reg_debug_ofdm 0xF126
+#define reg_debug_ofdm_pos 0
+#define reg_debug_ofdm_len 2
+#define reg_debug_ofdm_lsb 0
+#define xd_p_reg_trigger_module_sel (*(volatile byte xdata *) 0xF127)
+#define    p_reg_trigger_module_sel 0xF127
+#define reg_trigger_module_sel_pos 0
+#define reg_trigger_module_sel_len 6
+#define reg_trigger_module_sel_lsb 0
+#define xd_p_reg_trigger_set_sel    (*(volatile byte xdata *) 0xF128)
+#define    p_reg_trigger_set_sel    0xF128
+#define reg_trigger_set_sel_pos 0
+#define reg_trigger_set_sel_len 6
+#define reg_trigger_set_sel_lsb 0
+#define xd_p_reg_fw_int_mask_n  (*(volatile byte xdata *) 0xF129)
+#define    p_reg_fw_int_mask_n  0xF129
+#define reg_fw_int_mask_n_pos 0
+#define reg_fw_int_mask_n_len 1
+#define reg_fw_int_mask_n_lsb 0
+#define xd_p_reg_dioif_rst  (*(volatile byte xdata *) 0xF12A)
+#define    p_reg_dioif_rst  0xF12A
+#define reg_dioif_rst_pos 0
+#define reg_dioif_rst_len 1
+#define reg_dioif_rst_lsb 0
+#define xd_p_reg_debug_group    (*(volatile byte xdata *) 0xF12B)
+#define    p_reg_debug_group    0xF12B
+#define reg_debug_group_pos 0
+#define reg_debug_group_len 4
+#define reg_debug_group_lsb 0
+#define xd_p_reg_odbg_clk_sel   (*(volatile byte xdata *) 0xF12C)
+#define    p_reg_odbg_clk_sel   0xF12C
+#define reg_odbg_clk_sel_pos 0
+#define reg_odbg_clk_sel_len 3
+#define reg_odbg_clk_sel_lsb 0
+#define xd_p_reg_p_ccif_shift_fre   (*(volatile byte xdata *) 0xF12F)
+#define    p_reg_p_ccif_shift_fre   0xF12F
+#define reg_p_ccif_shift_fre_pos 0
+#define reg_p_ccif_shift_fre_len 1
+#define reg_p_ccif_shift_fre_lsb 0
+#define xd_p_reg_p_ccif_bandwidth_factor    (*(volatile byte xdata *) 0xF130)
+#define    p_reg_p_ccif_bandwidth_factor    0xF130
+#define reg_p_ccif_bandwidth_factor_pos 0
+#define reg_p_ccif_bandwidth_factor_len 3
+#define reg_p_ccif_bandwidth_factor_lsb 0
+#define xd_p_reg_ccif_rst   (*(volatile byte xdata *) 0xF131)
+#define    p_reg_ccif_rst   0xF131
+#define reg_ccif_rst_pos 0
+#define reg_ccif_rst_len 1
+#define reg_ccif_rst_lsb 0
+#define xd_p_reg_p_ccif_min_bandwidth   (*(volatile byte xdata *) 0xF132)
+#define    p_reg_p_ccif_min_bandwidth   0xF132
+#define reg_p_ccif_min_bandwidth_pos 0
+#define reg_p_ccif_min_bandwidth_len 7
+#define reg_p_ccif_min_bandwidth_lsb 0
+#define xd_p_reg_ccif_bq0_state (*(volatile byte xdata *) 0xF133)
+#define    p_reg_ccif_bq0_state 0xF133
+#define reg_ccif_bq0_state_pos 0
+#define reg_ccif_bq0_state_len 1
+#define reg_ccif_bq0_state_lsb 0
+#define xd_p_reg_ccif_bq0_outputscaling (*(volatile byte xdata *) 0xF134)
+#define    p_reg_ccif_bq0_outputscaling 0xF134
+#define reg_ccif_bq0_outputscaling_pos 0
+#define reg_ccif_bq0_outputscaling_len 5
+#define reg_ccif_bq0_outputscaling_lsb 0
+#define xd_p_reg_ccif_bq1_state (*(volatile byte xdata *) 0xF135)
+#define    p_reg_ccif_bq1_state 0xF135
+#define reg_ccif_bq1_state_pos 0
+#define reg_ccif_bq1_state_len 1
+#define reg_ccif_bq1_state_lsb 0
+#define xd_p_reg_ccif_bq1_outputscaling (*(volatile byte xdata *) 0xF136)
+#define    p_reg_ccif_bq1_outputscaling 0xF136
+#define reg_ccif_bq1_outputscaling_pos 0
+#define reg_ccif_bq1_outputscaling_len 5
+#define reg_ccif_bq1_outputscaling_lsb 0
+#define xd_p_reg_ccif_bq0_a1_7_0    (*(volatile byte xdata *) 0xF137)
+#define    p_reg_ccif_bq0_a1_7_0    0xF137
+#define reg_ccif_bq0_a1_7_0_pos 0
+#define reg_ccif_bq0_a1_7_0_len 8
+#define reg_ccif_bq0_a1_7_0_lsb 0
+#define xd_p_reg_ccif_bq0_a1_13_8   (*(volatile byte xdata *) 0xF138)
+#define    p_reg_ccif_bq0_a1_13_8   0xF138
+#define reg_ccif_bq0_a1_13_8_pos 0
+#define reg_ccif_bq0_a1_13_8_len 6
+#define reg_ccif_bq0_a1_13_8_lsb 8
+#define xd_p_reg_ccif_bq1_a1_7_0    (*(volatile byte xdata *) 0xF139)
+#define    p_reg_ccif_bq1_a1_7_0    0xF139
+#define reg_ccif_bq1_a1_7_0_pos 0
+#define reg_ccif_bq1_a1_7_0_len 8
+#define reg_ccif_bq1_a1_7_0_lsb 0
+#define xd_p_reg_ccif_bq1_a1_13_8   (*(volatile byte xdata *) 0xF13A)
+#define    p_reg_ccif_bq1_a1_13_8   0xF13A
+#define reg_ccif_bq1_a1_13_8_pos 0
+#define reg_ccif_bq1_a1_13_8_len 6
+#define reg_ccif_bq1_a1_13_8_lsb 8
+#define xd_p_reg_ccif_bq0_b1_7_0    (*(volatile byte xdata *) 0xF13B)
+#define    p_reg_ccif_bq0_b1_7_0    0xF13B
+#define reg_ccif_bq0_b1_7_0_pos 0
+#define reg_ccif_bq0_b1_7_0_len 8
+#define reg_ccif_bq0_b1_7_0_lsb 0
+#define xd_p_reg_ccif_bq0_b1_13_8   (*(volatile byte xdata *) 0xF13C)
+#define    p_reg_ccif_bq0_b1_13_8   0xF13C
+#define reg_ccif_bq0_b1_13_8_pos 0
+#define reg_ccif_bq0_b1_13_8_len 6
+#define reg_ccif_bq0_b1_13_8_lsb 8
+#define xd_p_reg_ccif_bq1_b1_7_0    (*(volatile byte xdata *) 0xF13D)
+#define    p_reg_ccif_bq1_b1_7_0    0xF13D
+#define reg_ccif_bq1_b1_7_0_pos 0
+#define reg_ccif_bq1_b1_7_0_len 8
+#define reg_ccif_bq1_b1_7_0_lsb 0
+#define xd_p_reg_ccif_bq1_b1_13_8   (*(volatile byte xdata *) 0xF13E)
+#define    p_reg_ccif_bq1_b1_13_8   0xF13E
+#define reg_ccif_bq1_b1_13_8_pos 0
+#define reg_ccif_bq1_b1_13_8_len 6
+#define reg_ccif_bq1_b1_13_8_lsb 8
+#define xd_p_reg_ccif_bq0_b2_7_0    (*(volatile byte xdata *) 0xF13F)
+#define    p_reg_ccif_bq0_b2_7_0    0xF13F
+#define reg_ccif_bq0_b2_7_0_pos 0
+#define reg_ccif_bq0_b2_7_0_len 8
+#define reg_ccif_bq0_b2_7_0_lsb 0
+#define xd_p_reg_ccif_bq0_b2_13_8   (*(volatile byte xdata *) 0xF140)
+#define    p_reg_ccif_bq0_b2_13_8   0xF140
+#define reg_ccif_bq0_b2_13_8_pos 0
+#define reg_ccif_bq0_b2_13_8_len 6
+#define reg_ccif_bq0_b2_13_8_lsb 8
+#define xd_p_reg_ccif_bq1_b2_7_0    (*(volatile byte xdata *) 0xF141)
+#define    p_reg_ccif_bq1_b2_7_0    0xF141
+#define reg_ccif_bq1_b2_7_0_pos 0
+#define reg_ccif_bq1_b2_7_0_len 8
+#define reg_ccif_bq1_b2_7_0_lsb 0
+#define xd_p_reg_ccif_bq1_b2_13_8   (*(volatile byte xdata *) 0xF142)
+#define    p_reg_ccif_bq1_b2_13_8   0xF142
+#define reg_ccif_bq1_b2_13_8_pos 0
+#define reg_ccif_bq1_b2_13_8_len 6
+#define reg_ccif_bq1_b2_13_8_lsb 8
+#define xd_p_reg_ccif_debug_rst (*(volatile byte xdata *) 0xF143)
+#define    p_reg_ccif_debug_rst 0xF143
+#define reg_ccif_debug_rst_pos 0
+#define reg_ccif_debug_rst_len 1
+#define reg_ccif_debug_rst_lsb 0
+#define xd_p_reg_mccid_defaultccifscstrobe  (*(volatile byte xdata *) 0xF144)
+#define    p_reg_mccid_defaultccifscstrobe  0xF144
+#define reg_mccid_defaultccifscstrobe_pos 0
+#define reg_mccid_defaultccifscstrobe_len 7
+#define reg_mccid_defaultccifscstrobe_lsb 0
+#define xd_p_reg_mccid_monitoringaci    (*(volatile byte xdata *) 0xF145)
+#define    p_reg_mccid_monitoringaci    0xF145
+#define reg_mccid_monitoringaci_pos 0
+#define reg_mccid_monitoringaci_len 1
+#define reg_mccid_monitoringaci_lsb 0
+#define xd_p_reg_mccid_ispassmode   (*(volatile byte xdata *) 0xF146)
+#define    p_reg_mccid_ispassmode   0xF146
+#define reg_mccid_ispassmode_pos 0
+#define reg_mccid_ispassmode_len 1
+#define reg_mccid_ispassmode_lsb 0
+#define xd_p_reg_mccid_issteadystatemode    (*(volatile byte xdata *) 0xF147)
+#define    p_reg_mccid_issteadystatemode    0xF147
+#define reg_mccid_issteadystatemode_pos 0
+#define reg_mccid_issteadystatemode_len 1
+#define reg_mccid_issteadystatemode_lsb 0
+#define xd_p_reg_mccid_fixedgaincmp (*(volatile byte xdata *) 0xF148)
+#define    p_reg_mccid_fixedgaincmp 0xF148
+#define reg_mccid_fixedgaincmp_pos 0
+#define reg_mccid_fixedgaincmp_len 1
+#define reg_mccid_fixedgaincmp_lsb 0
+#define xd_p_reg_mccid_misscounter_reset    (*(volatile byte xdata *) 0xF149)
+#define    p_reg_mccid_misscounter_reset    0xF149
+#define reg_mccid_misscounter_reset_pos 0
+#define reg_mccid_misscounter_reset_len 1
+#define reg_mccid_misscounter_reset_lsb 0
+#define xd_p_reg_mccid_acwgcheckcciexist    (*(volatile byte xdata *) 0xF14A)
+#define    p_reg_mccid_acwgcheckcciexist    0xF14A
+#define reg_mccid_acwgcheckcciexist_pos 0
+#define reg_mccid_acwgcheckcciexist_len 1
+#define reg_mccid_acwgcheckcciexist_lsb 0
+#define xd_p_reg_mccid_acidone  (*(volatile byte xdata *) 0xF14B)
+#define    p_reg_mccid_acidone  0xF14B
+#define reg_mccid_acidone_pos 0
+#define reg_mccid_acidone_len 1
+#define reg_mccid_acidone_lsb 0
+#define xd_p_reg_mccid_sxdesiredpower_7_0   (*(volatile byte xdata *) 0xF14C)
+#define    p_reg_mccid_sxdesiredpower_7_0   0xF14C
+#define reg_mccid_sxdesiredpower_7_0_pos 0
+#define reg_mccid_sxdesiredpower_7_0_len 8
+#define reg_mccid_sxdesiredpower_7_0_lsb 0
+#define xd_p_reg_mccid_sxdesiredpower_9_8   (*(volatile byte xdata *) 0xF14D)
+#define    p_reg_mccid_sxdesiredpower_9_8   0xF14D
+#define reg_mccid_sxdesiredpower_9_8_pos 0
+#define reg_mccid_sxdesiredpower_9_8_len 2
+#define reg_mccid_sxdesiredpower_9_8_lsb 8
+#define xd_p_reg_mccid_defaultccitimertriggerno (*(volatile byte xdata *) 0xF14E)
+#define    p_reg_mccid_defaultccitimertriggerno 0xF14E
+#define reg_mccid_defaultccitimertriggerno_pos 0
+#define reg_mccid_defaultccitimertriggerno_len 8
+#define reg_mccid_defaultccitimertriggerno_lsb 0
+#define xd_p_reg_mccid_detectedmaxtonecountshift    (*(volatile byte xdata *) 0xF14F)
+#define    p_reg_mccid_detectedmaxtonecountshift    0xF14F
+#define reg_mccid_detectedmaxtonecountshift_pos 0
+#define reg_mccid_detectedmaxtonecountshift_len 3
+#define reg_mccid_detectedmaxtonecountshift_lsb 0
+#define xd_p_reg_mccid_moveffttoccif_en (*(volatile byte xdata *) 0xF151)
+#define    p_reg_mccid_moveffttoccif_en 0xF151
+#define reg_mccid_moveffttoccif_en_pos 0
+#define reg_mccid_moveffttoccif_en_len 1
+#define reg_mccid_moveffttoccif_en_lsb 0
+#define xd_p_reg_mccid_fftindextobfsfcwfactor_7_0   (*(volatile byte xdata *) 0xF152)
+#define    p_reg_mccid_fftindextobfsfcwfactor_7_0   0xF152
+#define reg_mccid_fftindextobfsfcwfactor_7_0_pos 0
+#define reg_mccid_fftindextobfsfcwfactor_7_0_len 8
+#define reg_mccid_fftindextobfsfcwfactor_7_0_lsb 0
+#define xd_p_reg_mccid_fftindextobfsfcwfactor_9_8   (*(volatile byte xdata *) 0xF153)
+#define    p_reg_mccid_fftindextobfsfcwfactor_9_8   0xF153
+#define reg_mccid_fftindextobfsfcwfactor_9_8_pos 0
+#define reg_mccid_fftindextobfsfcwfactor_9_8_len 2
+#define reg_mccid_fftindextobfsfcwfactor_9_8_lsb 8
+#define xd_p_reg_mccid_bfsfcwffttoindexfactor_7_0   (*(volatile byte xdata *) 0xF154)
+#define    p_reg_mccid_bfsfcwffttoindexfactor_7_0   0xF154
+#define reg_mccid_bfsfcwffttoindexfactor_7_0_pos 0
+#define reg_mccid_bfsfcwffttoindexfactor_7_0_len 8
+#define reg_mccid_bfsfcwffttoindexfactor_7_0_lsb 0
+#define xd_p_reg_mccid_bfsfcwffttoindexfactor_10_8  (*(volatile byte xdata *) 0xF155)
+#define    p_reg_mccid_bfsfcwffttoindexfactor_10_8  0xF155
+#define reg_mccid_bfsfcwffttoindexfactor_10_8_pos 0
+#define reg_mccid_bfsfcwffttoindexfactor_10_8_len 3
+#define reg_mccid_bfsfcwffttoindexfactor_10_8_lsb 8
+#define xd_p_reg_mccid_detectedaci  (*(volatile byte xdata *) 0xF156)
+#define    p_reg_mccid_detectedaci  0xF156
+#define reg_mccid_detectedaci_pos 0
+#define reg_mccid_detectedaci_len 1
+#define reg_mccid_detectedaci_lsb 0
+#define xd_r_reg_mccid_filter_enable    (*(volatile byte xdata *) 0xF157)
+#define    r_reg_mccid_filter_enable    0xF157
+#define reg_mccid_filter_enable_pos 0
+#define reg_mccid_filter_enable_len 1
+#define reg_mccid_filter_enable_lsb 0
+#define xd_p_reg_mccid_aciscstrobe  (*(volatile byte xdata *) 0xF158)
+#define    p_reg_mccid_aciscstrobe  0xF158
+#define reg_mccid_aciscstrobe_pos 0
+#define reg_mccid_aciscstrobe_len 7
+#define reg_mccid_aciscstrobe_lsb 0
+#define xd_p_reg_mccid_scanningaci  (*(volatile byte xdata *) 0xF159)
+#define    p_reg_mccid_scanningaci  0xF159
+#define reg_mccid_scanningaci_pos 0
+#define reg_mccid_scanningaci_len 1
+#define reg_mccid_scanningaci_lsb 0
+#define xd_p_reg_mccid_windowsizeacciwdcount_7_0    (*(volatile byte xdata *) 0xF15A)
+#define    p_reg_mccid_windowsizeacciwdcount_7_0    0xF15A
+#define reg_mccid_windowsizeacciwdcount_7_0_pos 0
+#define reg_mccid_windowsizeacciwdcount_7_0_len 8
+#define reg_mccid_windowsizeacciwdcount_7_0_lsb 0
+#define xd_p_reg_mccid_windowsizeacciwdcount_12_8   (*(volatile byte xdata *) 0xF15B)
+#define    p_reg_mccid_windowsizeacciwdcount_12_8   0xF15B
+#define reg_mccid_windowsizeacciwdcount_12_8_pos 0
+#define reg_mccid_windowsizeacciwdcount_12_8_len 5
+#define reg_mccid_windowsizeacciwdcount_12_8_lsb 8
+#define xd_p_reg_mccid_scannedacionly   (*(volatile byte xdata *) 0xF15C)
+#define    p_reg_mccid_scannedacionly   0xF15C
+#define reg_mccid_scannedacionly_pos 0
+#define reg_mccid_scannedacionly_len 1
+#define reg_mccid_scannedacionly_lsb 0
+#define xd_p_reg_mccid_scfactor (*(volatile byte xdata *) 0xF15D)
+#define    p_reg_mccid_scfactor 0xF15D
+#define reg_mccid_scfactor_pos 0
+#define reg_mccid_scfactor_len 5
+#define reg_mccid_scfactor_lsb 0
+#define xd_p_reg_mccid_defaultevaluatingbandwidthfactor (*(volatile byte xdata *) 0xF15E)
+#define    p_reg_mccid_defaultevaluatingbandwidthfactor 0xF15E
+#define reg_mccid_defaultevaluatingbandwidthfactor_pos 0
+#define reg_mccid_defaultevaluatingbandwidthfactor_len 3
+#define reg_mccid_defaultevaluatingbandwidthfactor_lsb 0
+#define xd_p_reg_mccid_defaultacipowerlevel (*(volatile byte xdata *) 0xF15F)
+#define    p_reg_mccid_defaultacipowerlevel 0xF15F
+#define reg_mccid_defaultacipowerlevel_pos 0
+#define reg_mccid_defaultacipowerlevel_len 3
+#define reg_mccid_defaultacipowerlevel_lsb 0
+#define xd_r_reg_mccid_outputdagc1gain_7_0  (*(volatile byte xdata *) 0xF160)
+#define    r_reg_mccid_outputdagc1gain_7_0  0xF160
+#define reg_mccid_outputdagc1gain_7_0_pos 0
+#define reg_mccid_outputdagc1gain_7_0_len 8
+#define reg_mccid_outputdagc1gain_7_0_lsb 0
+#define xd_r_reg_mccid_outputdagc1gain_9_8  (*(volatile byte xdata *) 0xF161)
+#define    r_reg_mccid_outputdagc1gain_9_8  0xF161
+#define reg_mccid_outputdagc1gain_9_8_pos 0
+#define reg_mccid_outputdagc1gain_9_8_len 2
+#define reg_mccid_outputdagc1gain_9_8_lsb 8
+#define xd_r_reg_mccid_outputdagc1gainshift (*(volatile byte xdata *) 0xF162)
+#define    r_reg_mccid_outputdagc1gainshift 0xF162
+#define reg_mccid_outputdagc1gainshift_pos 0
+#define reg_mccid_outputdagc1gainshift_len 4
+#define reg_mccid_outputdagc1gainshift_lsb 0
+#define xd_p_reg_mccid_defaultacwgcheckccipowerlevel    (*(volatile byte xdata *) 0xF163)
+#define    p_reg_mccid_defaultacwgcheckccipowerlevel    0xF163
+#define reg_mccid_defaultacwgcheckccipowerlevel_pos 0
+#define reg_mccid_defaultacwgcheckccipowerlevel_len 3
+#define reg_mccid_defaultacwgcheckccipowerlevel_lsb 0
+#define xd_p_reg_mccid_ccipowerlevelfactor  (*(volatile byte xdata *) 0xF166)
+#define    p_reg_mccid_ccipowerlevelfactor  0xF166
+#define reg_mccid_ccipowerlevelfactor_pos 0
+#define reg_mccid_ccipowerlevelfactor_len 3
+#define reg_mccid_ccipowerlevelfactor_lsb 0
+#define xd_p_reg_mccid_scstrobesearchingrange   (*(volatile byte xdata *) 0xF167)
+#define    p_reg_mccid_scstrobesearchingrange   0xF167
+#define reg_mccid_scstrobesearchingrange_pos 0
+#define reg_mccid_scstrobesearchingrange_len 8
+#define reg_mccid_scstrobesearchingrange_lsb 0
+#define xd_p_reg_mccid_searchingno  (*(volatile byte xdata *) 0xF168)
+#define    p_reg_mccid_searchingno  0xF168
+#define reg_mccid_searchingno_pos 0
+#define reg_mccid_searchingno_len 6
+#define reg_mccid_searchingno_lsb 0
+#define xd_p_reg_mccid_scannedacifrequencyresolution    (*(volatile byte xdata *) 0xF169)
+#define    p_reg_mccid_scannedacifrequencyresolution    0xF169
+#define reg_mccid_scannedacifrequencyresolution_pos 0
+#define reg_mccid_scannedacifrequencyresolution_len 4
+#define reg_mccid_scannedacifrequencyresolution_lsb 0
+#define xd_p_reg_mccid_fft0_maskmaxtoneindex_7_0    (*(volatile byte xdata *) 0xF16A)
+#define    p_reg_mccid_fft0_maskmaxtoneindex_7_0    0xF16A
+#define reg_mccid_fft0_maskmaxtoneindex_7_0_pos 0
+#define reg_mccid_fft0_maskmaxtoneindex_7_0_len 8
+#define reg_mccid_fft0_maskmaxtoneindex_7_0_lsb 0
+#define xd_p_reg_mccid_fft0_maskmaxtoneindex_12_8   (*(volatile byte xdata *) 0xF16B)
+#define    p_reg_mccid_fft0_maskmaxtoneindex_12_8   0xF16B
+#define reg_mccid_fft0_maskmaxtoneindex_12_8_pos 0
+#define reg_mccid_fft0_maskmaxtoneindex_12_8_len 5
+#define reg_mccid_fft0_maskmaxtoneindex_12_8_lsb 8
+#define xd_p_reg_mccid_fft0_state   (*(volatile byte xdata *) 0xF16C)
+#define    p_reg_mccid_fft0_state   0xF16C
+#define reg_mccid_fft0_state_pos 0
+#define reg_mccid_fft0_state_len 1
+#define reg_mccid_fft0_state_lsb 0
+#define xd_p_reg_mccid_fft1_state   (*(volatile byte xdata *) 0xF16D)
+#define    p_reg_mccid_fft1_state   0xF16D
+#define reg_mccid_fft1_state_pos 0
+#define reg_mccid_fft1_state_len 1
+#define reg_mccid_fft1_state_lsb 0
+#define xd_p_reg_mccid_fft0_maskmintoneindex_7_0    (*(volatile byte xdata *) 0xF16E)
+#define    p_reg_mccid_fft0_maskmintoneindex_7_0    0xF16E
+#define reg_mccid_fft0_maskmintoneindex_7_0_pos 0
+#define reg_mccid_fft0_maskmintoneindex_7_0_len 8
+#define reg_mccid_fft0_maskmintoneindex_7_0_lsb 0
+#define xd_p_reg_mccid_fft0_maskmintoneindex_12_8   (*(volatile byte xdata *) 0xF16F)
+#define    p_reg_mccid_fft0_maskmintoneindex_12_8   0xF16F
+#define reg_mccid_fft0_maskmintoneindex_12_8_pos 0
+#define reg_mccid_fft0_maskmintoneindex_12_8_len 5
+#define reg_mccid_fft0_maskmintoneindex_12_8_lsb 8
+#define xd_p_reg_mccid_acipowerlevelfactor  (*(volatile byte xdata *) 0xF170)
+#define    p_reg_mccid_acipowerlevelfactor  0xF170
+#define reg_mccid_acipowerlevelfactor_pos 0
+#define reg_mccid_acipowerlevelfactor_len 3
+#define reg_mccid_acipowerlevelfactor_lsb 0
+#define xd_p_reg_mccid_fft1_maskmaxtoneindex_7_0    (*(volatile byte xdata *) 0xF171)
+#define    p_reg_mccid_fft1_maskmaxtoneindex_7_0    0xF171
+#define reg_mccid_fft1_maskmaxtoneindex_7_0_pos 0
+#define reg_mccid_fft1_maskmaxtoneindex_7_0_len 8
+#define reg_mccid_fft1_maskmaxtoneindex_7_0_lsb 0
+#define xd_p_reg_mccid_fft1_maskmaxtoneindex_12_8   (*(volatile byte xdata *) 0xF172)
+#define    p_reg_mccid_fft1_maskmaxtoneindex_12_8   0xF172
+#define reg_mccid_fft1_maskmaxtoneindex_12_8_pos 0
+#define reg_mccid_fft1_maskmaxtoneindex_12_8_len 5
+#define reg_mccid_fft1_maskmaxtoneindex_12_8_lsb 8
+#define xd_p_reg_mccid_fft1_maskmintoneindex_7_0    (*(volatile byte xdata *) 0xF173)
+#define    p_reg_mccid_fft1_maskmintoneindex_7_0    0xF173
+#define reg_mccid_fft1_maskmintoneindex_7_0_pos 0
+#define reg_mccid_fft1_maskmintoneindex_7_0_len 8
+#define reg_mccid_fft1_maskmintoneindex_7_0_lsb 0
+#define xd_p_reg_mccid_fft1_maskmintoneindex_12_8   (*(volatile byte xdata *) 0xF174)
+#define    p_reg_mccid_fft1_maskmintoneindex_12_8   0xF174
+#define reg_mccid_fft1_maskmintoneindex_12_8_pos 0
+#define reg_mccid_fft1_maskmintoneindex_12_8_len 5
+#define reg_mccid_fft1_maskmintoneindex_12_8_lsb 8
+#define xd_p_reg_mccid_reset    (*(volatile byte xdata *) 0xF175)
+#define    p_reg_mccid_reset    0xF175
+#define reg_mccid_reset_pos 0
+#define reg_mccid_reset_len 1
+#define reg_mccid_reset_lsb 0
+#define xd_p_reg_mccid_gaincmpreset (*(volatile byte xdata *) 0xF176)
+#define    p_reg_mccid_gaincmpreset 0xF176
+#define reg_mccid_gaincmpreset_pos 0
+#define reg_mccid_gaincmpreset_len 1
+#define reg_mccid_gaincmpreset_lsb 0
+#define xd_p_reg_mccid_acwgreset    (*(volatile byte xdata *) 0xF177)
+#define    p_reg_mccid_acwgreset    0xF177
+#define reg_mccid_acwgreset_pos 0
+#define reg_mccid_acwgreset_len 1
+#define reg_mccid_acwgreset_lsb 0
+#define xd_p_reg_mccid_ccif0_ofsmstateenable    (*(volatile byte xdata *) 0xF178)
+#define    p_reg_mccid_ccif0_ofsmstateenable    0xF178
+#define reg_mccid_ccif0_ofsmstateenable_pos 0
+#define reg_mccid_ccif0_ofsmstateenable_len 1
+#define reg_mccid_ccif0_ofsmstateenable_lsb 0
+#define xd_p_reg_mccid_ccif1_ofsmstateenable    (*(volatile byte xdata *) 0xF179)
+#define    p_reg_mccid_ccif1_ofsmstateenable    0xF179
+#define reg_mccid_ccif1_ofsmstateenable_pos 0
+#define reg_mccid_ccif1_ofsmstateenable_len 1
+#define reg_mccid_ccif1_ofsmstateenable_lsb 0
+#define xd_p_reg_mccid_fft0_ofsmstateenable (*(volatile byte xdata *) 0xF17A)
+#define    p_reg_mccid_fft0_ofsmstateenable 0xF17A
+#define reg_mccid_fft0_ofsmstateenable_pos 0
+#define reg_mccid_fft0_ofsmstateenable_len 1
+#define reg_mccid_fft0_ofsmstateenable_lsb 0
+#define xd_p_reg_mccid_fft1_ofsmstateenable (*(volatile byte xdata *) 0xF17B)
+#define    p_reg_mccid_fft1_ofsmstateenable 0xF17B
+#define reg_mccid_fft1_ofsmstateenable_pos 0
+#define reg_mccid_fft1_ofsmstateenable_len 1
+#define reg_mccid_fft1_ofsmstateenable_lsb 0
+#define xd_p_reg_mccid_fftfiltermaskchange  (*(volatile byte xdata *) 0xF17C)
+#define    p_reg_mccid_fftfiltermaskchange  0xF17C
+#define reg_mccid_fftfiltermaskchange_pos 0
+#define reg_mccid_fftfiltermaskchange_len 1
+#define reg_mccid_fftfiltermaskchange_lsb 0
+#define xd_r_reg_mccid_maxacipowertone_7_0  (*(volatile byte xdata *) 0xF17D)
+#define    r_reg_mccid_maxacipowertone_7_0  0xF17D
+#define reg_mccid_maxacipowertone_7_0_pos 0
+#define reg_mccid_maxacipowertone_7_0_len 8
+#define reg_mccid_maxacipowertone_7_0_lsb 0
+#define xd_r_reg_mccid_maxacipowertone_12_8 (*(volatile byte xdata *) 0xF17E)
+#define    r_reg_mccid_maxacipowertone_12_8 0xF17E
+#define reg_mccid_maxacipowertone_12_8_pos 0
+#define reg_mccid_maxacipowertone_12_8_len 5
+#define reg_mccid_maxacipowertone_12_8_lsb 8
+#define xd_r_reg_mccid_ccidisappear (*(volatile byte xdata *) 0xF17F)
+#define    r_reg_mccid_ccidisappear 0xF17F
+#define reg_mccid_ccidisappear_pos 0
+#define reg_mccid_ccidisappear_len 1
+#define reg_mccid_ccidisappear_lsb 0
+#define xd_r_reg_mccid_ccilocatordone   (*(volatile byte xdata *) 0xF182)
+#define    r_reg_mccid_ccilocatordone   0xF182
+#define reg_mccid_ccilocatordone_pos 0
+#define reg_mccid_ccilocatordone_len 1
+#define reg_mccid_ccilocatordone_lsb 0
+#define xd_p_reg_mccid_enablecciftrigger    (*(volatile byte xdata *) 0xF183)
+#define    p_reg_mccid_enablecciftrigger    0xF183
+#define reg_mccid_enablecciftrigger_pos 0
+#define reg_mccid_enablecciftrigger_len 1
+#define reg_mccid_enablecciftrigger_lsb 0
+#define xd_p_reg_mccid_disableacwglaunchevaluationbandwidthtrigger  (*(volatile byte xdata *) 0xF184)
+#define    p_reg_mccid_disableacwglaunchevaluationbandwidthtrigger  0xF184
+#define reg_mccid_disableacwglaunchevaluationbandwidthtrigger_pos 0
+#define reg_mccid_disableacwglaunchevaluationbandwidthtrigger_len 1
+#define reg_mccid_disableacwglaunchevaluationbandwidthtrigger_lsb 0
+#define xd_p_reg_mccid_control_by_ofsm  (*(volatile byte xdata *) 0xF185)
+#define    p_reg_mccid_control_by_ofsm  0xF185
+#define reg_mccid_control_by_ofsm_pos 0
+#define reg_mccid_control_by_ofsm_len 1
+#define reg_mccid_control_by_ofsm_lsb 0
+#define xd_p_reg_mccid_ofsmcontrolccilocator    (*(volatile byte xdata *) 0xF186)
+#define    p_reg_mccid_ofsmcontrolccilocator    0xF186
+#define reg_mccid_ofsmcontrolccilocator_pos 0
+#define reg_mccid_ofsmcontrolccilocator_len 1
+#define reg_mccid_ofsmcontrolccilocator_lsb 0
+#define xd_p_reg_mccid_disablepotentialccitriggerccilocator (*(volatile byte xdata *) 0xF187)
+#define    p_reg_mccid_disablepotentialccitriggerccilocator 0xF187
+#define reg_mccid_disablepotentialccitriggerccilocator_pos 0
+#define reg_mccid_disablepotentialccitriggerccilocator_len 1
+#define reg_mccid_disablepotentialccitriggerccilocator_lsb 0
+#define xd_p_reg_mccid_ofsmcontrolccitesting    (*(volatile byte xdata *) 0xF188)
+#define    p_reg_mccid_ofsmcontrolccitesting    0xF188
+#define reg_mccid_ofsmcontrolccitesting_pos 0
+#define reg_mccid_ofsmcontrolccitesting_len 1
+#define reg_mccid_ofsmcontrolccitesting_lsb 0
+#define xd_p_reg_mccid_disableccitestingtriggercheckcci (*(volatile byte xdata *) 0xF189)
+#define    p_reg_mccid_disableccitestingtriggercheckcci 0xF189
+#define reg_mccid_disableccitestingtriggercheckcci_pos 0
+#define reg_mccid_disableccitestingtriggercheckcci_len 1
+#define reg_mccid_disableccitestingtriggercheckcci_lsb 0
+#define xd_p_reg_mccid_ofsmcontrolacwgsetccifscstrobe   (*(volatile byte xdata *) 0xF18A)
+#define    p_reg_mccid_ofsmcontrolacwgsetccifscstrobe   0xF18A
+#define reg_mccid_ofsmcontrolacwgsetccifscstrobe_pos 0
+#define reg_mccid_ofsmcontrolacwgsetccifscstrobe_len 1
+#define reg_mccid_ofsmcontrolacwgsetccifscstrobe_lsb 0
+#define xd_p_reg_mccid_disableacwgevaluatingbandwidthtrigger    (*(volatile byte xdata *) 0xF18B)
+#define    p_reg_mccid_disableacwgevaluatingbandwidthtrigger    0xF18B
+#define reg_mccid_disableacwgevaluatingbandwidthtrigger_pos 0
+#define reg_mccid_disableacwgevaluatingbandwidthtrigger_len 1
+#define reg_mccid_disableacwgevaluatingbandwidthtrigger_lsb 0
+#define xd_p_reg_mccid_ofsmcontrolevaluatingbandwidth   (*(volatile byte xdata *) 0xF18C)
+#define    p_reg_mccid_ofsmcontrolevaluatingbandwidth   0xF18C
+#define reg_mccid_ofsmcontrolevaluatingbandwidth_pos 0
+#define reg_mccid_ofsmcontrolevaluatingbandwidth_len 1
+#define reg_mccid_ofsmcontrolevaluatingbandwidth_lsb 0
+#define xd_p_reg_mccid_ofsmcontrolscanningaci   (*(volatile byte xdata *) 0xF18D)
+#define    p_reg_mccid_ofsmcontrolscanningaci   0xF18D
+#define reg_mccid_ofsmcontrolscanningaci_pos 0
+#define reg_mccid_ofsmcontrolscanningaci_len 1
+#define reg_mccid_ofsmcontrolscanningaci_lsb 0
+#define xd_p_reg_mccid_disablescanningaci   (*(volatile byte xdata *) 0xF18E)
+#define    p_reg_mccid_disablescanningaci   0xF18E
+#define reg_mccid_disablescanningaci_pos 0
+#define reg_mccid_disablescanningaci_len 1
+#define reg_mccid_disablescanningaci_lsb 0
+#define xd_p_reg_mccid_disableacwgccidetecting  (*(volatile byte xdata *) 0xF18F)
+#define    p_reg_mccid_disableacwgccidetecting  0xF18F
+#define reg_mccid_disableacwgccidetecting_pos 0
+#define reg_mccid_disableacwgccidetecting_len 1
+#define reg_mccid_disableacwgccidetecting_lsb 0
+#define xd_p_reg_mccid_ofsmcontrolccitimertrigger   (*(volatile byte xdata *) 0xF190)
+#define    p_reg_mccid_ofsmcontrolccitimertrigger   0xF190
+#define reg_mccid_ofsmcontrolccitimertrigger_pos 0
+#define reg_mccid_ofsmcontrolccitimertrigger_len 1
+#define reg_mccid_ofsmcontrolccitimertrigger_lsb 0
+#define xd_p_reg_mccid_disableccitimertrigger   (*(volatile byte xdata *) 0xF191)
+#define    p_reg_mccid_disableccitimertrigger   0xF191
+#define reg_mccid_disableccitimertrigger_pos 0
+#define reg_mccid_disableccitimertrigger_len 1
+#define reg_mccid_disableccitimertrigger_lsb 0
+#define xd_p_reg_mccid_ofsmdisableccitriggercounting    (*(volatile byte xdata *) 0xF192)
+#define    p_reg_mccid_ofsmdisableccitriggercounting    0xF192
+#define reg_mccid_ofsmdisableccitriggercounting_pos 0
+#define reg_mccid_ofsmdisableccitriggercounting_len 1
+#define reg_mccid_ofsmdisableccitriggercounting_lsb 0
+#define xd_p_reg_mccid_enableccifilteraci   (*(volatile byte xdata *) 0xF193)
+#define    p_reg_mccid_enableccifilteraci   0xF193
+#define reg_mccid_enableccifilteraci_pos 0
+#define reg_mccid_enableccifilteraci_len 1
+#define reg_mccid_enableccifilteraci_lsb 0
+#define xd_p_reg_mccid_scannedfcwbfs_7_0    (*(volatile byte xdata *) 0xF194)
+#define    p_reg_mccid_scannedfcwbfs_7_0    0xF194
+#define reg_mccid_scannedfcwbfs_7_0_pos 0
+#define reg_mccid_scannedfcwbfs_7_0_len 8
+#define reg_mccid_scannedfcwbfs_7_0_lsb 0
+#define xd_p_reg_mccid_scannedfcwbfs_13_8   (*(volatile byte xdata *) 0xF195)
+#define    p_reg_mccid_scannedfcwbfs_13_8   0xF195
+#define reg_mccid_scannedfcwbfs_13_8_pos 0
+#define reg_mccid_scannedfcwbfs_13_8_len 6
+#define reg_mccid_scannedfcwbfs_13_8_lsb 8
+#define xd_p_reg_mccid_acwgevaluatingbandwidth  (*(volatile byte xdata *) 0xF196)
+#define    p_reg_mccid_acwgevaluatingbandwidth  0xF196
+#define reg_mccid_acwgevaluatingbandwidth_pos 0
+#define reg_mccid_acwgevaluatingbandwidth_len 1
+#define reg_mccid_acwgevaluatingbandwidth_lsb 0
+#define xd_p_reg_mccid_acwglaunchevaluationbandwidth    (*(volatile byte xdata *) 0xF197)
+#define    p_reg_mccid_acwglaunchevaluationbandwidth    0xF197
+#define reg_mccid_acwglaunchevaluationbandwidth_pos 0
+#define reg_mccid_acwglaunchevaluationbandwidth_len 1
+#define reg_mccid_acwglaunchevaluationbandwidth_lsb 0
+#define xd_p_reg_mccid_scannedcandidate (*(volatile byte xdata *) 0xF198)
+#define    p_reg_mccid_scannedcandidate 0xF198
+#define reg_mccid_scannedcandidate_pos 0
+#define reg_mccid_scannedcandidate_len 3
+#define reg_mccid_scannedcandidate_lsb 0
+#define xd_p_reg_mccid_scstrobesearchingcandidate   (*(volatile byte xdata *) 0xF199)
+#define    p_reg_mccid_scstrobesearchingcandidate   0xF199
+#define reg_mccid_scstrobesearchingcandidate_pos 0
+#define reg_mccid_scstrobesearchingcandidate_len 2
+#define reg_mccid_scstrobesearchingcandidate_lsb 0
+#define xd_p_reg_mccid_potentialcci (*(volatile byte xdata *) 0xF19A)
+#define    p_reg_mccid_potentialcci 0xF19A
+#define reg_mccid_potentialcci_pos 0
+#define reg_mccid_potentialcci_len 1
+#define reg_mccid_potentialcci_lsb 0
+#define xd_p_reg_mccid_cciftimertrigger (*(volatile byte xdata *) 0xF19B)
+#define    p_reg_mccid_cciftimertrigger 0xF19B
+#define reg_mccid_cciftimertrigger_pos 0
+#define reg_mccid_cciftimertrigger_len 1
+#define reg_mccid_cciftimertrigger_lsb 0
+#define xd_p_reg_mccid_ccitesting   (*(volatile byte xdata *) 0xF19C)
+#define    p_reg_mccid_ccitesting   0xF19C
+#define reg_mccid_ccitesting_pos 0
+#define reg_mccid_ccitesting_len 1
+#define reg_mccid_ccitesting_lsb 0
+#define xd_p_reg_mccid_defaultccilocatormissno  (*(volatile byte xdata *) 0xF19D)
+#define    p_reg_mccid_defaultccilocatormissno  0xF19D
+#define reg_mccid_defaultccilocatormissno_pos 0
+#define reg_mccid_defaultccilocatormissno_len 8
+#define reg_mccid_defaultccilocatormissno_lsb 0
+#define xd_p_reg_mccid_dagc1_use_despow (*(volatile byte xdata *) 0xF19E)
+#define    p_reg_mccid_dagc1_use_despow 0xF19E
+#define reg_mccid_dagc1_use_despow_pos 0
+#define reg_mccid_dagc1_use_despow_len 1
+#define reg_mccid_dagc1_use_despow_lsb 0
+#define xd_p_reg_mccid_scannedacifrequencybegin_7_0 (*(volatile byte xdata *) 0xF19F)
+#define    p_reg_mccid_scannedacifrequencybegin_7_0 0xF19F
+#define reg_mccid_scannedacifrequencybegin_7_0_pos 0
+#define reg_mccid_scannedacifrequencybegin_7_0_len 8
+#define reg_mccid_scannedacifrequencybegin_7_0_lsb 0
+#define xd_p_reg_mccid_scannedacifrequencybegin_13_8    (*(volatile byte xdata *) 0xF1A0)
+#define    p_reg_mccid_scannedacifrequencybegin_13_8    0xF1A0
+#define reg_mccid_scannedacifrequencybegin_13_8_pos 0
+#define reg_mccid_scannedacifrequencybegin_13_8_len 6
+#define reg_mccid_scannedacifrequencybegin_13_8_lsb 8
+#define xd_p_reg_mccid_scannedacifrequencyend_7_0   (*(volatile byte xdata *) 0xF1A1)
+#define    p_reg_mccid_scannedacifrequencyend_7_0   0xF1A1
+#define reg_mccid_scannedacifrequencyend_7_0_pos 0
+#define reg_mccid_scannedacifrequencyend_7_0_len 8
+#define reg_mccid_scannedacifrequencyend_7_0_lsb 0
+#define xd_p_reg_mccid_scannedacifrequencyend_13_8  (*(volatile byte xdata *) 0xF1A2)
+#define    p_reg_mccid_scannedacifrequencyend_13_8  0xF1A2
+#define reg_mccid_scannedacifrequencyend_13_8_pos 0
+#define reg_mccid_scannedacifrequencyend_13_8_len 6
+#define reg_mccid_scannedacifrequencyend_13_8_lsb 8
+#define xd_p_reg_bfs_fcw_7_0    (*(volatile byte xdata *) 0xF1A3)
+#define    p_reg_bfs_fcw_7_0    0xF1A3
+#define reg_bfs_fcw_7_0_pos 0
+#define reg_bfs_fcw_7_0_len 8
+#define reg_bfs_fcw_7_0_lsb 0
+#define xd_p_reg_bfs_fcw_15_8   (*(volatile byte xdata *) 0xF1A4)
+#define    p_reg_bfs_fcw_15_8   0xF1A4
+#define reg_bfs_fcw_15_8_pos 0
+#define reg_bfs_fcw_15_8_len 8
+#define reg_bfs_fcw_15_8_lsb 8
+#define xd_p_reg_bfs_fcw_22_16  (*(volatile byte xdata *) 0xF1A5)
+#define    p_reg_bfs_fcw_22_16  0xF1A5
+#define reg_bfs_fcw_22_16_pos 0
+#define reg_bfs_fcw_22_16_len 7
+#define reg_bfs_fcw_22_16_lsb 16
+#define xd_p_reg_cfoe_fcw_inv   (*(volatile byte xdata *) 0xF1A6)
+#define    p_reg_cfoe_fcw_inv   0xF1A6
+#define reg_cfoe_fcw_inv_pos 0
+#define reg_cfoe_fcw_inv_len 1
+#define reg_cfoe_fcw_inv_lsb 0
+#define xd_p_reg_bfs_0if    (*(volatile byte xdata *) 0xF1A7)
+#define    p_reg_bfs_0if    0xF1A7
+#define reg_bfs_0if_pos 0
+#define reg_bfs_0if_len 1
+#define reg_bfs_0if_lsb 0
+#define xd_p_reg_sadc_clk   (*(volatile byte xdata *) 0xF1A9)
+#define    p_reg_sadc_clk   0xF1A9
+#define reg_sadc_clk_pos 0
+#define reg_sadc_clk_len 1
+#define reg_sadc_clk_lsb 0
+#define xd_p_reg_sadc_tx    (*(volatile byte xdata *) 0xF1AA)
+#define    p_reg_sadc_tx    0xF1AA
+#define reg_sadc_tx_pos 0
+#define reg_sadc_tx_len 1
+#define reg_sadc_tx_lsb 0
+#define xd_p_reg_sadc_rx    (*(volatile byte xdata *) 0xF1AB)
+#define    p_reg_sadc_rx    0xF1AB
+#define reg_sadc_rx_pos 0
+#define reg_sadc_rx_len 1
+#define reg_sadc_rx_lsb 0
+#define xd_p_reg_sadc_cs    (*(volatile byte xdata *) 0xF1AC)
+#define    p_reg_sadc_cs    0xF1AC
+#define reg_sadc_cs_pos 0
+#define reg_sadc_cs_len 1
+#define reg_sadc_cs_lsb 0
+#define xd_p_reg_fix_fcw_7_0    (*(volatile byte xdata *) 0xF1AD)
+#define    p_reg_fix_fcw_7_0    0xF1AD
+#define reg_fix_fcw_7_0_pos 0
+#define reg_fix_fcw_7_0_len 8
+#define reg_fix_fcw_7_0_lsb 0
+#define xd_p_reg_fix_fcw_15_8   (*(volatile byte xdata *) 0xF1AE)
+#define    p_reg_fix_fcw_15_8   0xF1AE
+#define reg_fix_fcw_15_8_pos 0
+#define reg_fix_fcw_15_8_len 8
+#define reg_fix_fcw_15_8_lsb 8
+#define xd_p_reg_fix_fcw_22_16  (*(volatile byte xdata *) 0xF1AF)
+#define    p_reg_fix_fcw_22_16  0xF1AF
+#define reg_fix_fcw_22_16_pos 0
+#define reg_fix_fcw_22_16_len 7
+#define reg_fix_fcw_22_16_lsb 16
+#define xd_r_reg_bfs_fcw_offset_7_0 (*(volatile byte xdata *) 0xF1B0)
+#define    r_reg_bfs_fcw_offset_7_0 0xF1B0
+#define reg_bfs_fcw_offset_7_0_pos 0
+#define reg_bfs_fcw_offset_7_0_len 8
+#define reg_bfs_fcw_offset_7_0_lsb 0
+#define xd_r_reg_bfs_fcw_offset_15_8    (*(volatile byte xdata *) 0xF1B1)
+#define    r_reg_bfs_fcw_offset_15_8    0xF1B1
+#define reg_bfs_fcw_offset_15_8_pos 0
+#define reg_bfs_fcw_offset_15_8_len 8
+#define reg_bfs_fcw_offset_15_8_lsb 8
+#define xd_r_reg_bfs_fcw_offset_22_16   (*(volatile byte xdata *) 0xF1B2)
+#define    r_reg_bfs_fcw_offset_22_16   0xF1B2
+#define reg_bfs_fcw_offset_22_16_pos 0
+#define reg_bfs_fcw_offset_22_16_len 7
+#define reg_bfs_fcw_offset_22_16_lsb 16
+#define xd_r_bfs_fcw_q_7_0  (*(volatile byte xdata *) 0xF1B3)
+#define    r_bfs_fcw_q_7_0  0xF1B3
+#define bfs_fcw_q_7_0_pos 0
+#define bfs_fcw_q_7_0_len 8
+#define bfs_fcw_q_7_0_lsb 0
+#define xd_r_bfs_fcw_q_15_8 (*(volatile byte xdata *) 0xF1B4)
+#define    r_bfs_fcw_q_15_8 0xF1B4
+#define bfs_fcw_q_15_8_pos 0
+#define bfs_fcw_q_15_8_len 8
+#define bfs_fcw_q_15_8_lsb 8
+#define xd_r_bfs_fcw_q_22_16    (*(volatile byte xdata *) 0xF1B5)
+#define    r_bfs_fcw_q_22_16    0xF1B5
+#define bfs_fcw_q_22_16_pos 0
+#define bfs_fcw_q_22_16_len 7
+#define bfs_fcw_q_22_16_lsb 16
+#define xd_p_reg_dagc3_use_despow   (*(volatile byte xdata *) 0xF1B6)
+#define    p_reg_dagc3_use_despow   0xF1B6
+#define reg_dagc3_use_despow_pos 0
+#define reg_dagc3_use_despow_len 1
+#define reg_dagc3_use_despow_lsb 0
+#define xd_p_reg_dagc3_log_2_accumulate (*(volatile byte xdata *) 0xF1B7)
+#define    p_reg_dagc3_log_2_accumulate 0xF1B7
+#define reg_dagc3_log_2_accumulate_pos 0
+#define reg_dagc3_log_2_accumulate_len 5
+#define reg_dagc3_log_2_accumulate_lsb 0
+#define xd_p_reg_dagc3_desired_level_7_0    (*(volatile byte xdata *) 0xF1BC)
+#define    p_reg_dagc3_desired_level_7_0    0xF1BC
+#define reg_dagc3_desired_level_7_0_pos 0
+#define reg_dagc3_desired_level_7_0_len 8
+#define reg_dagc3_desired_level_7_0_lsb 0
+#define xd_p_reg_dagc3_desired_level_8  (*(volatile byte xdata *) 0xF1BD)
+#define    p_reg_dagc3_desired_level_8  0xF1BD
+#define reg_dagc3_desired_level_8_pos 0
+#define reg_dagc3_desired_level_8_len 1
+#define reg_dagc3_desired_level_8_lsb 8
+#define xd_p_reg_dagc3_apply_delay  (*(volatile byte xdata *) 0xF1BE)
+#define    p_reg_dagc3_apply_delay  0xF1BE
+#define reg_dagc3_apply_delay_pos 0
+#define reg_dagc3_apply_delay_len 7
+#define reg_dagc3_apply_delay_lsb 0
+#define xd_p_reg_dagc3_bp_scale (*(volatile byte xdata *) 0xF1BF)
+#define    p_reg_dagc3_bp_scale 0xF1BF
+#define reg_dagc3_bp_scale_pos 0
+#define reg_dagc3_bp_scale_len 3
+#define reg_dagc3_bp_scale_lsb 0
+#define xd_p_reg_dagc3_in_sat_cnt_7_0   (*(volatile byte xdata *) 0xF1C0)
+#define    p_reg_dagc3_in_sat_cnt_7_0   0xF1C0
+#define reg_dagc3_in_sat_cnt_7_0_pos 0
+#define reg_dagc3_in_sat_cnt_7_0_len 8
+#define reg_dagc3_in_sat_cnt_7_0_lsb 0
+#define xd_p_reg_dagc3_in_sat_cnt_15_8  (*(volatile byte xdata *) 0xF1C1)
+#define    p_reg_dagc3_in_sat_cnt_15_8  0xF1C1
+#define reg_dagc3_in_sat_cnt_15_8_pos 0
+#define reg_dagc3_in_sat_cnt_15_8_len 8
+#define reg_dagc3_in_sat_cnt_15_8_lsb 8
+#define xd_p_reg_dagc3_in_sat_cnt_23_16 (*(volatile byte xdata *) 0xF1C2)
+#define    p_reg_dagc3_in_sat_cnt_23_16 0xF1C2
+#define reg_dagc3_in_sat_cnt_23_16_pos 0
+#define reg_dagc3_in_sat_cnt_23_16_len 8
+#define reg_dagc3_in_sat_cnt_23_16_lsb 16
+#define xd_p_reg_dagc3_in_sat_cnt_31_24 (*(volatile byte xdata *) 0xF1C3)
+#define    p_reg_dagc3_in_sat_cnt_31_24 0xF1C3
+#define reg_dagc3_in_sat_cnt_31_24_pos 0
+#define reg_dagc3_in_sat_cnt_31_24_len 8
+#define reg_dagc3_in_sat_cnt_31_24_lsb 24
+#define xd_p_reg_dagc3_out_sat_cnt_7_0  (*(volatile byte xdata *) 0xF1C4)
+#define    p_reg_dagc3_out_sat_cnt_7_0  0xF1C4
+#define reg_dagc3_out_sat_cnt_7_0_pos 0
+#define reg_dagc3_out_sat_cnt_7_0_len 8
+#define reg_dagc3_out_sat_cnt_7_0_lsb 0
+#define xd_p_reg_dagc3_out_sat_cnt_15_8 (*(volatile byte xdata *) 0xF1C5)
+#define    p_reg_dagc3_out_sat_cnt_15_8 0xF1C5
+#define reg_dagc3_out_sat_cnt_15_8_pos 0
+#define reg_dagc3_out_sat_cnt_15_8_len 8
+#define reg_dagc3_out_sat_cnt_15_8_lsb 8
+#define xd_p_reg_dagc3_out_sat_cnt_23_16    (*(volatile byte xdata *) 0xF1C6)
+#define    p_reg_dagc3_out_sat_cnt_23_16    0xF1C6
+#define reg_dagc3_out_sat_cnt_23_16_pos 0
+#define reg_dagc3_out_sat_cnt_23_16_len 8
+#define reg_dagc3_out_sat_cnt_23_16_lsb 16
+#define xd_p_reg_dagc3_out_sat_cnt_31_24    (*(volatile byte xdata *) 0xF1C7)
+#define    p_reg_dagc3_out_sat_cnt_31_24    0xF1C7
+#define reg_dagc3_out_sat_cnt_31_24_pos 0
+#define reg_dagc3_out_sat_cnt_31_24_len 8
+#define reg_dagc3_out_sat_cnt_31_24_lsb 24
+#define xd_r_bfs_dagc3_multiplier_7_0   (*(volatile byte xdata *) 0xF1C8)
+#define    r_bfs_dagc3_multiplier_7_0   0xF1C8
+#define bfs_dagc3_multiplier_7_0_pos 0
+#define bfs_dagc3_multiplier_7_0_len 8
+#define bfs_dagc3_multiplier_7_0_lsb 0
+#define xd_r_bfs_dagc3_multiplier_15_8  (*(volatile byte xdata *) 0xF1C9)
+#define    r_bfs_dagc3_multiplier_15_8  0xF1C9
+#define bfs_dagc3_multiplier_15_8_pos 0
+#define bfs_dagc3_multiplier_15_8_len 8
+#define bfs_dagc3_multiplier_15_8_lsb 8
+#define xd_r_bfs_dagc3_right_shift_bits (*(volatile byte xdata *) 0xF1CA)
+#define    r_bfs_dagc3_right_shift_bits 0xF1CA
+#define bfs_dagc3_right_shift_bits_pos 0
+#define bfs_dagc3_right_shift_bits_len 4
+#define bfs_dagc3_right_shift_bits_lsb 0
+#define xd_p_reg_dagc3_fixed_gain_7_0   (*(volatile byte xdata *) 0xF1CB)
+#define    p_reg_dagc3_fixed_gain_7_0   0xF1CB
+#define reg_dagc3_fixed_gain_7_0_pos 0
+#define reg_dagc3_fixed_gain_7_0_len 8
+#define reg_dagc3_fixed_gain_7_0_lsb 0
+#define xd_p_reg_dagc3_fixed_gain_11_8  (*(volatile byte xdata *) 0xF1CC)
+#define    p_reg_dagc3_fixed_gain_11_8  0xF1CC
+#define reg_dagc3_fixed_gain_11_8_pos 0
+#define reg_dagc3_fixed_gain_11_8_len 4
+#define reg_dagc3_fixed_gain_11_8_lsb 8
+#define xd_p_reg_f_adc_7_0  (*(volatile byte xdata *) 0xF1CD)
+#define    p_reg_f_adc_7_0  0xF1CD
+#define reg_f_adc_7_0_pos 0
+#define reg_f_adc_7_0_len 8
+#define reg_f_adc_7_0_lsb 0
+#define xd_p_reg_f_adc_15_8 (*(volatile byte xdata *) 0xF1CE)
+#define    p_reg_f_adc_15_8 0xF1CE
+#define reg_f_adc_15_8_pos 0
+#define reg_f_adc_15_8_len 8
+#define reg_f_adc_15_8_lsb 8
+#define xd_p_reg_f_adc_23_16    (*(volatile byte xdata *) 0xF1CF)
+#define    p_reg_f_adc_23_16    0xF1CF
+#define reg_f_adc_23_16_pos 0
+#define reg_f_adc_23_16_len 8
+#define reg_f_adc_23_16_lsb 16
+#define xd_p_reg_fste_frac_step_size_7_0    (*(volatile byte xdata *) 0xF1D0)
+#define    p_reg_fste_frac_step_size_7_0    0xF1D0
+#define reg_fste_frac_step_size_7_0_pos 0
+#define reg_fste_frac_step_size_7_0_len 8
+#define reg_fste_frac_step_size_7_0_lsb 0
+#define xd_p_reg_fste_frac_step_size_15_8   (*(volatile byte xdata *) 0xF1D1)
+#define    p_reg_fste_frac_step_size_15_8   0xF1D1
+#define reg_fste_frac_step_size_15_8_pos 0
+#define reg_fste_frac_step_size_15_8_len 8
+#define reg_fste_frac_step_size_15_8_lsb 8
+#define xd_p_reg_fste_frac_step_size_19_16  (*(volatile byte xdata *) 0xF1D2)
+#define    p_reg_fste_frac_step_size_19_16  0xF1D2
+#define reg_fste_frac_step_size_19_16_pos 0
+#define reg_fste_frac_step_size_19_16_len 4
+#define reg_fste_frac_step_size_19_16_lsb 16
+#define xd_r_intp_mu_7_0    (*(volatile byte xdata *) 0xF1D3)
+#define    r_intp_mu_7_0    0xF1D3
+#define intp_mu_7_0_pos 0
+#define intp_mu_7_0_len 8
+#define intp_mu_7_0_lsb 0
+#define xd_r_intp_mu_15_8   (*(volatile byte xdata *) 0xF1D4)
+#define    r_intp_mu_15_8   0xF1D4
+#define intp_mu_15_8_pos 0
+#define intp_mu_15_8_len 8
+#define intp_mu_15_8_lsb 8
+#define xd_r_intp_mu_23_16  (*(volatile byte xdata *) 0xF1D5)
+#define    r_intp_mu_23_16  0xF1D5
+#define intp_mu_23_16_pos 0
+#define intp_mu_23_16_len 8
+#define intp_mu_23_16_lsb 16
+#define xd_r_intp_mu_25_24  (*(volatile byte xdata *) 0xF1D6)
+#define    r_intp_mu_25_24  0xF1D6
+#define intp_mu_25_24_pos 0
+#define intp_mu_25_24_len 2
+#define intp_mu_25_24_lsb 24
+#define xd_p_intp_muq_7_0   (*(volatile byte xdata *) 0xF1D7)
+#define    p_intp_muq_7_0   0xF1D7
+#define intp_muq_7_0_pos 0
+#define intp_muq_7_0_len 8
+#define intp_muq_7_0_lsb 0
+#define xd_p_intp_muq_15_8  (*(volatile byte xdata *) 0xF1D8)
+#define    p_intp_muq_15_8  0xF1D8
+#define intp_muq_15_8_pos 0
+#define intp_muq_15_8_len 8
+#define intp_muq_15_8_lsb 8
+#define xd_p_intp_muq_23_16 (*(volatile byte xdata *) 0xF1D9)
+#define    p_intp_muq_23_16 0xF1D9
+#define intp_muq_23_16_pos 0
+#define intp_muq_23_16_len 8
+#define intp_muq_23_16_lsb 16
+#define xd_p_reg_sfoe_inv   (*(volatile byte xdata *) 0xF1DA)
+#define    p_reg_sfoe_inv   0xF1DA
+#define reg_sfoe_inv_pos 0
+#define reg_sfoe_inv_len 1
+#define reg_sfoe_inv_lsb 0
+#define xd_p_intp_ext_en    (*(volatile byte xdata *) 0xF1DB)
+#define    p_intp_ext_en    0xF1DB
+#define intp_ext_en_pos 0
+#define intp_ext_en_len 1
+#define intp_ext_en_lsb 0
+#define xd_r_intp_ext_done  (*(volatile byte xdata *) 0xF1DC)
+#define    r_intp_ext_done  0xF1DC
+#define intp_ext_done_pos 0
+#define intp_ext_done_len 1
+#define intp_ext_done_lsb 0
+#define xd_p_intp_ext_in_7_0    (*(volatile byte xdata *) 0xF1DD)
+#define    p_intp_ext_in_7_0    0xF1DD
+#define intp_ext_in_7_0_pos 0
+#define intp_ext_in_7_0_len 8
+#define intp_ext_in_7_0_lsb 0
+#define xd_p_intp_ext_in_15_8   (*(volatile byte xdata *) 0xF1DE)
+#define    p_intp_ext_in_15_8   0xF1DE
+#define intp_ext_in_15_8_pos 0
+#define intp_ext_in_15_8_len 8
+#define intp_ext_in_15_8_lsb 8
+#define xd_p_intp_ext_in_23_16  (*(volatile byte xdata *) 0xF1DF)
+#define    p_intp_ext_in_23_16  0xF1DF
+#define intp_ext_in_23_16_pos 0
+#define intp_ext_in_23_16_len 8
+#define intp_ext_in_23_16_lsb 16
+#define xd_p_intp_ext_in_25_24  (*(volatile byte xdata *) 0xF1E0)
+#define    p_intp_ext_in_25_24  0xF1E0
+#define intp_ext_in_25_24_pos 0
+#define intp_ext_in_25_24_len 2
+#define intp_ext_in_25_24_lsb 24
+#define xd_r_intp_ext_out_7_0   (*(volatile byte xdata *) 0xF1E1)
+#define    r_intp_ext_out_7_0   0xF1E1
+#define intp_ext_out_7_0_pos 0
+#define intp_ext_out_7_0_len 8
+#define intp_ext_out_7_0_lsb 0
+#define xd_r_intp_ext_out_15_8  (*(volatile byte xdata *) 0xF1E2)
+#define    r_intp_ext_out_15_8  0xF1E2
+#define intp_ext_out_15_8_pos 0
+#define intp_ext_out_15_8_len 8
+#define intp_ext_out_15_8_lsb 8
+#define xd_r_intp_ext_out_23_16 (*(volatile byte xdata *) 0xF1E3)
+#define    r_intp_ext_out_23_16 0xF1E3
+#define intp_ext_out_23_16_pos 0
+#define intp_ext_out_23_16_len 8
+#define intp_ext_out_23_16_lsb 16
+#define xd_r_intp_ext_out_28_24 (*(volatile byte xdata *) 0xF1E4)
+#define    r_intp_ext_out_28_24 0xF1E4
+#define intp_ext_out_28_24_pos 0
+#define intp_ext_out_28_24_len 5
+#define intp_ext_out_28_24_lsb 24
+#define xd_p_reg_agc_rst    (*(volatile byte xdata *) 0xF1E5)
+#define    p_reg_agc_rst    0xF1E5
+#define reg_agc_rst_pos 0
+#define reg_agc_rst_len 1
+#define reg_agc_rst_lsb 0
+#define xd_p_rf_agc_en  (*(volatile byte xdata *) 0xF1E6)
+#define    p_rf_agc_en  0xF1E6
+#define rf_agc_en_pos 0
+#define rf_agc_en_len 1
+#define rf_agc_en_lsb 0
+#define xd_p_agc_lock   (*(volatile byte xdata *) 0xF1E7)
+#define    p_agc_lock   0xF1E7
+#define agc_lock_pos 0
+#define agc_lock_len 1
+#define agc_lock_lsb 0
+#define xd_p_reg_tinr_rst   (*(volatile byte xdata *) 0xF1E8)
+#define    p_reg_tinr_rst   0xF1E8
+#define reg_tinr_rst_pos 0
+#define reg_tinr_rst_len 1
+#define reg_tinr_rst_lsb 0
+#define xd_p_reg_tinr_en    (*(volatile byte xdata *) 0xF1E9)
+#define    p_reg_tinr_en    0xF1E9
+#define reg_tinr_en_pos 0
+#define reg_tinr_en_len 1
+#define reg_tinr_en_lsb 0
+#define xd_p_reg_bfs_en (*(volatile byte xdata *) 0xF1EA)
+#define    p_reg_bfs_en 0xF1EA
+#define reg_bfs_en_pos 0
+#define reg_bfs_en_len 1
+#define reg_bfs_en_lsb 0
+#define xd_p_reg_bfs_rst    (*(volatile byte xdata *) 0xF1EB)
+#define    p_reg_bfs_rst    0xF1EB
+#define reg_bfs_rst_pos 0
+#define reg_bfs_rst_len 1
+#define reg_bfs_rst_lsb 0
+#define xd_p_reg_bfs_byp    (*(volatile byte xdata *) 0xF1EC)
+#define    p_reg_bfs_byp    0xF1EC
+#define reg_bfs_byp_pos 0
+#define reg_bfs_byp_len 1
+#define reg_bfs_byp_lsb 0
+#define xd_p_intp_en    (*(volatile byte xdata *) 0xF1EF)
+#define    p_intp_en    0xF1EF
+#define intp_en_pos 0
+#define intp_en_len 1
+#define intp_en_lsb 0
+#define xd_p_intp_rst   (*(volatile byte xdata *) 0xF1F0)
+#define    p_intp_rst   0xF1F0
+#define intp_rst_pos 0
+#define intp_rst_len 1
+#define intp_rst_lsb 0
+#define xd_p_reg_p_acif_en  (*(volatile byte xdata *) 0xF1F2)
+#define    p_reg_p_acif_en  0xF1F2
+#define reg_p_acif_en_pos 0
+#define reg_p_acif_en_len 1
+#define reg_p_acif_en_lsb 0
+#define xd_p_reg_p_acif_rst (*(volatile byte xdata *) 0xF1F3)
+#define    p_reg_p_acif_rst 0xF1F3
+#define reg_p_acif_rst_pos 0
+#define reg_p_acif_rst_len 1
+#define reg_p_acif_rst_lsb 0
+#define xd_p_reg_p_acif_byp (*(volatile byte xdata *) 0xF1F4)
+#define    p_reg_p_acif_byp 0xF1F4
+#define reg_p_acif_byp_pos 0
+#define reg_p_acif_byp_len 1
+#define reg_p_acif_byp_lsb 0
+#define xd_p_dagc2_rst  (*(volatile byte xdata *) 0xF1F6)
+#define    p_dagc2_rst  0xF1F6
+#define dagc2_rst_pos 0
+#define dagc2_rst_len 1
+#define dagc2_rst_lsb 0
+#define xd_p_dagc2_en   (*(volatile byte xdata *) 0xF1F7)
+#define    p_dagc2_en   0xF1F7
+#define dagc2_en_pos 0
+#define dagc2_en_len 1
+#define dagc2_en_lsb 0
+#define xd_p_dagc2_mode (*(volatile byte xdata *) 0xF1F8)
+#define    p_dagc2_mode 0xF1F8
+#define dagc2_mode_pos 0
+#define dagc2_mode_len 2
+#define dagc2_mode_lsb 0
+#define xd_p_dagc2_done (*(volatile byte xdata *) 0xF1F9)
+#define    p_dagc2_done 0xF1F9
+#define dagc2_done_pos 0
+#define dagc2_done_len 1
+#define dagc2_done_lsb 0
+#define xd_p_dagc3_rst  (*(volatile byte xdata *) 0xF1FA)
+#define    p_dagc3_rst  0xF1FA
+#define dagc3_rst_pos 0
+#define dagc3_rst_len 1
+#define dagc3_rst_lsb 0
+#define xd_p_dagc3_en   (*(volatile byte xdata *) 0xF1FB)
+#define    p_dagc3_en   0xF1FB
+#define dagc3_en_pos 0
+#define dagc3_en_len 1
+#define dagc3_en_lsb 0
+#define xd_p_dagc3_mode (*(volatile byte xdata *) 0xF1FC)
+#define    p_dagc3_mode 0xF1FC
+#define dagc3_mode_pos 0
+#define dagc3_mode_len 2
+#define dagc3_mode_lsb 0
+#define xd_p_dagc3_done (*(volatile byte xdata *) 0xF1FD)
+#define    p_dagc3_done 0xF1FD
+#define dagc3_done_pos 0
+#define dagc3_done_len 1
+#define dagc3_done_lsb 0
+#define xd_p_reg_dagc2_desired_level_7_0    (*(volatile byte xdata *) 0xF202)
+#define    p_reg_dagc2_desired_level_7_0    0xF202
+#define reg_dagc2_desired_level_7_0_pos 0
+#define reg_dagc2_desired_level_7_0_len 8
+#define reg_dagc2_desired_level_7_0_lsb 0
+#define xd_p_reg_dagc2_desired_level_8  (*(volatile byte xdata *) 0xF203)
+#define    p_reg_dagc2_desired_level_8  0xF203
+#define reg_dagc2_desired_level_8_pos 0
+#define reg_dagc2_desired_level_8_len 1
+#define reg_dagc2_desired_level_8_lsb 8
+#define xd_p_reg_dagc2_apply_delay  (*(volatile byte xdata *) 0xF204)
+#define    p_reg_dagc2_apply_delay  0xF204
+#define reg_dagc2_apply_delay_pos 0
+#define reg_dagc2_apply_delay_len 7
+#define reg_dagc2_apply_delay_lsb 0
+#define xd_p_reg_dagc2_bypass_scale_ctl (*(volatile byte xdata *) 0xF205)
+#define    p_reg_dagc2_bypass_scale_ctl 0xF205
+#define reg_dagc2_bypass_scale_ctl_pos 0
+#define reg_dagc2_bypass_scale_ctl_len 3
+#define reg_dagc2_bypass_scale_ctl_lsb 0
+#define xd_p_reg_dagc2_programmable_shift2  (*(volatile byte xdata *) 0xF206)
+#define    p_reg_dagc2_programmable_shift2  0xF206
+#define reg_dagc2_programmable_shift2_pos 0
+#define reg_dagc2_programmable_shift2_len 8
+#define reg_dagc2_programmable_shift2_lsb 0
+#define xd_p_reg_dagc2_in_sat_cnt_7_0   (*(volatile byte xdata *) 0xF207)
+#define    p_reg_dagc2_in_sat_cnt_7_0   0xF207
+#define reg_dagc2_in_sat_cnt_7_0_pos 0
+#define reg_dagc2_in_sat_cnt_7_0_len 8
+#define reg_dagc2_in_sat_cnt_7_0_lsb 0
+#define xd_p_reg_dagc2_in_sat_cnt_15_8  (*(volatile byte xdata *) 0xF208)
+#define    p_reg_dagc2_in_sat_cnt_15_8  0xF208
+#define reg_dagc2_in_sat_cnt_15_8_pos 0
+#define reg_dagc2_in_sat_cnt_15_8_len 8
+#define reg_dagc2_in_sat_cnt_15_8_lsb 8
+#define xd_p_reg_dagc2_in_sat_cnt_23_16 (*(volatile byte xdata *) 0xF209)
+#define    p_reg_dagc2_in_sat_cnt_23_16 0xF209
+#define reg_dagc2_in_sat_cnt_23_16_pos 0
+#define reg_dagc2_in_sat_cnt_23_16_len 8
+#define reg_dagc2_in_sat_cnt_23_16_lsb 16
+#define xd_p_reg_dagc2_in_sat_cnt_31_24 (*(volatile byte xdata *) 0xF20A)
+#define    p_reg_dagc2_in_sat_cnt_31_24 0xF20A
+#define reg_dagc2_in_sat_cnt_31_24_pos 0
+#define reg_dagc2_in_sat_cnt_31_24_len 8
+#define reg_dagc2_in_sat_cnt_31_24_lsb 24
+#define xd_p_reg_dagc2_out_sat_cnt_7_0  (*(volatile byte xdata *) 0xF20B)
+#define    p_reg_dagc2_out_sat_cnt_7_0  0xF20B
+#define reg_dagc2_out_sat_cnt_7_0_pos 0
+#define reg_dagc2_out_sat_cnt_7_0_len 8
+#define reg_dagc2_out_sat_cnt_7_0_lsb 0
+#define xd_p_reg_dagc2_out_sat_cnt_15_8 (*(volatile byte xdata *) 0xF20C)
+#define    p_reg_dagc2_out_sat_cnt_15_8 0xF20C
+#define reg_dagc2_out_sat_cnt_15_8_pos 0
+#define reg_dagc2_out_sat_cnt_15_8_len 8
+#define reg_dagc2_out_sat_cnt_15_8_lsb 8
+#define xd_p_reg_dagc2_out_sat_cnt_23_16    (*(volatile byte xdata *) 0xF20D)
+#define    p_reg_dagc2_out_sat_cnt_23_16    0xF20D
+#define reg_dagc2_out_sat_cnt_23_16_pos 0
+#define reg_dagc2_out_sat_cnt_23_16_len 8
+#define reg_dagc2_out_sat_cnt_23_16_lsb 16
+#define xd_p_reg_dagc2_out_sat_cnt_31_24    (*(volatile byte xdata *) 0xF20E)
+#define    p_reg_dagc2_out_sat_cnt_31_24    0xF20E
+#define reg_dagc2_out_sat_cnt_31_24_pos 0
+#define reg_dagc2_out_sat_cnt_31_24_len 8
+#define reg_dagc2_out_sat_cnt_31_24_lsb 24
+#define xd_r_reg_dagc2_multiplier_7_0   (*(volatile byte xdata *) 0xF20F)
+#define    r_reg_dagc2_multiplier_7_0   0xF20F
+#define reg_dagc2_multiplier_7_0_pos 0
+#define reg_dagc2_multiplier_7_0_len 8
+#define reg_dagc2_multiplier_7_0_lsb 0
+#define xd_r_reg_dagc2_multiplier_15_8  (*(volatile byte xdata *) 0xF210)
+#define    r_reg_dagc2_multiplier_15_8  0xF210
+#define reg_dagc2_multiplier_15_8_pos 0
+#define reg_dagc2_multiplier_15_8_len 8
+#define reg_dagc2_multiplier_15_8_lsb 8
+#define xd_r_reg_dagc2_right_shift_bits (*(volatile byte xdata *) 0xF211)
+#define    r_reg_dagc2_right_shift_bits 0xF211
+#define reg_dagc2_right_shift_bits_pos 0
+#define reg_dagc2_right_shift_bits_len 4
+#define reg_dagc2_right_shift_bits_lsb 0
+#define xd_p_reg_dagc2_smbuf_err    (*(volatile byte xdata *) 0xF212)
+#define    p_reg_dagc2_smbuf_err    0xF212
+#define reg_dagc2_smbuf_err_pos 0
+#define reg_dagc2_smbuf_err_len 1
+#define reg_dagc2_smbuf_err_lsb 0
+#define xd_p_reg_dagc2_cplxconj (*(volatile byte xdata *) 0xF213)
+#define    p_reg_dagc2_cplxconj 0xF213
+#define reg_dagc2_cplxconj_pos 0
+#define reg_dagc2_cplxconj_len 1
+#define reg_dagc2_cplxconj_lsb 0
+#define xd_p_reg_dagc2_use_despow   (*(volatile byte xdata *) 0xF214)
+#define    p_reg_dagc2_use_despow   0xF214
+#define reg_dagc2_use_despow_pos 0
+#define reg_dagc2_use_despow_len 1
+#define reg_dagc2_use_despow_lsb 0
+#define xd_p_reg_dagc2_log_2_accumulate (*(volatile byte xdata *) 0xF215)
+#define    p_reg_dagc2_log_2_accumulate 0xF215
+#define reg_dagc2_log_2_accumulate_pos 0
+#define reg_dagc2_log_2_accumulate_len 5
+#define reg_dagc2_log_2_accumulate_lsb 0
+#define xd_r_dagc2_dca_gain (*(volatile byte xdata *) 0xF216)
+#define    r_dagc2_dca_gain 0xF216
+#define dagc2_dca_gain_pos 0
+#define dagc2_dca_gain_len 8
+#define dagc2_dca_gain_lsb 0
+#define xd_p_reg_dca_gain_offset    (*(volatile byte xdata *) 0xF217)
+#define    p_reg_dca_gain_offset    0xF217
+#define reg_dca_gain_offset_pos 0
+#define reg_dca_gain_offset_len 8
+#define reg_dca_gain_offset_lsb 0
+#define xd_p_reg_dagc2_FG_mode  (*(volatile byte xdata *) 0xF218)
+#define    p_reg_dagc2_FG_mode  0xF218
+#define reg_dagc2_FG_mode_pos 0
+#define reg_dagc2_FG_mode_len 1
+#define reg_dagc2_FG_mode_lsb 0
+#define xd_p_reg_dagc2_fixed_gain_7_0   (*(volatile byte xdata *) 0xF219)
+#define    p_reg_dagc2_fixed_gain_7_0   0xF219
+#define reg_dagc2_fixed_gain_7_0_pos 0
+#define reg_dagc2_fixed_gain_7_0_len 8
+#define reg_dagc2_fixed_gain_7_0_lsb 0
+#define xd_p_reg_dagc2_fixed_gain_11_8  (*(volatile byte xdata *) 0xF21A)
+#define    p_reg_dagc2_fixed_gain_11_8  0xF21A
+#define reg_dagc2_fixed_gain_11_8_pos 0
+#define reg_dagc2_fixed_gain_11_8_len 4
+#define reg_dagc2_fixed_gain_11_8_lsb 8
+#define xd_p_reg_td_debug_7_0   (*(volatile byte xdata *) 0xF21B)
+#define    p_reg_td_debug_7_0   0xF21B
+#define reg_td_debug_7_0_pos 0
+#define reg_td_debug_7_0_len 8
+#define reg_td_debug_7_0_lsb 0
+#define xd_p_reg_td_debug_15_8  (*(volatile byte xdata *) 0xF21C)
+#define    p_reg_td_debug_15_8  0xF21C
+#define reg_td_debug_15_8_pos 0
+#define reg_td_debug_15_8_len 8
+#define reg_td_debug_15_8_lsb 8
+#define xd_p_reg_td_debug_23_16 (*(volatile byte xdata *) 0xF21D)
+#define    p_reg_td_debug_23_16 0xF21D
+#define reg_td_debug_23_16_pos 0
+#define reg_td_debug_23_16_len 8
+#define reg_td_debug_23_16_lsb 16
+#define xd_p_reg_td_debug_30_24 (*(volatile byte xdata *) 0xF21E)
+#define    p_reg_td_debug_30_24 0xF21E
+#define reg_td_debug_30_24_pos 0
+#define reg_td_debug_30_24_len 7
+#define reg_td_debug_30_24_lsb 24
+#define xd_g_reg_tpsd_txmod (*(volatile byte xdata *) 0xF900)
+#define    g_reg_tpsd_txmod 0xF900
+#define reg_tpsd_txmod_pos 0
+#define reg_tpsd_txmod_len 2
+#define reg_tpsd_txmod_lsb 0
+#define xd_g_reg_tpsd_gi    (*(volatile byte xdata *) 0xF901)
+#define    g_reg_tpsd_gi    0xF901
+#define reg_tpsd_gi_pos 0
+#define reg_tpsd_gi_len 2
+#define reg_tpsd_gi_lsb 0
+#define xd_g_reg_tpsd_hier  (*(volatile byte xdata *) 0xF902)
+#define    g_reg_tpsd_hier  0xF902
+#define reg_tpsd_hier_pos 0
+#define reg_tpsd_hier_len 3
+#define reg_tpsd_hier_lsb 0
+#define xd_g_reg_tpsd_const (*(volatile byte xdata *) 0xF903)
+#define    g_reg_tpsd_const 0xF903
+#define reg_tpsd_const_pos 0
+#define reg_tpsd_const_len 2
+#define reg_tpsd_const_lsb 0
+#define xd_g_reg_bw (*(volatile byte xdata *) 0xF904)
+#define    g_reg_bw 0xF904
+#define reg_bw_pos 0
+#define reg_bw_len 2
+#define reg_bw_lsb 0
+#define xd_g_reg_dec_pri    (*(volatile byte xdata *) 0xF905)
+#define    g_reg_dec_pri    0xF905
+#define reg_dec_pri_pos 0
+#define reg_dec_pri_len 1
+#define reg_dec_pri_lsb 0
+#define xd_g_reg_tpsd_hpcr  (*(volatile byte xdata *) 0xF906)
+#define    g_reg_tpsd_hpcr  0xF906
+#define reg_tpsd_hpcr_pos 0
+#define reg_tpsd_hpcr_len 3
+#define reg_tpsd_hpcr_lsb 0
+#define xd_g_reg_tpsd_lpcr  (*(volatile byte xdata *) 0xF907)
+#define    g_reg_tpsd_lpcr  0xF907
+#define reg_tpsd_lpcr_pos 0
+#define reg_tpsd_lpcr_len 3
+#define reg_tpsd_lpcr_lsb 0
+#define xd_g_reg_tpsd_indep (*(volatile byte xdata *) 0xF908)
+#define    g_reg_tpsd_indep 0xF908
+#define reg_tpsd_indep_pos 0
+#define reg_tpsd_indep_len 1
+#define reg_tpsd_indep_lsb 0
+#define xd_g_reg_tpsd_tslice    (*(volatile byte xdata *) 0xF909)
+#define    g_reg_tpsd_tslice    0xF909
+#define reg_tpsd_tslice_pos 0
+#define reg_tpsd_tslice_len 1
+#define reg_tpsd_tslice_lsb 0
+#define xd_g_reg_tpsd_mpefec    (*(volatile byte xdata *) 0xF90A)
+#define    g_reg_tpsd_mpefec    0xF90A
+#define reg_tpsd_mpefec_pos 0
+#define reg_tpsd_mpefec_len 1
+#define reg_tpsd_mpefec_lsb 0
+#define xd_g_reg_sntc_en    (*(volatile byte xdata *) 0xF90B)
+#define    g_reg_sntc_en    0xF90B
+#define reg_sntc_en_pos 0
+#define reg_sntc_en_len 1
+#define reg_sntc_en_lsb 0
+#define xd_g_reg_intp_sys_div   (*(volatile byte xdata *) 0xF90C)
+#define    g_reg_intp_sys_div   0xF90C
+#define reg_intp_sys_div_pos 0
+#define reg_intp_sys_div_len 1
+#define reg_intp_sys_div_lsb 0
+#define xd_g_reg_clk_sntc_sel   (*(volatile byte xdata *) 0xF90D)
+#define    g_reg_clk_sntc_sel   0xF90D
+#define reg_clk_sntc_sel_pos 0
+#define reg_clk_sntc_sel_len 3
+#define reg_clk_sntc_sel_lsb 0
+#define xd_g_reg_clk_sys40  (*(volatile byte xdata *) 0xF90E)
+#define    g_reg_clk_sys40  0xF90E
+#define reg_clk_sys40_pos 0
+#define reg_clk_sys40_len 1
+#define reg_clk_sys40_lsb 0
+#define xd_g_reg_intp_sys_polarity  (*(volatile byte xdata *) 0xF90F)
+#define    g_reg_intp_sys_polarity  0xF90F
+#define reg_intp_sys_polarity_pos 0
+#define reg_intp_sys_polarity_len 1
+#define reg_intp_sys_polarity_lsb 0
+#define xd_g_reg_intp_sys_sc_7_0    (*(volatile byte xdata *) 0xF910)
+#define    g_reg_intp_sys_sc_7_0    0xF910
+#define reg_intp_sys_sc_7_0_pos 0
+#define reg_intp_sys_sc_7_0_len 8
+#define reg_intp_sys_sc_7_0_lsb 0
+#define xd_g_reg_intp_sys_sc_15_8   (*(volatile byte xdata *) 0xF911)
+#define    g_reg_intp_sys_sc_15_8   0xF911
+#define reg_intp_sys_sc_15_8_pos 0
+#define reg_intp_sys_sc_15_8_len 8
+#define reg_intp_sys_sc_15_8_lsb 8
+#define xd_g_reg_intp_sys_sc_23_16  (*(volatile byte xdata *) 0xF912)
+#define    g_reg_intp_sys_sc_23_16  0xF912
+#define reg_intp_sys_sc_23_16_pos 0
+#define reg_intp_sys_sc_23_16_len 8
+#define reg_intp_sys_sc_23_16_lsb 16
+#define xd_g_reg_intp_sys_sc_26_24  (*(volatile byte xdata *) 0xF913)
+#define    g_reg_intp_sys_sc_26_24  0xF913
+#define reg_intp_sys_sc_26_24_pos 0
+#define reg_intp_sys_sc_26_24_len 3
+#define reg_intp_sys_sc_26_24_lsb 24
+#define xd_g_reg_ofsm_clk   (*(volatile byte xdata *) 0xF914)
+#define    g_reg_ofsm_clk   0xF914
+#define reg_ofsm_clk_pos 0
+#define reg_ofsm_clk_len 3
+#define reg_ofsm_clk_lsb 0
+#define xd_g_reg_fclk_cfg   (*(volatile byte xdata *) 0xF915)
+#define    g_reg_fclk_cfg   0xF915
+#define reg_fclk_cfg_pos 0
+#define reg_fclk_cfg_len 1
+#define reg_fclk_cfg_lsb 0
+#define xd_g_reg_fclk_idi   (*(volatile byte xdata *) 0xF916)
+#define    g_reg_fclk_idi   0xF916
+#define reg_fclk_idi_pos 0
+#define reg_fclk_idi_len 1
+#define reg_fclk_idi_lsb 0
+#define xd_g_reg_fclk_odi   (*(volatile byte xdata *) 0xF917)
+#define    g_reg_fclk_odi   0xF917
+#define reg_fclk_odi_pos 0
+#define reg_fclk_odi_len 1
+#define reg_fclk_odi_lsb 0
+#define xd_g_reg_fclk_rsd   (*(volatile byte xdata *) 0xF918)
+#define    g_reg_fclk_rsd   0xF918
+#define reg_fclk_rsd_pos 0
+#define reg_fclk_rsd_len 1
+#define reg_fclk_rsd_lsb 0
+#define xd_g_reg_fclk_vtb   (*(volatile byte xdata *) 0xF919)
+#define    g_reg_fclk_vtb   0xF919
+#define reg_fclk_vtb_pos 0
+#define reg_fclk_vtb_len 1
+#define reg_fclk_vtb_lsb 0
+#define xd_g_reg_fclk_cste  (*(volatile byte xdata *) 0xF91A)
+#define    g_reg_fclk_cste  0xF91A
+#define reg_fclk_cste_pos 0
+#define reg_fclk_cste_len 1
+#define reg_fclk_cste_lsb 0
+#define xd_g_reg_fclk_mp2if (*(volatile byte xdata *) 0xF91B)
+#define    g_reg_fclk_mp2if 0xF91B
+#define reg_fclk_mp2if_pos 0
+#define reg_fclk_mp2if_len 1
+#define reg_fclk_mp2if_lsb 0
+#define xd_p_reg_adcout_sync    (*(volatile byte xdata *) 0xFA00)
+#define    p_reg_adcout_sync    0xFA00
+#define reg_adcout_sync_pos 0
+#define reg_adcout_sync_len 1
+#define reg_adcout_sync_lsb 0
+#define xd_p_reg_dagc2o_edge1   (*(volatile byte xdata *) 0xFA01)
+#define    p_reg_dagc2o_edge1   0xFA01
+#define reg_dagc2o_edge1_pos 0
+#define reg_dagc2o_edge1_len 1
+#define reg_dagc2o_edge1_lsb 0
+#define xd_p_reg_dagc2o_edge0   (*(volatile byte xdata *) 0xFA02)
+#define    p_reg_dagc2o_edge0   0xFA02
+#define reg_dagc2o_edge0_pos 0
+#define reg_dagc2o_edge0_len 1
+#define reg_dagc2o_edge0_lsb 0
+#define xd_p_reg_second_rom_on  (*(volatile byte xdata *) 0xFA03)
+#define    p_reg_second_rom_on  0xFA03
+#define reg_second_rom_on_pos 0
+#define reg_second_rom_on_len 1
+#define reg_second_rom_on_lsb 0
+#define xd_p_reg_bypass_host2tuner  (*(volatile byte xdata *) 0xFA04)
+#define    p_reg_bypass_host2tuner  0xFA04
+#define reg_bypass_host2tuner_pos 0
+#define reg_bypass_host2tuner_len 1
+#define reg_bypass_host2tuner_lsb 0
+#endif
+// biu_reg.h 6-27-2007
+// gen_biu Ver 1.0 generated by tienchi
+#define xd_p_cfoe_NS_coeff1_7_0 (*(volatile byte xdata *) 0xF400)
+#define    p_cfoe_NS_coeff1_7_0 0xF400
+#define cfoe_NS_coeff1_7_0_pos 0
+#define cfoe_NS_coeff1_7_0_len 8
+#define cfoe_NS_coeff1_7_0_lsb 0
+#define xd_p_cfoe_NS_coeff1_15_8    (*(volatile byte xdata *) 0xF401)
+#define    p_cfoe_NS_coeff1_15_8    0xF401
+#define cfoe_NS_coeff1_15_8_pos 0
+#define cfoe_NS_coeff1_15_8_len 8
+#define cfoe_NS_coeff1_15_8_lsb 8
+#define xd_p_cfoe_NS_coeff1_23_16   (*(volatile byte xdata *) 0xF402)
+#define    p_cfoe_NS_coeff1_23_16   0xF402
+#define cfoe_NS_coeff1_23_16_pos 0
+#define cfoe_NS_coeff1_23_16_len 8
+#define cfoe_NS_coeff1_23_16_lsb 16
+#define xd_p_cfoe_NS_coeff1_25_24   (*(volatile byte xdata *) 0xF403)
+#define    p_cfoe_NS_coeff1_25_24   0xF403
+#define cfoe_NS_coeff1_25_24_pos 0
+#define cfoe_NS_coeff1_25_24_len 2
+#define cfoe_NS_coeff1_25_24_lsb 24
+#define xd_p_cfoe_NS_coeff2_7_0 (*(volatile byte xdata *) 0xF404)
+#define    p_cfoe_NS_coeff2_7_0 0xF404
+#define cfoe_NS_coeff2_7_0_pos 0
+#define cfoe_NS_coeff2_7_0_len 8
+#define cfoe_NS_coeff2_7_0_lsb 0
+#define xd_p_cfoe_NS_coeff2_15_8    (*(volatile byte xdata *) 0xF405)
+#define    p_cfoe_NS_coeff2_15_8    0xF405
+#define cfoe_NS_coeff2_15_8_pos 0
+#define cfoe_NS_coeff2_15_8_len 8
+#define cfoe_NS_coeff2_15_8_lsb 8
+#define xd_p_cfoe_NS_coeff2_23_16   (*(volatile byte xdata *) 0xF406)
+#define    p_cfoe_NS_coeff2_23_16   0xF406
+#define cfoe_NS_coeff2_23_16_pos 0
+#define cfoe_NS_coeff2_23_16_len 8
+#define cfoe_NS_coeff2_23_16_lsb 16
+#define xd_p_cfoe_NS_coeff2_24  (*(volatile byte xdata *) 0xF407)
+#define    p_cfoe_NS_coeff2_24  0xF407
+#define cfoe_NS_coeff2_24_pos 0
+#define cfoe_NS_coeff2_24_len 1
+#define cfoe_NS_coeff2_24_lsb 24
+#define xd_p_cfoe_lf_c1_7_0 (*(volatile byte xdata *) 0xF408)
+#define    p_cfoe_lf_c1_7_0 0xF408
+#define cfoe_lf_c1_7_0_pos 0
+#define cfoe_lf_c1_7_0_len 8
+#define cfoe_lf_c1_7_0_lsb 0
+#define xd_p_cfoe_lf_c1_9_8 (*(volatile byte xdata *) 0xF409)
+#define    p_cfoe_lf_c1_9_8 0xF409
+#define cfoe_lf_c1_9_8_pos 0
+#define cfoe_lf_c1_9_8_len 2
+#define cfoe_lf_c1_9_8_lsb 8
+#define xd_p_cfoe_lf_c2_7_0 (*(volatile byte xdata *) 0xF40A)
+#define    p_cfoe_lf_c2_7_0 0xF40A
+#define cfoe_lf_c2_7_0_pos 0
+#define cfoe_lf_c2_7_0_len 8
+#define cfoe_lf_c2_7_0_lsb 0
+#define xd_p_cfoe_lf_c2_9_8 (*(volatile byte xdata *) 0xF40B)
+#define    p_cfoe_lf_c2_9_8 0xF40B
+#define cfoe_lf_c2_9_8_pos 0
+#define cfoe_lf_c2_9_8_len 2
+#define cfoe_lf_c2_9_8_lsb 8
+#define xd_p_cfoe_ifod_7_0  (*(volatile byte xdata *) 0xF40C)
+#define    p_cfoe_ifod_7_0  0xF40C
+#define cfoe_ifod_7_0_pos 0
+#define cfoe_ifod_7_0_len 8
+#define cfoe_ifod_7_0_lsb 0
+#define xd_p_cfoe_ifod_10_8 (*(volatile byte xdata *) 0xF40D)
+#define    p_cfoe_ifod_10_8 0xF40D
+#define cfoe_ifod_10_8_pos 0
+#define cfoe_ifod_10_8_len 3
+#define cfoe_ifod_10_8_lsb 8
+#define xd_p_cfoe_Divg_ctr_th   (*(volatile byte xdata *) 0xF40E)
+#define    p_cfoe_Divg_ctr_th   0xF40E
+#define cfoe_Divg_ctr_th_pos 0
+#define cfoe_Divg_ctr_th_len 4
+#define cfoe_Divg_ctr_th_lsb 0
+#define xd_p_cfoe_FOT_divg_th   (*(volatile byte xdata *) 0xF40F)
+#define    p_cfoe_FOT_divg_th   0xF40F
+#define cfoe_FOT_divg_th_pos 0
+#define cfoe_FOT_divg_th_len 8
+#define cfoe_FOT_divg_th_lsb 0
+#define xd_p_cfoe_FOT_cnvg_th   (*(volatile byte xdata *) 0xF410)
+#define    p_cfoe_FOT_cnvg_th   0xF410
+#define cfoe_FOT_cnvg_th_pos 0
+#define cfoe_FOT_cnvg_th_len 8
+#define cfoe_FOT_cnvg_th_lsb 0
+#define xd_p_reg_cfoe_offset_7_0    (*(volatile byte xdata *) 0xF411)
+#define    p_reg_cfoe_offset_7_0    0xF411
+#define reg_cfoe_offset_7_0_pos 0
+#define reg_cfoe_offset_7_0_len 8
+#define reg_cfoe_offset_7_0_lsb 0
+#define xd_p_reg_cfoe_offset_10_8   (*(volatile byte xdata *) 0xF412)
+#define    p_reg_cfoe_offset_10_8   0xF412
+#define reg_cfoe_offset_10_8_pos 0
+#define reg_cfoe_offset_10_8_len 3
+#define reg_cfoe_offset_10_8_lsb 8
+#define xd_p_reg_cfoe_ifoe_sign_corr    (*(volatile byte xdata *) 0xF413)
+#define    p_reg_cfoe_ifoe_sign_corr    0xF413
+#define reg_cfoe_ifoe_sign_corr_pos 0
+#define reg_cfoe_ifoe_sign_corr_len 1
+#define reg_cfoe_ifoe_sign_corr_lsb 0
+#define xd_p_cfoe_FOT_pullin_cnt_clr    (*(volatile byte xdata *) 0xF414)
+#define    p_cfoe_FOT_pullin_cnt_clr    0xF414
+#define cfoe_FOT_pullin_cnt_clr_pos 0
+#define cfoe_FOT_pullin_cnt_clr_len 1
+#define cfoe_FOT_pullin_cnt_clr_lsb 0
+#define xd_p_cfoe_FOT_spec_inv  (*(volatile byte xdata *) 0xF415)
+#define    p_cfoe_FOT_spec_inv  0xF415
+#define cfoe_FOT_spec_inv_pos 0
+#define cfoe_FOT_spec_inv_len 1
+#define cfoe_FOT_spec_inv_lsb 0
+#define xd_p_cfoe_FOT_pullin_ctr_th (*(volatile byte xdata *) 0xF416)
+#define    p_cfoe_FOT_pullin_ctr_th 0xF416
+#define cfoe_FOT_pullin_ctr_th_pos 0
+#define cfoe_FOT_pullin_ctr_th_len 4
+#define cfoe_FOT_pullin_ctr_th_lsb 0
+#define xd_p_cfoe_FOT_sf_ctr_th (*(volatile byte xdata *) 0xF417)
+#define    p_cfoe_FOT_sf_ctr_th 0xF417
+#define cfoe_FOT_sf_ctr_th_pos 0
+#define cfoe_FOT_sf_ctr_th_len 4
+#define cfoe_FOT_sf_ctr_th_lsb 0
+#define xd_p_cfoe_FOT_pullin_th (*(volatile byte xdata *) 0xF418)
+#define    p_cfoe_FOT_pullin_th 0xF418
+#define cfoe_FOT_pullin_th_pos 0
+#define cfoe_FOT_pullin_th_len 8
+#define cfoe_FOT_pullin_th_lsb 0
+#define xd_p_cfoe_FOT_kalman_cnt    (*(volatile byte xdata *) 0xF419)
+#define    p_cfoe_FOT_kalman_cnt    0xF419
+#define cfoe_FOT_kalman_cnt_pos 0
+#define cfoe_FOT_kalman_cnt_len 4
+#define cfoe_FOT_kalman_cnt_lsb 0
+#define xd_p_cfoe_FOT_fsm_info  (*(volatile byte xdata *) 0xF41A)
+#define    p_cfoe_FOT_fsm_info  0xF41A
+#define cfoe_FOT_fsm_info_pos 0
+#define cfoe_FOT_fsm_info_len 4
+#define cfoe_FOT_fsm_info_lsb 0
+#define xd_r_cfoe_FOT_pullin_cnt    (*(volatile byte xdata *) 0xF41B)
+#define    r_cfoe_FOT_pullin_cnt    0xF41B
+#define cfoe_FOT_pullin_cnt_pos 0
+#define cfoe_FOT_pullin_cnt_len 4
+#define cfoe_FOT_pullin_cnt_lsb 0
+#define xd_r_cfoe_FOT_sf_cnt    (*(volatile byte xdata *) 0xF41C)
+#define    r_cfoe_FOT_sf_cnt    0xF41C
+#define cfoe_FOT_sf_cnt_pos 0
+#define cfoe_FOT_sf_cnt_len 4
+#define cfoe_FOT_sf_cnt_lsb 0
+#define xd_r_reg_r_cfoe_ifoe_ifo_metric (*(volatile byte xdata *) 0xF41D)
+#define    r_reg_r_cfoe_ifoe_ifo_metric 0xF41D
+#define reg_r_cfoe_ifoe_ifo_metric_pos 0
+#define reg_r_cfoe_ifoe_ifo_metric_len 8
+#define reg_r_cfoe_ifoe_ifo_metric_lsb 0
+#define xd_r_reg_r_cfoe_ifoe_cos2num_7_0    (*(volatile byte xdata *) 0xF41E)
+#define    r_reg_r_cfoe_ifoe_cos2num_7_0    0xF41E
+#define reg_r_cfoe_ifoe_cos2num_7_0_pos 0
+#define reg_r_cfoe_ifoe_cos2num_7_0_len 8
+#define reg_r_cfoe_ifoe_cos2num_7_0_lsb 0
+#define xd_r_reg_r_cfoe_ifoe_cos2num_15_8   (*(volatile byte xdata *) 0xF41F)
+#define    r_reg_r_cfoe_ifoe_cos2num_15_8   0xF41F
+#define reg_r_cfoe_ifoe_cos2num_15_8_pos 0
+#define reg_r_cfoe_ifoe_cos2num_15_8_len 8
+#define reg_r_cfoe_ifoe_cos2num_15_8_lsb 8
+#define xd_r_reg_r_cfoe_ifoe_cos2num_19_16  (*(volatile byte xdata *) 0xF420)
+#define    r_reg_r_cfoe_ifoe_cos2num_19_16  0xF420
+#define reg_r_cfoe_ifoe_cos2num_19_16_pos 0
+#define reg_r_cfoe_ifoe_cos2num_19_16_len 4
+#define reg_r_cfoe_ifoe_cos2num_19_16_lsb 16
+#define xd_p_ste_Nu (*(volatile byte xdata *) 0xF460)
+#define    p_ste_Nu 0xF460
+#define ste_Nu_pos 0
+#define ste_Nu_len 3
+#define ste_Nu_lsb 0
+#define xd_p_ste_GI (*(volatile byte xdata *) 0xF461)
+#define    p_ste_GI 0xF461
+#define ste_GI_pos 0
+#define ste_GI_len 3
+#define ste_GI_lsb 0
+#define xd_p_ste_symbol_num (*(volatile byte xdata *) 0xF463)
+#define    p_ste_symbol_num 0xF463
+#define ste_symbol_num_pos 0
+#define ste_symbol_num_len 3
+#define ste_symbol_num_lsb 0
+#define xd_p_ste_sample_num (*(volatile byte xdata *) 0xF464)
+#define    p_ste_sample_num 0xF464
+#define ste_sample_num_pos 0
+#define ste_sample_num_len 2
+#define ste_sample_num_lsb 0
+#define xd_p_ste_symbol_num_4K  (*(volatile byte xdata *) 0xF465)
+#define    p_ste_symbol_num_4K  0xF465
+#define ste_symbol_num_4K_pos 0
+#define ste_symbol_num_4K_len 3
+#define ste_symbol_num_4K_lsb 0
+#define xd_p_ste_FFT_offset_7_0 (*(volatile byte xdata *) 0xF466)
+#define    p_ste_FFT_offset_7_0 0xF466
+#define ste_FFT_offset_7_0_pos 0
+#define ste_FFT_offset_7_0_len 8
+#define ste_FFT_offset_7_0_lsb 0
+#define xd_p_ste_FFT_offset_13_8    (*(volatile byte xdata *) 0xF467)
+#define    p_ste_FFT_offset_13_8    0xF467
+#define ste_FFT_offset_13_8_pos 0
+#define ste_FFT_offset_13_8_len 6
+#define ste_FFT_offset_13_8_lsb 8
+#define xd_p_ste_sample_num_4K  (*(volatile byte xdata *) 0xF468)
+#define    p_ste_sample_num_4K  0xF468
+#define ste_sample_num_4K_pos 0
+#define ste_sample_num_4K_len 2
+#define ste_sample_num_4K_lsb 0
+#define xd_p_ste_adv_start_7_0  (*(volatile byte xdata *) 0xF469)
+#define    p_ste_adv_start_7_0  0xF469
+#define ste_adv_start_7_0_pos 0
+#define ste_adv_start_7_0_len 8
+#define ste_adv_start_7_0_lsb 0
+#define xd_p_ste_adv_start_10_8 (*(volatile byte xdata *) 0xF46A)
+#define    p_ste_adv_start_10_8 0xF46A
+#define ste_adv_start_10_8_pos 0
+#define ste_adv_start_10_8_len 3
+#define ste_adv_start_10_8_lsb 8
+#define xd_p_ste_symbol_num_8K  (*(volatile byte xdata *) 0xF46B)
+#define    p_ste_symbol_num_8K  0xF46B
+#define ste_symbol_num_8K_pos 0
+#define ste_symbol_num_8K_len 3
+#define ste_symbol_num_8K_lsb 0
+#define xd_p_ste_sample_num_8K  (*(volatile byte xdata *) 0xF46C)
+#define    p_ste_sample_num_8K  0xF46C
+#define ste_sample_num_8K_pos 0
+#define ste_sample_num_8K_len 2
+#define ste_sample_num_8K_lsb 0
+#define xd_p_ste_adv_stop   (*(volatile byte xdata *) 0xF46D)
+#define    p_ste_adv_stop   0xF46D
+#define ste_adv_stop_pos 0
+#define ste_adv_stop_len 8
+#define ste_adv_stop_lsb 0
+#define xd_r_ste_P_value_7_0    (*(volatile byte xdata *) 0xF46E)
+#define    r_ste_P_value_7_0    0xF46E
+#define ste_P_value_7_0_pos 0
+#define ste_P_value_7_0_len 8
+#define ste_P_value_7_0_lsb 0
+#define xd_r_ste_P_value_10_8   (*(volatile byte xdata *) 0xF46F)
+#define    r_ste_P_value_10_8   0xF46F
+#define ste_P_value_10_8_pos 0
+#define ste_P_value_10_8_len 3
+#define ste_P_value_10_8_lsb 8
+#define xd_p_reg_ste_tstmod (*(volatile byte xdata *) 0xF470)
+#define    p_reg_ste_tstmod 0xF470
+#define reg_ste_tstmod_pos 0
+#define reg_ste_tstmod_len 1
+#define reg_ste_tstmod_lsb 0
+#define xd_p_reg_ste_buf_en (*(volatile byte xdata *) 0xF471)
+#define    p_reg_ste_buf_en 0xF471
+#define reg_ste_buf_en_pos 0
+#define reg_ste_buf_en_len 1
+#define reg_ste_buf_en_lsb 0
+#define xd_r_ste_M_value_7_0    (*(volatile byte xdata *) 0xF472)
+#define    r_ste_M_value_7_0    0xF472
+#define ste_M_value_7_0_pos 0
+#define ste_M_value_7_0_len 8
+#define ste_M_value_7_0_lsb 0
+#define xd_r_ste_M_value_10_8   (*(volatile byte xdata *) 0xF473)
+#define    r_ste_M_value_10_8   0xF473
+#define ste_M_value_10_8_pos 0
+#define ste_M_value_10_8_len 3
+#define ste_M_value_10_8_lsb 8
+#define xd_r_ste_H1 (*(volatile byte xdata *) 0xF474)
+#define    r_ste_H1 0xF474
+#define ste_H1_pos 0
+#define ste_H1_len 7
+#define ste_H1_lsb 0
+#define xd_r_ste_H2 (*(volatile byte xdata *) 0xF475)
+#define    r_ste_H2 0xF475
+#define ste_H2_pos 0
+#define ste_H2_len 7
+#define ste_H2_lsb 0
+#define xd_r_ste_H3 (*(volatile byte xdata *) 0xF476)
+#define    r_ste_H3 0xF476
+#define ste_H3_pos 0
+#define ste_H3_len 7
+#define ste_H3_lsb 0
+#define xd_r_ste_H4 (*(volatile byte xdata *) 0xF477)
+#define    r_ste_H4 0xF477
+#define ste_H4_pos 0
+#define ste_H4_len 7
+#define ste_H4_lsb 0
+#define xd_r_ste_Corr_value_I_7_0   (*(volatile byte xdata *) 0xF478)
+#define    r_ste_Corr_value_I_7_0   0xF478
+#define ste_Corr_value_I_7_0_pos 0
+#define ste_Corr_value_I_7_0_len 8
+#define ste_Corr_value_I_7_0_lsb 0
+#define xd_r_ste_Corr_value_I_15_8  (*(volatile byte xdata *) 0xF479)
+#define    r_ste_Corr_value_I_15_8  0xF479
+#define ste_Corr_value_I_15_8_pos 0
+#define ste_Corr_value_I_15_8_len 8
+#define ste_Corr_value_I_15_8_lsb 8
+#define xd_r_ste_Corr_value_I_23_16 (*(volatile byte xdata *) 0xF47A)
+#define    r_ste_Corr_value_I_23_16 0xF47A
+#define ste_Corr_value_I_23_16_pos 0
+#define ste_Corr_value_I_23_16_len 8
+#define ste_Corr_value_I_23_16_lsb 16
+#define xd_r_ste_Corr_value_I_27_24 (*(volatile byte xdata *) 0xF47B)
+#define    r_ste_Corr_value_I_27_24 0xF47B
+#define ste_Corr_value_I_27_24_pos 0
+#define ste_Corr_value_I_27_24_len 4
+#define ste_Corr_value_I_27_24_lsb 24
+#define xd_r_ste_Corr_value_Q_7_0   (*(volatile byte xdata *) 0xF47C)
+#define    r_ste_Corr_value_Q_7_0   0xF47C
+#define ste_Corr_value_Q_7_0_pos 0
+#define ste_Corr_value_Q_7_0_len 8
+#define ste_Corr_value_Q_7_0_lsb 0
+#define xd_r_ste_Corr_value_Q_15_8  (*(volatile byte xdata *) 0xF47D)
+#define    r_ste_Corr_value_Q_15_8  0xF47D
+#define ste_Corr_value_Q_15_8_pos 0
+#define ste_Corr_value_Q_15_8_len 8
+#define ste_Corr_value_Q_15_8_lsb 8
+#define xd_r_ste_Corr_value_Q_23_16 (*(volatile byte xdata *) 0xF47E)
+#define    r_ste_Corr_value_Q_23_16 0xF47E
+#define ste_Corr_value_Q_23_16_pos 0
+#define ste_Corr_value_Q_23_16_len 8
+#define ste_Corr_value_Q_23_16_lsb 16
+#define xd_r_ste_Corr_value_Q_27_24 (*(volatile byte xdata *) 0xF47F)
+#define    r_ste_Corr_value_Q_27_24 0xF47F
+#define ste_Corr_value_Q_27_24_pos 0
+#define ste_Corr_value_Q_27_24_len 4
+#define ste_Corr_value_Q_27_24_lsb 24
+#define xd_r_ste_J_num_7_0  (*(volatile byte xdata *) 0xF480)
+#define    r_ste_J_num_7_0  0xF480
+#define ste_J_num_7_0_pos 0
+#define ste_J_num_7_0_len 8
+#define ste_J_num_7_0_lsb 0
+#define xd_r_ste_J_num_15_8 (*(volatile byte xdata *) 0xF481)
+#define    r_ste_J_num_15_8 0xF481
+#define ste_J_num_15_8_pos 0
+#define ste_J_num_15_8_len 8
+#define ste_J_num_15_8_lsb 8
+#define xd_r_ste_J_num_23_16    (*(volatile byte xdata *) 0xF482)
+#define    r_ste_J_num_23_16    0xF482
+#define ste_J_num_23_16_pos 0
+#define ste_J_num_23_16_len 8
+#define ste_J_num_23_16_lsb 16
+#define xd_r_ste_J_num_31_24    (*(volatile byte xdata *) 0xF483)
+#define    r_ste_J_num_31_24    0xF483
+#define ste_J_num_31_24_pos 0
+#define ste_J_num_31_24_len 8
+#define ste_J_num_31_24_lsb 24
+#define xd_r_ste_J_den_7_0  (*(volatile byte xdata *) 0xF484)
+#define    r_ste_J_den_7_0  0xF484
+#define ste_J_den_7_0_pos 0
+#define ste_J_den_7_0_len 8
+#define ste_J_den_7_0_lsb 0
+#define xd_r_ste_J_den_15_8 (*(volatile byte xdata *) 0xF485)
+#define    r_ste_J_den_15_8 0xF485
+#define ste_J_den_15_8_pos 0
+#define ste_J_den_15_8_len 8
+#define ste_J_den_15_8_lsb 8
+#define xd_r_ste_J_den_18_16    (*(volatile byte xdata *) 0xF486)
+#define    r_ste_J_den_18_16    0xF486
+#define ste_J_den_18_16_pos 0
+#define ste_J_den_18_16_len 3
+#define ste_J_den_18_16_lsb 16
+#define xd_r_ste_Beacon_Indicator   (*(volatile byte xdata *) 0xF488)
+#define    r_ste_Beacon_Indicator   0xF488
+#define ste_Beacon_Indicator_pos 0
+#define ste_Beacon_Indicator_len 1
+#define ste_Beacon_Indicator_lsb 0
+#define xd_p_ste_got_sntc_bcn   (*(volatile byte xdata *) 0xF48B)
+#define    p_ste_got_sntc_bcn   0xF48B
+#define ste_got_sntc_bcn_pos 0
+#define ste_got_sntc_bcn_len 1
+#define ste_got_sntc_bcn_lsb 0
+#define xd_r_tpsd_Frame_Num (*(volatile byte xdata *) 0xF4C0)
+#define    r_tpsd_Frame_Num 0xF4C0
+#define tpsd_Frame_Num_pos 0
+#define tpsd_Frame_Num_len 2
+#define tpsd_Frame_Num_lsb 0
+#define xd_r_tpsd_Constel   (*(volatile byte xdata *) 0xF4C1)
+#define    r_tpsd_Constel   0xF4C1
+#define tpsd_Constel_pos 0
+#define tpsd_Constel_len 2
+#define tpsd_Constel_lsb 0
+#define xd_r_tpsd_GI    (*(volatile byte xdata *) 0xF4C2)
+#define    r_tpsd_GI    0xF4C2
+#define tpsd_GI_pos 0
+#define tpsd_GI_len 2
+#define tpsd_GI_lsb 0
+#define xd_r_tpsd_Mode  (*(volatile byte xdata *) 0xF4C3)
+#define    r_tpsd_Mode  0xF4C3
+#define tpsd_Mode_pos 0
+#define tpsd_Mode_len 2
+#define tpsd_Mode_lsb 0
+#define xd_r_tpsd_CR_HP (*(volatile byte xdata *) 0xF4C4)
+#define    r_tpsd_CR_HP 0xF4C4
+#define tpsd_CR_HP_pos 0
+#define tpsd_CR_HP_len 3
+#define tpsd_CR_HP_lsb 0
+#define xd_r_tpsd_CR_LP (*(volatile byte xdata *) 0xF4C5)
+#define    r_tpsd_CR_LP 0xF4C5
+#define tpsd_CR_LP_pos 0
+#define tpsd_CR_LP_len 3
+#define tpsd_CR_LP_lsb 0
+#define xd_r_tpsd_Hie   (*(volatile byte xdata *) 0xF4C6)
+#define    r_tpsd_Hie   0xF4C6
+#define tpsd_Hie_pos 0
+#define tpsd_Hie_len 3
+#define tpsd_Hie_lsb 0
+#define xd_r_tpsd_Res_Bits  (*(volatile byte xdata *) 0xF4C7)
+#define    r_tpsd_Res_Bits  0xF4C7
+#define tpsd_Res_Bits_pos 0
+#define tpsd_Res_Bits_len 5
+#define tpsd_Res_Bits_lsb 0
+#define xd_r_tpsd_Res_Bits_0    (*(volatile byte xdata *) 0xF4C8)
+#define    r_tpsd_Res_Bits_0    0xF4C8
+#define tpsd_Res_Bits_0_pos 0
+#define tpsd_Res_Bits_0_len 1
+#define tpsd_Res_Bits_0_lsb 0
+#define xd_r_tpsd_LengthInd (*(volatile byte xdata *) 0xF4C9)
+#define    r_tpsd_LengthInd 0xF4C9
+#define tpsd_LengthInd_pos 0
+#define tpsd_LengthInd_len 6
+#define tpsd_LengthInd_lsb 0
+#define xd_r_tpsd_Cell_Id_7_0   (*(volatile byte xdata *) 0xF4CA)
+#define    r_tpsd_Cell_Id_7_0   0xF4CA
+#define tpsd_Cell_Id_7_0_pos 0
+#define tpsd_Cell_Id_7_0_len 8
+#define tpsd_Cell_Id_7_0_lsb 0
+#define xd_r_tpsd_Cell_Id_15_8  (*(volatile byte xdata *) 0xF4CB)
+#define    r_tpsd_Cell_Id_15_8  0xF4CB
+#define tpsd_Cell_Id_15_8_pos 0
+#define tpsd_Cell_Id_15_8_len 8
+#define tpsd_Cell_Id_15_8_lsb 0
+#define xd_r_tpsd_use_InDepthInt    (*(volatile byte xdata *) 0xF4CC)
+#define    r_tpsd_use_InDepthInt    0xF4CC
+#define tpsd_use_InDepthInt_pos 0
+#define tpsd_use_InDepthInt_len 1
+#define tpsd_use_InDepthInt_lsb 0
+#define xd_r_tpsd_use_TimeSlicing_HP    (*(volatile byte xdata *) 0xF4CD)
+#define    r_tpsd_use_TimeSlicing_HP    0xF4CD
+#define tpsd_use_TimeSlicing_HP_pos 0
+#define tpsd_use_TimeSlicing_HP_len 1
+#define tpsd_use_TimeSlicing_HP_lsb 0
+#define xd_r_tpsd_use_mpe_fec_HP    (*(volatile byte xdata *) 0xF4CE)
+#define    r_tpsd_use_mpe_fec_HP    0xF4CE
+#define tpsd_use_mpe_fec_HP_pos 0
+#define tpsd_use_mpe_fec_HP_len 1
+#define tpsd_use_mpe_fec_HP_lsb 0
+#define xd_r_tpsd_use_TimeSlicing_LP    (*(volatile byte xdata *) 0xF4CF)
+#define    r_tpsd_use_TimeSlicing_LP    0xF4CF
+#define tpsd_use_TimeSlicing_LP_pos 0
+#define tpsd_use_TimeSlicing_LP_len 1
+#define tpsd_use_TimeSlicing_LP_lsb 0
+#define xd_r_tpsd_use_mpe_fec_LP    (*(volatile byte xdata *) 0xF4D0)
+#define    r_tpsd_use_mpe_fec_LP    0xF4D0
+#define tpsd_use_mpe_fec_LP_pos 0
+#define tpsd_use_mpe_fec_LP_len 1
+#define tpsd_use_mpe_fec_LP_lsb 0
+#define xd_r_tpsd_leng23_ind_return (*(volatile byte xdata *) 0xF4D1)
+#define    r_tpsd_leng23_ind_return 0xF4D1
+#define tpsd_leng23_ind_return_pos 0
+#define tpsd_leng23_ind_return_len 1
+#define tpsd_leng23_ind_return_lsb 0
+#define xd_p_reg_fft_re_exp (*(volatile byte xdata *) 0xF500)
+#define    p_reg_fft_re_exp 0xF500
+#define reg_fft_re_exp_pos 0
+#define reg_fft_re_exp_len 4
+#define reg_fft_re_exp_lsb 0
+#define xd_p_reg_fft_re_mts (*(volatile byte xdata *) 0xF501)
+#define    p_reg_fft_re_mts 0xF501
+#define reg_fft_re_mts_pos 0
+#define reg_fft_re_mts_len 8
+#define reg_fft_re_mts_lsb 0
+#define xd_p_reg_fft_im_exp (*(volatile byte xdata *) 0xF502)
+#define    p_reg_fft_im_exp 0xF502
+#define reg_fft_im_exp_pos 0
+#define reg_fft_im_exp_len 4
+#define reg_fft_im_exp_lsb 0
+#define xd_p_reg_fft_im_mts (*(volatile byte xdata *) 0xF503)
+#define    p_reg_fft_im_mts 0xF503
+#define reg_fft_im_mts_pos 0
+#define reg_fft_im_mts_len 8
+#define reg_fft_im_mts_lsb 0
+#define xd_p_reg_fft_conjugate  (*(volatile byte xdata *) 0xF504)
+#define    p_reg_fft_conjugate  0xF504
+#define reg_fft_conjugate_pos 0
+#define reg_fft_conjugate_len 1
+#define reg_fft_conjugate_lsb 0
+#define xd_p_reg_fft_power_en   (*(volatile byte xdata *) 0xF505)
+#define    p_reg_fft_power_en   0xF505
+#define reg_fft_power_en_pos 0
+#define reg_fft_power_en_len 1
+#define reg_fft_power_en_lsb 0
+#define xd_p_reg_fft_power_factor   (*(volatile byte xdata *) 0xF506)
+#define    p_reg_fft_power_factor   0xF506
+#define reg_fft_power_factor_pos 0
+#define reg_fft_power_factor_len 6
+#define reg_fft_power_factor_lsb 0
+#define xd_p_reg_fft_power_in   (*(volatile byte xdata *) 0xF507)
+#define    p_reg_fft_power_in   0xF507
+#define reg_fft_power_in_pos 0
+#define reg_fft_power_in_len 8
+#define reg_fft_power_in_lsb 0
+#define xd_p_reg_fft_mask_from0_7_0 (*(volatile byte xdata *) 0xF508)
+#define    p_reg_fft_mask_from0_7_0 0xF508
+#define reg_fft_mask_from0_7_0_pos 0
+#define reg_fft_mask_from0_7_0_len 8
+#define reg_fft_mask_from0_7_0_lsb 0
+#define xd_p_reg_fft_mask_from0_12_8    (*(volatile byte xdata *) 0xF509)
+#define    p_reg_fft_mask_from0_12_8    0xF509
+#define reg_fft_mask_from0_12_8_pos 0
+#define reg_fft_mask_from0_12_8_len 5
+#define reg_fft_mask_from0_12_8_lsb 8
+#define xd_p_reg_fft_mask_to0_7_0   (*(volatile byte xdata *) 0xF50A)
+#define    p_reg_fft_mask_to0_7_0   0xF50A
+#define reg_fft_mask_to0_7_0_pos 0
+#define reg_fft_mask_to0_7_0_len 8
+#define reg_fft_mask_to0_7_0_lsb 0
+#define xd_p_reg_fft_mask_to0_12_8  (*(volatile byte xdata *) 0xF50B)
+#define    p_reg_fft_mask_to0_12_8  0xF50B
+#define reg_fft_mask_to0_12_8_pos 0
+#define reg_fft_mask_to0_12_8_len 5
+#define reg_fft_mask_to0_12_8_lsb 8
+#define xd_p_reg_fft_mask_from1_7_0 (*(volatile byte xdata *) 0xF50C)
+#define    p_reg_fft_mask_from1_7_0 0xF50C
+#define reg_fft_mask_from1_7_0_pos 0
+#define reg_fft_mask_from1_7_0_len 8
+#define reg_fft_mask_from1_7_0_lsb 0
+#define xd_p_reg_fft_mask_from1_12_8    (*(volatile byte xdata *) 0xF50D)
+#define    p_reg_fft_mask_from1_12_8    0xF50D
+#define reg_fft_mask_from1_12_8_pos 0
+#define reg_fft_mask_from1_12_8_len 5
+#define reg_fft_mask_from1_12_8_lsb 8
+#define xd_p_reg_fft_mask_to1_7_0   (*(volatile byte xdata *) 0xF50E)
+#define    p_reg_fft_mask_to1_7_0   0xF50E
+#define reg_fft_mask_to1_7_0_pos 0
+#define reg_fft_mask_to1_7_0_len 8
+#define reg_fft_mask_to1_7_0_lsb 0
+#define xd_p_reg_fft_mask_to1_12_8  (*(volatile byte xdata *) 0xF50F)
+#define    p_reg_fft_mask_to1_12_8  0xF50F
+#define reg_fft_mask_to1_12_8_pos 0
+#define reg_fft_mask_to1_12_8_len 5
+#define reg_fft_mask_to1_12_8_lsb 8
+#define xd_p_reg_fft_mask_from2_7_0 (*(volatile byte xdata *) 0xF510)
+#define    p_reg_fft_mask_from2_7_0 0xF510
+#define reg_fft_mask_from2_7_0_pos 0
+#define reg_fft_mask_from2_7_0_len 8
+#define reg_fft_mask_from2_7_0_lsb 0
+#define xd_p_reg_fft_mask_from2_12_8    (*(volatile byte xdata *) 0xF511)
+#define    p_reg_fft_mask_from2_12_8    0xF511
+#define reg_fft_mask_from2_12_8_pos 0
+#define reg_fft_mask_from2_12_8_len 5
+#define reg_fft_mask_from2_12_8_lsb 8
+#define xd_p_reg_fft_mask_to2_7_0   (*(volatile byte xdata *) 0xF512)
+#define    p_reg_fft_mask_to2_7_0   0xF512
+#define reg_fft_mask_to2_7_0_pos 0
+#define reg_fft_mask_to2_7_0_len 8
+#define reg_fft_mask_to2_7_0_lsb 0
+#define xd_p_reg_fft_mask_to2_12_8  (*(volatile byte xdata *) 0xF513)
+#define    p_reg_fft_mask_to2_12_8  0xF513
+#define reg_fft_mask_to2_12_8_pos 0
+#define reg_fft_mask_to2_12_8_len 5
+#define reg_fft_mask_to2_12_8_lsb 8
+#define xd_p_reg_fft_mask_from3_7_0 (*(volatile byte xdata *) 0xF514)
+#define    p_reg_fft_mask_from3_7_0 0xF514
+#define reg_fft_mask_from3_7_0_pos 0
+#define reg_fft_mask_from3_7_0_len 8
+#define reg_fft_mask_from3_7_0_lsb 0
+#define xd_p_reg_fft_mask_from3_12_8    (*(volatile byte xdata *) 0xF515)
+#define    p_reg_fft_mask_from3_12_8    0xF515
+#define reg_fft_mask_from3_12_8_pos 0
+#define reg_fft_mask_from3_12_8_len 5
+#define reg_fft_mask_from3_12_8_lsb 8
+#define xd_p_reg_fft_mask_to3_7_0   (*(volatile byte xdata *) 0xF516)
+#define    p_reg_fft_mask_to3_7_0   0xF516
+#define reg_fft_mask_to3_7_0_pos 0
+#define reg_fft_mask_to3_7_0_len 8
+#define reg_fft_mask_to3_7_0_lsb 0
+#define xd_p_reg_fft_mask_to3_12_8  (*(volatile byte xdata *) 0xF517)
+#define    p_reg_fft_mask_to3_12_8  0xF517
+#define reg_fft_mask_to3_12_8_pos 0
+#define reg_fft_mask_to3_12_8_len 5
+#define reg_fft_mask_to3_12_8_lsb 8
+#define xd_r_fd_sntc_frame_num  (*(volatile byte xdata *) 0xF518)
+#define    r_fd_sntc_frame_num  0xF518
+#define fd_sntc_frame_num_pos 0
+#define fd_sntc_frame_num_len 2
+#define fd_sntc_frame_num_lsb 0
+#define xd_r_fd_sntc_symbol_count   (*(volatile byte xdata *) 0xF519)
+#define    r_fd_sntc_symbol_count   0xF519
+#define fd_sntc_symbol_count_pos 0
+#define fd_sntc_symbol_count_len 7
+#define fd_sntc_symbol_count_lsb 0
+#define xd_p_reg_sntc_cnt_lo    (*(volatile byte xdata *) 0xF51A)
+#define    p_reg_sntc_cnt_lo    0xF51A
+#define reg_sntc_cnt_lo_pos 0
+#define reg_sntc_cnt_lo_len 8
+#define reg_sntc_cnt_lo_lsb 0
+#define xd_p_reg_sntc_cnt_hi    (*(volatile byte xdata *) 0xF51B)
+#define    p_reg_sntc_cnt_hi    0xF51B
+#define reg_sntc_cnt_hi_pos 0
+#define reg_sntc_cnt_hi_len 7
+#define reg_sntc_cnt_hi_lsb 0
+#define xd_p_reg_sntc_fft_in    (*(volatile byte xdata *) 0xF51C)
+#define    p_reg_sntc_fft_in    0xF51C
+#define reg_sntc_fft_in_pos 0
+#define reg_sntc_fft_in_len 1
+#define reg_sntc_fft_in_lsb 0
+#define xd_r_fd_sntc_en (*(volatile byte xdata *) 0xF51D)
+#define    r_fd_sntc_en 0xF51D
+#define fd_sntc_en_pos 0
+#define fd_sntc_en_len 1
+#define fd_sntc_en_lsb 0
+#define xd_p_reg_sntc_x2    (*(volatile byte xdata *) 0xF51E)
+#define    p_reg_sntc_x2    0xF51E
+#define reg_sntc_x2_pos 0
+#define reg_sntc_x2_len 1
+#define reg_sntc_x2_lsb 0
+#define xd_p_reg_cge_en_7_0 (*(volatile byte xdata *) 0xF51F)
+#define    p_reg_cge_en_7_0 0xF51F
+#define reg_cge_en_7_0_pos 0
+#define reg_cge_en_7_0_len 8
+#define reg_cge_en_7_0_lsb 0
+#define xd_p_reg_cge_en_15_8    (*(volatile byte xdata *) 0xF520)
+#define    p_reg_cge_en_15_8    0xF520
+#define reg_cge_en_15_8_pos 0
+#define reg_cge_en_15_8_len 8
+#define reg_cge_en_15_8_lsb 8
+#define xd_p_reg_cge_en_23_16   (*(volatile byte xdata *) 0xF521)
+#define    p_reg_cge_en_23_16   0xF521
+#define reg_cge_en_23_16_pos 0
+#define reg_cge_en_23_16_len 8
+#define reg_cge_en_23_16_lsb 16
+#define xd_p_reg_cge_en_31_24   (*(volatile byte xdata *) 0xF522)
+#define    p_reg_cge_en_31_24   0xF522
+#define reg_cge_en_31_24_pos 0
+#define reg_cge_en_31_24_len 8
+#define reg_cge_en_31_24_lsb 24
+#define xd_p_reg_cge_en_39_32   (*(volatile byte xdata *) 0xF523)
+#define    p_reg_cge_en_39_32   0xF523
+#define reg_cge_en_39_32_pos 0
+#define reg_cge_en_39_32_len 8
+#define reg_cge_en_39_32_lsb 32
+#define xd_p_reg_cge_en_43_40   (*(volatile byte xdata *) 0xF524)
+#define    p_reg_cge_en_43_40   0xF524
+#define reg_cge_en_43_40_pos 0
+#define reg_cge_en_43_40_len 4
+#define reg_cge_en_43_40_lsb 40
+#define xd_p_reg_fft_sat_en (*(volatile byte xdata *) 0xF525)
+#define    p_reg_fft_sat_en 0xF525
+#define reg_fft_sat_en_pos 0
+#define reg_fft_sat_en_len 1
+#define reg_fft_sat_en_lsb 0
+#define xd_p_reg_fft_sat_count_clr  (*(volatile byte xdata *) 0xF526)
+#define    p_reg_fft_sat_count_clr  0xF526
+#define reg_fft_sat_count_clr_pos 0
+#define reg_fft_sat_count_clr_len 1
+#define reg_fft_sat_count_clr_lsb 0
+#define xd_p_reg_fft_rescale_round  (*(volatile byte xdata *) 0xF527)
+#define    p_reg_fft_rescale_round  0xF527
+#define reg_fft_rescale_round_pos 0
+#define reg_fft_rescale_round_len 1
+#define reg_fft_rescale_round_lsb 0
+#define xd_r_reg_fft_sat_count_12_7_0   (*(volatile byte xdata *) 0xF528)
+#define    r_reg_fft_sat_count_12_7_0   0xF528
+#define reg_fft_sat_count_12_7_0_pos 0
+#define reg_fft_sat_count_12_7_0_len 8
+#define reg_fft_sat_count_12_7_0_lsb 0
+#define xd_r_reg_fft_sat_count_12_15_8  (*(volatile byte xdata *) 0xF529)
+#define    r_reg_fft_sat_count_12_15_8  0xF529
+#define reg_fft_sat_count_12_15_8_pos 0
+#define reg_fft_sat_count_12_15_8_len 8
+#define reg_fft_sat_count_12_15_8_lsb 8
+#define xd_r_reg_fft_sat_count_10_7_0   (*(volatile byte xdata *) 0xF52A)
+#define    r_reg_fft_sat_count_10_7_0   0xF52A
+#define reg_fft_sat_count_10_7_0_pos 0
+#define reg_fft_sat_count_10_7_0_len 8
+#define reg_fft_sat_count_10_7_0_lsb 0
+#define xd_r_reg_fft_sat_count_10_15_8  (*(volatile byte xdata *) 0xF52B)
+#define    r_reg_fft_sat_count_10_15_8  0xF52B
+#define reg_fft_sat_count_10_15_8_pos 0
+#define reg_fft_sat_count_10_15_8_len 8
+#define reg_fft_sat_count_10_15_8_lsb 8
+#define xd_p_reg_fft_capture_idx_7_0    (*(volatile byte xdata *) 0xF52C)
+#define    p_reg_fft_capture_idx_7_0    0xF52C
+#define reg_fft_capture_idx_7_0_pos 0
+#define reg_fft_capture_idx_7_0_len 8
+#define reg_fft_capture_idx_7_0_lsb 0
+#define xd_p_reg_fft_capture_idx_12_8   (*(volatile byte xdata *) 0xF52D)
+#define    p_reg_fft_capture_idx_12_8   0xF52D
+#define reg_fft_capture_idx_12_8_pos 0
+#define reg_fft_capture_idx_12_8_len 5
+#define reg_fft_capture_idx_12_8_lsb 8
+#define xd_p_reg_fft_capture    (*(volatile byte xdata *) 0xF52E)
+#define    p_reg_fft_capture    0xF52E
+#define reg_fft_capture_pos 0
+#define reg_fft_capture_len 1
+#define reg_fft_capture_lsb 0
+#define xd_p_reg_gp_trigger_fd  (*(volatile byte xdata *) 0xF52F)
+#define    p_reg_gp_trigger_fd  0xF52F
+#define reg_gp_trigger_fd_pos 0
+#define reg_gp_trigger_fd_len 1
+#define reg_gp_trigger_fd_lsb 0
+#define xd_p_reg_trigger_sel_fd (*(volatile byte xdata *) 0xF530)
+#define    p_reg_trigger_sel_fd 0xF530
+#define reg_trigger_sel_fd_pos 0
+#define reg_trigger_sel_fd_len 2
+#define reg_trigger_sel_fd_lsb 0
+#define xd_p_reg_trigger_module_sel_fd  (*(volatile byte xdata *) 0xF531)
+#define    p_reg_trigger_module_sel_fd  0xF531
+#define reg_trigger_module_sel_fd_pos 0
+#define reg_trigger_module_sel_fd_len 6
+#define reg_trigger_module_sel_fd_lsb 0
+#define xd_p_reg_trigger_set_sel_fd (*(volatile byte xdata *) 0xF532)
+#define    p_reg_trigger_set_sel_fd 0xF532
+#define reg_trigger_set_sel_fd_pos 0
+#define reg_trigger_set_sel_fd_len 6
+#define reg_trigger_set_sel_fd_lsb 0
+#define xd_r_reg_fft_idx_pre_max_7_0    (*(volatile byte xdata *) 0xF533)
+#define    r_reg_fft_idx_pre_max_7_0    0xF533
+#define reg_fft_idx_pre_max_7_0_pos 0
+#define reg_fft_idx_pre_max_7_0_len 8
+#define reg_fft_idx_pre_max_7_0_lsb 0
+#define xd_r_reg_fft_idx_pre_max_12_8   (*(volatile byte xdata *) 0xF534)
+#define    r_reg_fft_idx_pre_max_12_8   0xF534
+#define reg_fft_idx_pre_max_12_8_pos 0
+#define reg_fft_idx_pre_max_12_8_len 5
+#define reg_fft_idx_pre_max_12_8_lsb 8
+#define xd_r_reg_fft_crc    (*(volatile byte xdata *) 0xF535)
+#define    r_reg_fft_crc    0xF535
+#define reg_fft_crc_pos 0
+#define reg_fft_crc_len 8
+#define reg_fft_crc_lsb 0
+#define xd_p_fd_fft_shift_max   (*(volatile byte xdata *) 0xF536)
+#define    p_fd_fft_shift_max   0xF536
+#define fd_fft_shift_max_pos 0
+#define fd_fft_shift_max_len 4
+#define fd_fft_shift_max_lsb 0
+#define xd_p_fd_fft_frame_num   (*(volatile byte xdata *) 0xF537)
+#define    p_fd_fft_frame_num   0xF537
+#define fd_fft_frame_num_pos 0
+#define fd_fft_frame_num_len 2
+#define fd_fft_frame_num_lsb 0
+#define xd_p_fd_fft_symbol_count    (*(volatile byte xdata *) 0xF538)
+#define    p_fd_fft_symbol_count    0xF538
+#define fd_fft_symbol_count_pos 0
+#define fd_fft_symbol_count_len 7
+#define fd_fft_symbol_count_lsb 0
+#define xd_r_reg_fft_idx_max_7_0    (*(volatile byte xdata *) 0xF539)
+#define    r_reg_fft_idx_max_7_0    0xF539
+#define reg_fft_idx_max_7_0_pos 0
+#define reg_fft_idx_max_7_0_len 8
+#define reg_fft_idx_max_7_0_lsb 0
+#define xd_r_reg_fft_idx_max_12_8   (*(volatile byte xdata *) 0xF53A)
+#define    r_reg_fft_idx_max_12_8   0xF53A
+#define reg_fft_idx_max_12_8_pos 0
+#define reg_fft_idx_max_12_8_len 5
+#define reg_fft_idx_max_12_8_lsb 8
+#define xd_p_reg_fft_rotate_en  (*(volatile byte xdata *) 0xF53B)
+#define    p_reg_fft_rotate_en  0xF53B
+#define reg_fft_rotate_en_pos 0
+#define reg_fft_rotate_en_len 1
+#define reg_fft_rotate_en_lsb 0
+#define xd_p_reg_fft_rotate_base_7_0    (*(volatile byte xdata *) 0xF53C)
+#define    p_reg_fft_rotate_base_7_0    0xF53C
+#define reg_fft_rotate_base_7_0_pos 0
+#define reg_fft_rotate_base_7_0_len 8
+#define reg_fft_rotate_base_7_0_lsb 0
+#define xd_p_reg_fft_rotate_base_12_8   (*(volatile byte xdata *) 0xF53D)
+#define    p_reg_fft_rotate_base_12_8   0xF53D
+#define reg_fft_rotate_base_12_8_pos 0
+#define reg_fft_rotate_base_12_8_len 5
+#define reg_fft_rotate_base_12_8_lsb 8
+#define xd_r_fd_fpcc_cp_corr_signn  (*(volatile byte xdata *) 0xF53E)
+#define    r_fd_fpcc_cp_corr_signn  0xF53E
+#define fd_fpcc_cp_corr_signn_pos 0
+#define fd_fpcc_cp_corr_signn_len 8
+#define fd_fpcc_cp_corr_signn_lsb 0
+#define xd_p_reg_feq_s1 (*(volatile byte xdata *) 0xF53F)
+#define    p_reg_feq_s1 0xF53F
+#define reg_feq_s1_pos 0
+#define reg_feq_s1_len 5
+#define reg_feq_s1_lsb 0
+#define xd_p_reg_feq_sat_ind    (*(volatile byte xdata *) 0xF540)
+#define    p_reg_feq_sat_ind    0xF540
+#define reg_feq_sat_ind_pos 0
+#define reg_feq_sat_ind_len 3
+#define reg_feq_sat_ind_lsb 0
+#define xd_p_reg_p_csi_cal_en   (*(volatile byte xdata *) 0xF541)
+#define    p_reg_p_csi_cal_en   0xF541
+#define reg_p_csi_cal_en_pos 0
+#define reg_p_csi_cal_en_len 1
+#define reg_p_csi_cal_en_lsb 0
+#define xd_p_reg_p_csi_ar_mode  (*(volatile byte xdata *) 0xF542)
+#define    p_reg_p_csi_ar_mode  0xF542
+#define reg_p_csi_ar_mode_pos 0
+#define reg_p_csi_ar_mode_len 2
+#define reg_p_csi_ar_mode_lsb 0
+#define xd_p_reg_p_csi_accu_sym_num (*(volatile byte xdata *) 0xF543)
+#define    p_reg_p_csi_accu_sym_num 0xF543
+#define reg_p_csi_accu_sym_num_pos 0
+#define reg_p_csi_accu_sym_num_len 8
+#define reg_p_csi_accu_sym_num_lsb 0
+#define xd_p_reg_p_csi_eh2_shift_thr    (*(volatile byte xdata *) 0xF544)
+#define    p_reg_p_csi_eh2_shift_thr    0xF544
+#define reg_p_csi_eh2_shift_thr_pos 0
+#define reg_p_csi_eh2_shift_thr_len 4
+#define reg_p_csi_eh2_shift_thr_lsb 0
+#define xd_p_reg_p_feq_protect_eh2_shift_thr    (*(volatile byte xdata *) 0xF545)
+#define    p_reg_p_feq_protect_eh2_shift_thr    0xF545
+#define reg_p_feq_protect_eh2_shift_thr_pos 0
+#define reg_p_feq_protect_eh2_shift_thr_len 4
+#define reg_p_feq_protect_eh2_shift_thr_lsb 0
+#define xd_p_reg_p_csi_error_accu_s1    (*(volatile byte xdata *) 0xF546)
+#define    p_reg_p_csi_error_accu_s1    0xF546
+#define reg_p_csi_error_accu_s1_pos 0
+#define reg_p_csi_error_accu_s1_len 6
+#define reg_p_csi_error_accu_s1_lsb 0
+#define xd_p_reg_p_csi_shift2   (*(volatile byte xdata *) 0xF547)
+#define    p_reg_p_csi_shift2   0xF547
+#define reg_p_csi_shift2_pos 0
+#define reg_p_csi_shift2_len 4
+#define reg_p_csi_shift2_lsb 0
+#define xd_p_reg_p_csi_mul2 (*(volatile byte xdata *) 0xF548)
+#define    p_reg_p_csi_mul2 0xF548
+#define reg_p_csi_mul2_pos 0
+#define reg_p_csi_mul2_len 8
+#define reg_p_csi_mul2_lsb 0
+#define xd_p_reg_p_csi_level2_7_0   (*(volatile byte xdata *) 0xF549)
+#define    p_reg_p_csi_level2_7_0   0xF549
+#define reg_p_csi_level2_7_0_pos 0
+#define reg_p_csi_level2_7_0_len 8
+#define reg_p_csi_level2_7_0_lsb 0
+#define xd_p_reg_p_csi_level2_8 (*(volatile byte xdata *) 0xF54A)
+#define    p_reg_p_csi_level2_8 0xF54A
+#define reg_p_csi_level2_8_pos 0
+#define reg_p_csi_level2_8_len 1
+#define reg_p_csi_level2_8_lsb 8
+#define xd_p_reg_p_feq_protect_ratio    (*(volatile byte xdata *) 0xF54B)
+#define    p_reg_p_feq_protect_ratio    0xF54B
+#define reg_p_feq_protect_ratio_pos 0
+#define reg_p_feq_protect_ratio_len 8
+#define reg_p_feq_protect_ratio_lsb 0
+#define xd_r_reg_csi_rdy    (*(volatile byte xdata *) 0xF54C)
+#define    r_reg_csi_rdy    0xF54C
+#define reg_csi_rdy_pos 0
+#define reg_csi_rdy_len 1
+#define reg_csi_rdy_lsb 0
+#define xd_p_reg_p_feq_h2protect_en (*(volatile byte xdata *) 0xF54D)
+#define    p_reg_p_feq_h2protect_en 0xF54D
+#define reg_p_feq_h2protect_en_pos 0
+#define reg_p_feq_h2protect_en_len 1
+#define reg_p_feq_h2protect_en_lsb 0
+#define xd_r_reg_tpsd_lock_f0   (*(volatile byte xdata *) 0xF54E)
+#define    r_reg_tpsd_lock_f0   0xF54E
+#define reg_tpsd_lock_f0_pos 0
+#define reg_tpsd_lock_f0_len 1
+#define reg_tpsd_lock_f0_lsb 0
+#define xd_r_reg_tpsd_lock_f1   (*(volatile byte xdata *) 0xF54F)
+#define    r_reg_tpsd_lock_f1   0xF54F
+#define reg_tpsd_lock_f1_pos 0
+#define reg_tpsd_lock_f1_len 1
+#define reg_tpsd_lock_f1_lsb 0
+#define xd_p_reg_p_csi_sp_idx_7_0   (*(volatile byte xdata *) 0xF550)
+#define    p_reg_p_csi_sp_idx_7_0   0xF550
+#define reg_p_csi_sp_idx_7_0_pos 0
+#define reg_p_csi_sp_idx_7_0_len 8
+#define reg_p_csi_sp_idx_7_0_lsb 0
+#define xd_p_reg_p_csi_sp_idx_11_8  (*(volatile byte xdata *) 0xF551)
+#define    p_reg_p_csi_sp_idx_11_8  0xF551
+#define reg_p_csi_sp_idx_11_8_pos 0
+#define reg_p_csi_sp_idx_11_8_len 4
+#define reg_p_csi_sp_idx_11_8_lsb 8
+#define xd_p_fd_fpcc_cp_corr_tone_th    (*(volatile byte xdata *) 0xF552)
+#define    p_fd_fpcc_cp_corr_tone_th    0xF552
+#define fd_fpcc_cp_corr_tone_th_pos 0
+#define fd_fpcc_cp_corr_tone_th_len 6
+#define fd_fpcc_cp_corr_tone_th_lsb 0
+#define xd_p_fd_fpcc_cp_corr_symbol_log_th  (*(volatile byte xdata *) 0xF553)
+#define    p_fd_fpcc_cp_corr_symbol_log_th  0xF553
+#define fd_fpcc_cp_corr_symbol_log_th_pos 0
+#define fd_fpcc_cp_corr_symbol_log_th_len 4
+#define fd_fpcc_cp_corr_symbol_log_th_lsb 0
+#define xd_p_fd_fpcc_cp_corr_int    (*(volatile byte xdata *) 0xF554)
+#define    p_fd_fpcc_cp_corr_int    0xF554
+#define fd_fpcc_cp_corr_int_pos 0
+#define fd_fpcc_cp_corr_int_len 1
+#define fd_fpcc_cp_corr_int_lsb 0
+#define xd_p_reg_fpcc_cp_memidx (*(volatile byte xdata *) 0xF555)
+#define    p_reg_fpcc_cp_memidx 0xF555
+#define reg_fpcc_cp_memidx_pos 0
+#define reg_fpcc_cp_memidx_len 8
+#define reg_fpcc_cp_memidx_lsb 0
+#define xd_p_reg_fpcc_cpmask_en (*(volatile byte xdata *) 0xF556)
+#define    p_reg_fpcc_cpmask_en 0xF556
+#define reg_fpcc_cpmask_en_pos 0
+#define reg_fpcc_cpmask_en_len 1
+#define reg_fpcc_cpmask_en_lsb 0
+#define xd_p_reg_fpcc_cp_grpidx (*(volatile byte xdata *) 0xF557)
+#define    p_reg_fpcc_cp_grpidx 0xF557
+#define reg_fpcc_cp_grpidx_pos 0
+#define reg_fpcc_cp_grpidx_len 5
+#define reg_fpcc_cp_grpidx_lsb 0
+#define xd_r_reg_fpcc_cp_sts    (*(volatile byte xdata *) 0xF558)
+#define    r_reg_fpcc_cp_sts    0xF558
+#define reg_fpcc_cp_sts_pos 0
+#define reg_fpcc_cp_sts_len 1
+#define reg_fpcc_cp_sts_lsb 0
+#define xd_p_reg_sfoe_ns_7_0    (*(volatile byte xdata *) 0xF559)
+#define    p_reg_sfoe_ns_7_0    0xF559
+#define reg_sfoe_ns_7_0_pos 0
+#define reg_sfoe_ns_7_0_len 8
+#define reg_sfoe_ns_7_0_lsb 0
+#define xd_p_reg_sfoe_ns_14_8   (*(volatile byte xdata *) 0xF55A)
+#define    p_reg_sfoe_ns_14_8   0xF55A
+#define reg_sfoe_ns_14_8_pos 0
+#define reg_sfoe_ns_14_8_len 7
+#define reg_sfoe_ns_14_8_lsb 8
+#define xd_p_reg_sfoe_c1_7_0    (*(volatile byte xdata *) 0xF55B)
+#define    p_reg_sfoe_c1_7_0    0xF55B
+#define reg_sfoe_c1_7_0_pos 0
+#define reg_sfoe_c1_7_0_len 8
+#define reg_sfoe_c1_7_0_lsb 0
+#define xd_p_reg_sfoe_c1_9_8    (*(volatile byte xdata *) 0xF55C)
+#define    p_reg_sfoe_c1_9_8    0xF55C
+#define reg_sfoe_c1_9_8_pos 0
+#define reg_sfoe_c1_9_8_len 2
+#define reg_sfoe_c1_9_8_lsb 8
+#define xd_p_reg_sfoe_c2_7_0    (*(volatile byte xdata *) 0xF55D)
+#define    p_reg_sfoe_c2_7_0    0xF55D
+#define reg_sfoe_c2_7_0_pos 0
+#define reg_sfoe_c2_7_0_len 8
+#define reg_sfoe_c2_7_0_lsb 0
+#define xd_p_reg_sfoe_c2_9_8    (*(volatile byte xdata *) 0xF55E)
+#define    p_reg_sfoe_c2_9_8    0xF55E
+#define reg_sfoe_c2_9_8_pos 0
+#define reg_sfoe_c2_9_8_len 2
+#define reg_sfoe_c2_9_8_lsb 8
+#define xd_p_reg_sfoe_lm_counter_th (*(volatile byte xdata *) 0xF55F)
+#define    p_reg_sfoe_lm_counter_th 0xF55F
+#define reg_sfoe_lm_counter_th_pos 0
+#define reg_sfoe_lm_counter_th_len 4
+#define reg_sfoe_lm_counter_th_lsb 0
+#define xd_p_reg_sfoe_spec_inv  (*(volatile byte xdata *) 0xF560)
+#define    p_reg_sfoe_spec_inv  0xF560
+#define reg_sfoe_spec_inv_pos 0
+#define reg_sfoe_spec_inv_len 1
+#define reg_sfoe_spec_inv_lsb 0
+#define xd_p_reg_sfoe_convg_th  (*(volatile byte xdata *) 0xF561)
+#define    p_reg_sfoe_convg_th  0xF561
+#define reg_sfoe_convg_th_pos 0
+#define reg_sfoe_convg_th_len 8
+#define reg_sfoe_convg_th_lsb 0
+#define xd_p_reg_sfoe_divg_th   (*(volatile byte xdata *) 0xF562)
+#define    p_reg_sfoe_divg_th   0xF562
+#define reg_sfoe_divg_th_pos 0
+#define reg_sfoe_divg_th_len 8
+#define reg_sfoe_divg_th_lsb 0
+#define xd_p_reg_sfoe_pullin_ctr_th (*(volatile byte xdata *) 0xF563)
+#define    p_reg_sfoe_pullin_ctr_th 0xF563
+#define reg_sfoe_pullin_ctr_th_pos 0
+#define reg_sfoe_pullin_ctr_th_len 4
+#define reg_sfoe_pullin_ctr_th_lsb 0
+#define xd_p_reg_sfoe_sf_ctr_th (*(volatile byte xdata *) 0xF564)
+#define    p_reg_sfoe_sf_ctr_th 0xF564
+#define reg_sfoe_sf_ctr_th_pos 0
+#define reg_sfoe_sf_ctr_th_len 4
+#define reg_sfoe_sf_ctr_th_lsb 0
+#define xd_p_reg_sfoe_pullin_th (*(volatile byte xdata *) 0xF565)
+#define    p_reg_sfoe_pullin_th 0xF565
+#define reg_sfoe_pullin_th_pos 0
+#define reg_sfoe_pullin_th_len 8
+#define reg_sfoe_pullin_th_lsb 0
+#define xd_p_reg_sfoe_kalman_cnt    (*(volatile byte xdata *) 0xF566)
+#define    p_reg_sfoe_kalman_cnt    0xF566
+#define reg_sfoe_kalman_cnt_pos 0
+#define reg_sfoe_kalman_cnt_len 4
+#define reg_sfoe_kalman_cnt_lsb 0
+#define xd_p_reg_sfoe_fsm_info  (*(volatile byte xdata *) 0xF567)
+#define    p_reg_sfoe_fsm_info  0xF567
+#define reg_sfoe_fsm_info_pos 0
+#define reg_sfoe_fsm_info_len 4
+#define reg_sfoe_fsm_info_lsb 0
+#define xd_r_reg_sfoe_pullin_cnt    (*(volatile byte xdata *) 0xF568)
+#define    r_reg_sfoe_pullin_cnt    0xF568
+#define reg_sfoe_pullin_cnt_pos 0
+#define reg_sfoe_pullin_cnt_len 4
+#define reg_sfoe_pullin_cnt_lsb 0
+#define xd_r_reg_sfoe_sf_cnt    (*(volatile byte xdata *) 0xF569)
+#define    r_reg_sfoe_sf_cnt    0xF569
+#define reg_sfoe_sf_cnt_pos 0
+#define reg_sfoe_sf_cnt_len 4
+#define reg_sfoe_sf_cnt_lsb 0
+#define xd_p_reg_fste_phase_ini_7_0 (*(volatile byte xdata *) 0xF56A)
+#define    p_reg_fste_phase_ini_7_0 0xF56A
+#define reg_fste_phase_ini_7_0_pos 0
+#define reg_fste_phase_ini_7_0_len 8
+#define reg_fste_phase_ini_7_0_lsb 0
+#define xd_p_reg_fste_phase_ini_11_8    (*(volatile byte xdata *) 0xF56B)
+#define    p_reg_fste_phase_ini_11_8    0xF56B
+#define reg_fste_phase_ini_11_8_pos 0
+#define reg_fste_phase_ini_11_8_len 4
+#define reg_fste_phase_ini_11_8_lsb 8
+#define xd_p_reg_fste_phase_inc_7_0 (*(volatile byte xdata *) 0xF56C)
+#define    p_reg_fste_phase_inc_7_0 0xF56C
+#define reg_fste_phase_inc_7_0_pos 0
+#define reg_fste_phase_inc_7_0_len 8
+#define reg_fste_phase_inc_7_0_lsb 0
+#define xd_p_reg_fste_phase_inc_11_8    (*(volatile byte xdata *) 0xF56D)
+#define    p_reg_fste_phase_inc_11_8    0xF56D
+#define reg_fste_phase_inc_11_8_pos 0
+#define reg_fste_phase_inc_11_8_len 4
+#define reg_fste_phase_inc_11_8_lsb 8
+#define xd_p_reg_fste_acum_cost_cnt_max (*(volatile byte xdata *) 0xF56E)
+#define    p_reg_fste_acum_cost_cnt_max 0xF56E
+#define reg_fste_acum_cost_cnt_max_pos 0
+#define reg_fste_acum_cost_cnt_max_len 4
+#define reg_fste_acum_cost_cnt_max_lsb 0
+#define xd_p_reg_fste_step_size_std (*(volatile byte xdata *) 0xF56F)
+#define    p_reg_fste_step_size_std 0xF56F
+#define reg_fste_step_size_std_pos 0
+#define reg_fste_step_size_std_len 4
+#define reg_fste_step_size_std_lsb 0
+#define xd_p_reg_fste_step_size_max (*(volatile byte xdata *) 0xF570)
+#define    p_reg_fste_step_size_max 0xF570
+#define reg_fste_step_size_max_pos 0
+#define reg_fste_step_size_max_len 4
+#define reg_fste_step_size_max_lsb 0
+#define xd_p_reg_fste_rpd_dir_cnt_max   (*(volatile byte xdata *) 0xF571)
+#define    p_reg_fste_rpd_dir_cnt_max   0xF571
+#define reg_fste_rpd_dir_cnt_max_pos 0
+#define reg_fste_rpd_dir_cnt_max_len 4
+#define reg_fste_rpd_dir_cnt_max_lsb 0
+#define xd_p_reg_fste_frac_cost_cnt_max_7_0 (*(volatile byte xdata *) 0xF572)
+#define    p_reg_fste_frac_cost_cnt_max_7_0 0xF572
+#define reg_fste_frac_cost_cnt_max_7_0_pos 0
+#define reg_fste_frac_cost_cnt_max_7_0_len 8
+#define reg_fste_frac_cost_cnt_max_7_0_lsb 0
+#define xd_p_reg_fste_frac_cost_cnt_max_9_8 (*(volatile byte xdata *) 0xF573)
+#define    p_reg_fste_frac_cost_cnt_max_9_8 0xF573
+#define reg_fste_frac_cost_cnt_max_9_8_pos 0
+#define reg_fste_frac_cost_cnt_max_9_8_len 2
+#define reg_fste_frac_cost_cnt_max_9_8_lsb 8
+#define xd_p_reg_fste_isLongWeakTail    (*(volatile byte xdata *) 0xF574)
+#define    p_reg_fste_isLongWeakTail    0xF574
+#define reg_fste_isLongWeakTail_pos 0
+#define reg_fste_isLongWeakTail_len 1
+#define reg_fste_isLongWeakTail_lsb 0
+#define xd_p_reg_fste_isLongWeakHead    (*(volatile byte xdata *) 0xF575)
+#define    p_reg_fste_isLongWeakHead    0xF575
+#define reg_fste_isLongWeakHead_pos 0
+#define reg_fste_isLongWeakHead_len 1
+#define reg_fste_isLongWeakHead_lsb 0
+#define xd_p_reg_fste_w0_7_0    (*(volatile byte xdata *) 0xF576)
+#define    p_reg_fste_w0_7_0    0xF576
+#define reg_fste_w0_7_0_pos 0
+#define reg_fste_w0_7_0_len 8
+#define reg_fste_w0_7_0_lsb 0
+#define xd_p_reg_fste_w0_9_8    (*(volatile byte xdata *) 0xF577)
+#define    p_reg_fste_w0_9_8    0xF577
+#define reg_fste_w0_9_8_pos 0
+#define reg_fste_w0_9_8_len 2
+#define reg_fste_w0_9_8_lsb 8
+#define xd_p_reg_fste_w1_7_0    (*(volatile byte xdata *) 0xF578)
+#define    p_reg_fste_w1_7_0    0xF578
+#define reg_fste_w1_7_0_pos 0
+#define reg_fste_w1_7_0_len 8
+#define reg_fste_w1_7_0_lsb 0
+#define xd_p_reg_fste_w1_9_8    (*(volatile byte xdata *) 0xF579)
+#define    p_reg_fste_w1_9_8    0xF579
+#define reg_fste_w1_9_8_pos 0
+#define reg_fste_w1_9_8_len 2
+#define reg_fste_w1_9_8_lsb 8
+#define xd_p_reg_fste_w2_7_0    (*(volatile byte xdata *) 0xF57A)
+#define    p_reg_fste_w2_7_0    0xF57A
+#define reg_fste_w2_7_0_pos 0
+#define reg_fste_w2_7_0_len 8
+#define reg_fste_w2_7_0_lsb 0
+#define xd_p_reg_fste_w2_9_8    (*(volatile byte xdata *) 0xF57B)
+#define    p_reg_fste_w2_9_8    0xF57B
+#define reg_fste_w2_9_8_pos 0
+#define reg_fste_w2_9_8_len 2
+#define reg_fste_w2_9_8_lsb 8
+#define xd_p_reg_fste_w3_7_0    (*(volatile byte xdata *) 0xF57C)
+#define    p_reg_fste_w3_7_0    0xF57C
+#define reg_fste_w3_7_0_pos 0
+#define reg_fste_w3_7_0_len 8
+#define reg_fste_w3_7_0_lsb 0
+#define xd_p_reg_fste_w3_9_8    (*(volatile byte xdata *) 0xF57D)
+#define    p_reg_fste_w3_9_8    0xF57D
+#define reg_fste_w3_9_8_pos 0
+#define reg_fste_w3_9_8_len 2
+#define reg_fste_w3_9_8_lsb 8
+#define xd_p_reg_fste_w4_7_0    (*(volatile byte xdata *) 0xF57E)
+#define    p_reg_fste_w4_7_0    0xF57E
+#define reg_fste_w4_7_0_pos 0
+#define reg_fste_w4_7_0_len 8
+#define reg_fste_w4_7_0_lsb 0
+#define xd_p_reg_fste_w4_9_8    (*(volatile byte xdata *) 0xF57F)
+#define    p_reg_fste_w4_9_8    0xF57F
+#define reg_fste_w4_9_8_pos 0
+#define reg_fste_w4_9_8_len 2
+#define reg_fste_w4_9_8_lsb 8
+#define xd_p_reg_fste_w5_7_0    (*(volatile byte xdata *) 0xF580)
+#define    p_reg_fste_w5_7_0    0xF580
+#define reg_fste_w5_7_0_pos 0
+#define reg_fste_w5_7_0_len 8
+#define reg_fste_w5_7_0_lsb 0
+#define xd_p_reg_fste_w5_9_8    (*(volatile byte xdata *) 0xF581)
+#define    p_reg_fste_w5_9_8    0xF581
+#define reg_fste_w5_9_8_pos 0
+#define reg_fste_w5_9_8_len 2
+#define reg_fste_w5_9_8_lsb 8
+#define xd_p_reg_fste_w6_7_0    (*(volatile byte xdata *) 0xF582)
+#define    p_reg_fste_w6_7_0    0xF582
+#define reg_fste_w6_7_0_pos 0
+#define reg_fste_w6_7_0_len 8
+#define reg_fste_w6_7_0_lsb 0
+#define xd_p_reg_fste_w6_9_8    (*(volatile byte xdata *) 0xF583)
+#define    p_reg_fste_w6_9_8    0xF583
+#define reg_fste_w6_9_8_pos 0
+#define reg_fste_w6_9_8_len 2
+#define reg_fste_w6_9_8_lsb 8
+#define xd_p_reg_fste_w7_7_0    (*(volatile byte xdata *) 0xF584)
+#define    p_reg_fste_w7_7_0    0xF584
+#define reg_fste_w7_7_0_pos 0
+#define reg_fste_w7_7_0_len 8
+#define reg_fste_w7_7_0_lsb 0
+#define xd_p_reg_fste_w7_9_8    (*(volatile byte xdata *) 0xF585)
+#define    p_reg_fste_w7_9_8    0xF585
+#define reg_fste_w7_9_8_pos 0
+#define reg_fste_w7_9_8_len 2
+#define reg_fste_w7_9_8_lsb 8
+#define xd_p_reg_fste_w8_7_0    (*(volatile byte xdata *) 0xF586)
+#define    p_reg_fste_w8_7_0    0xF586
+#define reg_fste_w8_7_0_pos 0
+#define reg_fste_w8_7_0_len 8
+#define reg_fste_w8_7_0_lsb 0
+#define xd_p_reg_fste_w8_9_8    (*(volatile byte xdata *) 0xF587)
+#define    p_reg_fste_w8_9_8    0xF587
+#define reg_fste_w8_9_8_pos 0
+#define reg_fste_w8_9_8_len 2
+#define reg_fste_w8_9_8_lsb 8
+#define xd_p_reg_fste_w9_7_0    (*(volatile byte xdata *) 0xF588)
+#define    p_reg_fste_w9_7_0    0xF588
+#define reg_fste_w9_7_0_pos 0
+#define reg_fste_w9_7_0_len 8
+#define reg_fste_w9_7_0_lsb 0
+#define xd_p_reg_fste_w9_9_8    (*(volatile byte xdata *) 0xF589)
+#define    p_reg_fste_w9_9_8    0xF589
+#define reg_fste_w9_9_8_pos 0
+#define reg_fste_w9_9_8_len 2
+#define reg_fste_w9_9_8_lsb 8
+#define xd_p_reg_fste_wa_7_0    (*(volatile byte xdata *) 0xF58A)
+#define    p_reg_fste_wa_7_0    0xF58A
+#define reg_fste_wa_7_0_pos 0
+#define reg_fste_wa_7_0_len 8
+#define reg_fste_wa_7_0_lsb 0
+#define xd_p_reg_fste_wa_9_8    (*(volatile byte xdata *) 0xF58B)
+#define    p_reg_fste_wa_9_8    0xF58B
+#define reg_fste_wa_9_8_pos 0
+#define reg_fste_wa_9_8_len 2
+#define reg_fste_wa_9_8_lsb 8
+#define xd_p_reg_fste_wb_7_0    (*(volatile byte xdata *) 0xF58C)
+#define    p_reg_fste_wb_7_0    0xF58C
+#define reg_fste_wb_7_0_pos 0
+#define reg_fste_wb_7_0_len 8
+#define reg_fste_wb_7_0_lsb 0
+#define xd_p_reg_fste_wb_9_8    (*(volatile byte xdata *) 0xF58D)
+#define    p_reg_fste_wb_9_8    0xF58D
+#define reg_fste_wb_9_8_pos 0
+#define reg_fste_wb_9_8_len 2
+#define reg_fste_wb_9_8_lsb 8
+#define xd_p_reg_fste_wc_7_0    (*(volatile byte xdata *) 0xF58E)
+#define    p_reg_fste_wc_7_0    0xF58E
+#define reg_fste_wc_7_0_pos 0
+#define reg_fste_wc_7_0_len 8
+#define reg_fste_wc_7_0_lsb 0
+#define xd_p_reg_fste_wc_9_8    (*(volatile byte xdata *) 0xF58F)
+#define    p_reg_fste_wc_9_8    0xF58F
+#define reg_fste_wc_9_8_pos 0
+#define reg_fste_wc_9_8_len 2
+#define reg_fste_wc_9_8_lsb 8
+#define xd_p_reg_fste_wd_7_0    (*(volatile byte xdata *) 0xF590)
+#define    p_reg_fste_wd_7_0    0xF590
+#define reg_fste_wd_7_0_pos 0
+#define reg_fste_wd_7_0_len 8
+#define reg_fste_wd_7_0_lsb 0
+#define xd_p_reg_fste_wd_9_8    (*(volatile byte xdata *) 0xF591)
+#define    p_reg_fste_wd_9_8    0xF591
+#define reg_fste_wd_9_8_pos 0
+#define reg_fste_wd_9_8_len 2
+#define reg_fste_wd_9_8_lsb 8
+#define xd_p_reg_fste_we_7_0    (*(volatile byte xdata *) 0xF592)
+#define    p_reg_fste_we_7_0    0xF592
+#define reg_fste_we_7_0_pos 0
+#define reg_fste_we_7_0_len 8
+#define reg_fste_we_7_0_lsb 0
+#define xd_p_reg_fste_we_9_8    (*(volatile byte xdata *) 0xF593)
+#define    p_reg_fste_we_9_8    0xF593
+#define reg_fste_we_9_8_pos 0
+#define reg_fste_we_9_8_len 2
+#define reg_fste_we_9_8_lsb 8
+#define xd_p_reg_fste_wf_7_0    (*(volatile byte xdata *) 0xF594)
+#define    p_reg_fste_wf_7_0    0xF594
+#define reg_fste_wf_7_0_pos 0
+#define reg_fste_wf_7_0_len 8
+#define reg_fste_wf_7_0_lsb 0
+#define xd_p_reg_fste_wf_9_8    (*(volatile byte xdata *) 0xF595)
+#define    p_reg_fste_wf_9_8    0xF595
+#define reg_fste_wf_9_8_pos 0
+#define reg_fste_wf_9_8_len 2
+#define reg_fste_wf_9_8_lsb 8
+#define xd_p_reg_fste_wg_7_0    (*(volatile byte xdata *) 0xF596)
+#define    p_reg_fste_wg_7_0    0xF596
+#define reg_fste_wg_7_0_pos 0
+#define reg_fste_wg_7_0_len 8
+#define reg_fste_wg_7_0_lsb 0
+#define xd_p_reg_fste_wg_9_8    (*(volatile byte xdata *) 0xF597)
+#define    p_reg_fste_wg_9_8    0xF597
+#define reg_fste_wg_9_8_pos 0
+#define reg_fste_wg_9_8_len 2
+#define reg_fste_wg_9_8_lsb 8
+#define xd_p_reg_fste_wh_7_0    (*(volatile byte xdata *) 0xF598)
+#define    p_reg_fste_wh_7_0    0xF598
+#define reg_fste_wh_7_0_pos 0
+#define reg_fste_wh_7_0_len 8
+#define reg_fste_wh_7_0_lsb 0
+#define xd_p_reg_fste_wh_9_8    (*(volatile byte xdata *) 0xF599)
+#define    p_reg_fste_wh_9_8    0xF599
+#define reg_fste_wh_9_8_pos 0
+#define reg_fste_wh_9_8_len 2
+#define reg_fste_wh_9_8_lsb 8
+#define xd_r_fd_fste_i_adj_org  (*(volatile byte xdata *) 0xF59A)
+#define    r_fd_fste_i_adj_org  0xF59A
+#define fd_fste_i_adj_org_pos 0
+#define fd_fste_i_adj_org_len 5
+#define fd_fste_i_adj_org_lsb 0
+#define xd_r_fd_fste_f_adj_7_0  (*(volatile byte xdata *) 0xF59B)
+#define    r_fd_fste_f_adj_7_0  0xF59B
+#define fd_fste_f_adj_7_0_pos 0
+#define fd_fste_f_adj_7_0_len 8
+#define fd_fste_f_adj_7_0_lsb 0
+#define xd_r_fd_fste_f_adj_15_8 (*(volatile byte xdata *) 0xF59C)
+#define    r_fd_fste_f_adj_15_8 0xF59C
+#define fd_fste_f_adj_15_8_pos 0
+#define fd_fste_f_adj_15_8_len 8
+#define fd_fste_f_adj_15_8_lsb 8
+#define xd_r_fd_fste_f_adj_19_16    (*(volatile byte xdata *) 0xF59D)
+#define    r_fd_fste_f_adj_19_16    0xF59D
+#define fd_fste_f_adj_19_16_pos 0
+#define fd_fste_f_adj_19_16_len 4
+#define fd_fste_f_adj_19_16_lsb 16
+#define xd_p_reg_fste_ehw_7_0   (*(volatile byte xdata *) 0xF59E)
+#define    p_reg_fste_ehw_7_0   0xF59E
+#define reg_fste_ehw_7_0_pos 0
+#define reg_fste_ehw_7_0_len 8
+#define reg_fste_ehw_7_0_lsb 0
+#define xd_p_reg_fste_ehw_12_8  (*(volatile byte xdata *) 0xF59F)
+#define    p_reg_fste_ehw_12_8  0xF59F
+#define reg_fste_ehw_12_8_pos 0
+#define reg_fste_ehw_12_8_len 5
+#define reg_fste_ehw_12_8_lsb 8
+#define xd_p_reg_fste_i_adj_vld (*(volatile byte xdata *) 0xF5A0)
+#define    p_reg_fste_i_adj_vld 0xF5A0
+#define reg_fste_i_adj_vld_pos 0
+#define reg_fste_i_adj_vld_len 1
+#define reg_fste_i_adj_vld_lsb 0
+#define xd_p_reg_fste_ceTimesPhasor_real    (*(volatile byte xdata *) 0xF5A1)
+#define    p_reg_fste_ceTimesPhasor_real    0xF5A1
+#define reg_fste_ceTimesPhasor_real_pos 0
+#define reg_fste_ceTimesPhasor_real_len 1
+#define reg_fste_ceTimesPhasor_real_lsb 0
+#define xd_p_reg_fste_ceTimesPhasor_imag    (*(volatile byte xdata *) 0xF5A2)
+#define    p_reg_fste_ceTimesPhasor_imag    0xF5A2
+#define reg_fste_ceTimesPhasor_imag_pos 0
+#define reg_fste_ceTimesPhasor_imag_len 1
+#define reg_fste_ceTimesPhasor_imag_lsb 0
+#define xd_p_reg_fste_cerTimesW_real    (*(volatile byte xdata *) 0xF5A3)
+#define    p_reg_fste_cerTimesW_real    0xF5A3
+#define reg_fste_cerTimesW_real_pos 0
+#define reg_fste_cerTimesW_real_len 1
+#define reg_fste_cerTimesW_real_lsb 0
+#define xd_p_reg_fste_cerTimesW_imag    (*(volatile byte xdata *) 0xF5A4)
+#define    p_reg_fste_cerTimesW_imag    0xF5A4
+#define reg_fste_cerTimesW_imag_pos 0
+#define reg_fste_cerTimesW_imag_len 1
+#define reg_fste_cerTimesW_imag_lsb 0
+#define xd_p_reg_fste_cerTimesWAccum_real   (*(volatile byte xdata *) 0xF5A5)
+#define    p_reg_fste_cerTimesWAccum_real   0xF5A5
+#define reg_fste_cerTimesWAccum_real_pos 0
+#define reg_fste_cerTimesWAccum_real_len 1
+#define reg_fste_cerTimesWAccum_real_lsb 0
+#define xd_p_reg_fste_cerTimesWAccum_imag   (*(volatile byte xdata *) 0xF5A6)
+#define    p_reg_fste_cerTimesWAccum_imag   0xF5A6
+#define reg_fste_cerTimesWAccum_imag_pos 0
+#define reg_fste_cerTimesWAccum_imag_len 1
+#define reg_fste_cerTimesWAccum_imag_lsb 0
+#define xd_p_reg_fste_cost  (*(volatile byte xdata *) 0xF5A7)
+#define    p_reg_fste_cost  0xF5A7
+#define reg_fste_cost_pos 0
+#define reg_fste_cost_len 1
+#define reg_fste_cost_lsb 0
+#define xd_p_fd_tpsd_en (*(volatile byte xdata *) 0xF5A8)
+#define    p_fd_tpsd_en 0xF5A8
+#define fd_tpsd_en_pos 0
+#define fd_tpsd_en_len 1
+#define fd_tpsd_en_lsb 0
+#define xd_p_fd_tpsd_lock   (*(volatile byte xdata *) 0xF5A9)
+#define    p_fd_tpsd_lock   0xF5A9
+#define fd_tpsd_lock_pos 0
+#define fd_tpsd_lock_len 1
+#define fd_tpsd_lock_lsb 0
+#define xd_r_fd_tpsd_s19    (*(volatile byte xdata *) 0xF5AA)
+#define    r_fd_tpsd_s19    0xF5AA
+#define fd_tpsd_s19_pos 0
+#define fd_tpsd_s19_len 1
+#define fd_tpsd_s19_lsb 0
+#define xd_r_fd_tpsd_s17    (*(volatile byte xdata *) 0xF5AB)
+#define    r_fd_tpsd_s17    0xF5AB
+#define fd_tpsd_s17_pos 0
+#define fd_tpsd_s17_len 1
+#define fd_tpsd_s17_lsb 0
+#define xd_p_fd_sfr_ste_en  (*(volatile byte xdata *) 0xF5AC)
+#define    p_fd_sfr_ste_en  0xF5AC
+#define fd_sfr_ste_en_pos 0
+#define fd_sfr_ste_en_len 1
+#define fd_sfr_ste_en_lsb 0
+#define xd_p_fd_sfr_ste_mode    (*(volatile byte xdata *) 0xF5AD)
+#define    p_fd_sfr_ste_mode    0xF5AD
+#define fd_sfr_ste_mode_pos 0
+#define fd_sfr_ste_mode_len 2
+#define fd_sfr_ste_mode_lsb 0
+#define xd_p_fd_sfr_ste_done    (*(volatile byte xdata *) 0xF5AE)
+#define    p_fd_sfr_ste_done    0xF5AE
+#define fd_sfr_ste_done_pos 0
+#define fd_sfr_ste_done_len 1
+#define fd_sfr_ste_done_lsb 0
+#define xd_p_reg_cfoe_ffoe_en   (*(volatile byte xdata *) 0xF5AF)
+#define    p_reg_cfoe_ffoe_en   0xF5AF
+#define reg_cfoe_ffoe_en_pos 0
+#define reg_cfoe_ffoe_en_len 1
+#define reg_cfoe_ffoe_en_lsb 0
+#define xd_p_reg_cfoe_ifoe_en   (*(volatile byte xdata *) 0xF5B0)
+#define    p_reg_cfoe_ifoe_en   0xF5B0
+#define reg_cfoe_ifoe_en_pos 0
+#define reg_cfoe_ifoe_en_len 1
+#define reg_cfoe_ifoe_en_lsb 0
+#define xd_p_reg_cfoe_fot_en    (*(volatile byte xdata *) 0xF5B1)
+#define    p_reg_cfoe_fot_en    0xF5B1
+#define reg_cfoe_fot_en_pos 0
+#define reg_cfoe_fot_en_len 1
+#define reg_cfoe_fot_en_lsb 0
+#define xd_p_reg_cfoe_fot_lm_en (*(volatile byte xdata *) 0xF5B2)
+#define    p_reg_cfoe_fot_lm_en 0xF5B2
+#define reg_cfoe_fot_lm_en_pos 0
+#define reg_cfoe_fot_lm_en_len 1
+#define reg_cfoe_fot_lm_en_lsb 0
+#define xd_p_reg_cfoe_fot_rst   (*(volatile byte xdata *) 0xF5B3)
+#define    p_reg_cfoe_fot_rst   0xF5B3
+#define reg_cfoe_fot_rst_pos 0
+#define reg_cfoe_fot_rst_len 1
+#define reg_cfoe_fot_rst_lsb 0
+#define xd_r_fd_cfoe_ffoe_done  (*(volatile byte xdata *) 0xF5B4)
+#define    r_fd_cfoe_ffoe_done  0xF5B4
+#define fd_cfoe_ffoe_done_pos 0
+#define fd_cfoe_ffoe_done_len 1
+#define fd_cfoe_ffoe_done_lsb 0
+#define xd_p_fd_cfoe_metric_vld (*(volatile byte xdata *) 0xF5B5)
+#define    p_fd_cfoe_metric_vld 0xF5B5
+#define fd_cfoe_metric_vld_pos 0
+#define fd_cfoe_metric_vld_len 1
+#define fd_cfoe_metric_vld_lsb 0
+#define xd_p_reg_cfoe_ifod_vld  (*(volatile byte xdata *) 0xF5B6)
+#define    p_reg_cfoe_ifod_vld  0xF5B6
+#define reg_cfoe_ifod_vld_pos 0
+#define reg_cfoe_ifod_vld_len 1
+#define reg_cfoe_ifod_vld_lsb 0
+#define xd_r_fd_cfoe_ifoe_done  (*(volatile byte xdata *) 0xF5B7)
+#define    r_fd_cfoe_ifoe_done  0xF5B7
+#define fd_cfoe_ifoe_done_pos 0
+#define fd_cfoe_ifoe_done_len 1
+#define fd_cfoe_ifoe_done_lsb 0
+#define xd_p_reg_cfoe_ifoe_spec_inv (*(volatile byte xdata *) 0xF5B8)
+#define    p_reg_cfoe_ifoe_spec_inv 0xF5B8
+#define reg_cfoe_ifoe_spec_inv_pos 0
+#define reg_cfoe_ifoe_spec_inv_len 1
+#define reg_cfoe_ifoe_spec_inv_lsb 0
+#define xd_p_reg_cfoe_divg_int  (*(volatile byte xdata *) 0xF5B9)
+#define    p_reg_cfoe_divg_int  0xF5B9
+#define reg_cfoe_divg_int_pos 0
+#define reg_cfoe_divg_int_len 1
+#define reg_cfoe_divg_int_lsb 0
+#define xd_r_reg_cfoe_divg_flag (*(volatile byte xdata *) 0xF5BA)
+#define    r_reg_cfoe_divg_flag 0xF5BA
+#define reg_cfoe_divg_flag_pos 0
+#define reg_cfoe_divg_flag_len 1
+#define reg_cfoe_divg_flag_lsb 0
+#define xd_p_reg_sfoe_en    (*(volatile byte xdata *) 0xF5BB)
+#define    p_reg_sfoe_en    0xF5BB
+#define reg_sfoe_en_pos 0
+#define reg_sfoe_en_len 1
+#define reg_sfoe_en_lsb 0
+#define xd_p_reg_sfoe_dis   (*(volatile byte xdata *) 0xF5BC)
+#define    p_reg_sfoe_dis   0xF5BC
+#define reg_sfoe_dis_pos 0
+#define reg_sfoe_dis_len 1
+#define reg_sfoe_dis_lsb 0
+#define xd_p_reg_sfoe_rst   (*(volatile byte xdata *) 0xF5BD)
+#define    p_reg_sfoe_rst   0xF5BD
+#define reg_sfoe_rst_pos 0
+#define reg_sfoe_rst_len 1
+#define reg_sfoe_rst_lsb 0
+#define xd_p_reg_sfoe_vld_int   (*(volatile byte xdata *) 0xF5BE)
+#define    p_reg_sfoe_vld_int   0xF5BE
+#define reg_sfoe_vld_int_pos 0
+#define reg_sfoe_vld_int_len 1
+#define reg_sfoe_vld_int_lsb 0
+#define xd_p_reg_sfoe_lm_en (*(volatile byte xdata *) 0xF5BF)
+#define    p_reg_sfoe_lm_en 0xF5BF
+#define reg_sfoe_lm_en_pos 0
+#define reg_sfoe_lm_en_len 1
+#define reg_sfoe_lm_en_lsb 0
+#define xd_p_reg_sfoe_divg_int  (*(volatile byte xdata *) 0xF5C0)
+#define    p_reg_sfoe_divg_int  0xF5C0
+#define reg_sfoe_divg_int_pos 0
+#define reg_sfoe_divg_int_len 1
+#define reg_sfoe_divg_int_lsb 0
+#define xd_r_reg_sfoe_divg_flag (*(volatile byte xdata *) 0xF5C1)
+#define    r_reg_sfoe_divg_flag 0xF5C1
+#define reg_sfoe_divg_flag_pos 0
+#define reg_sfoe_divg_flag_len 1
+#define reg_sfoe_divg_flag_lsb 0
+#define xd_p_reg_fft_rst    (*(volatile byte xdata *) 0xF5C2)
+#define    p_reg_fft_rst    0xF5C2
+#define reg_fft_rst_pos 0
+#define reg_fft_rst_len 1
+#define reg_fft_rst_lsb 0
+#define xd_p_reg_fft_mask2_en   (*(volatile byte xdata *) 0xF5C3)
+#define    p_reg_fft_mask2_en   0xF5C3
+#define reg_fft_mask2_en_pos 0
+#define reg_fft_mask2_en_len 1
+#define reg_fft_mask2_en_lsb 0
+#define xd_p_reg_fft_mask3_en   (*(volatile byte xdata *) 0xF5C4)
+#define    p_reg_fft_mask3_en   0xF5C4
+#define reg_fft_mask3_en_pos 0
+#define reg_fft_mask3_en_len 1
+#define reg_fft_mask3_en_lsb 0
+#define xd_p_reg_fft_crc_en (*(volatile byte xdata *) 0xF5C5)
+#define    p_reg_fft_crc_en 0xF5C5
+#define reg_fft_crc_en_pos 0
+#define reg_fft_crc_en_len 1
+#define reg_fft_crc_en_lsb 0
+#define xd_p_reg_fft_mask0_en   (*(volatile byte xdata *) 0xF5C6)
+#define    p_reg_fft_mask0_en   0xF5C6
+#define reg_fft_mask0_en_pos 0
+#define reg_fft_mask0_en_len 1
+#define reg_fft_mask0_en_lsb 0
+#define xd_p_reg_fft_mask1_en   (*(volatile byte xdata *) 0xF5C7)
+#define    p_reg_fft_mask1_en   0xF5C7
+#define reg_fft_mask1_en_pos 0
+#define reg_fft_mask1_en_len 1
+#define reg_fft_mask1_en_lsb 0
+#define xd_p_fd_fste_en (*(volatile byte xdata *) 0xF5C8)
+#define    p_fd_fste_en 0xF5C8
+#define fd_fste_en_pos 0
+#define fd_fste_en_len 1
+#define fd_fste_en_lsb 0
+#define xd_p_reg_feq_eh2_comp_en    (*(volatile byte xdata *) 0xF5C9)
+#define    p_reg_feq_eh2_comp_en    0xF5C9
+#define reg_feq_eh2_comp_en_pos 0
+#define reg_feq_eh2_comp_en_len 1
+#define reg_feq_eh2_comp_en_lsb 0
+#define xd_p_reg_feq_read_update    (*(volatile byte xdata *) 0xF5CA)
+#define    p_reg_feq_read_update    0xF5CA
+#define reg_feq_read_update_pos 0
+#define reg_feq_read_update_len 1
+#define reg_feq_read_update_lsb 0
+#define xd_p_reg_feq_data_vld   (*(volatile byte xdata *) 0xF5CB)
+#define    p_reg_feq_data_vld   0xF5CB
+#define reg_feq_data_vld_pos 0
+#define reg_feq_data_vld_len 1
+#define reg_feq_data_vld_lsb 0
+#define xd_p_reg_feq_tone_idx_7_0   (*(volatile byte xdata *) 0xF5CC)
+#define    p_reg_feq_tone_idx_7_0   0xF5CC
+#define reg_feq_tone_idx_7_0_pos 0
+#define reg_feq_tone_idx_7_0_len 8
+#define reg_feq_tone_idx_7_0_lsb 0
+#define xd_p_reg_feq_tone_idx_12_8  (*(volatile byte xdata *) 0xF5CD)
+#define    p_reg_feq_tone_idx_12_8  0xF5CD
+#define reg_feq_tone_idx_12_8_pos 0
+#define reg_feq_tone_idx_12_8_len 5
+#define reg_feq_tone_idx_12_8_lsb 8
+#define xd_r_reg_feq_data_re_7_0    (*(volatile byte xdata *) 0xF5CE)
+#define    r_reg_feq_data_re_7_0    0xF5CE
+#define reg_feq_data_re_7_0_pos 0
+#define reg_feq_data_re_7_0_len 8
+#define reg_feq_data_re_7_0_lsb 0
+#define xd_r_reg_feq_data_re_15_8   (*(volatile byte xdata *) 0xF5CF)
+#define    r_reg_feq_data_re_15_8   0xF5CF
+#define reg_feq_data_re_15_8_pos 0
+#define reg_feq_data_re_15_8_len 8
+#define reg_feq_data_re_15_8_lsb 8
+#define xd_r_reg_feq_data_re_21_16  (*(volatile byte xdata *) 0xF5D0)
+#define    r_reg_feq_data_re_21_16  0xF5D0
+#define reg_feq_data_re_21_16_pos 0
+#define reg_feq_data_re_21_16_len 6
+#define reg_feq_data_re_21_16_lsb 16
+#define xd_r_reg_feq_data_im_7_0    (*(volatile byte xdata *) 0xF5D1)
+#define    r_reg_feq_data_im_7_0    0xF5D1
+#define reg_feq_data_im_7_0_pos 0
+#define reg_feq_data_im_7_0_len 8
+#define reg_feq_data_im_7_0_lsb 0
+#define xd_r_reg_feq_data_im_15_8   (*(volatile byte xdata *) 0xF5D2)
+#define    r_reg_feq_data_im_15_8   0xF5D2
+#define reg_feq_data_im_15_8_pos 0
+#define reg_feq_data_im_15_8_len 8
+#define reg_feq_data_im_15_8_lsb 8
+#define xd_r_reg_feq_data_im_21_16  (*(volatile byte xdata *) 0xF5D3)
+#define    r_reg_feq_data_im_21_16  0xF5D3
+#define reg_feq_data_im_21_16_pos 0
+#define reg_feq_data_im_21_16_len 6
+#define reg_feq_data_im_21_16_lsb 16
+#define xd_r_reg_feq_data_h2_7_0    (*(volatile byte xdata *) 0xF5D4)
+#define    r_reg_feq_data_h2_7_0    0xF5D4
+#define reg_feq_data_h2_7_0_pos 0
+#define reg_feq_data_h2_7_0_len 8
+#define reg_feq_data_h2_7_0_lsb 0
+#define xd_r_reg_feq_data_h2_15_8   (*(volatile byte xdata *) 0xF5D5)
+#define    r_reg_feq_data_h2_15_8   0xF5D5
+#define reg_feq_data_h2_15_8_pos 0
+#define reg_feq_data_h2_15_8_len 8
+#define reg_feq_data_h2_15_8_lsb 8
+#define xd_r_reg_feq_data_h2_18_16  (*(volatile byte xdata *) 0xF5D6)
+#define    r_reg_feq_data_h2_18_16  0xF5D6
+#define reg_feq_data_h2_18_16_pos 0
+#define reg_feq_data_h2_18_16_len 3
+#define reg_feq_data_h2_18_16_lsb 16
+#define xd_p_reg_fs_en  (*(volatile byte xdata *) 0xF5D7)
+#define    p_reg_fs_en  0xF5D7
+#define reg_fs_en_pos 0
+#define reg_fs_en_len 1
+#define reg_fs_en_lsb 0
+#define xd_p_reg_fs_offset  (*(volatile byte xdata *) 0xF5D8)
+#define    p_reg_fs_offset  0xF5D8
+#define reg_fs_offset_pos 0
+#define reg_fs_offset_len 3
+#define reg_fs_offset_lsb 0
+#define xd_p_reg_fs_debug   (*(volatile byte xdata *) 0xF5D9)
+#define    p_reg_fs_debug   0xF5D9
+#define reg_fs_debug_pos 0
+#define reg_fs_debug_len 1
+#define reg_fs_debug_lsb 0
+#define xd_p_reg_fs_half_inv    (*(volatile byte xdata *) 0xF5DA)
+#define    p_reg_fs_half_inv    0xF5DA
+#define reg_fs_half_inv_pos 0
+#define reg_fs_half_inv_len 1
+#define reg_fs_half_inv_lsb 0
+#define xd_p_reg_cdpf_currentfftposition_7_0    (*(volatile byte xdata *) 0xF5DB)
+#define    p_reg_cdpf_currentfftposition_7_0    0xF5DB
+#define reg_cdpf_currentfftposition_7_0_pos 0
+#define reg_cdpf_currentfftposition_7_0_len 8
+#define reg_cdpf_currentfftposition_7_0_lsb 0
+#define xd_p_reg_cdpf_currentfftposition_14_8   (*(volatile byte xdata *) 0xF5DC)
+#define    p_reg_cdpf_currentfftposition_14_8   0xF5DC
+#define reg_cdpf_currentfftposition_14_8_pos 0
+#define reg_cdpf_currentfftposition_14_8_len 7
+#define reg_cdpf_currentfftposition_14_8_lsb 8
+#define xd_r_reg_cdpf_fftshift_7_0  (*(volatile byte xdata *) 0xF5DD)
+#define    r_reg_cdpf_fftshift_7_0  0xF5DD
+#define reg_cdpf_fftshift_7_0_pos 0
+#define reg_cdpf_fftshift_7_0_len 8
+#define reg_cdpf_fftshift_7_0_lsb 0
+#define xd_r_reg_cdpf_fftshift_13_8 (*(volatile byte xdata *) 0xF5DE)
+#define    r_reg_cdpf_fftshift_13_8 0xF5DE
+#define reg_cdpf_fftshift_13_8_pos 0
+#define reg_cdpf_fftshift_13_8_len 6
+#define reg_cdpf_fftshift_13_8_lsb 8
+#define xd_p_reg_cdpf_channelpowerdown_7_0  (*(volatile byte xdata *) 0xF5DF)
+#define    p_reg_cdpf_channelpowerdown_7_0  0xF5DF
+#define reg_cdpf_channelpowerdown_7_0_pos 0
+#define reg_cdpf_channelpowerdown_7_0_len 8
+#define reg_cdpf_channelpowerdown_7_0_lsb 0
+#define xd_p_reg_cdpf_channelpowerdown_10_8 (*(volatile byte xdata *) 0xF5E0)
+#define    p_reg_cdpf_channelpowerdown_10_8 0xF5E0
+#define reg_cdpf_channelpowerdown_10_8_pos 0
+#define reg_cdpf_channelpowerdown_10_8_len 3
+#define reg_cdpf_channelpowerdown_10_8_lsb 8
+#define xd_p_reg_cdpf_state (*(volatile byte xdata *) 0xF5E1)
+#define    p_reg_cdpf_state 0xF5E1
+#define reg_cdpf_state_pos 0
+#define reg_cdpf_state_len 4
+#define reg_cdpf_state_lsb 0
+#define xd_p_reg_cdpf_echotestsearchingrange    (*(volatile byte xdata *) 0xF5E2)
+#define    p_reg_cdpf_echotestsearchingrange    0xF5E2
+#define reg_cdpf_echotestsearchingrange_pos 0
+#define reg_cdpf_echotestsearchingrange_len 8
+#define reg_cdpf_echotestsearchingrange_lsb 0
+#define xd_p_reg_cdpf_rxsymboldelay (*(volatile byte xdata *) 0xF5E3)
+#define    p_reg_cdpf_rxsymboldelay 0xF5E3
+#define reg_cdpf_rxsymboldelay_pos 0
+#define reg_cdpf_rxsymboldelay_len 4
+#define reg_cdpf_rxsymboldelay_lsb 0
+#define xd_p_reg_cdpf_ceavesymbolno (*(volatile byte xdata *) 0xF5E4)
+#define    p_reg_cdpf_ceavesymbolno 0xF5E4
+#define reg_cdpf_ceavesymbolno_pos 0
+#define reg_cdpf_ceavesymbolno_len 4
+#define reg_cdpf_ceavesymbolno_lsb 0
+#define xd_p_reg_cdpf_ceshift   (*(volatile byte xdata *) 0xF5E5)
+#define    p_reg_cdpf_ceshift   0xF5E5
+#define reg_cdpf_ceshift_pos 0
+#define reg_cdpf_ceshift_len 3
+#define reg_cdpf_ceshift_lsb 0
+#define xd_p_reg_cdpf_postpreechotry    (*(volatile byte xdata *) 0xF5E6)
+#define    p_reg_cdpf_postpreechotry    0xF5E6
+#define reg_cdpf_postpreechotry_pos 0
+#define reg_cdpf_postpreechotry_len 2
+#define reg_cdpf_postpreechotry_lsb 0
+#define xd_p_reg_cdpf_en    (*(volatile byte xdata *) 0xF5E7)
+#define    p_reg_cdpf_en    0xF5E7
+#define reg_cdpf_en_pos 0
+#define reg_cdpf_en_len 1
+#define reg_cdpf_en_lsb 0
+#define xd_p_reg_cdpf_stateready    (*(volatile byte xdata *) 0xF5E8)
+#define    p_reg_cdpf_stateready    0xF5E8
+#define reg_cdpf_stateready_pos 0
+#define reg_cdpf_stateready_len 1
+#define reg_cdpf_stateready_lsb 0
+#define xd_r_reg_cdpf_prepostpowercompare   (*(volatile byte xdata *) 0xF5E9)
+#define    r_reg_cdpf_prepostpowercompare   0xF5E9
+#define reg_cdpf_prepostpowercompare_pos 0
+#define reg_cdpf_prepostpowercompare_len 1
+#define reg_cdpf_prepostpowercompare_lsb 0
+#define xd_r_reg_cdpf_candidateno   (*(volatile byte xdata *) 0xF5EA)
+#define    r_reg_cdpf_candidateno   0xF5EA
+#define reg_cdpf_candidateno_pos 0
+#define reg_cdpf_candidateno_len 6
+#define reg_cdpf_candidateno_lsb 0
+#define xd_p_reg_cdpf_preechopower_7_0  (*(volatile byte xdata *) 0xF5EB)
+#define    p_reg_cdpf_preechopower_7_0  0xF5EB
+#define reg_cdpf_preechopower_7_0_pos 0
+#define reg_cdpf_preechopower_7_0_len 8
+#define reg_cdpf_preechopower_7_0_lsb 0
+#define xd_p_reg_cdpf_preechopower_15_8 (*(volatile byte xdata *) 0xF5EC)
+#define    p_reg_cdpf_preechopower_15_8 0xF5EC
+#define reg_cdpf_preechopower_15_8_pos 0
+#define reg_cdpf_preechopower_15_8_len 8
+#define reg_cdpf_preechopower_15_8_lsb 8
+#define xd_p_reg_cdpf_postechopower_7_0 (*(volatile byte xdata *) 0xF5ED)
+#define    p_reg_cdpf_postechopower_7_0 0xF5ED
+#define reg_cdpf_postechopower_7_0_pos 0
+#define reg_cdpf_postechopower_7_0_len 8
+#define reg_cdpf_postechopower_7_0_lsb 0
+#define xd_p_reg_cdpf_postechopower_15_8    (*(volatile byte xdata *) 0xF5EE)
+#define    p_reg_cdpf_postechopower_15_8    0xF5EE
+#define reg_cdpf_postechopower_15_8_pos 0
+#define reg_cdpf_postechopower_15_8_len 8
+#define reg_cdpf_postechopower_15_8_lsb 8
+#define xd_p_reg_cdpf_searchingend  (*(volatile byte xdata *) 0xF5EF)
+#define    p_reg_cdpf_searchingend  0xF5EF
+#define reg_cdpf_searchingend_pos 0
+#define reg_cdpf_searchingend_len 8
+#define reg_cdpf_searchingend_lsb 0
+#define xd_r_reg_cdpf_candidate_7_0 (*(volatile byte xdata *) 0xF5F0)
+#define    r_reg_cdpf_candidate_7_0 0xF5F0
+#define reg_cdpf_candidate_7_0_pos 0
+#define reg_cdpf_candidate_7_0_len 8
+#define reg_cdpf_candidate_7_0_lsb 0
+#define xd_r_reg_cdpf_candidate_15_8    (*(volatile byte xdata *) 0xF5F1)
+#define    r_reg_cdpf_candidate_15_8    0xF5F1
+#define reg_cdpf_candidate_15_8_pos 0
+#define reg_cdpf_candidate_15_8_len 8
+#define reg_cdpf_candidate_15_8_lsb 8
+#define xd_p_reg_cdpf_candidate_rptr    (*(volatile byte xdata *) 0xF5F2)
+#define    p_reg_cdpf_candidate_rptr    0xF5F2
+#define reg_cdpf_candidate_rptr_pos 0
+#define reg_cdpf_candidate_rptr_len 7
+#define reg_cdpf_candidate_rptr_lsb 0
+#define xd_p_reg_cdpf_candidate_rptr_force  (*(volatile byte xdata *) 0xF5F3)
+#define    p_reg_cdpf_candidate_rptr_force  0xF5F3
+#define reg_cdpf_candidate_rptr_force_pos 0
+#define reg_cdpf_candidate_rptr_force_len 1
+#define reg_cdpf_candidate_rptr_force_lsb 0
+#define xd_p_reg_cdpf_trialshiftoffset_7_0  (*(volatile byte xdata *) 0xF5F4)
+#define    p_reg_cdpf_trialshiftoffset_7_0  0xF5F4
+#define reg_cdpf_trialshiftoffset_7_0_pos 0
+#define reg_cdpf_trialshiftoffset_7_0_len 8
+#define reg_cdpf_trialshiftoffset_7_0_lsb 0
+#define xd_p_reg_cdpf_trialshiftoffset_13_8 (*(volatile byte xdata *) 0xF5F5)
+#define    p_reg_cdpf_trialshiftoffset_13_8 0xF5F5
+#define reg_cdpf_trialshiftoffset_13_8_pos 0
+#define reg_cdpf_trialshiftoffset_13_8_len 6
+#define reg_cdpf_trialshiftoffset_13_8_lsb 8
+#define xd_p_reg_cdpf_channellength_7_0 (*(volatile byte xdata *) 0xF5F6)
+#define    p_reg_cdpf_channellength_7_0 0xF5F6
+#define reg_cdpf_channellength_7_0_pos 0
+#define reg_cdpf_channellength_7_0_len 8
+#define reg_cdpf_channellength_7_0_lsb 0
+#define xd_p_reg_cdpf_channellength_12_8    (*(volatile byte xdata *) 0xF5F7)
+#define    p_reg_cdpf_channellength_12_8    0xF5F7
+#define reg_cdpf_channellength_12_8_pos 0
+#define reg_cdpf_channellength_12_8_len 5
+#define reg_cdpf_channellength_12_8_lsb 8
+#define xd_p_reg_cdpf_hardwaresort  (*(volatile byte xdata *) 0xF5F8)
+#define    p_reg_cdpf_hardwaresort  0xF5F8
+#define reg_cdpf_hardwaresort_pos 0
+#define reg_cdpf_hardwaresort_len 1
+#define reg_cdpf_hardwaresort_lsb 0
+#define xd_p_reg_cdpf_maxcandidateno    (*(volatile byte xdata *) 0xF5F9)
+#define    p_reg_cdpf_maxcandidateno    0xF5F9
+#define reg_cdpf_maxcandidateno_pos 0
+#define reg_cdpf_maxcandidateno_len 3
+#define reg_cdpf_maxcandidateno_lsb 0
+#define xd_p_reg_cdpf_channelleftindex  (*(volatile byte xdata *) 0xF5FA)
+#define    p_reg_cdpf_channelleftindex  0xF5FA
+#define reg_cdpf_channelleftindex_pos 0
+#define reg_cdpf_channelleftindex_len 4
+#define reg_cdpf_channelleftindex_lsb 0
+#define xd_r_reg_cdpf_fdishift_7_0  (*(volatile byte xdata *) 0xF5FB)
+#define    r_reg_cdpf_fdishift_7_0  0xF5FB
+#define reg_cdpf_fdishift_7_0_pos 0
+#define reg_cdpf_fdishift_7_0_len 8
+#define reg_cdpf_fdishift_7_0_lsb 0
+#define xd_r_reg_cdpf_fdishift_15_8 (*(volatile byte xdata *) 0xF5FC)
+#define    r_reg_cdpf_fdishift_15_8 0xF5FC
+#define reg_cdpf_fdishift_15_8_pos 0
+#define reg_cdpf_fdishift_15_8_len 8
+#define reg_cdpf_fdishift_15_8_lsb 8
+#define xd_p_reg_cdpf_guardband (*(volatile byte xdata *) 0xF5FD)
+#define    p_reg_cdpf_guardband 0xF5FD
+#define reg_cdpf_guardband_pos 0
+#define reg_cdpf_guardband_len 5
+#define reg_cdpf_guardband_lsb 0
+#define xd_p_reg_cdpf_maxtonemaxindex_7_0   (*(volatile byte xdata *) 0xF5FE)
+#define    p_reg_cdpf_maxtonemaxindex_7_0   0xF5FE
+#define reg_cdpf_maxtonemaxindex_7_0_pos 0
+#define reg_cdpf_maxtonemaxindex_7_0_len 8
+#define reg_cdpf_maxtonemaxindex_7_0_lsb 0
+#define xd_p_reg_cdpf_maxtonemaxindex_12_8  (*(volatile byte xdata *) 0xF5FF)
+#define    p_reg_cdpf_maxtonemaxindex_12_8  0xF5FF
+#define reg_cdpf_maxtonemaxindex_12_8_pos 0
+#define reg_cdpf_maxtonemaxindex_12_8_len 5
+#define reg_cdpf_maxtonemaxindex_12_8_lsb 8
+#define xd_p_reg_cdpf_fdiw0 (*(volatile byte xdata *) 0xF600)
+#define    p_reg_cdpf_fdiw0 0xF600
+#define reg_cdpf_fdiw0_pos 0
+#define reg_cdpf_fdiw0_len 7
+#define reg_cdpf_fdiw0_lsb 0
+#define xd_p_reg_cdpf_fdiw1 (*(volatile byte xdata *) 0xF601)
+#define    p_reg_cdpf_fdiw1 0xF601
+#define reg_cdpf_fdiw1_pos 0
+#define reg_cdpf_fdiw1_len 7
+#define reg_cdpf_fdiw1_lsb 0
+#define xd_p_reg_cdpf_fdiw2 (*(volatile byte xdata *) 0xF602)
+#define    p_reg_cdpf_fdiw2 0xF602
+#define reg_cdpf_fdiw2_pos 0
+#define reg_cdpf_fdiw2_len 7
+#define reg_cdpf_fdiw2_lsb 0
+#define xd_p_reg_cdpf_fdiw3 (*(volatile byte xdata *) 0xF603)
+#define    p_reg_cdpf_fdiw3 0xF603
+#define reg_cdpf_fdiw3_pos 0
+#define reg_cdpf_fdiw3_len 7
+#define reg_cdpf_fdiw3_lsb 0
+#define xd_p_reg_cdpf_fdiw4 (*(volatile byte xdata *) 0xF604)
+#define    p_reg_cdpf_fdiw4 0xF604
+#define reg_cdpf_fdiw4_pos 0
+#define reg_cdpf_fdiw4_len 7
+#define reg_cdpf_fdiw4_lsb 0
+#define xd_p_reg_cdpf_fdiw5 (*(volatile byte xdata *) 0xF605)
+#define    p_reg_cdpf_fdiw5 0xF605
+#define reg_cdpf_fdiw5_pos 0
+#define reg_cdpf_fdiw5_len 7
+#define reg_cdpf_fdiw5_lsb 0
+#define xd_p_reg_cdpf_fdiw6 (*(volatile byte xdata *) 0xF606)
+#define    p_reg_cdpf_fdiw6 0xF606
+#define reg_cdpf_fdiw6_pos 0
+#define reg_cdpf_fdiw6_len 7
+#define reg_cdpf_fdiw6_lsb 0
+#define xd_p_reg_cdpf_fdiw7 (*(volatile byte xdata *) 0xF607)
+#define    p_reg_cdpf_fdiw7 0xF607
+#define reg_cdpf_fdiw7_pos 0
+#define reg_cdpf_fdiw7_len 7
+#define reg_cdpf_fdiw7_lsb 0
+#define xd_r_reg_cdpf_fdiwindowsize (*(volatile byte xdata *) 0xF608)
+#define    r_reg_cdpf_fdiwindowsize 0xF608
+#define reg_cdpf_fdiwindowsize_pos 0
+#define reg_cdpf_fdiwindowsize_len 4
+#define reg_cdpf_fdiwindowsize_lsb 0
+#define xd_p_reg_stes_mode  (*(volatile byte xdata *) 0xF609)
+#define    p_reg_stes_mode  0xF609
+#define reg_stes_mode_pos 0
+#define reg_stes_mode_len 1
+#define reg_stes_mode_lsb 0
+#define xd_p_reg_stes_done_st   (*(volatile byte xdata *) 0xF60A)
+#define    p_reg_stes_done_st   0xF60A
+#define reg_stes_done_st_pos 0
+#define reg_stes_done_st_len 2
+#define reg_stes_done_st_lsb 0
+#define xd_p_reg_stes_done  (*(volatile byte xdata *) 0xF60B)
+#define    p_reg_stes_done  0xF60B
+#define reg_stes_done_pos 0
+#define reg_stes_done_len 1
+#define reg_stes_done_lsb 0
+#define xd_p_reg_stes_timing_7_0    (*(volatile byte xdata *) 0xF60C)
+#define    p_reg_stes_timing_7_0    0xF60C
+#define reg_stes_timing_7_0_pos 0
+#define reg_stes_timing_7_0_len 8
+#define reg_stes_timing_7_0_lsb 0
+#define xd_p_reg_stes_timing_15_8   (*(volatile byte xdata *) 0xF60D)
+#define    p_reg_stes_timing_15_8   0xF60D
+#define reg_stes_timing_15_8_pos 0
+#define reg_stes_timing_15_8_len 8
+#define reg_stes_timing_15_8_lsb 8
+#define xd_p_reg_stes_sym_tot_adj_thre_7_0  (*(volatile byte xdata *) 0xF60E)
+#define    p_reg_stes_sym_tot_adj_thre_7_0  0xF60E
+#define reg_stes_sym_tot_adj_thre_7_0_pos 0
+#define reg_stes_sym_tot_adj_thre_7_0_len 8
+#define reg_stes_sym_tot_adj_thre_7_0_lsb 0
+#define xd_p_reg_stes_sym_tot_adj_thre_15_8 (*(volatile byte xdata *) 0xF60F)
+#define    p_reg_stes_sym_tot_adj_thre_15_8 0xF60F
+#define reg_stes_sym_tot_adj_thre_15_8_pos 0
+#define reg_stes_sym_tot_adj_thre_15_8_len 8
+#define reg_stes_sym_tot_adj_thre_15_8_lsb 8
+#define xd_p_reg_stes_sym_thre_9_2  (*(volatile byte xdata *) 0xF610)
+#define    p_reg_stes_sym_thre_9_2  0xF610
+#define reg_stes_sym_thre_9_2_pos 0
+#define reg_stes_sym_thre_9_2_len 8
+#define reg_stes_sym_thre_9_2_lsb 0
+#define xd_p_reg_stes_sym_wo_adj_thre_9_2   (*(volatile byte xdata *) 0xF611)
+#define    p_reg_stes_sym_wo_adj_thre_9_2   0xF611
+#define reg_stes_sym_wo_adj_thre_9_2_pos 0
+#define reg_stes_sym_wo_adj_thre_9_2_len 8
+#define reg_stes_sym_wo_adj_thre_9_2_lsb 0
+#define xd_p_reg_fste_i_adj_7_0 (*(volatile byte xdata *) 0xF612)
+#define    p_reg_fste_i_adj_7_0 0xF612
+#define reg_fste_i_adj_7_0_pos 0
+#define reg_fste_i_adj_7_0_len 8
+#define reg_fste_i_adj_7_0_lsb 0
+#define xd_p_reg_fste_i_adj_15_8    (*(volatile byte xdata *) 0xF613)
+#define    p_reg_fste_i_adj_15_8    0xF613
+#define reg_fste_i_adj_15_8_pos 0
+#define reg_fste_i_adj_15_8_len 8
+#define reg_fste_i_adj_15_8_lsb 8
+#define xd_r_fd_stes_iadj_val_7_0   (*(volatile byte xdata *) 0xF614)
+#define    r_fd_stes_iadj_val_7_0   0xF614
+#define fd_stes_iadj_val_7_0_pos 0
+#define fd_stes_iadj_val_7_0_len 8
+#define fd_stes_iadj_val_7_0_lsb 0
+#define xd_r_fd_stes_iadj_val_15_8  (*(volatile byte xdata *) 0xF615)
+#define    r_fd_stes_iadj_val_15_8  0xF615
+#define fd_stes_iadj_val_15_8_pos 0
+#define fd_stes_iadj_val_15_8_len 8
+#define fd_stes_iadj_val_15_8_lsb 8
+#define xd_r_fd_stes_symb_cnt_9_2   (*(volatile byte xdata *) 0xF616)
+#define    r_fd_stes_symb_cnt_9_2   0xF616
+#define fd_stes_symb_cnt_9_2_pos 0
+#define fd_stes_symb_cnt_9_2_len 8
+#define fd_stes_symb_cnt_9_2_lsb 0
+#define xd_r_fd_stes_snoi_cnt_9_2   (*(volatile byte xdata *) 0xF617)
+#define    r_fd_stes_snoi_cnt_9_2   0xF617
+#define fd_stes_snoi_cnt_9_2_pos 0
+#define fd_stes_snoi_cnt_9_2_len 8
+#define fd_stes_snoi_cnt_9_2_lsb 0
+#define xd_r_fd_last_iadj_val_7_0   (*(volatile byte xdata *) 0xF618)
+#define    r_fd_last_iadj_val_7_0   0xF618
+#define fd_last_iadj_val_7_0_pos 0
+#define fd_last_iadj_val_7_0_len 8
+#define fd_last_iadj_val_7_0_lsb 0
+#define xd_r_fd_last_iadj_val_15_8  (*(volatile byte xdata *) 0xF619)
+#define    r_fd_last_iadj_val_15_8  0xF619
+#define fd_last_iadj_val_15_8_pos 0
+#define fd_last_iadj_val_15_8_len 8
+#define fd_last_iadj_val_15_8_lsb 8
+#define xd_p_reg_stes_bypass    (*(volatile byte xdata *) 0xF61A)
+#define    p_reg_stes_bypass    0xF61A
+#define reg_stes_bypass_pos 0
+#define reg_stes_bypass_len 1
+#define reg_stes_bypass_lsb 0
+#define xd_p_reg_stes_best_timing_idx   (*(volatile byte xdata *) 0xF61B)
+#define    p_reg_stes_best_timing_idx   0xF61B
+#define reg_stes_best_timing_idx_pos 0
+#define reg_stes_best_timing_idx_len 4
+#define reg_stes_best_timing_idx_lsb 0
+#define xd_p_reg_stes_iadj_val_7_0  (*(volatile byte xdata *) 0xF61C)
+#define    p_reg_stes_iadj_val_7_0  0xF61C
+#define reg_stes_iadj_val_7_0_pos 0
+#define reg_stes_iadj_val_7_0_len 8
+#define reg_stes_iadj_val_7_0_lsb 0
+#define xd_p_reg_stes_iadj_val_15_8 (*(volatile byte xdata *) 0xF61D)
+#define    p_reg_stes_iadj_val_15_8 0xF61D
+#define reg_stes_iadj_val_15_8_pos 0
+#define reg_stes_iadj_val_15_8_len 8
+#define reg_stes_iadj_val_15_8_lsb 8
+#define xd_p_reg_p_ste_start_guard_7_0  (*(volatile byte xdata *) 0xF620)
+#define    p_reg_p_ste_start_guard_7_0  0xF620
+#define reg_p_ste_start_guard_7_0_pos 0
+#define reg_p_ste_start_guard_7_0_len 8
+#define reg_p_ste_start_guard_7_0_lsb 0
+#define xd_p_reg_p_ste_start_guard_9_8  (*(volatile byte xdata *) 0xF621)
+#define    p_reg_p_ste_start_guard_9_8  0xF621
+#define reg_p_ste_start_guard_9_8_pos 0
+#define reg_p_ste_start_guard_9_8_len 2
+#define reg_p_ste_start_guard_9_8_lsb 8
+#define xd_p_reg_p_ste_end_guard_7_0    (*(volatile byte xdata *) 0xF622)
+#define    p_reg_p_ste_end_guard_7_0    0xF622
+#define reg_p_ste_end_guard_7_0_pos 0
+#define reg_p_ste_end_guard_7_0_len 8
+#define reg_p_ste_end_guard_7_0_lsb 0
+#define xd_p_reg_p_ste_end_guard_9_8    (*(volatile byte xdata *) 0xF623)
+#define    p_reg_p_ste_end_guard_9_8    0xF623
+#define reg_p_ste_end_guard_9_8_pos 0
+#define reg_p_ste_end_guard_9_8_len 2
+#define reg_p_ste_end_guard_9_8_lsb 8
+#define xd_r_reg_r_ste_wrong_beacon_count   (*(volatile byte xdata *) 0xF624)
+#define    r_reg_r_ste_wrong_beacon_count   0xF624
+#define reg_r_ste_wrong_beacon_count_pos 0
+#define reg_r_ste_wrong_beacon_count_len 7
+#define reg_r_ste_wrong_beacon_count_lsb 0
+#define xd_p_reg_p_fccid_en (*(volatile byte xdata *) 0xF625)
+#define    p_reg_p_fccid_en 0xF625
+#define reg_p_fccid_en_pos 0
+#define reg_p_fccid_en_len 1
+#define reg_p_fccid_en_lsb 0
+#define xd_p_reg_p_fccid_fft_ave_symbol_num (*(volatile byte xdata *) 0xF626)
+#define    p_reg_p_fccid_fft_ave_symbol_num 0xF626
+#define reg_p_fccid_fft_ave_symbol_num_pos 0
+#define reg_p_fccid_fft_ave_symbol_num_len 6
+#define reg_p_fccid_fft_ave_symbol_num_lsb 0
+#define xd_p_reg_p_fccid_fft_work_start_tone_7_0    (*(volatile byte xdata *) 0xF627)
+#define    p_reg_p_fccid_fft_work_start_tone_7_0    0xF627
+#define reg_p_fccid_fft_work_start_tone_7_0_pos 0
+#define reg_p_fccid_fft_work_start_tone_7_0_len 8
+#define reg_p_fccid_fft_work_start_tone_7_0_lsb 0
+#define xd_p_reg_p_fccid_fft_work_start_tone_12_8   (*(volatile byte xdata *) 0xF628)
+#define    p_reg_p_fccid_fft_work_start_tone_12_8   0xF628
+#define reg_p_fccid_fft_work_start_tone_12_8_pos 0
+#define reg_p_fccid_fft_work_start_tone_12_8_len 5
+#define reg_p_fccid_fft_work_start_tone_12_8_lsb 8
+#define xd_p_reg_p_fccid_fft_work_end_tone_7_0  (*(volatile byte xdata *) 0xF629)
+#define    p_reg_p_fccid_fft_work_end_tone_7_0  0xF629
+#define reg_p_fccid_fft_work_end_tone_7_0_pos 0
+#define reg_p_fccid_fft_work_end_tone_7_0_len 8
+#define reg_p_fccid_fft_work_end_tone_7_0_lsb 0
+#define xd_p_reg_p_fccid_fft_work_end_tone_12_8 (*(volatile byte xdata *) 0xF62A)
+#define    p_reg_p_fccid_fft_work_end_tone_12_8 0xF62A
+#define reg_p_fccid_fft_work_end_tone_12_8_pos 0
+#define reg_p_fccid_fft_work_end_tone_12_8_len 5
+#define reg_p_fccid_fft_work_end_tone_12_8_lsb 8
+#define xd_p_reg_p_fccid_peak_to_th_divider (*(volatile byte xdata *) 0xF62B)
+#define    p_reg_p_fccid_peak_to_th_divider 0xF62B
+#define reg_p_fccid_peak_to_th_divider_pos 0
+#define reg_p_fccid_peak_to_th_divider_len 4
+#define reg_p_fccid_peak_to_th_divider_lsb 0
+#define xd_p_reg_p_fccid_peak_to_th_mode    (*(volatile byte xdata *) 0xF62C)
+#define    p_reg_p_fccid_peak_to_th_mode    0xF62C
+#define reg_p_fccid_peak_to_th_mode_pos 0
+#define reg_p_fccid_peak_to_th_mode_len 2
+#define reg_p_fccid_peak_to_th_mode_lsb 0
+#define xd_p_reg_p_fccid_search_mode    (*(volatile byte xdata *) 0xF62D)
+#define    p_reg_p_fccid_search_mode    0xF62D
+#define reg_p_fccid_search_mode_pos 0
+#define reg_p_fccid_search_mode_len 1
+#define reg_p_fccid_search_mode_lsb 0
+#define xd_p_reg_p_fccid_group_th   (*(volatile byte xdata *) 0xF62E)
+#define    p_reg_p_fccid_group_th   0xF62E
+#define reg_p_fccid_group_th_pos 0
+#define reg_p_fccid_group_th_len 7
+#define reg_p_fccid_group_th_lsb 0
+#define xd_p_reg_p_fccid_search_rdy (*(volatile byte xdata *) 0xF62F)
+#define    p_reg_p_fccid_search_rdy 0xF62F
+#define reg_p_fccid_search_rdy_pos 0
+#define reg_p_fccid_search_rdy_len 1
+#define reg_p_fccid_search_rdy_lsb 0
+#define xd_r_reg_r_fccid_fft_ave_read_out_7_0   (*(volatile byte xdata *) 0xF630)
+#define    r_reg_r_fccid_fft_ave_read_out_7_0   0xF630
+#define reg_r_fccid_fft_ave_read_out_7_0_pos 0
+#define reg_r_fccid_fft_ave_read_out_7_0_len 8
+#define reg_r_fccid_fft_ave_read_out_7_0_lsb 0
+#define xd_r_reg_r_fccid_fft_ave_read_out_15_8  (*(volatile byte xdata *) 0xF631)
+#define    r_reg_r_fccid_fft_ave_read_out_15_8  0xF631
+#define reg_r_fccid_fft_ave_read_out_15_8_pos 0
+#define reg_r_fccid_fft_ave_read_out_15_8_len 8
+#define reg_r_fccid_fft_ave_read_out_15_8_lsb 8
+#define xd_r_reg_r_fccid_large_tone_num_7_0 (*(volatile byte xdata *) 0xF632)
+#define    r_reg_r_fccid_large_tone_num_7_0 0xF632
+#define reg_r_fccid_large_tone_num_7_0_pos 0
+#define reg_r_fccid_large_tone_num_7_0_len 8
+#define reg_r_fccid_large_tone_num_7_0_lsb 0
+#define xd_r_reg_r_fccid_large_tone_num_12_8    (*(volatile byte xdata *) 0xF633)
+#define    r_reg_r_fccid_large_tone_num_12_8    0xF633
+#define reg_r_fccid_large_tone_num_12_8_pos 0
+#define reg_r_fccid_large_tone_num_12_8_len 5
+#define reg_r_fccid_large_tone_num_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci1_start_tone_7_0    (*(volatile byte xdata *) 0xF634)
+#define    r_reg_r_fccid_cci1_start_tone_7_0    0xF634
+#define reg_r_fccid_cci1_start_tone_7_0_pos 0
+#define reg_r_fccid_cci1_start_tone_7_0_len 8
+#define reg_r_fccid_cci1_start_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci1_start_tone_12_8   (*(volatile byte xdata *) 0xF635)
+#define    r_reg_r_fccid_cci1_start_tone_12_8   0xF635
+#define reg_r_fccid_cci1_start_tone_12_8_pos 0
+#define reg_r_fccid_cci1_start_tone_12_8_len 5
+#define reg_r_fccid_cci1_start_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci1_end_tone_7_0  (*(volatile byte xdata *) 0xF636)
+#define    r_reg_r_fccid_cci1_end_tone_7_0  0xF636
+#define reg_r_fccid_cci1_end_tone_7_0_pos 0
+#define reg_r_fccid_cci1_end_tone_7_0_len 8
+#define reg_r_fccid_cci1_end_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci1_end_tone_12_8 (*(volatile byte xdata *) 0xF637)
+#define    r_reg_r_fccid_cci1_end_tone_12_8 0xF637
+#define reg_r_fccid_cci1_end_tone_12_8_pos 0
+#define reg_r_fccid_cci1_end_tone_12_8_len 5
+#define reg_r_fccid_cci1_end_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci1_peak_7_0  (*(volatile byte xdata *) 0xF638)
+#define    r_reg_r_fccid_cci1_peak_7_0  0xF638
+#define reg_r_fccid_cci1_peak_7_0_pos 0
+#define reg_r_fccid_cci1_peak_7_0_len 8
+#define reg_r_fccid_cci1_peak_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci1_peak_15_8 (*(volatile byte xdata *) 0xF639)
+#define    r_reg_r_fccid_cci1_peak_15_8 0xF639
+#define reg_r_fccid_cci1_peak_15_8_pos 0
+#define reg_r_fccid_cci1_peak_15_8_len 8
+#define reg_r_fccid_cci1_peak_15_8_lsb 8
+#define xd_r_reg_r_fccid_cci2_start_tone_7_0    (*(volatile byte xdata *) 0xF63A)
+#define    r_reg_r_fccid_cci2_start_tone_7_0    0xF63A
+#define reg_r_fccid_cci2_start_tone_7_0_pos 0
+#define reg_r_fccid_cci2_start_tone_7_0_len 8
+#define reg_r_fccid_cci2_start_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci2_start_tone_12_8   (*(volatile byte xdata *) 0xF63B)
+#define    r_reg_r_fccid_cci2_start_tone_12_8   0xF63B
+#define reg_r_fccid_cci2_start_tone_12_8_pos 0
+#define reg_r_fccid_cci2_start_tone_12_8_len 5
+#define reg_r_fccid_cci2_start_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci2_end_tone_7_0  (*(volatile byte xdata *) 0xF63C)
+#define    r_reg_r_fccid_cci2_end_tone_7_0  0xF63C
+#define reg_r_fccid_cci2_end_tone_7_0_pos 0
+#define reg_r_fccid_cci2_end_tone_7_0_len 8
+#define reg_r_fccid_cci2_end_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci2_end_tone_12_8 (*(volatile byte xdata *) 0xF63D)
+#define    r_reg_r_fccid_cci2_end_tone_12_8 0xF63D
+#define reg_r_fccid_cci2_end_tone_12_8_pos 0
+#define reg_r_fccid_cci2_end_tone_12_8_len 5
+#define reg_r_fccid_cci2_end_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci2_peak_7_0  (*(volatile byte xdata *) 0xF63E)
+#define    r_reg_r_fccid_cci2_peak_7_0  0xF63E
+#define reg_r_fccid_cci2_peak_7_0_pos 0
+#define reg_r_fccid_cci2_peak_7_0_len 8
+#define reg_r_fccid_cci2_peak_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci2_peak_15_8 (*(volatile byte xdata *) 0xF63F)
+#define    r_reg_r_fccid_cci2_peak_15_8 0xF63F
+#define reg_r_fccid_cci2_peak_15_8_pos 0
+#define reg_r_fccid_cci2_peak_15_8_len 8
+#define reg_r_fccid_cci2_peak_15_8_lsb 8
+#define xd_r_reg_r_fccid_cci3_start_tone_7_0    (*(volatile byte xdata *) 0xF640)
+#define    r_reg_r_fccid_cci3_start_tone_7_0    0xF640
+#define reg_r_fccid_cci3_start_tone_7_0_pos 0
+#define reg_r_fccid_cci3_start_tone_7_0_len 8
+#define reg_r_fccid_cci3_start_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci3_start_tone_12_8   (*(volatile byte xdata *) 0xF641)
+#define    r_reg_r_fccid_cci3_start_tone_12_8   0xF641
+#define reg_r_fccid_cci3_start_tone_12_8_pos 0
+#define reg_r_fccid_cci3_start_tone_12_8_len 5
+#define reg_r_fccid_cci3_start_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci3_end_tone_7_0  (*(volatile byte xdata *) 0xF642)
+#define    r_reg_r_fccid_cci3_end_tone_7_0  0xF642
+#define reg_r_fccid_cci3_end_tone_7_0_pos 0
+#define reg_r_fccid_cci3_end_tone_7_0_len 8
+#define reg_r_fccid_cci3_end_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci3_end_tone_12_8 (*(volatile byte xdata *) 0xF643)
+#define    r_reg_r_fccid_cci3_end_tone_12_8 0xF643
+#define reg_r_fccid_cci3_end_tone_12_8_pos 0
+#define reg_r_fccid_cci3_end_tone_12_8_len 5
+#define reg_r_fccid_cci3_end_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci3_peak_7_0  (*(volatile byte xdata *) 0xF644)
+#define    r_reg_r_fccid_cci3_peak_7_0  0xF644
+#define reg_r_fccid_cci3_peak_7_0_pos 0
+#define reg_r_fccid_cci3_peak_7_0_len 8
+#define reg_r_fccid_cci3_peak_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci3_peak_15_8 (*(volatile byte xdata *) 0xF645)
+#define    r_reg_r_fccid_cci3_peak_15_8 0xF645
+#define reg_r_fccid_cci3_peak_15_8_pos 0
+#define reg_r_fccid_cci3_peak_15_8_len 8
+#define reg_r_fccid_cci3_peak_15_8_lsb 8
+#define xd_r_reg_r_fccid_cci4_start_tone_7_0    (*(volatile byte xdata *) 0xF646)
+#define    r_reg_r_fccid_cci4_start_tone_7_0    0xF646
+#define reg_r_fccid_cci4_start_tone_7_0_pos 0
+#define reg_r_fccid_cci4_start_tone_7_0_len 8
+#define reg_r_fccid_cci4_start_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci4_start_tone_12_8   (*(volatile byte xdata *) 0xF647)
+#define    r_reg_r_fccid_cci4_start_tone_12_8   0xF647
+#define reg_r_fccid_cci4_start_tone_12_8_pos 0
+#define reg_r_fccid_cci4_start_tone_12_8_len 5
+#define reg_r_fccid_cci4_start_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci4_end_tone_7_0  (*(volatile byte xdata *) 0xF648)
+#define    r_reg_r_fccid_cci4_end_tone_7_0  0xF648
+#define reg_r_fccid_cci4_end_tone_7_0_pos 0
+#define reg_r_fccid_cci4_end_tone_7_0_len 8
+#define reg_r_fccid_cci4_end_tone_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci4_end_tone_12_8 (*(volatile byte xdata *) 0xF649)
+#define    r_reg_r_fccid_cci4_end_tone_12_8 0xF649
+#define reg_r_fccid_cci4_end_tone_12_8_pos 0
+#define reg_r_fccid_cci4_end_tone_12_8_len 5
+#define reg_r_fccid_cci4_end_tone_12_8_lsb 8
+#define xd_r_reg_r_fccid_cci4_peak_7_0  (*(volatile byte xdata *) 0xF64A)
+#define    r_reg_r_fccid_cci4_peak_7_0  0xF64A
+#define reg_r_fccid_cci4_peak_7_0_pos 0
+#define reg_r_fccid_cci4_peak_7_0_len 8
+#define reg_r_fccid_cci4_peak_7_0_lsb 0
+#define xd_r_reg_r_fccid_cci4_peak_15_8 (*(volatile byte xdata *) 0xF64B)
+#define    r_reg_r_fccid_cci4_peak_15_8 0xF64B
+#define reg_r_fccid_cci4_peak_15_8_pos 0
+#define reg_r_fccid_cci4_peak_15_8_len 8
+#define reg_r_fccid_cci4_peak_15_8_lsb 8
+#define xd_r_reg_r_fccid_cci1_rank  (*(volatile byte xdata *) 0xF64C)
+#define    r_reg_r_fccid_cci1_rank  0xF64C
+#define reg_r_fccid_cci1_rank_pos 0
+#define reg_r_fccid_cci1_rank_len 3
+#define reg_r_fccid_cci1_rank_lsb 0
+#define xd_r_reg_r_fccid_cci2_rank  (*(volatile byte xdata *) 0xF64D)
+#define    r_reg_r_fccid_cci2_rank  0xF64D
+#define reg_r_fccid_cci2_rank_pos 0
+#define reg_r_fccid_cci2_rank_len 3
+#define reg_r_fccid_cci2_rank_lsb 0
+#define xd_r_reg_r_fccid_cci3_rank  (*(volatile byte xdata *) 0xF64E)
+#define    r_reg_r_fccid_cci3_rank  0xF64E
+#define reg_r_fccid_cci3_rank_pos 0
+#define reg_r_fccid_cci3_rank_len 3
+#define reg_r_fccid_cci3_rank_lsb 0
+#define xd_r_reg_r_fccid_cci4_rank  (*(volatile byte xdata *) 0xF64F)
+#define    r_reg_r_fccid_cci4_rank  0xF64F
+#define reg_r_fccid_cci4_rank_pos 0
+#define reg_r_fccid_cci4_rank_len 3
+#define reg_r_fccid_cci4_rank_lsb 0
+#define xd_p_reg_p_csi_shift3   (*(volatile byte xdata *) 0xF650)
+#define    p_reg_p_csi_shift3   0xF650
+#define reg_p_csi_shift3_pos 0
+#define reg_p_csi_shift3_len 4
+#define reg_p_csi_shift3_lsb 0
+#define xd_p_reg_p_csi_mul3 (*(volatile byte xdata *) 0xF651)
+#define    p_reg_p_csi_mul3 0xF651
+#define reg_p_csi_mul3_pos 0
+#define reg_p_csi_mul3_len 8
+#define reg_p_csi_mul3_lsb 0
+#define xd_p_reg_p_csi_level3_7_0   (*(volatile byte xdata *) 0xF652)
+#define    p_reg_p_csi_level3_7_0   0xF652
+#define reg_p_csi_level3_7_0_pos 0
+#define reg_p_csi_level3_7_0_len 8
+#define reg_p_csi_level3_7_0_lsb 0
+#define xd_p_reg_p_csi_level3_8 (*(volatile byte xdata *) 0xF653)
+#define    p_reg_p_csi_level3_8 0xF653
+#define reg_p_csi_level3_8_pos 0
+#define reg_p_csi_level3_8_len 1
+#define reg_p_csi_level3_8_lsb 8
+#define xd_p_reg_p_csi_fftout_shift_fix_value   (*(volatile byte xdata *) 0xF654)
+#define    p_reg_p_csi_fftout_shift_fix_value   0xF654
+#define reg_p_csi_fftout_shift_fix_value_pos 0
+#define reg_p_csi_fftout_shift_fix_value_len 4
+#define reg_p_csi_fftout_shift_fix_value_lsb 0
+#define xd_p_reg_p_feq_scale_pow    (*(volatile byte xdata *) 0xF655)
+#define    p_reg_p_feq_scale_pow    0xF655
+#define reg_p_feq_scale_pow_pos 0
+#define reg_p_feq_scale_pow_len 6
+#define reg_p_feq_scale_pow_lsb 0
+#define xd_p_reg_p_csi_cp_idx   (*(volatile byte xdata *) 0xF656)
+#define    p_reg_p_csi_cp_idx   0xF656
+#define reg_p_csi_cp_idx_pos 0
+#define reg_p_csi_cp_idx_len 8
+#define reg_p_csi_cp_idx_lsb 0
+#define xd_p_reg_p_csi_outsh_zero_th_7_0    (*(volatile byte xdata *) 0xF657)
+#define    p_reg_p_csi_outsh_zero_th_7_0    0xF657
+#define reg_p_csi_outsh_zero_th_7_0_pos 0
+#define reg_p_csi_outsh_zero_th_7_0_len 8
+#define reg_p_csi_outsh_zero_th_7_0_lsb 0
+#define xd_p_reg_p_csi_outsh_zero_th_10_8   (*(volatile byte xdata *) 0xF658)
+#define    p_reg_p_csi_outsh_zero_th_10_8   0xF658
+#define reg_p_csi_outsh_zero_th_10_8_pos 0
+#define reg_p_csi_outsh_zero_th_10_8_len 3
+#define reg_p_csi_outsh_zero_th_10_8_lsb 8
+#define xd_p_reg_p_csi_ar_ratio (*(volatile byte xdata *) 0xF659)
+#define    p_reg_p_csi_ar_ratio 0xF659
+#define reg_p_csi_ar_ratio_pos 0
+#define reg_p_csi_ar_ratio_len 8
+#define reg_p_csi_ar_ratio_lsb 0
+#define xd_p_reg_r_csi_cp_vld   (*(volatile byte xdata *) 0xF65A)
+#define    p_reg_r_csi_cp_vld   0xF65A
+#define reg_r_csi_cp_vld_pos 0
+#define reg_r_csi_cp_vld_len 1
+#define reg_r_csi_cp_vld_lsb 0
+#define xd_p_reg_r_csi_sp_vld   (*(volatile byte xdata *) 0xF65B)
+#define    p_reg_r_csi_sp_vld   0xF65B
+#define reg_r_csi_sp_vld_pos 0
+#define reg_r_csi_sp_vld_len 1
+#define reg_r_csi_sp_vld_lsb 0
+#define xd_p_reg_p_csi_fft_out_shift_en (*(volatile byte xdata *) 0xF65C)
+#define    p_reg_p_csi_fft_out_shift_en 0xF65C
+#define reg_p_csi_fft_out_shift_en_pos 0
+#define reg_p_csi_fft_out_shift_en_len 1
+#define reg_p_csi_fft_out_shift_en_lsb 0
+#define xd_p_reg_p_csi_feq_out_shift_en (*(volatile byte xdata *) 0xF65D)
+#define    p_reg_p_csi_feq_out_shift_en 0xF65D
+#define reg_p_csi_feq_out_shift_en_pos 0
+#define reg_p_csi_feq_out_shift_en_len 1
+#define reg_p_csi_feq_out_shift_en_lsb 0
+#define xd_p_reg_r_csi_cp_fft_out   (*(volatile byte xdata *) 0xF65E)
+#define    p_reg_r_csi_cp_fft_out   0xF65E
+#define reg_r_csi_cp_fft_out_pos 0
+#define reg_r_csi_cp_fft_out_len 1
+#define reg_r_csi_cp_fft_out_lsb 0
+#define xd_p_reg_r_csi_sp_feq_log2_out  (*(volatile byte xdata *) 0xF65F)
+#define    p_reg_r_csi_sp_feq_log2_out  0xF65F
+#define reg_r_csi_sp_feq_log2_out_pos 0
+#define reg_r_csi_sp_feq_log2_out_len 8
+#define reg_r_csi_sp_feq_log2_out_lsb 0
+#define xd_p_reg_r_csi_sp_fft_out   (*(volatile byte xdata *) 0xF660)
+#define    p_reg_r_csi_sp_fft_out   0xF660
+#define reg_r_csi_sp_fft_out_pos 0
+#define reg_r_csi_sp_fft_out_len 1
+#define reg_r_csi_sp_fft_out_lsb 0
+#define xd_p_reg_p_feq_eh2_from_fpcc_en (*(volatile byte xdata *) 0xF661)
+#define    p_reg_p_feq_eh2_from_fpcc_en 0xF661
+#define reg_p_feq_eh2_from_fpcc_en_pos 0
+#define reg_p_feq_eh2_from_fpcc_en_len 1
+#define reg_p_feq_eh2_from_fpcc_en_lsb 0
+#define xd_r_reg_r_fccid_fft_ave_peak_7_0   (*(volatile byte xdata *) 0xF662)
+#define    r_reg_r_fccid_fft_ave_peak_7_0   0xF662
+#define reg_r_fccid_fft_ave_peak_7_0_pos 0
+#define reg_r_fccid_fft_ave_peak_7_0_len 8
+#define reg_r_fccid_fft_ave_peak_7_0_lsb 0
+#define xd_r_reg_r_fccid_fft_ave_peak_15_8  (*(volatile byte xdata *) 0xF663)
+#define    r_reg_r_fccid_fft_ave_peak_15_8  0xF663
+#define reg_r_fccid_fft_ave_peak_15_8_pos 0
+#define reg_r_fccid_fft_ave_peak_15_8_len 8
+#define reg_r_fccid_fft_ave_peak_15_8_lsb 8
+#define xd_r_reg_r_fccid_fft_ave_peak_23_16 (*(volatile byte xdata *) 0xF664)
+#define    r_reg_r_fccid_fft_ave_peak_23_16 0xF664
+#define reg_r_fccid_fft_ave_peak_23_16_pos 0
+#define reg_r_fccid_fft_ave_peak_23_16_len 8
+#define reg_r_fccid_fft_ave_peak_23_16_lsb 16
+#define xd_r_reg_r_fccid_fft_ave_peak_26_24 (*(volatile byte xdata *) 0xF665)
+#define    r_reg_r_fccid_fft_ave_peak_26_24 0xF665
+#define reg_r_fccid_fft_ave_peak_26_24_pos 0
+#define reg_r_fccid_fft_ave_peak_26_24_len 3
+#define reg_r_fccid_fft_ave_peak_26_24_lsb 24
+#define xd_p_reg_p_fccid_fft_ave_read_rdy   (*(volatile byte xdata *) 0xF666)
+#define    p_reg_p_fccid_fft_ave_read_rdy   0xF666
+#define reg_p_fccid_fft_ave_read_rdy_pos 0
+#define reg_p_fccid_fft_ave_read_rdy_len 1
+#define reg_p_fccid_fft_ave_read_rdy_lsb 0
+#define xd_p_reg_p_fccid_fft_ave_read_index_7_0 (*(volatile byte xdata *) 0xF667)
+#define    p_reg_p_fccid_fft_ave_read_index_7_0 0xF667
+#define reg_p_fccid_fft_ave_read_index_7_0_pos 0
+#define reg_p_fccid_fft_ave_read_index_7_0_len 8
+#define reg_p_fccid_fft_ave_read_index_7_0_lsb 0
+#define xd_p_reg_p_fccid_fft_ave_read_index_12_8    (*(volatile byte xdata *) 0xF668)
+#define    p_reg_p_fccid_fft_ave_read_index_12_8    0xF668
+#define reg_p_fccid_fft_ave_read_index_12_8_pos 0
+#define reg_p_fccid_fft_ave_read_index_12_8_len 5
+#define reg_p_fccid_fft_ave_read_index_12_8_lsb 8
+#define xd_p_reg_cdpf_candidate_rw  (*(volatile byte xdata *) 0xF669)
+#define    p_reg_cdpf_candidate_rw  0xF669
+#define reg_cdpf_candidate_rw_pos 0
+#define reg_cdpf_candidate_rw_len 1
+#define reg_cdpf_candidate_rw_lsb 0
+#define xd_p_reg_cdpf_candidate_prog_7_0    (*(volatile byte xdata *) 0xF66A)
+#define    p_reg_cdpf_candidate_prog_7_0    0xF66A
+#define reg_cdpf_candidate_prog_7_0_pos 0
+#define reg_cdpf_candidate_prog_7_0_len 8
+#define reg_cdpf_candidate_prog_7_0_lsb 0
+#define xd_p_reg_cdpf_candidate_prog_15_8   (*(volatile byte xdata *) 0xF66B)
+#define    p_reg_cdpf_candidate_prog_15_8   0xF66B
+#define reg_cdpf_candidate_prog_15_8_pos 0
+#define reg_cdpf_candidate_prog_15_8_len 8
+#define reg_cdpf_candidate_prog_15_8_lsb 8
+#define xd_p_reg_cdpf_candidateno_prog  (*(volatile byte xdata *) 0xF66C)
+#define    p_reg_cdpf_candidateno_prog  0xF66C
+#define reg_cdpf_candidateno_prog_pos 0
+#define reg_cdpf_candidateno_prog_len 6
+#define reg_cdpf_candidateno_prog_lsb 0
+#define xd_p_reg_cdpf_candidateno_switch    (*(volatile byte xdata *) 0xF66D)
+#define    p_reg_cdpf_candidateno_switch    0xF66D
+#define reg_cdpf_candidateno_switch_pos 0
+#define reg_cdpf_candidateno_switch_len 1
+#define reg_cdpf_candidateno_switch_lsb 0
+#define xd_g_reg_tpsd_txmod (*(volatile byte xdata *) 0xF900)
+#define    g_reg_tpsd_txmod 0xF900
+#define reg_tpsd_txmod_pos 0
+#define reg_tpsd_txmod_len 2
+#define reg_tpsd_txmod_lsb 0
+#define xd_g_reg_tpsd_gi    (*(volatile byte xdata *) 0xF901)
+#define    g_reg_tpsd_gi    0xF901
+#define reg_tpsd_gi_pos 0
+#define reg_tpsd_gi_len 2
+#define reg_tpsd_gi_lsb 0
+#define xd_g_reg_tpsd_hier  (*(volatile byte xdata *) 0xF902)
+#define    g_reg_tpsd_hier  0xF902
+#define reg_tpsd_hier_pos 0
+#define reg_tpsd_hier_len 3
+#define reg_tpsd_hier_lsb 0
+#define xd_g_reg_tpsd_const (*(volatile byte xdata *) 0xF903)
+#define    g_reg_tpsd_const 0xF903
+#define reg_tpsd_const_pos 0
+#define reg_tpsd_const_len 2
+#define reg_tpsd_const_lsb 0
+#define xd_g_reg_bw (*(volatile byte xdata *) 0xF904)
+#define    g_reg_bw 0xF904
+#define reg_bw_pos 0
+#define reg_bw_len 2
+#define reg_bw_lsb 0
+#define xd_g_reg_dec_pri    (*(volatile byte xdata *) 0xF905)
+#define    g_reg_dec_pri    0xF905
+#define reg_dec_pri_pos 0
+#define reg_dec_pri_len 1
+#define reg_dec_pri_lsb 0
+#define xd_g_reg_tpsd_hpcr  (*(volatile byte xdata *) 0xF906)
+#define    g_reg_tpsd_hpcr  0xF906
+#define reg_tpsd_hpcr_pos 0
+#define reg_tpsd_hpcr_len 3
+#define reg_tpsd_hpcr_lsb 0
+#define xd_g_reg_tpsd_lpcr  (*(volatile byte xdata *) 0xF907)
+#define    g_reg_tpsd_lpcr  0xF907
+#define reg_tpsd_lpcr_pos 0
+#define reg_tpsd_lpcr_len 3
+#define reg_tpsd_lpcr_lsb 0
+#define xd_g_reg_tpsd_indep (*(volatile byte xdata *) 0xF908)
+#define    g_reg_tpsd_indep 0xF908
+#define reg_tpsd_indep_pos 0
+#define reg_tpsd_indep_len 1
+#define reg_tpsd_indep_lsb 0
+#define xd_g_reg_tpsd_tslice    (*(volatile byte xdata *) 0xF909)
+#define    g_reg_tpsd_tslice    0xF909
+#define reg_tpsd_tslice_pos 0
+#define reg_tpsd_tslice_len 1
+#define reg_tpsd_tslice_lsb 0
+#define xd_g_reg_tpsd_mpefec    (*(volatile byte xdata *) 0xF90A)
+#define    g_reg_tpsd_mpefec    0xF90A
+#define reg_tpsd_mpefec_pos 0
+#define reg_tpsd_mpefec_len 1
+#define reg_tpsd_mpefec_lsb 0
+#define xd_g_reg_sntc_en    (*(volatile byte xdata *) 0xF90B)
+#define    g_reg_sntc_en    0xF90B
+#define reg_sntc_en_pos 0
+#define reg_sntc_en_len 1
+#define reg_sntc_en_lsb 0
+#define xd_g_reg_intp_sys_div   (*(volatile byte xdata *) 0xF90C)
+#define    g_reg_intp_sys_div   0xF90C
+#define reg_intp_sys_div_pos 0
+#define reg_intp_sys_div_len 1
+#define reg_intp_sys_div_lsb 0
+#define xd_g_reg_clk_sntc_sel   (*(volatile byte xdata *) 0xF90D)
+#define    g_reg_clk_sntc_sel   0xF90D
+#define reg_clk_sntc_sel_pos 0
+#define reg_clk_sntc_sel_len 3
+#define reg_clk_sntc_sel_lsb 0
+#define xd_p_reg_ce_gs_force    (*(volatile byte xdata *) 0xFD00)
+#define    p_reg_ce_gs_force    0xFD00
+#define reg_ce_gs_force_pos 0
+#define reg_ce_gs_force_len 1
+#define reg_ce_gs_force_lsb 0
+#define xd_p_reg_ce_dagcgain_delay  (*(volatile byte xdata *) 0xFD01)
+#define    p_reg_ce_dagcgain_delay  0xFD01
+#define reg_ce_dagcgain_delay_pos 0
+#define reg_ce_dagcgain_delay_len 2
+#define reg_ce_dagcgain_delay_lsb 0
+#define xd_p_reg_ce_derot_en    (*(volatile byte xdata *) 0xFD02)
+#define    p_reg_ce_derot_en    0xFD02
+#define reg_ce_derot_en_pos 0
+#define reg_ce_derot_en_len 1
+#define reg_ce_derot_en_lsb 0
+#define xd_p_reg_ce_fctrl_en    (*(volatile byte xdata *) 0xFD05)
+#define    p_reg_ce_fctrl_en    0xFD05
+#define reg_ce_fctrl_en_pos 0
+#define reg_ce_fctrl_en_len 1
+#define reg_ce_fctrl_en_lsb 0
+#define xd_p_reg_ce_en  (*(volatile byte xdata *) 0xFD06)
+#define    p_reg_ce_en  0xFD06
+#define reg_ce_en_pos 0
+#define reg_ce_en_len 1
+#define reg_ce_en_lsb 0
+#define xd_p_reg_ce_sat_wes (*(volatile byte xdata *) 0xFD07)
+#define    p_reg_ce_sat_wes 0xFD07
+#define reg_ce_sat_wes_pos 0
+#define reg_ce_sat_wes_len 1
+#define reg_ce_sat_wes_lsb 0
+#define xd_p_reg_ce_sat_sigma2  (*(volatile byte xdata *) 0xFD08)
+#define    p_reg_ce_sat_sigma2  0xFD08
+#define reg_ce_sat_sigma2_pos 0
+#define reg_ce_sat_sigma2_len 1
+#define reg_ce_sat_sigma2_lsb 0
+#define xd_p_reg_ce_sat_tdi_br_re   (*(volatile byte xdata *) 0xFD09)
+#define    p_reg_ce_sat_tdi_br_re   0xFD09
+#define reg_ce_sat_tdi_br_re_pos 0
+#define reg_ce_sat_tdi_br_re_len 1
+#define reg_ce_sat_tdi_br_re_lsb 0
+#define xd_p_reg_ce_sat_tdi_br_im   (*(volatile byte xdata *) 0xFD0A)
+#define    p_reg_ce_sat_tdi_br_im   0xFD0A
+#define reg_ce_sat_tdi_br_im_pos 0
+#define reg_ce_sat_tdi_br_im_len 1
+#define reg_ce_sat_tdi_br_im_lsb 0
+#define xd_p_reg_ce_sat_tdi_ar_re   (*(volatile byte xdata *) 0xFD0B)
+#define    p_reg_ce_sat_tdi_ar_re   0xFD0B
+#define reg_ce_sat_tdi_ar_re_pos 0
+#define reg_ce_sat_tdi_ar_re_len 1
+#define reg_ce_sat_tdi_ar_re_lsb 0
+#define xd_p_reg_ce_sat_tdi_ar_im   (*(volatile byte xdata *) 0xFD0C)
+#define    p_reg_ce_sat_tdi_ar_im   0xFD0C
+#define reg_ce_sat_tdi_ar_im_pos 0
+#define reg_ce_sat_tdi_ar_im_len 1
+#define reg_ce_sat_tdi_ar_im_lsb 0
+#define xd_p_reg_ce_sat_fdi_br_re   (*(volatile byte xdata *) 0xFD0D)
+#define    p_reg_ce_sat_fdi_br_re   0xFD0D
+#define reg_ce_sat_fdi_br_re_pos 0
+#define reg_ce_sat_fdi_br_re_len 1
+#define reg_ce_sat_fdi_br_re_lsb 0
+#define xd_p_reg_ce_sat_fdi_br_im   (*(volatile byte xdata *) 0xFD0E)
+#define    p_reg_ce_sat_fdi_br_im   0xFD0E
+#define reg_ce_sat_fdi_br_im_pos 0
+#define reg_ce_sat_fdi_br_im_len 1
+#define reg_ce_sat_fdi_br_im_lsb 0
+#define xd_p_reg_ce_var_forced_value    (*(volatile byte xdata *) 0xFD0F)
+#define    p_reg_ce_var_forced_value    0xFD0F
+#define reg_ce_var_forced_value_pos 0
+#define reg_ce_var_forced_value_len 3
+#define reg_ce_var_forced_value_lsb 0
+#define xd_p_reg_ce_s1  (*(volatile byte xdata *) 0xFD10)
+#define    p_reg_ce_s1  0xFD10
+#define reg_ce_s1_pos 0
+#define reg_ce_s1_len 5
+#define reg_ce_s1_lsb 0
+#define xd_r_reg_ce_tdi_flatness_7_0    (*(volatile byte xdata *) 0xFD11)
+#define    r_reg_ce_tdi_flatness_7_0    0xFD11
+#define reg_ce_tdi_flatness_7_0_pos 0
+#define reg_ce_tdi_flatness_7_0_len 8
+#define reg_ce_tdi_flatness_7_0_lsb 0
+#define xd_r_reg_ce_tdi_flatness_8  (*(volatile byte xdata *) 0xFD12)
+#define    r_reg_ce_tdi_flatness_8  0xFD12
+#define reg_ce_tdi_flatness_8_pos 0
+#define reg_ce_tdi_flatness_8_len 1
+#define reg_ce_tdi_flatness_8_lsb 8
+#define xd_r_reg_ce_tone_7_0    (*(volatile byte xdata *) 0xFD13)
+#define    r_reg_ce_tone_7_0    0xFD13
+#define reg_ce_tone_7_0_pos 0
+#define reg_ce_tone_7_0_len 8
+#define reg_ce_tone_7_0_lsb 0
+#define xd_r_reg_ce_tone_12_8   (*(volatile byte xdata *) 0xFD14)
+#define    r_reg_ce_tone_12_8   0xFD14
+#define reg_ce_tone_12_8_pos 0
+#define reg_ce_tone_12_8_len 5
+#define reg_ce_tone_12_8_lsb 8
+#define xd_p_reg_ce_centroid_drift_th   (*(volatile byte xdata *) 0xFD15)
+#define    p_reg_ce_centroid_drift_th   0xFD15
+#define reg_ce_centroid_drift_th_pos 0
+#define reg_ce_centroid_drift_th_len 8
+#define reg_ce_centroid_drift_th_lsb 0
+#define xd_p_reg_ce_centroid_bias_inc_7_0   (*(volatile byte xdata *) 0xFD16)
+#define    p_reg_ce_centroid_bias_inc_7_0   0xFD16
+#define reg_ce_centroid_bias_inc_7_0_pos 0
+#define reg_ce_centroid_bias_inc_7_0_len 8
+#define reg_ce_centroid_bias_inc_7_0_lsb 0
+#define xd_p_reg_ce_centroid_bias_inc_8 (*(volatile byte xdata *) 0xFD17)
+#define    p_reg_ce_centroid_bias_inc_8 0xFD17
+#define reg_ce_centroid_bias_inc_8_pos 0
+#define reg_ce_centroid_bias_inc_8_len 1
+#define reg_ce_centroid_bias_inc_8_lsb 8
+#define xd_p_reg_ce_centroid_count_max  (*(volatile byte xdata *) 0xFD18)
+#define    p_reg_ce_centroid_count_max  0xFD18
+#define reg_ce_centroid_count_max_pos 0
+#define reg_ce_centroid_count_max_len 4
+#define reg_ce_centroid_count_max_lsb 0
+#define xd_p_reg_ce_var_th0_7_0 (*(volatile byte xdata *) 0xFD19)
+#define    p_reg_ce_var_th0_7_0 0xFD19
+#define reg_ce_var_th0_7_0_pos 0
+#define reg_ce_var_th0_7_0_len 8
+#define reg_ce_var_th0_7_0_lsb 0
+#define xd_p_reg_ce_var_th0_15_8    (*(volatile byte xdata *) 0xFD1A)
+#define    p_reg_ce_var_th0_15_8    0xFD1A
+#define reg_ce_var_th0_15_8_pos 0
+#define reg_ce_var_th0_15_8_len 8
+#define reg_ce_var_th0_15_8_lsb 8
+#define xd_p_reg_ce_var_th1_7_0 (*(volatile byte xdata *) 0xFD1B)
+#define    p_reg_ce_var_th1_7_0 0xFD1B
+#define reg_ce_var_th1_7_0_pos 0
+#define reg_ce_var_th1_7_0_len 8
+#define reg_ce_var_th1_7_0_lsb 0
+#define xd_p_reg_ce_var_th1_15_8    (*(volatile byte xdata *) 0xFD1C)
+#define    p_reg_ce_var_th1_15_8    0xFD1C
+#define reg_ce_var_th1_15_8_pos 0
+#define reg_ce_var_th1_15_8_len 8
+#define reg_ce_var_th1_15_8_lsb 8
+#define xd_p_reg_ce_var_th2_7_0 (*(volatile byte xdata *) 0xFD1D)
+#define    p_reg_ce_var_th2_7_0 0xFD1D
+#define reg_ce_var_th2_7_0_pos 0
+#define reg_ce_var_th2_7_0_len 8
+#define reg_ce_var_th2_7_0_lsb 0
+#define xd_p_reg_ce_var_th2_15_8    (*(volatile byte xdata *) 0xFD1E)
+#define    p_reg_ce_var_th2_15_8    0xFD1E
+#define reg_ce_var_th2_15_8_pos 0
+#define reg_ce_var_th2_15_8_len 8
+#define reg_ce_var_th2_15_8_lsb 8
+#define xd_p_reg_ce_var_th3_7_0 (*(volatile byte xdata *) 0xFD1F)
+#define    p_reg_ce_var_th3_7_0 0xFD1F
+#define reg_ce_var_th3_7_0_pos 0
+#define reg_ce_var_th3_7_0_len 8
+#define reg_ce_var_th3_7_0_lsb 0
+#define xd_p_reg_ce_var_th3_15_8    (*(volatile byte xdata *) 0xFD20)
+#define    p_reg_ce_var_th3_15_8    0xFD20
+#define reg_ce_var_th3_15_8_pos 0
+#define reg_ce_var_th3_15_8_len 8
+#define reg_ce_var_th3_15_8_lsb 8
+#define xd_p_reg_ce_var_th4_7_0 (*(volatile byte xdata *) 0xFD21)
+#define    p_reg_ce_var_th4_7_0 0xFD21
+#define reg_ce_var_th4_7_0_pos 0
+#define reg_ce_var_th4_7_0_len 8
+#define reg_ce_var_th4_7_0_lsb 0
+#define xd_p_reg_ce_var_th4_15_8    (*(volatile byte xdata *) 0xFD22)
+#define    p_reg_ce_var_th4_15_8    0xFD22
+#define reg_ce_var_th4_15_8_pos 0
+#define reg_ce_var_th4_15_8_len 8
+#define reg_ce_var_th4_15_8_lsb 8
+#define xd_p_reg_ce_var_th5_7_0 (*(volatile byte xdata *) 0xFD23)
+#define    p_reg_ce_var_th5_7_0 0xFD23
+#define reg_ce_var_th5_7_0_pos 0
+#define reg_ce_var_th5_7_0_len 8
+#define reg_ce_var_th5_7_0_lsb 0
+#define xd_p_reg_ce_var_th5_15_8    (*(volatile byte xdata *) 0xFD24)
+#define    p_reg_ce_var_th5_15_8    0xFD24
+#define reg_ce_var_th5_15_8_pos 0
+#define reg_ce_var_th5_15_8_len 8
+#define reg_ce_var_th5_15_8_lsb 8
+#define xd_p_reg_ce_var_th6_7_0 (*(volatile byte xdata *) 0xFD25)
+#define    p_reg_ce_var_th6_7_0 0xFD25
+#define reg_ce_var_th6_7_0_pos 0
+#define reg_ce_var_th6_7_0_len 8
+#define reg_ce_var_th6_7_0_lsb 0
+#define xd_p_reg_ce_var_th6_15_8    (*(volatile byte xdata *) 0xFD26)
+#define    p_reg_ce_var_th6_15_8    0xFD26
+#define reg_ce_var_th6_15_8_pos 0
+#define reg_ce_var_th6_15_8_len 8
+#define reg_ce_var_th6_15_8_lsb 8
+#define xd_p_reg_ce_var_max (*(volatile byte xdata *) 0xFD27)
+#define    p_reg_ce_var_max 0xFD27
+#define reg_ce_var_max_pos 0
+#define reg_ce_var_max_len 3
+#define reg_ce_var_max_lsb 0
+#define xd_p_reg_ce_cent_forced_en  (*(volatile byte xdata *) 0xFD28)
+#define    p_reg_ce_cent_forced_en  0xFD28
+#define reg_ce_cent_forced_en_pos 0
+#define reg_ce_cent_forced_en_len 1
+#define reg_ce_cent_forced_en_lsb 0
+#define xd_p_reg_ce_var_forced_en   (*(volatile byte xdata *) 0xFD29)
+#define    p_reg_ce_var_forced_en   0xFD29
+#define reg_ce_var_forced_en_pos 0
+#define reg_ce_var_forced_en_len 1
+#define reg_ce_var_forced_en_lsb 0
+#define xd_p_reg_ce_fctrl_auto_reset_en (*(volatile byte xdata *) 0xFD2A)
+#define    p_reg_ce_fctrl_auto_reset_en 0xFD2A
+#define reg_ce_fctrl_auto_reset_en_pos 0
+#define reg_ce_fctrl_auto_reset_en_len 1
+#define reg_ce_fctrl_auto_reset_en_lsb 0
+#define xd_p_reg_ce_cent_auto_clr_en    (*(volatile byte xdata *) 0xFD2B)
+#define    p_reg_ce_cent_auto_clr_en    0xFD2B
+#define reg_ce_cent_auto_clr_en_pos 0
+#define reg_ce_cent_auto_clr_en_len 1
+#define reg_ce_cent_auto_clr_en_lsb 0
+#define xd_p_reg_ce_fctrl_reset (*(volatile byte xdata *) 0xFD2C)
+#define    p_reg_ce_fctrl_reset 0xFD2C
+#define reg_ce_fctrl_reset_pos 0
+#define reg_ce_fctrl_reset_len 1
+#define reg_ce_fctrl_reset_lsb 0
+#define xd_p_reg_ce_cent_forced_value_7_0   (*(volatile byte xdata *) 0xFD2D)
+#define    p_reg_ce_cent_forced_value_7_0   0xFD2D
+#define reg_ce_cent_forced_value_7_0_pos 0
+#define reg_ce_cent_forced_value_7_0_len 8
+#define reg_ce_cent_forced_value_7_0_lsb 0
+#define xd_p_reg_ce_cent_forced_value_11_8  (*(volatile byte xdata *) 0xFD2E)
+#define    p_reg_ce_cent_forced_value_11_8  0xFD2E
+#define reg_ce_cent_forced_value_11_8_pos 0
+#define reg_ce_cent_forced_value_11_8_len 4
+#define reg_ce_cent_forced_value_11_8_lsb 8
+#define xd_p_reg_ce_cent_auto_clr_value_7_0 (*(volatile byte xdata *) 0xFD2F)
+#define    p_reg_ce_cent_auto_clr_value_7_0 0xFD2F
+#define reg_ce_cent_auto_clr_value_7_0_pos 0
+#define reg_ce_cent_auto_clr_value_7_0_len 8
+#define reg_ce_cent_auto_clr_value_7_0_lsb 0
+#define xd_p_reg_ce_cent_auto_clr_value_11_8    (*(volatile byte xdata *) 0xFD30)
+#define    p_reg_ce_cent_auto_clr_value_11_8    0xFD30
+#define reg_ce_cent_auto_clr_value_11_8_pos 0
+#define reg_ce_cent_auto_clr_value_11_8_len 4
+#define reg_ce_cent_auto_clr_value_11_8_lsb 8
+#define xd_p_reg_ce_centroid_max_7_0    (*(volatile byte xdata *) 0xFD31)
+#define    p_reg_ce_centroid_max_7_0    0xFD31
+#define reg_ce_centroid_max_7_0_pos 0
+#define reg_ce_centroid_max_7_0_len 8
+#define reg_ce_centroid_max_7_0_lsb 0
+#define xd_p_reg_ce_centroid_max_11_8   (*(volatile byte xdata *) 0xFD32)
+#define    p_reg_ce_centroid_max_11_8   0xFD32
+#define reg_ce_centroid_max_11_8_pos 0
+#define reg_ce_centroid_max_11_8_len 4
+#define reg_ce_centroid_max_11_8_lsb 8
+#define xd_p_reg_ce_fctrl_rd    (*(volatile byte xdata *) 0xFD33)
+#define    p_reg_ce_fctrl_rd    0xFD33
+#define reg_ce_fctrl_rd_pos 0
+#define reg_ce_fctrl_rd_len 1
+#define reg_ce_fctrl_rd_lsb 0
+#define xd_r_reg_ce_centroid_out_7_0    (*(volatile byte xdata *) 0xFD34)
+#define    r_reg_ce_centroid_out_7_0    0xFD34
+#define reg_ce_centroid_out_7_0_pos 0
+#define reg_ce_centroid_out_7_0_len 8
+#define reg_ce_centroid_out_7_0_lsb 0
+#define xd_r_reg_ce_centroid_out_11_8   (*(volatile byte xdata *) 0xFD35)
+#define    r_reg_ce_centroid_out_11_8   0xFD35
+#define reg_ce_centroid_out_11_8_pos 0
+#define reg_ce_centroid_out_11_8_len 4
+#define reg_ce_centroid_out_11_8_lsb 8
+#define xd_r_reg_ce_fctrl_rdy   (*(volatile byte xdata *) 0xFD36)
+#define    r_reg_ce_fctrl_rdy   0xFD36
+#define reg_ce_fctrl_rdy_pos 0
+#define reg_ce_fctrl_rdy_len 1
+#define reg_ce_fctrl_rdy_lsb 0
+#define xd_r_reg_ce_var (*(volatile byte xdata *) 0xFD37)
+#define    r_reg_ce_var 0xFD37
+#define reg_ce_var_pos 0
+#define reg_ce_var_len 3
+#define reg_ce_var_lsb 0
+#define xd_r_reg_ce_bias_7_0    (*(volatile byte xdata *) 0xFD38)
+#define    r_reg_ce_bias_7_0    0xFD38
+#define reg_ce_bias_7_0_pos 0
+#define reg_ce_bias_7_0_len 8
+#define reg_ce_bias_7_0_lsb 0
+#define xd_r_reg_ce_bias_11_8   (*(volatile byte xdata *) 0xFD39)
+#define    r_reg_ce_bias_11_8   0xFD39
+#define reg_ce_bias_11_8_pos 0
+#define reg_ce_bias_11_8_len 4
+#define reg_ce_bias_11_8_lsb 8
+#define xd_r_reg_ce_m1_7_0  (*(volatile byte xdata *) 0xFD3A)
+#define    r_reg_ce_m1_7_0  0xFD3A
+#define reg_ce_m1_7_0_pos 0
+#define reg_ce_m1_7_0_len 8
+#define reg_ce_m1_7_0_lsb 0
+#define xd_r_reg_ce_m1_11_8 (*(volatile byte xdata *) 0xFD3B)
+#define    r_reg_ce_m1_11_8 0xFD3B
+#define reg_ce_m1_11_8_pos 0
+#define reg_ce_m1_11_8_len 4
+#define reg_ce_m1_11_8_lsb 8
+#define xd_r_reg_ce_rh0_7_0 (*(volatile byte xdata *) 0xFD3C)
+#define    r_reg_ce_rh0_7_0 0xFD3C
+#define reg_ce_rh0_7_0_pos 0
+#define reg_ce_rh0_7_0_len 8
+#define reg_ce_rh0_7_0_lsb 0
+#define xd_r_reg_ce_rh0_15_8    (*(volatile byte xdata *) 0xFD3D)
+#define    r_reg_ce_rh0_15_8    0xFD3D
+#define reg_ce_rh0_15_8_pos 0
+#define reg_ce_rh0_15_8_len 8
+#define reg_ce_rh0_15_8_lsb 8
+#define xd_r_reg_ce_rh0_23_16   (*(volatile byte xdata *) 0xFD3E)
+#define    r_reg_ce_rh0_23_16   0xFD3E
+#define reg_ce_rh0_23_16_pos 0
+#define reg_ce_rh0_23_16_len 8
+#define reg_ce_rh0_23_16_lsb 16
+#define xd_r_reg_ce_rh0_31_24   (*(volatile byte xdata *) 0xFD3F)
+#define    r_reg_ce_rh0_31_24   0xFD3F
+#define reg_ce_rh0_31_24_pos 0
+#define reg_ce_rh0_31_24_len 8
+#define reg_ce_rh0_31_24_lsb 24
+#define xd_p_reg_ce_tdi_delta   (*(volatile byte xdata *) 0xFD40)
+#define    p_reg_ce_tdi_delta   0xFD40
+#define reg_ce_tdi_delta_pos 0
+#define reg_ce_tdi_delta_len 3
+#define reg_ce_tdi_delta_lsb 0
+#define xd_p_reg_ce_fdi_delta   (*(volatile byte xdata *) 0xFD41)
+#define    p_reg_ce_fdi_delta   0xFD41
+#define reg_ce_fdi_delta_pos 0
+#define reg_ce_fdi_delta_len 3
+#define reg_ce_fdi_delta_lsb 0
+#define xd_p_reg_ce_fste_delta  (*(volatile byte xdata *) 0xFD42)
+#define    p_reg_ce_fste_delta  0xFD42
+#define reg_ce_fste_delta_pos 0
+#define reg_ce_fste_delta_len 3
+#define reg_ce_fste_delta_lsb 0
+#define xd_r_reg_ce_fft_s1  (*(volatile byte xdata *) 0xFD43)
+#define    r_reg_ce_fft_s1  0xFD43
+#define reg_ce_fft_s1_pos 0
+#define reg_ce_fft_s1_len 4
+#define reg_ce_fft_s1_lsb 0
+#define xd_r_reg_feq_fix_eh2_7_0    (*(volatile byte xdata *) 0xFD44)
+#define    r_reg_feq_fix_eh2_7_0    0xFD44
+#define reg_feq_fix_eh2_7_0_pos 0
+#define reg_feq_fix_eh2_7_0_len 8
+#define reg_feq_fix_eh2_7_0_lsb 0
+#define xd_r_reg_feq_fix_eh2_15_8   (*(volatile byte xdata *) 0xFD45)
+#define    r_reg_feq_fix_eh2_15_8   0xFD45
+#define reg_feq_fix_eh2_15_8_pos 0
+#define reg_feq_fix_eh2_15_8_len 8
+#define reg_feq_fix_eh2_15_8_lsb 8
+#define xd_r_reg_feq_fix_eh2_23_16  (*(volatile byte xdata *) 0xFD46)
+#define    r_reg_feq_fix_eh2_23_16  0xFD46
+#define reg_feq_fix_eh2_23_16_pos 0
+#define reg_feq_fix_eh2_23_16_len 8
+#define reg_feq_fix_eh2_23_16_lsb 16
+#define xd_r_reg_feq_fix_eh2_31_24  (*(volatile byte xdata *) 0xFD47)
+#define    r_reg_feq_fix_eh2_31_24  0xFD47
+#define reg_feq_fix_eh2_31_24_pos 0
+#define reg_feq_fix_eh2_31_24_len 8
+#define reg_feq_fix_eh2_31_24_lsb 24
+#define xd_r_reg_ce_m2_central_7_0  (*(volatile byte xdata *) 0xFD48)
+#define    r_reg_ce_m2_central_7_0  0xFD48
+#define reg_ce_m2_central_7_0_pos 0
+#define reg_ce_m2_central_7_0_len 8
+#define reg_ce_m2_central_7_0_lsb 0
+#define xd_r_reg_ce_m2_central_15_8 (*(volatile byte xdata *) 0xFD49)
+#define    r_reg_ce_m2_central_15_8 0xFD49
+#define reg_ce_m2_central_15_8_pos 0
+#define reg_ce_m2_central_15_8_len 8
+#define reg_ce_m2_central_15_8_lsb 8
+#define xd_r_reg_ce_sigma2_7_0  (*(volatile byte xdata *) 0xFD4A)
+#define    r_reg_ce_sigma2_7_0  0xFD4A
+#define reg_ce_sigma2_7_0_pos 0
+#define reg_ce_sigma2_7_0_len 8
+#define reg_ce_sigma2_7_0_lsb 0
+#define xd_r_reg_ce_sigma2_15_8 (*(volatile byte xdata *) 0xFD4B)
+#define    r_reg_ce_sigma2_15_8 0xFD4B
+#define reg_ce_sigma2_15_8_pos 0
+#define reg_ce_sigma2_15_8_len 8
+#define reg_ce_sigma2_15_8_lsb 8
+#define xd_r_reg_ce_sigma2_19_16    (*(volatile byte xdata *) 0xFD4C)
+#define    r_reg_ce_sigma2_19_16    0xFD4C
+#define reg_ce_sigma2_19_16_pos 0
+#define reg_ce_sigma2_19_16_len 4
+#define reg_ce_sigma2_19_16_lsb 16
+#define xd_r_reg_ce_data_im_7_0 (*(volatile byte xdata *) 0xFD4D)
+#define    r_reg_ce_data_im_7_0 0xFD4D
+#define reg_ce_data_im_7_0_pos 0
+#define reg_ce_data_im_7_0_len 8
+#define reg_ce_data_im_7_0_lsb 0
+#define xd_r_reg_ce_data_im_14_8    (*(volatile byte xdata *) 0xFD4E)
+#define    r_reg_ce_data_im_14_8    0xFD4E
+#define reg_ce_data_im_14_8_pos 0
+#define reg_ce_data_im_14_8_len 7
+#define reg_ce_data_im_14_8_lsb 8
+#define xd_r_reg_ce_data_re_7_0 (*(volatile byte xdata *) 0xFD4F)
+#define    r_reg_ce_data_re_7_0 0xFD4F
+#define reg_ce_data_re_7_0_pos 0
+#define reg_ce_data_re_7_0_len 8
+#define reg_ce_data_re_7_0_lsb 0
+#define xd_r_reg_ce_data_re_14_8    (*(volatile byte xdata *) 0xFD50)
+#define    r_reg_ce_data_re_14_8    0xFD50
+#define reg_ce_data_re_14_8_pos 0
+#define reg_ce_data_re_14_8_len 7
+#define reg_ce_data_re_14_8_lsb 8
+#define xd_p_reg_ce_var_default_value   (*(volatile byte xdata *) 0xFD51)
+#define    p_reg_ce_var_default_value   0xFD51
+#define reg_ce_var_default_value_pos 0
+#define reg_ce_var_default_value_len 3
+#define reg_ce_var_default_value_lsb 0
+#define xd_p_reg_ce_cent_default_value_7_0  (*(volatile byte xdata *) 0xFD52)
+#define    p_reg_ce_cent_default_value_7_0  0xFD52
+#define reg_ce_cent_default_value_7_0_pos 0
+#define reg_ce_cent_default_value_7_0_len 8
+#define reg_ce_cent_default_value_7_0_lsb 0
+#define xd_p_reg_ce_cent_default_value_11_8 (*(volatile byte xdata *) 0xFD53)
+#define    p_reg_ce_cent_default_value_11_8 0xFD53
+#define reg_ce_cent_default_value_11_8_pos 0
+#define reg_ce_cent_default_value_11_8_len 4
+#define reg_ce_cent_default_value_11_8_lsb 8
+#define xd_r_reg_ce_var_hw  (*(volatile byte xdata *) 0xFD54)
+#define    r_reg_ce_var_hw  0xFD54
+#define reg_ce_var_hw_pos 0
+#define reg_ce_var_hw_len 3
+#define reg_ce_var_hw_lsb 0
+#define xd_r_reg_ce_cent_hw_7_0 (*(volatile byte xdata *) 0xFD55)
+#define    r_reg_ce_cent_hw_7_0 0xFD55
+#define reg_ce_cent_hw_7_0_pos 0
+#define reg_ce_cent_hw_7_0_len 8
+#define reg_ce_cent_hw_7_0_lsb 0
+#define xd_r_reg_ce_cent_hw_11_8    (*(volatile byte xdata *) 0xFD56)
+#define    r_reg_ce_cent_hw_11_8    0xFD56
+#define reg_ce_cent_hw_11_8_pos 0
+#define reg_ce_cent_hw_11_8_len 4
+#define reg_ce_cent_hw_11_8_lsb 8
+#define xd_p_reg_ce_fdi_cp_test_en  (*(volatile byte xdata *) 0xFD57)
+#define    p_reg_ce_fdi_cp_test_en  0xFD57
+#define reg_ce_fdi_cp_test_en_pos 0
+#define reg_ce_fdi_cp_test_en_len 1
+#define reg_ce_fdi_cp_test_en_lsb 0
+#define xd_p_reg_ce_cptestindex0_7_0    (*(volatile byte xdata *) 0xFD58)
+#define    p_reg_ce_cptestindex0_7_0    0xFD58
+#define reg_ce_cptestindex0_7_0_pos 0
+#define reg_ce_cptestindex0_7_0_len 8
+#define reg_ce_cptestindex0_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex0_12_8   (*(volatile byte xdata *) 0xFD59)
+#define    p_reg_ce_cptestindex0_12_8   0xFD59
+#define reg_ce_cptestindex0_12_8_pos 0
+#define reg_ce_cptestindex0_12_8_len 5
+#define reg_ce_cptestindex0_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi0  (*(volatile byte xdata *) 0xFD5A)
+#define    p_reg_ce_cptestfdi0  0xFD5A
+#define reg_ce_cptestfdi0_pos 0
+#define reg_ce_cptestfdi0_len 3
+#define reg_ce_cptestfdi0_lsb 0
+#define xd_p_reg_ce_cptestindex1_7_0    (*(volatile byte xdata *) 0xFD5B)
+#define    p_reg_ce_cptestindex1_7_0    0xFD5B
+#define reg_ce_cptestindex1_7_0_pos 0
+#define reg_ce_cptestindex1_7_0_len 8
+#define reg_ce_cptestindex1_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex1_12_8   (*(volatile byte xdata *) 0xFD5C)
+#define    p_reg_ce_cptestindex1_12_8   0xFD5C
+#define reg_ce_cptestindex1_12_8_pos 0
+#define reg_ce_cptestindex1_12_8_len 5
+#define reg_ce_cptestindex1_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi1  (*(volatile byte xdata *) 0xFD5D)
+#define    p_reg_ce_cptestfdi1  0xFD5D
+#define reg_ce_cptestfdi1_pos 0
+#define reg_ce_cptestfdi1_len 3
+#define reg_ce_cptestfdi1_lsb 0
+#define xd_p_reg_ce_cptestindex2_7_0    (*(volatile byte xdata *) 0xFD5E)
+#define    p_reg_ce_cptestindex2_7_0    0xFD5E
+#define reg_ce_cptestindex2_7_0_pos 0
+#define reg_ce_cptestindex2_7_0_len 8
+#define reg_ce_cptestindex2_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex2_12_8   (*(volatile byte xdata *) 0xFD5F)
+#define    p_reg_ce_cptestindex2_12_8   0xFD5F
+#define reg_ce_cptestindex2_12_8_pos 0
+#define reg_ce_cptestindex2_12_8_len 5
+#define reg_ce_cptestindex2_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi2  (*(volatile byte xdata *) 0xFD60)
+#define    p_reg_ce_cptestfdi2  0xFD60
+#define reg_ce_cptestfdi2_pos 0
+#define reg_ce_cptestfdi2_len 3
+#define reg_ce_cptestfdi2_lsb 0
+#define xd_p_reg_ce_cptestindex3_7_0    (*(volatile byte xdata *) 0xFD61)
+#define    p_reg_ce_cptestindex3_7_0    0xFD61
+#define reg_ce_cptestindex3_7_0_pos 0
+#define reg_ce_cptestindex3_7_0_len 8
+#define reg_ce_cptestindex3_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex3_12_8   (*(volatile byte xdata *) 0xFD62)
+#define    p_reg_ce_cptestindex3_12_8   0xFD62
+#define reg_ce_cptestindex3_12_8_pos 0
+#define reg_ce_cptestindex3_12_8_len 5
+#define reg_ce_cptestindex3_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi3  (*(volatile byte xdata *) 0xFD63)
+#define    p_reg_ce_cptestfdi3  0xFD63
+#define reg_ce_cptestfdi3_pos 0
+#define reg_ce_cptestfdi3_len 3
+#define reg_ce_cptestfdi3_lsb 0
+#define xd_p_reg_ce_cptestindex4_7_0    (*(volatile byte xdata *) 0xFD64)
+#define    p_reg_ce_cptestindex4_7_0    0xFD64
+#define reg_ce_cptestindex4_7_0_pos 0
+#define reg_ce_cptestindex4_7_0_len 8
+#define reg_ce_cptestindex4_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex4_12_8   (*(volatile byte xdata *) 0xFD65)
+#define    p_reg_ce_cptestindex4_12_8   0xFD65
+#define reg_ce_cptestindex4_12_8_pos 0
+#define reg_ce_cptestindex4_12_8_len 5
+#define reg_ce_cptestindex4_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi4  (*(volatile byte xdata *) 0xFD66)
+#define    p_reg_ce_cptestfdi4  0xFD66
+#define reg_ce_cptestfdi4_pos 0
+#define reg_ce_cptestfdi4_len 3
+#define reg_ce_cptestfdi4_lsb 0
+#define xd_p_reg_ce_cptestindex5_7_0    (*(volatile byte xdata *) 0xFD67)
+#define    p_reg_ce_cptestindex5_7_0    0xFD67
+#define reg_ce_cptestindex5_7_0_pos 0
+#define reg_ce_cptestindex5_7_0_len 8
+#define reg_ce_cptestindex5_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex5_12_8   (*(volatile byte xdata *) 0xFD68)
+#define    p_reg_ce_cptestindex5_12_8   0xFD68
+#define reg_ce_cptestindex5_12_8_pos 0
+#define reg_ce_cptestindex5_12_8_len 5
+#define reg_ce_cptestindex5_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi5  (*(volatile byte xdata *) 0xFD69)
+#define    p_reg_ce_cptestfdi5  0xFD69
+#define reg_ce_cptestfdi5_pos 0
+#define reg_ce_cptestfdi5_len 3
+#define reg_ce_cptestfdi5_lsb 0
+#define xd_p_reg_ce_cptestindex6_7_0    (*(volatile byte xdata *) 0xFD6A)
+#define    p_reg_ce_cptestindex6_7_0    0xFD6A
+#define reg_ce_cptestindex6_7_0_pos 0
+#define reg_ce_cptestindex6_7_0_len 8
+#define reg_ce_cptestindex6_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex6_12_8   (*(volatile byte xdata *) 0xFD6B)
+#define    p_reg_ce_cptestindex6_12_8   0xFD6B
+#define reg_ce_cptestindex6_12_8_pos 0
+#define reg_ce_cptestindex6_12_8_len 5
+#define reg_ce_cptestindex6_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi6  (*(volatile byte xdata *) 0xFD6C)
+#define    p_reg_ce_cptestfdi6  0xFD6C
+#define reg_ce_cptestfdi6_pos 0
+#define reg_ce_cptestfdi6_len 3
+#define reg_ce_cptestfdi6_lsb 0
+#define xd_p_reg_ce_cptestindex7_7_0    (*(volatile byte xdata *) 0xFD6D)
+#define    p_reg_ce_cptestindex7_7_0    0xFD6D
+#define reg_ce_cptestindex7_7_0_pos 0
+#define reg_ce_cptestindex7_7_0_len 8
+#define reg_ce_cptestindex7_7_0_lsb 0
+#define xd_p_reg_ce_cptestindex7_12_8   (*(volatile byte xdata *) 0xFD6E)
+#define    p_reg_ce_cptestindex7_12_8   0xFD6E
+#define reg_ce_cptestindex7_12_8_pos 0
+#define reg_ce_cptestindex7_12_8_len 5
+#define reg_ce_cptestindex7_12_8_lsb 8
+#define xd_p_reg_ce_cptestfdi7  (*(volatile byte xdata *) 0xFD6F)
+#define    p_reg_ce_cptestfdi7  0xFD6F
+#define reg_ce_cptestfdi7_pos 0
+#define reg_ce_cptestfdi7_len 3
+#define reg_ce_cptestfdi7_lsb 0
+#define xd_p_reg_ce_cp_replace_tdiout_en    (*(volatile byte xdata *) 0xFD74)
+#define    p_reg_ce_cp_replace_tdiout_en    0xFD74
+#define reg_ce_cp_replace_tdiout_en_pos 0
+#define reg_ce_cp_replace_tdiout_en_len 1
+#define reg_ce_cp_replace_tdiout_en_lsb 0
+#define xd_p_reg_ce_tdi_mask0_en    (*(volatile byte xdata *) 0xFD7D)
+#define    p_reg_ce_tdi_mask0_en    0xFD7D
+#define reg_ce_tdi_mask0_en_pos 0
+#define reg_ce_tdi_mask0_en_len 1
+#define reg_ce_tdi_mask0_en_lsb 0
+#define xd_p_reg_ce_tdi_mask_from0_7_0  (*(volatile byte xdata *) 0xFD7E)
+#define    p_reg_ce_tdi_mask_from0_7_0  0xFD7E
+#define reg_ce_tdi_mask_from0_7_0_pos 0
+#define reg_ce_tdi_mask_from0_7_0_len 8
+#define reg_ce_tdi_mask_from0_7_0_lsb 0
+#define xd_p_reg_ce_tdi_mask_from0_12_8 (*(volatile byte xdata *) 0xFD7F)
+#define    p_reg_ce_tdi_mask_from0_12_8 0xFD7F
+#define reg_ce_tdi_mask_from0_12_8_pos 0
+#define reg_ce_tdi_mask_from0_12_8_len 5
+#define reg_ce_tdi_mask_from0_12_8_lsb 8
+#define xd_p_reg_ce_tdi_mask_to0_7_0    (*(volatile byte xdata *) 0xFD80)
+#define    p_reg_ce_tdi_mask_to0_7_0    0xFD80
+#define reg_ce_tdi_mask_to0_7_0_pos 0
+#define reg_ce_tdi_mask_to0_7_0_len 8
+#define reg_ce_tdi_mask_to0_7_0_lsb 0
+#define xd_p_reg_ce_tdi_mask_to0_12_8   (*(volatile byte xdata *) 0xFD81)
+#define    p_reg_ce_tdi_mask_to0_12_8   0xFD81
+#define reg_ce_tdi_mask_to0_12_8_pos 0
+#define reg_ce_tdi_mask_to0_12_8_len 5
+#define reg_ce_tdi_mask_to0_12_8_lsb 8
+#define xd_p_reg_ce_tdi_mask1_en    (*(volatile byte xdata *) 0xFD82)
+#define    p_reg_ce_tdi_mask1_en    0xFD82
+#define reg_ce_tdi_mask1_en_pos 0
+#define reg_ce_tdi_mask1_en_len 1
+#define reg_ce_tdi_mask1_en_lsb 0
+#define xd_p_reg_ce_tdi_mask_from1_7_0  (*(volatile byte xdata *) 0xFD83)
+#define    p_reg_ce_tdi_mask_from1_7_0  0xFD83
+#define reg_ce_tdi_mask_from1_7_0_pos 0
+#define reg_ce_tdi_mask_from1_7_0_len 8
+#define reg_ce_tdi_mask_from1_7_0_lsb 0
+#define xd_p_reg_ce_tdi_mask_from1_12_8 (*(volatile byte xdata *) 0xFD84)
+#define    p_reg_ce_tdi_mask_from1_12_8 0xFD84
+#define reg_ce_tdi_mask_from1_12_8_pos 0
+#define reg_ce_tdi_mask_from1_12_8_len 5
+#define reg_ce_tdi_mask_from1_12_8_lsb 8
+#define xd_p_reg_ce_tdi_mask_to1_7_0    (*(volatile byte xdata *) 0xFD85)
+#define    p_reg_ce_tdi_mask_to1_7_0    0xFD85
+#define reg_ce_tdi_mask_to1_7_0_pos 0
+#define reg_ce_tdi_mask_to1_7_0_len 8
+#define reg_ce_tdi_mask_to1_7_0_lsb 0
+#define xd_p_reg_ce_tdi_mask_to1_12_8   (*(volatile byte xdata *) 0xFD86)
+#define    p_reg_ce_tdi_mask_to1_12_8   0xFD86
+#define reg_ce_tdi_mask_to1_12_8_pos 0
+#define reg_ce_tdi_mask_to1_12_8_len 5
+#define reg_ce_tdi_mask_to1_12_8_lsb 8
+#define xd_p_reg_ce_2nd_var_max (*(volatile byte xdata *) 0xFD87)
+#define    p_reg_ce_2nd_var_max 0xFD87
+#define reg_ce_2nd_var_max_pos 0
+#define reg_ce_2nd_var_max_len 3
+#define reg_ce_2nd_var_max_lsb 0
+#define xd_p_reg_ce_2nd_cent_forced_en  (*(volatile byte xdata *) 0xFD88)
+#define    p_reg_ce_2nd_cent_forced_en  0xFD88
+#define reg_ce_2nd_cent_forced_en_pos 0
+#define reg_ce_2nd_cent_forced_en_len 1
+#define reg_ce_2nd_cent_forced_en_lsb 0
+#define xd_p_reg_ce_2nd_var_forced_en   (*(volatile byte xdata *) 0xFD89)
+#define    p_reg_ce_2nd_var_forced_en   0xFD89
+#define reg_ce_2nd_var_forced_en_pos 0
+#define reg_ce_2nd_var_forced_en_len 1
+#define reg_ce_2nd_var_forced_en_lsb 0
+#define xd_p_reg_ce_2nd_fctrl_auto_reset_en (*(volatile byte xdata *) 0xFD8A)
+#define    p_reg_ce_2nd_fctrl_auto_reset_en 0xFD8A
+#define reg_ce_2nd_fctrl_auto_reset_en_pos 0
+#define reg_ce_2nd_fctrl_auto_reset_en_len 1
+#define reg_ce_2nd_fctrl_auto_reset_en_lsb 0
+#define xd_p_reg_ce_2nd_cent_auto_clr_en    (*(volatile byte xdata *) 0xFD8B)
+#define    p_reg_ce_2nd_cent_auto_clr_en    0xFD8B
+#define reg_ce_2nd_cent_auto_clr_en_pos 0
+#define reg_ce_2nd_cent_auto_clr_en_len 1
+#define reg_ce_2nd_cent_auto_clr_en_lsb 0
+#define xd_p_reg_ce_2nd_cent_forced_value_7_0   (*(volatile byte xdata *) 0xFD8C)
+#define    p_reg_ce_2nd_cent_forced_value_7_0   0xFD8C
+#define reg_ce_2nd_cent_forced_value_7_0_pos 0
+#define reg_ce_2nd_cent_forced_value_7_0_len 8
+#define reg_ce_2nd_cent_forced_value_7_0_lsb 0
+#define xd_p_reg_ce_2nd_cent_forced_value_11_8  (*(volatile byte xdata *) 0xFD8D)
+#define    p_reg_ce_2nd_cent_forced_value_11_8  0xFD8D
+#define reg_ce_2nd_cent_forced_value_11_8_pos 0
+#define reg_ce_2nd_cent_forced_value_11_8_len 4
+#define reg_ce_2nd_cent_forced_value_11_8_lsb 8
+#define xd_p_reg_ce_2nd_cent_auto_clr_value_7_0 (*(volatile byte xdata *) 0xFD8E)
+#define    p_reg_ce_2nd_cent_auto_clr_value_7_0 0xFD8E
+#define reg_ce_2nd_cent_auto_clr_value_7_0_pos 0
+#define reg_ce_2nd_cent_auto_clr_value_7_0_len 8
+#define reg_ce_2nd_cent_auto_clr_value_7_0_lsb 0
+#define xd_p_reg_ce_2nd_cent_auto_clr_value_11_8    (*(volatile byte xdata *) 0xFD8F)
+#define    p_reg_ce_2nd_cent_auto_clr_value_11_8    0xFD8F
+#define reg_ce_2nd_cent_auto_clr_value_11_8_pos 0
+#define reg_ce_2nd_cent_auto_clr_value_11_8_len 4
+#define reg_ce_2nd_cent_auto_clr_value_11_8_lsb 8
+#define xd_p_reg_ce_gs_s1_var   (*(volatile byte xdata *) 0xFD90)
+#define    p_reg_ce_gs_s1_var   0xFD90
+#define reg_ce_gs_s1_var_pos 0
+#define reg_ce_gs_s1_var_len 4
+#define reg_ce_gs_s1_var_lsb 0
+#define xd_p_reg_ce_2nd_centroid_max_7_0    (*(volatile byte xdata *) 0xFD91)
+#define    p_reg_ce_2nd_centroid_max_7_0    0xFD91
+#define reg_ce_2nd_centroid_max_7_0_pos 0
+#define reg_ce_2nd_centroid_max_7_0_len 8
+#define reg_ce_2nd_centroid_max_7_0_lsb 0
+#define xd_p_reg_ce_2nd_centroid_max_11_8   (*(volatile byte xdata *) 0xFD92)
+#define    p_reg_ce_2nd_centroid_max_11_8   0xFD92
+#define reg_ce_2nd_centroid_max_11_8_pos 0
+#define reg_ce_2nd_centroid_max_11_8_len 4
+#define reg_ce_2nd_centroid_max_11_8_lsb 8
+#define xd_r_reg_ce_2nd_centroid_out_7_0    (*(volatile byte xdata *) 0xFD93)
+#define    r_reg_ce_2nd_centroid_out_7_0    0xFD93
+#define reg_ce_2nd_centroid_out_7_0_pos 0
+#define reg_ce_2nd_centroid_out_7_0_len 8
+#define reg_ce_2nd_centroid_out_7_0_lsb 0
+#define xd_r_reg_ce_2nd_centroid_out_11_8   (*(volatile byte xdata *) 0xFD94)
+#define    r_reg_ce_2nd_centroid_out_11_8   0xFD94
+#define reg_ce_2nd_centroid_out_11_8_pos 0
+#define reg_ce_2nd_centroid_out_11_8_len 4
+#define reg_ce_2nd_centroid_out_11_8_lsb 8
+#define xd_r_reg_ce_2nd_fctrl_rdy   (*(volatile byte xdata *) 0xFD95)
+#define    r_reg_ce_2nd_fctrl_rdy   0xFD95
+#define reg_ce_2nd_fctrl_rdy_pos 0
+#define reg_ce_2nd_fctrl_rdy_len 1
+#define reg_ce_2nd_fctrl_rdy_lsb 0
+#define xd_r_reg_ce_2nd_var (*(volatile byte xdata *) 0xFD96)
+#define    r_reg_ce_2nd_var 0xFD96
+#define reg_ce_2nd_var_pos 0
+#define reg_ce_2nd_var_len 3
+#define reg_ce_2nd_var_lsb 0
+#define xd_r_reg_ce_2nd_bias_7_0    (*(volatile byte xdata *) 0xFD97)
+#define    r_reg_ce_2nd_bias_7_0    0xFD97
+#define reg_ce_2nd_bias_7_0_pos 0
+#define reg_ce_2nd_bias_7_0_len 8
+#define reg_ce_2nd_bias_7_0_lsb 0
+#define xd_r_reg_ce_2nd_bias_11_8   (*(volatile byte xdata *) 0xFD98)
+#define    r_reg_ce_2nd_bias_11_8   0xFD98
+#define reg_ce_2nd_bias_11_8_pos 0
+#define reg_ce_2nd_bias_11_8_len 4
+#define reg_ce_2nd_bias_11_8_lsb 8
+#define xd_r_reg_ce_2nd_m1_7_0  (*(volatile byte xdata *) 0xFD99)
+#define    r_reg_ce_2nd_m1_7_0  0xFD99
+#define reg_ce_2nd_m1_7_0_pos 0
+#define reg_ce_2nd_m1_7_0_len 8
+#define reg_ce_2nd_m1_7_0_lsb 0
+#define xd_r_reg_ce_2nd_m1_11_8 (*(volatile byte xdata *) 0xFD9A)
+#define    r_reg_ce_2nd_m1_11_8 0xFD9A
+#define reg_ce_2nd_m1_11_8_pos 0
+#define reg_ce_2nd_m1_11_8_len 4
+#define reg_ce_2nd_m1_11_8_lsb 8
+#define xd_p_reg_ce_2nd_var_forced_value    (*(volatile byte xdata *) 0xFD9B)
+#define    p_reg_ce_2nd_var_forced_value    0xFD9B
+#define reg_ce_2nd_var_forced_value_pos 0
+#define reg_ce_2nd_var_forced_value_len 3
+#define reg_ce_2nd_var_forced_value_lsb 0
+#define xd_r_reg_ce_2nd_m2_central_7_0  (*(volatile byte xdata *) 0xFD9C)
+#define    r_reg_ce_2nd_m2_central_7_0  0xFD9C
+#define reg_ce_2nd_m2_central_7_0_pos 0
+#define reg_ce_2nd_m2_central_7_0_len 8
+#define reg_ce_2nd_m2_central_7_0_lsb 0
+#define xd_r_reg_ce_2nd_m2_central_15_8 (*(volatile byte xdata *) 0xFD9D)
+#define    r_reg_ce_2nd_m2_central_15_8 0xFD9D
+#define reg_ce_2nd_m2_central_15_8_pos 0
+#define reg_ce_2nd_m2_central_15_8_len 8
+#define reg_ce_2nd_m2_central_15_8_lsb 8
+#define xd_p_reg_ce_2nd_var_default_value   (*(volatile byte xdata *) 0xFD9E)
+#define    p_reg_ce_2nd_var_default_value   0xFD9E
+#define reg_ce_2nd_var_default_value_pos 0
+#define reg_ce_2nd_var_default_value_len 3
+#define reg_ce_2nd_var_default_value_lsb 0
+#define xd_p_reg_ce_2nd_cent_default_value_7_0  (*(volatile byte xdata *) 0xFD9F)
+#define    p_reg_ce_2nd_cent_default_value_7_0  0xFD9F
+#define reg_ce_2nd_cent_default_value_7_0_pos 0
+#define reg_ce_2nd_cent_default_value_7_0_len 8
+#define reg_ce_2nd_cent_default_value_7_0_lsb 0
+#define xd_p_reg_ce_2nd_cent_default_value_11_8 (*(volatile byte xdata *) 0xFDA0)
+#define    p_reg_ce_2nd_cent_default_value_11_8 0xFDA0
+#define reg_ce_2nd_cent_default_value_11_8_pos 0
+#define reg_ce_2nd_cent_default_value_11_8_len 4
+#define reg_ce_2nd_cent_default_value_11_8_lsb 8
+#define xd_p_reg_ce_use_fdi_long    (*(volatile byte xdata *) 0xFDA1)
+#define    p_reg_ce_use_fdi_long    0xFDA1
+#define reg_ce_use_fdi_long_pos 0
+#define reg_ce_use_fdi_long_len 1
+#define reg_ce_use_fdi_long_lsb 0
+#define xd_p_reg_p_ce_tdi_lms_en    (*(volatile byte xdata *) 0xFDA2)
+#define    p_reg_p_ce_tdi_lms_en    0xFDA2
+#define reg_p_ce_tdi_lms_en_pos 0
+#define reg_p_ce_tdi_lms_en_len 1
+#define reg_p_ce_tdi_lms_en_lsb 0
+#define xd_p_reg_p_ce_tdi_lms_bufshift  (*(volatile byte xdata *) 0xFDA3)
+#define    p_reg_p_ce_tdi_lms_bufshift  0xFDA3
+#define reg_p_ce_tdi_lms_bufshift_pos 0
+#define reg_p_ce_tdi_lms_bufshift_len 2
+#define reg_p_ce_tdi_lms_bufshift_lsb 0
+#define xd_p_reg_p_ce_tdi_lms_ave_ratio (*(volatile byte xdata *) 0xFDA4)
+#define    p_reg_p_ce_tdi_lms_ave_ratio 0xFDA4
+#define reg_p_ce_tdi_lms_ave_ratio_pos 0
+#define reg_p_ce_tdi_lms_ave_ratio_len 5
+#define reg_p_ce_tdi_lms_ave_ratio_lsb 0
+#define xd_p_reg_p_ce_conf2_in_con0_en  (*(volatile byte xdata *) 0xFDA5)
+#define    p_reg_p_ce_conf2_in_con0_en  0xFDA5
+#define reg_p_ce_conf2_in_con0_en_pos 0
+#define reg_p_ce_conf2_in_con0_en_len 1
+#define reg_p_ce_conf2_in_con0_en_lsb 0
+// biu_reg.h 7-6-2007
+// gen_biu Ver 1.0 generated by
+#define xd_p_fec_rsd_packet_unit_7_0    (*(volatile byte xdata *) 0xF700)
+#define    p_fec_rsd_packet_unit_7_0    0xF700
+#define fec_rsd_packet_unit_7_0_pos 0
+#define fec_rsd_packet_unit_7_0_len 8
+#define fec_rsd_packet_unit_7_0_lsb 0
+#define xd_p_fec_rsd_packet_unit_15_8   (*(volatile byte xdata *) 0xF701)
+#define    p_fec_rsd_packet_unit_15_8   0xF701
+#define fec_rsd_packet_unit_15_8_pos 0
+#define fec_rsd_packet_unit_15_8_len 8
+#define fec_rsd_packet_unit_15_8_lsb 8
+#define xd_r_reg_rsd_bit_err_cnt_7_0    (*(volatile byte xdata *) 0xF702)
+#define    r_reg_rsd_bit_err_cnt_7_0    0xF702
+#define reg_rsd_bit_err_cnt_7_0_pos 0
+#define reg_rsd_bit_err_cnt_7_0_len 8
+#define reg_rsd_bit_err_cnt_7_0_lsb 0
+#define xd_r_reg_rsd_bit_err_cnt_15_8   (*(volatile byte xdata *) 0xF703)
+#define    r_reg_rsd_bit_err_cnt_15_8   0xF703
+#define reg_rsd_bit_err_cnt_15_8_pos 0
+#define reg_rsd_bit_err_cnt_15_8_len 8
+#define reg_rsd_bit_err_cnt_15_8_lsb 8
+#define xd_r_reg_rsd_bit_err_cnt_23_16  (*(volatile byte xdata *) 0xF704)
+#define    r_reg_rsd_bit_err_cnt_23_16  0xF704
+#define reg_rsd_bit_err_cnt_23_16_pos 0
+#define reg_rsd_bit_err_cnt_23_16_len 8
+#define reg_rsd_bit_err_cnt_23_16_lsb 16
+#define xd_r_reg_rsd_abort_packet_cnt_7_0   (*(volatile byte xdata *) 0xF705)
+#define    r_reg_rsd_abort_packet_cnt_7_0   0xF705
+#define reg_rsd_abort_packet_cnt_7_0_pos 0
+#define reg_rsd_abort_packet_cnt_7_0_len 8
+#define reg_rsd_abort_packet_cnt_7_0_lsb 0
+#define xd_r_reg_rsd_abort_packet_cnt_15_8  (*(volatile byte xdata *) 0xF706)
+#define    r_reg_rsd_abort_packet_cnt_15_8  0xF706
+#define reg_rsd_abort_packet_cnt_15_8_pos 0
+#define reg_rsd_abort_packet_cnt_15_8_len 8
+#define reg_rsd_abort_packet_cnt_15_8_lsb 8
+#define xd_p_fec_RSD_PKT_NUM_PER_UNIT_7_0   (*(volatile byte xdata *) 0xF707)
+#define    p_fec_RSD_PKT_NUM_PER_UNIT_7_0   0xF707
+#define fec_RSD_PKT_NUM_PER_UNIT_7_0_pos 0
+#define fec_RSD_PKT_NUM_PER_UNIT_7_0_len 8
+#define fec_RSD_PKT_NUM_PER_UNIT_7_0_lsb 0
+#define xd_p_fec_RSD_PKT_NUM_PER_UNIT_15_8  (*(volatile byte xdata *) 0xF708)
+#define    p_fec_RSD_PKT_NUM_PER_UNIT_15_8  0xF708
+#define fec_RSD_PKT_NUM_PER_UNIT_15_8_pos 0
+#define fec_RSD_PKT_NUM_PER_UNIT_15_8_len 8
+#define fec_RSD_PKT_NUM_PER_UNIT_15_8_lsb 8
+#define xd_p_fec_RS_TH_1_7_0    (*(volatile byte xdata *) 0xF709)
+#define    p_fec_RS_TH_1_7_0    0xF709
+#define fec_RS_TH_1_7_0_pos 0
+#define fec_RS_TH_1_7_0_len 8
+#define fec_RS_TH_1_7_0_lsb 0
+#define xd_p_fec_RS_TH_1_15_8   (*(volatile byte xdata *) 0xF70A)
+#define    p_fec_RS_TH_1_15_8   0xF70A
+#define fec_RS_TH_1_15_8_pos 0
+#define fec_RS_TH_1_15_8_len 8
+#define fec_RS_TH_1_15_8_lsb 8
+#define xd_p_fec_RS_TH_2    (*(volatile byte xdata *) 0xF70B)
+#define    p_fec_RS_TH_2    0xF70B
+#define fec_RS_TH_2_pos 0
+#define fec_RS_TH_2_len 8
+#define fec_RS_TH_2_lsb 0
+#define xd_p_fec_rsd_ber_rst    (*(volatile byte xdata *) 0xF70C)
+#define    p_fec_rsd_ber_rst    0xF70C
+#define fec_rsd_ber_rst_pos 0
+#define fec_rsd_ber_rst_len 1
+#define fec_rsd_ber_rst_lsb 0
+#define xd_p_reg_rsd_ber_rdy    (*(volatile byte xdata *) 0xF70D)
+#define    p_reg_rsd_ber_rdy    0xF70D
+#define reg_rsd_ber_rdy_pos 0
+#define reg_rsd_ber_rdy_len 1
+#define reg_rsd_ber_rdy_lsb 0
+#define xd_p_reg_rsd_trigger_retrain    (*(volatile byte xdata *) 0xF70E)
+#define    p_reg_rsd_trigger_retrain    0xF70E
+#define reg_rsd_trigger_retrain_pos 0
+#define reg_rsd_trigger_retrain_len 1
+#define reg_rsd_trigger_retrain_lsb 0
+#define xd_p_reg_sync_recover   (*(volatile byte xdata *) 0xF70F)
+#define    p_reg_sync_recover   0xF70F
+#define reg_sync_recover_pos 0
+#define reg_sync_recover_len 1
+#define reg_sync_recover_lsb 0
+#define xd_p_fec_crc_en (*(volatile byte xdata *) 0xF710)
+#define    p_fec_crc_en 0xF710
+#define fec_crc_en_pos 0
+#define fec_crc_en_len 1
+#define fec_crc_en_lsb 0
+#define xd_p_fec_mon_en (*(volatile byte xdata *) 0xF711)
+#define    p_fec_mon_en 0xF711
+#define fec_mon_en_pos 0
+#define fec_mon_en_len 1
+#define fec_mon_en_lsb 0
+#define xd_p_reg_sync_chk   (*(volatile byte xdata *) 0xF712)
+#define    p_reg_sync_chk   0xF712
+#define reg_sync_chk_pos 0
+#define reg_sync_chk_len 1
+#define reg_sync_chk_lsb 0
+#define xd_p_fec_dummy_reg_2    (*(volatile byte xdata *) 0xF713)
+#define    p_fec_dummy_reg_2    0xF713
+#define fec_dummy_reg_2_pos 0
+#define fec_dummy_reg_2_len 3
+#define fec_dummy_reg_2_lsb 0
+#define xd_p_reg_fec_data_en    (*(volatile byte xdata *) 0xF714)
+#define    p_reg_fec_data_en    0xF714
+#define reg_fec_data_en_pos 0
+#define reg_fec_data_en_len 1
+#define reg_fec_data_en_lsb 0
+#define xd_p_fec_vtb_rsd_mon_en (*(volatile byte xdata *) 0xF715)
+#define    p_fec_vtb_rsd_mon_en 0xF715
+#define fec_vtb_rsd_mon_en_pos 0
+#define fec_vtb_rsd_mon_en_len 1
+#define fec_vtb_rsd_mon_en_lsb 0
+#define xd_p_reg_fec_sw_rst (*(volatile byte xdata *) 0xF716)
+#define    p_reg_fec_sw_rst 0xF716
+#define reg_fec_sw_rst_pos 0
+#define reg_fec_sw_rst_len 1
+#define reg_fec_sw_rst_lsb 0
+#define xd_r_fec_vtb_pm_crc (*(volatile byte xdata *) 0xF717)
+#define    r_fec_vtb_pm_crc 0xF717
+#define fec_vtb_pm_crc_pos 0
+#define fec_vtb_pm_crc_len 8
+#define fec_vtb_pm_crc_lsb 0
+#define xd_r_fec_vtb_tb_7_crc   (*(volatile byte xdata *) 0xF718)
+#define    r_fec_vtb_tb_7_crc   0xF718
+#define fec_vtb_tb_7_crc_pos 0
+#define fec_vtb_tb_7_crc_len 8
+#define fec_vtb_tb_7_crc_lsb 0
+#define xd_r_fec_vtb_tb_6_crc   (*(volatile byte xdata *) 0xF719)
+#define    r_fec_vtb_tb_6_crc   0xF719
+#define fec_vtb_tb_6_crc_pos 0
+#define fec_vtb_tb_6_crc_len 8
+#define fec_vtb_tb_6_crc_lsb 0
+#define xd_r_fec_vtb_tb_5_crc   (*(volatile byte xdata *) 0xF71A)
+#define    r_fec_vtb_tb_5_crc   0xF71A
+#define fec_vtb_tb_5_crc_pos 0
+#define fec_vtb_tb_5_crc_len 8
+#define fec_vtb_tb_5_crc_lsb 0
+#define xd_r_fec_vtb_tb_4_crc   (*(volatile byte xdata *) 0xF71B)
+#define    r_fec_vtb_tb_4_crc   0xF71B
+#define fec_vtb_tb_4_crc_pos 0
+#define fec_vtb_tb_4_crc_len 8
+#define fec_vtb_tb_4_crc_lsb 0
+#define xd_r_fec_vtb_tb_3_crc   (*(volatile byte xdata *) 0xF71C)
+#define    r_fec_vtb_tb_3_crc   0xF71C
+#define fec_vtb_tb_3_crc_pos 0
+#define fec_vtb_tb_3_crc_len 8
+#define fec_vtb_tb_3_crc_lsb 0
+#define xd_r_fec_vtb_tb_2_crc   (*(volatile byte xdata *) 0xF71D)
+#define    r_fec_vtb_tb_2_crc   0xF71D
+#define fec_vtb_tb_2_crc_pos 0
+#define fec_vtb_tb_2_crc_len 8
+#define fec_vtb_tb_2_crc_lsb 0
+#define xd_r_fec_vtb_tb_1_crc   (*(volatile byte xdata *) 0xF71E)
+#define    r_fec_vtb_tb_1_crc   0xF71E
+#define fec_vtb_tb_1_crc_pos 0
+#define fec_vtb_tb_1_crc_len 8
+#define fec_vtb_tb_1_crc_lsb 0
+#define xd_r_fec_vtb_tb_0_crc   (*(volatile byte xdata *) 0xF71F)
+#define    r_fec_vtb_tb_0_crc   0xF71F
+#define fec_vtb_tb_0_crc_pos 0
+#define fec_vtb_tb_0_crc_len 8
+#define fec_vtb_tb_0_crc_lsb 0
+#define xd_r_fec_rsd_bank0_crc  (*(volatile byte xdata *) 0xF720)
+#define    r_fec_rsd_bank0_crc  0xF720
+#define fec_rsd_bank0_crc_pos 0
+#define fec_rsd_bank0_crc_len 8
+#define fec_rsd_bank0_crc_lsb 0
+#define xd_r_fec_rsd_bank1_crc  (*(volatile byte xdata *) 0xF721)
+#define    r_fec_rsd_bank1_crc  0xF721
+#define fec_rsd_bank1_crc_pos 0
+#define fec_rsd_bank1_crc_len 8
+#define fec_rsd_bank1_crc_lsb 0
+#define xd_r_fec_idi_vtb_crc    (*(volatile byte xdata *) 0xF722)
+#define    r_fec_idi_vtb_crc    0xF722
+#define fec_idi_vtb_crc_pos 0
+#define fec_idi_vtb_crc_len 8
+#define fec_idi_vtb_crc_lsb 0
+#define xd_p_reg_fec_rsd_packet_unit_exp    (*(volatile byte xdata *) 0xF723)
+#define    p_reg_fec_rsd_packet_unit_exp    0xF723
+#define reg_fec_rsd_packet_unit_exp_pos 0
+#define reg_fec_rsd_packet_unit_exp_len 4
+#define reg_fec_rsd_packet_unit_exp_lsb 0
+#define xd_p_reg_rsd_bit_err_exp_rdy    (*(volatile byte xdata *) 0xF724)
+#define    p_reg_rsd_bit_err_exp_rdy    0xF724
+#define reg_rsd_bit_err_exp_rdy_pos 0
+#define reg_rsd_bit_err_exp_rdy_len 1
+#define reg_rsd_bit_err_exp_rdy_lsb 0
+#define xd_r_reg_rsd_bit_err_exp    (*(volatile byte xdata *) 0xF725)
+#define    r_reg_rsd_bit_err_exp    0xF725
+#define reg_rsd_bit_err_exp_pos 0
+#define reg_rsd_bit_err_exp_len 5
+#define reg_rsd_bit_err_exp_lsb 0
+#define xd_p_fec_rsd_packet_unit1_7_0   (*(volatile byte xdata *) 0xF726)
+#define    p_fec_rsd_packet_unit1_7_0   0xF726
+#define fec_rsd_packet_unit1_7_0_pos 0
+#define fec_rsd_packet_unit1_7_0_len 8
+#define fec_rsd_packet_unit1_7_0_lsb 0
+#define xd_p_fec_rsd_packet_unit1_15_8  (*(volatile byte xdata *) 0xF727)
+#define    p_fec_rsd_packet_unit1_15_8  0xF727
+#define fec_rsd_packet_unit1_15_8_pos 0
+#define fec_rsd_packet_unit1_15_8_len 8
+#define fec_rsd_packet_unit1_15_8_lsb 8
+#define xd_r_reg_rsd_bit_err_cnt1_7_0   (*(volatile byte xdata *) 0xF728)
+#define    r_reg_rsd_bit_err_cnt1_7_0   0xF728
+#define reg_rsd_bit_err_cnt1_7_0_pos 0
+#define reg_rsd_bit_err_cnt1_7_0_len 8
+#define reg_rsd_bit_err_cnt1_7_0_lsb 0
+#define xd_r_reg_rsd_bit_err_cnt1_15_8  (*(volatile byte xdata *) 0xF729)
+#define    r_reg_rsd_bit_err_cnt1_15_8  0xF729
+#define reg_rsd_bit_err_cnt1_15_8_pos 0
+#define reg_rsd_bit_err_cnt1_15_8_len 8
+#define reg_rsd_bit_err_cnt1_15_8_lsb 8
+#define xd_r_reg_rsd_bit_err_cnt1_23_16 (*(volatile byte xdata *) 0xF72A)
+#define    r_reg_rsd_bit_err_cnt1_23_16 0xF72A
+#define reg_rsd_bit_err_cnt1_23_16_pos 0
+#define reg_rsd_bit_err_cnt1_23_16_len 8
+#define reg_rsd_bit_err_cnt1_23_16_lsb 16
+#define xd_r_reg_rsd_abort_packet_cnt1_7_0  (*(volatile byte xdata *) 0xF72B)
+#define    r_reg_rsd_abort_packet_cnt1_7_0  0xF72B
+#define reg_rsd_abort_packet_cnt1_7_0_pos 0
+#define reg_rsd_abort_packet_cnt1_7_0_len 8
+#define reg_rsd_abort_packet_cnt1_7_0_lsb 0
+#define xd_r_reg_rsd_abort_packet_cnt1_15_8 (*(volatile byte xdata *) 0xF72C)
+#define    r_reg_rsd_abort_packet_cnt1_15_8 0xF72C
+#define reg_rsd_abort_packet_cnt1_15_8_pos 0
+#define reg_rsd_abort_packet_cnt1_15_8_len 8
+#define reg_rsd_abort_packet_cnt1_15_8_lsb 8
+#define xd_p_fec_rsd_ber_rst1   (*(volatile byte xdata *) 0xF72D)
+#define    p_fec_rsd_ber_rst1   0xF72D
+#define fec_rsd_ber_rst1_pos 0
+#define fec_rsd_ber_rst1_len 1
+#define fec_rsd_ber_rst1_lsb 0
+#define xd_p_reg_rsd_ber_rdy1   (*(volatile byte xdata *) 0xF72E)
+#define    p_reg_rsd_ber_rdy1   0xF72E
+#define reg_rsd_ber_rdy1_pos 0
+#define reg_rsd_ber_rdy1_len 1
+#define reg_rsd_ber_rdy1_lsb 0
+#define xd_p_reg_dca_txmod_sel  (*(volatile byte xdata *) 0xF72F)
+#define    p_reg_dca_txmod_sel  0xF72F
+#define reg_dca_txmod_sel_pos 0
+#define reg_dca_txmod_sel_len 1
+#define reg_dca_txmod_sel_lsb 0
+#define xd_p_reg_dca_platch (*(volatile byte xdata *) 0xF730)
+#define    p_reg_dca_platch 0xF730
+#define reg_dca_platch_pos 0
+#define reg_dca_platch_len 1
+#define reg_dca_platch_lsb 0
+#define xd_p_reg_dca_upper_chip (*(volatile byte xdata *) 0xF731)
+#define    p_reg_dca_upper_chip 0xF731
+#define reg_dca_upper_chip_pos 0
+#define reg_dca_upper_chip_len 1
+#define reg_dca_upper_chip_lsb 0
+#define xd_p_reg_dca_lower_chip (*(volatile byte xdata *) 0xF732)
+#define    p_reg_dca_lower_chip 0xF732
+#define reg_dca_lower_chip_pos 0
+#define reg_dca_lower_chip_len 1
+#define reg_dca_lower_chip_lsb 0
+#define xd_p_reg_dca_enl    (*(volatile byte xdata *) 0xF733)
+#define    p_reg_dca_enl    0xF733
+#define reg_dca_enl_pos 0
+#define reg_dca_enl_len 1
+#define reg_dca_enl_lsb 0
+#define xd_p_reg_dca_enu    (*(volatile byte xdata *) 0xF734)
+#define    p_reg_dca_enu    0xF734
+#define reg_dca_enu_pos 0
+#define reg_dca_enu_len 1
+#define reg_dca_enu_lsb 0
+#define xd_p_reg_dca_th (*(volatile byte xdata *) 0xF735)
+#define    p_reg_dca_th 0xF735
+#define reg_dca_th_pos 0
+#define reg_dca_th_len 5
+#define reg_dca_th_lsb 0
+#define xd_p_reg_dca_scale  (*(volatile byte xdata *) 0xF736)
+#define    p_reg_dca_scale  0xF736
+#define reg_dca_scale_pos 0
+#define reg_dca_scale_len 4
+#define reg_dca_scale_lsb 0
+#define xd_p_reg_dca_tone_7_0   (*(volatile byte xdata *) 0xF737)
+#define    p_reg_dca_tone_7_0   0xF737
+#define reg_dca_tone_7_0_pos 0
+#define reg_dca_tone_7_0_len 8
+#define reg_dca_tone_7_0_lsb 0
+#define xd_p_reg_dca_tone_12_8  (*(volatile byte xdata *) 0xF738)
+#define    p_reg_dca_tone_12_8  0xF738
+#define reg_dca_tone_12_8_pos 0
+#define reg_dca_tone_12_8_len 5
+#define reg_dca_tone_12_8_lsb 8
+#define xd_p_reg_dca_time_7_0   (*(volatile byte xdata *) 0xF739)
+#define    p_reg_dca_time_7_0   0xF739
+#define reg_dca_time_7_0_pos 0
+#define reg_dca_time_7_0_len 8
+#define reg_dca_time_7_0_lsb 0
+#define xd_p_reg_dca_time_15_8  (*(volatile byte xdata *) 0xF73A)
+#define    p_reg_dca_time_15_8  0xF73A
+#define reg_dca_time_15_8_pos 0
+#define reg_dca_time_15_8_len 8
+#define reg_dca_time_15_8_lsb 8
+#define xd_r_fec_dcasm  (*(volatile byte xdata *) 0xF73B)
+#define    r_fec_dcasm  0xF73B
+#define fec_dcasm_pos 0
+#define fec_dcasm_len 3
+#define fec_dcasm_lsb 0
+#define xd_p_reg_dca_stand_alone    (*(volatile byte xdata *) 0xF73C)
+#define    p_reg_dca_stand_alone    0xF73C
+#define reg_dca_stand_alone_pos 0
+#define reg_dca_stand_alone_len 1
+#define reg_dca_stand_alone_lsb 0
+#define xd_p_reg_dca_upper_out_en   (*(volatile byte xdata *) 0xF73D)
+#define    p_reg_dca_upper_out_en   0xF73D
+#define reg_dca_upper_out_en_pos 0
+#define reg_dca_upper_out_en_len 1
+#define reg_dca_upper_out_en_lsb 0
+#define xd_p_reg_dca_rc_en  (*(volatile byte xdata *) 0xF73E)
+#define    p_reg_dca_rc_en  0xF73E
+#define reg_dca_rc_en_pos 0
+#define reg_dca_rc_en_len 1
+#define reg_dca_rc_en_lsb 0
+#define xd_p_reg_dca_retrain_send   (*(volatile byte xdata *) 0xF73F)
+#define    p_reg_dca_retrain_send   0xF73F
+#define reg_dca_retrain_send_pos 0
+#define reg_dca_retrain_send_len 1
+#define reg_dca_retrain_send_lsb 0
+#define xd_p_reg_dca_retrain_rec    (*(volatile byte xdata *) 0xF740)
+#define    p_reg_dca_retrain_rec    0xF740
+#define reg_dca_retrain_rec_pos 0
+#define reg_dca_retrain_rec_len 1
+#define reg_dca_retrain_rec_lsb 0
+#define xd_p_reg_dca_gi_gap (*(volatile byte xdata *) 0xF741)
+#define    p_reg_dca_gi_gap 0xF741
+#define reg_dca_gi_gap_pos 0
+#define reg_dca_gi_gap_len 8
+#define reg_dca_gi_gap_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_txmod  (*(volatile byte xdata *) 0xF742)
+#define    r_reg_dca_rec_up_tpsd_txmod  0xF742
+#define reg_dca_rec_up_tpsd_txmod_pos 0
+#define reg_dca_rec_up_tpsd_txmod_len 2
+#define reg_dca_rec_up_tpsd_txmod_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_const  (*(volatile byte xdata *) 0xF743)
+#define    r_reg_dca_rec_up_tpsd_const  0xF743
+#define reg_dca_rec_up_tpsd_const_pos 0
+#define reg_dca_rec_up_tpsd_const_len 2
+#define reg_dca_rec_up_tpsd_const_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_indep  (*(volatile byte xdata *) 0xF744)
+#define    r_reg_dca_rec_up_tpsd_indep  0xF744
+#define reg_dca_rec_up_tpsd_indep_pos 0
+#define reg_dca_rec_up_tpsd_indep_len 1
+#define reg_dca_rec_up_tpsd_indep_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_hier   (*(volatile byte xdata *) 0xF745)
+#define    r_reg_dca_rec_up_tpsd_hier   0xF745
+#define reg_dca_rec_up_tpsd_hier_pos 0
+#define reg_dca_rec_up_tpsd_hier_len 2
+#define reg_dca_rec_up_tpsd_hier_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_hpcr   (*(volatile byte xdata *) 0xF746)
+#define    r_reg_dca_rec_up_tpsd_hpcr   0xF746
+#define reg_dca_rec_up_tpsd_hpcr_pos 0
+#define reg_dca_rec_up_tpsd_hpcr_len 3
+#define reg_dca_rec_up_tpsd_hpcr_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_lpcr   (*(volatile byte xdata *) 0xF747)
+#define    r_reg_dca_rec_up_tpsd_lpcr   0xF747
+#define reg_dca_rec_up_tpsd_lpcr_pos 0
+#define reg_dca_rec_up_tpsd_lpcr_len 3
+#define reg_dca_rec_up_tpsd_lpcr_lsb 0
+#define xd_r_reg_dca_rec_up_tpsd_lock   (*(volatile byte xdata *) 0xF748)
+#define    r_reg_dca_rec_up_tpsd_lock   0xF748
+#define reg_dca_rec_up_tpsd_lock_pos 0
+#define reg_dca_rec_up_tpsd_lock_len 1
+#define reg_dca_rec_up_tpsd_lock_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_txmod  (*(volatile byte xdata *) 0xF749)
+#define    r_reg_dca_rec_lo_tpsd_txmod  0xF749
+#define reg_dca_rec_lo_tpsd_txmod_pos 0
+#define reg_dca_rec_lo_tpsd_txmod_len 2
+#define reg_dca_rec_lo_tpsd_txmod_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_const  (*(volatile byte xdata *) 0xF74A)
+#define    r_reg_dca_rec_lo_tpsd_const  0xF74A
+#define reg_dca_rec_lo_tpsd_const_pos 0
+#define reg_dca_rec_lo_tpsd_const_len 2
+#define reg_dca_rec_lo_tpsd_const_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_indep  (*(volatile byte xdata *) 0xF74B)
+#define    r_reg_dca_rec_lo_tpsd_indep  0xF74B
+#define reg_dca_rec_lo_tpsd_indep_pos 0
+#define reg_dca_rec_lo_tpsd_indep_len 1
+#define reg_dca_rec_lo_tpsd_indep_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_hier   (*(volatile byte xdata *) 0xF74C)
+#define    r_reg_dca_rec_lo_tpsd_hier   0xF74C
+#define reg_dca_rec_lo_tpsd_hier_pos 0
+#define reg_dca_rec_lo_tpsd_hier_len 2
+#define reg_dca_rec_lo_tpsd_hier_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_hpcr   (*(volatile byte xdata *) 0xF74D)
+#define    r_reg_dca_rec_lo_tpsd_hpcr   0xF74D
+#define reg_dca_rec_lo_tpsd_hpcr_pos 0
+#define reg_dca_rec_lo_tpsd_hpcr_len 3
+#define reg_dca_rec_lo_tpsd_hpcr_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_lpcr   (*(volatile byte xdata *) 0xF74E)
+#define    r_reg_dca_rec_lo_tpsd_lpcr   0xF74E
+#define reg_dca_rec_lo_tpsd_lpcr_pos 0
+#define reg_dca_rec_lo_tpsd_lpcr_len 3
+#define reg_dca_rec_lo_tpsd_lpcr_lsb 0
+#define xd_r_reg_dca_rec_lo_tpsd_lock   (*(volatile byte xdata *) 0xF74F)
+#define    r_reg_dca_rec_lo_tpsd_lock   0xF74F
+#define reg_dca_rec_lo_tpsd_lock_pos 0
+#define reg_dca_rec_lo_tpsd_lock_len 1
+#define reg_dca_rec_lo_tpsd_lock_lsb 0
+#define xd_p_reg_dca_gpr_ctr_up_send    (*(volatile byte xdata *) 0xF750)
+#define    p_reg_dca_gpr_ctr_up_send    0xF750
+#define reg_dca_gpr_ctr_up_send_pos 0
+#define reg_dca_gpr_ctr_up_send_len 8
+#define reg_dca_gpr_ctr_up_send_lsb 0
+#define xd_p_reg_dca_gpr_dat_up_send_0  (*(volatile byte xdata *) 0xF751)
+#define    p_reg_dca_gpr_dat_up_send_0  0xF751
+#define reg_dca_gpr_dat_up_send_0_pos 0
+#define reg_dca_gpr_dat_up_send_0_len 8
+#define reg_dca_gpr_dat_up_send_0_lsb 0
+#define xd_p_reg_dca_gpr_dat_up_send_1  (*(volatile byte xdata *) 0xF752)
+#define    p_reg_dca_gpr_dat_up_send_1  0xF752
+#define reg_dca_gpr_dat_up_send_1_pos 0
+#define reg_dca_gpr_dat_up_send_1_len 8
+#define reg_dca_gpr_dat_up_send_1_lsb 0
+#define xd_p_reg_dca_gpr_dat_up_send_2  (*(volatile byte xdata *) 0xF753)
+#define    p_reg_dca_gpr_dat_up_send_2  0xF753
+#define reg_dca_gpr_dat_up_send_2_pos 0
+#define reg_dca_gpr_dat_up_send_2_len 8
+#define reg_dca_gpr_dat_up_send_2_lsb 0
+#define xd_p_reg_dca_gpr_dat_up_send_3  (*(volatile byte xdata *) 0xF754)
+#define    p_reg_dca_gpr_dat_up_send_3  0xF754
+#define reg_dca_gpr_dat_up_send_3_pos 0
+#define reg_dca_gpr_dat_up_send_3_len 8
+#define reg_dca_gpr_dat_up_send_3_lsb 0
+#define xd_p_reg_dca_gpr_dat_up_send_4  (*(volatile byte xdata *) 0xF755)
+#define    p_reg_dca_gpr_dat_up_send_4  0xF755
+#define reg_dca_gpr_dat_up_send_4_pos 0
+#define reg_dca_gpr_dat_up_send_4_len 8
+#define reg_dca_gpr_dat_up_send_4_lsb 0
+#define xd_p_reg_dca_gpr_dat_up_send_5  (*(volatile byte xdata *) 0xF756)
+#define    p_reg_dca_gpr_dat_up_send_5  0xF756
+#define reg_dca_gpr_dat_up_send_5_pos 0
+#define reg_dca_gpr_dat_up_send_5_len 8
+#define reg_dca_gpr_dat_up_send_5_lsb 0
+#define xd_p_reg_dca_over_wr_up_send    (*(volatile byte xdata *) 0xF757)
+#define    p_reg_dca_over_wr_up_send    0xF757
+#define reg_dca_over_wr_up_send_pos 0
+#define reg_dca_over_wr_up_send_len 1
+#define reg_dca_over_wr_up_send_lsb 0
+#define xd_p_reg_dca_int_up_send    (*(volatile byte xdata *) 0xF758)
+#define    p_reg_dca_int_up_send    0xF758
+#define reg_dca_int_up_send_pos 0
+#define reg_dca_int_up_send_len 1
+#define reg_dca_int_up_send_lsb 0
+#define xd_p_reg_dca_gpr_ctr_lo_send    (*(volatile byte xdata *) 0xF759)
+#define    p_reg_dca_gpr_ctr_lo_send    0xF759
+#define reg_dca_gpr_ctr_lo_send_pos 0
+#define reg_dca_gpr_ctr_lo_send_len 8
+#define reg_dca_gpr_ctr_lo_send_lsb 0
+#define xd_p_reg_dca_gpr_dat_lo_send_0  (*(volatile byte xdata *) 0xF75A)
+#define    p_reg_dca_gpr_dat_lo_send_0  0xF75A
+#define reg_dca_gpr_dat_lo_send_0_pos 0
+#define reg_dca_gpr_dat_lo_send_0_len 8
+#define reg_dca_gpr_dat_lo_send_0_lsb 0
+#define xd_p_reg_dca_gpr_dat_lo_send_1  (*(volatile byte xdata *) 0xF75B)
+#define    p_reg_dca_gpr_dat_lo_send_1  0xF75B
+#define reg_dca_gpr_dat_lo_send_1_pos 0
+#define reg_dca_gpr_dat_lo_send_1_len 8
+#define reg_dca_gpr_dat_lo_send_1_lsb 0
+#define xd_p_reg_dca_gpr_dat_lo_send_2  (*(volatile byte xdata *) 0xF75C)
+#define    p_reg_dca_gpr_dat_lo_send_2  0xF75C
+#define reg_dca_gpr_dat_lo_send_2_pos 0
+#define reg_dca_gpr_dat_lo_send_2_len 8
+#define reg_dca_gpr_dat_lo_send_2_lsb 0
+#define xd_p_reg_dca_gpr_dat_lo_send_3  (*(volatile byte xdata *) 0xF75D)
+#define    p_reg_dca_gpr_dat_lo_send_3  0xF75D
+#define reg_dca_gpr_dat_lo_send_3_pos 0
+#define reg_dca_gpr_dat_lo_send_3_len 8
+#define reg_dca_gpr_dat_lo_send_3_lsb 0
+#define xd_p_reg_dca_gpr_dat_lo_send_4  (*(volatile byte xdata *) 0xF75E)
+#define    p_reg_dca_gpr_dat_lo_send_4  0xF75E
+#define reg_dca_gpr_dat_lo_send_4_pos 0
+#define reg_dca_gpr_dat_lo_send_4_len 8
+#define reg_dca_gpr_dat_lo_send_4_lsb 0
+#define xd_p_reg_dca_gpr_dat_lo_send_5  (*(volatile byte xdata *) 0xF75F)
+#define    p_reg_dca_gpr_dat_lo_send_5  0xF75F
+#define reg_dca_gpr_dat_lo_send_5_pos 0
+#define reg_dca_gpr_dat_lo_send_5_len 8
+#define reg_dca_gpr_dat_lo_send_5_lsb 0
+#define xd_p_reg_dca_over_wr_lo_send    (*(volatile byte xdata *) 0xF760)
+#define    p_reg_dca_over_wr_lo_send    0xF760
+#define reg_dca_over_wr_lo_send_pos 0
+#define reg_dca_over_wr_lo_send_len 1
+#define reg_dca_over_wr_lo_send_lsb 0
+#define xd_p_reg_dca_int_lo_send    (*(volatile byte xdata *) 0xF761)
+#define    p_reg_dca_int_lo_send    0xF761
+#define reg_dca_int_lo_send_pos 0
+#define reg_dca_int_lo_send_len 1
+#define reg_dca_int_lo_send_lsb 0
+#define xd_r_reg_dca_gpr_ctr_up_rec (*(volatile byte xdata *) 0xF762)
+#define    r_reg_dca_gpr_ctr_up_rec 0xF762
+#define reg_dca_gpr_ctr_up_rec_pos 0
+#define reg_dca_gpr_ctr_up_rec_len 8
+#define reg_dca_gpr_ctr_up_rec_lsb 0
+#define xd_r_reg_dca_gpr_dat_up_rec_0   (*(volatile byte xdata *) 0xF763)
+#define    r_reg_dca_gpr_dat_up_rec_0   0xF763
+#define reg_dca_gpr_dat_up_rec_0_pos 0
+#define reg_dca_gpr_dat_up_rec_0_len 8
+#define reg_dca_gpr_dat_up_rec_0_lsb 0
+#define xd_r_reg_dca_gpr_dat_up_rec_1   (*(volatile byte xdata *) 0xF764)
+#define    r_reg_dca_gpr_dat_up_rec_1   0xF764
+#define reg_dca_gpr_dat_up_rec_1_pos 0
+#define reg_dca_gpr_dat_up_rec_1_len 8
+#define reg_dca_gpr_dat_up_rec_1_lsb 0
+#define xd_r_reg_dca_gpr_dat_up_rec_2   (*(volatile byte xdata *) 0xF765)
+#define    r_reg_dca_gpr_dat_up_rec_2   0xF765
+#define reg_dca_gpr_dat_up_rec_2_pos 0
+#define reg_dca_gpr_dat_up_rec_2_len 8
+#define reg_dca_gpr_dat_up_rec_2_lsb 0
+#define xd_r_reg_dca_gpr_dat_up_rec_3   (*(volatile byte xdata *) 0xF766)
+#define    r_reg_dca_gpr_dat_up_rec_3   0xF766
+#define reg_dca_gpr_dat_up_rec_3_pos 0
+#define reg_dca_gpr_dat_up_rec_3_len 8
+#define reg_dca_gpr_dat_up_rec_3_lsb 0
+#define xd_r_reg_dca_gpr_dat_up_rec_4   (*(volatile byte xdata *) 0xF767)
+#define    r_reg_dca_gpr_dat_up_rec_4   0xF767
+#define reg_dca_gpr_dat_up_rec_4_pos 0
+#define reg_dca_gpr_dat_up_rec_4_len 8
+#define reg_dca_gpr_dat_up_rec_4_lsb 0
+#define xd_r_reg_dca_gpr_dat_up_rec_5   (*(volatile byte xdata *) 0xF768)
+#define    r_reg_dca_gpr_dat_up_rec_5   0xF768
+#define reg_dca_gpr_dat_up_rec_5_pos 0
+#define reg_dca_gpr_dat_up_rec_5_len 8
+#define reg_dca_gpr_dat_up_rec_5_lsb 0
+#define xd_r_reg_dca_over_wr_up_rec (*(volatile byte xdata *) 0xF769)
+#define    r_reg_dca_over_wr_up_rec 0xF769
+#define reg_dca_over_wr_up_rec_pos 0
+#define reg_dca_over_wr_up_rec_len 1
+#define reg_dca_over_wr_up_rec_lsb 0
+#define xd_p_reg_dca_int_up_rec (*(volatile byte xdata *) 0xF76A)
+#define    p_reg_dca_int_up_rec 0xF76A
+#define reg_dca_int_up_rec_pos 0
+#define reg_dca_int_up_rec_len 1
+#define reg_dca_int_up_rec_lsb 0
+#define xd_p_reg_dca_fw_read_yet_up (*(volatile byte xdata *) 0xF76B)
+#define    p_reg_dca_fw_read_yet_up 0xF76B
+#define reg_dca_fw_read_yet_up_pos 0
+#define reg_dca_fw_read_yet_up_len 1
+#define reg_dca_fw_read_yet_up_lsb 0
+#define xd_r_reg_dca_gpr_ctr_lo_rec (*(volatile byte xdata *) 0xF76C)
+#define    r_reg_dca_gpr_ctr_lo_rec 0xF76C
+#define reg_dca_gpr_ctr_lo_rec_pos 0
+#define reg_dca_gpr_ctr_lo_rec_len 8
+#define reg_dca_gpr_ctr_lo_rec_lsb 0
+#define xd_r_reg_dca_gpr_dat_lo_rec_0   (*(volatile byte xdata *) 0xF76D)
+#define    r_reg_dca_gpr_dat_lo_rec_0   0xF76D
+#define reg_dca_gpr_dat_lo_rec_0_pos 0
+#define reg_dca_gpr_dat_lo_rec_0_len 8
+#define reg_dca_gpr_dat_lo_rec_0_lsb 0
+#define xd_r_reg_dca_gpr_dat_lo_rec_1   (*(volatile byte xdata *) 0xF76E)
+#define    r_reg_dca_gpr_dat_lo_rec_1   0xF76E
+#define reg_dca_gpr_dat_lo_rec_1_pos 0
+#define reg_dca_gpr_dat_lo_rec_1_len 8
+#define reg_dca_gpr_dat_lo_rec_1_lsb 0
+#define xd_r_reg_dca_gpr_dat_lo_rec_2   (*(volatile byte xdata *) 0xF76F)
+#define    r_reg_dca_gpr_dat_lo_rec_2   0xF76F
+#define reg_dca_gpr_dat_lo_rec_2_pos 0
+#define reg_dca_gpr_dat_lo_rec_2_len 8
+#define reg_dca_gpr_dat_lo_rec_2_lsb 0
+#define xd_r_reg_dca_gpr_dat_lo_rec_3   (*(volatile byte xdata *) 0xF770)
+#define    r_reg_dca_gpr_dat_lo_rec_3   0xF770
+#define reg_dca_gpr_dat_lo_rec_3_pos 0
+#define reg_dca_gpr_dat_lo_rec_3_len 8
+#define reg_dca_gpr_dat_lo_rec_3_lsb 0
+#define xd_r_reg_dca_gpr_dat_lo_rec_4   (*(volatile byte xdata *) 0xF771)
+#define    r_reg_dca_gpr_dat_lo_rec_4   0xF771
+#define reg_dca_gpr_dat_lo_rec_4_pos 0
+#define reg_dca_gpr_dat_lo_rec_4_len 8
+#define reg_dca_gpr_dat_lo_rec_4_lsb 0
+#define xd_r_reg_dca_gpr_dat_lo_rec_5   (*(volatile byte xdata *) 0xF772)
+#define    r_reg_dca_gpr_dat_lo_rec_5   0xF772
+#define reg_dca_gpr_dat_lo_rec_5_pos 0
+#define reg_dca_gpr_dat_lo_rec_5_len 8
+#define reg_dca_gpr_dat_lo_rec_5_lsb 0
+#define xd_r_reg_dca_over_wr_lo_rec (*(volatile byte xdata *) 0xF773)
+#define    r_reg_dca_over_wr_lo_rec 0xF773
+#define reg_dca_over_wr_lo_rec_pos 0
+#define reg_dca_over_wr_lo_rec_len 1
+#define reg_dca_over_wr_lo_rec_lsb 0
+#define xd_p_reg_dca_int_lo_rec (*(volatile byte xdata *) 0xF774)
+#define    p_reg_dca_int_lo_rec 0xF774
+#define reg_dca_int_lo_rec_pos 0
+#define reg_dca_int_lo_rec_len 1
+#define reg_dca_int_lo_rec_lsb 0
+#define xd_p_reg_dca_fw_read_yet_lo (*(volatile byte xdata *) 0xF775)
+#define    p_reg_dca_fw_read_yet_lo 0xF775
+#define reg_dca_fw_read_yet_lo_pos 0
+#define reg_dca_fw_read_yet_lo_len 1
+#define reg_dca_fw_read_yet_lo_lsb 0
+#define xd_p_reg_dca_en (*(volatile byte xdata *) 0xF776)
+#define    p_reg_dca_en 0xF776
+#define reg_dca_en_pos 0
+#define reg_dca_en_len 1
+#define reg_dca_en_lsb 0
+#define xd_p_reg_dca_ulrdy_delay    (*(volatile byte xdata *) 0xF777)
+#define    p_reg_dca_ulrdy_delay    0xF777
+#define reg_dca_ulrdy_delay_pos 0
+#define reg_dca_ulrdy_delay_len 8
+#define reg_dca_ulrdy_delay_lsb 0
+#define xd_p_reg_dca_fpga_latch (*(volatile byte xdata *) 0xF778)
+#define    p_reg_dca_fpga_latch 0xF778
+#define reg_dca_fpga_latch_pos 0
+#define reg_dca_fpga_latch_len 8
+#define reg_dca_fpga_latch_lsb 0
+#define xd_p_reg_dca_vldld_err  (*(volatile byte xdata *) 0xF779)
+#define    p_reg_dca_vldld_err  0xF779
+#define reg_dca_vldld_err_pos 0
+#define reg_dca_vldld_err_len 1
+#define reg_dca_vldld_err_lsb 0
+#define xd_p_reg_dca_vldud_err  (*(volatile byte xdata *) 0xF77A)
+#define    p_reg_dca_vldud_err  0xF77A
+#define reg_dca_vldud_err_pos 0
+#define reg_dca_vldud_err_len 1
+#define reg_dca_vldud_err_lsb 0
+#define xd_p_reg_dca_modeu_err  (*(volatile byte xdata *) 0xF77B)
+#define    p_reg_dca_modeu_err  0xF77B
+#define reg_dca_modeu_err_pos 0
+#define reg_dca_modeu_err_len 1
+#define reg_dca_modeu_err_lsb 0
+#define xd_p_reg_dca_model_err  (*(volatile byte xdata *) 0xF77C)
+#define    p_reg_dca_model_err  0xF77C
+#define reg_dca_model_err_pos 0
+#define reg_dca_model_err_len 1
+#define reg_dca_model_err_lsb 0
+#define xd_p_reg_dca_interrupt  (*(volatile byte xdata *) 0xF77D)
+#define    p_reg_dca_interrupt  0xF77D
+#define reg_dca_interrupt_pos 0
+#define reg_dca_interrupt_len 1
+#define reg_dca_interrupt_lsb 0
+#define xd_p_reg_dca_auto_reset_en  (*(volatile byte xdata *) 0xF77E)
+#define    p_reg_dca_auto_reset_en  0xF77E
+#define reg_dca_auto_reset_en_pos 0
+#define reg_dca_auto_reset_en_len 1
+#define reg_dca_auto_reset_en_lsb 0
+#define xd_p_reg_qnt_valuew_7_0 (*(volatile byte xdata *) 0xF77F)
+#define    p_reg_qnt_valuew_7_0 0xF77F
+#define reg_qnt_valuew_7_0_pos 0
+#define reg_qnt_valuew_7_0_len 8
+#define reg_qnt_valuew_7_0_lsb 0
+#define xd_p_reg_qnt_valuew_10_8    (*(volatile byte xdata *) 0xF780)
+#define    p_reg_qnt_valuew_10_8    0xF780
+#define reg_qnt_valuew_10_8_pos 0
+#define reg_qnt_valuew_10_8_len 3
+#define reg_qnt_valuew_10_8_lsb 8
+#define xd_p_reg_qnt_nfvaluew_7_0   (*(volatile byte xdata *) 0xF781)
+#define    p_reg_qnt_nfvaluew_7_0   0xF781
+#define reg_qnt_nfvaluew_7_0_pos 0
+#define reg_qnt_nfvaluew_7_0_len 8
+#define reg_qnt_nfvaluew_7_0_lsb 0
+#define xd_p_reg_qnt_nfvaluew_10_8  (*(volatile byte xdata *) 0xF782)
+#define    p_reg_qnt_nfvaluew_10_8  0xF782
+#define reg_qnt_nfvaluew_10_8_pos 0
+#define reg_qnt_nfvaluew_10_8_len 3
+#define reg_qnt_nfvaluew_10_8_lsb 8
+#define xd_p_reg_qnt_flatness_thr_7_0   (*(volatile byte xdata *) 0xF783)
+#define    p_reg_qnt_flatness_thr_7_0   0xF783
+#define reg_qnt_flatness_thr_7_0_pos 0
+#define reg_qnt_flatness_thr_7_0_len 8
+#define reg_qnt_flatness_thr_7_0_lsb 0
+#define xd_p_reg_qnt_flatness_thr_8 (*(volatile byte xdata *) 0xF784)
+#define    p_reg_qnt_flatness_thr_8 0xF784
+#define reg_qnt_flatness_thr_8_pos 0
+#define reg_qnt_flatness_thr_8_len 1
+#define reg_qnt_flatness_thr_8_lsb 8
+#define xd_p_reg_llr_to_be_monitor  (*(volatile byte xdata *) 0xF785)
+#define    p_reg_llr_to_be_monitor  0xF785
+#define reg_llr_to_be_monitor_pos 0
+#define reg_llr_to_be_monitor_len 1
+#define reg_llr_to_be_monitor_lsb 0
+#define xd_p_reg_qnt_vbc_rdy    (*(volatile byte xdata *) 0xF786)
+#define    p_reg_qnt_vbc_rdy    0xF786
+#define reg_qnt_vbc_rdy_pos 0
+#define reg_qnt_vbc_rdy_len 1
+#define reg_qnt_vbc_rdy_lsb 0
+#define xd_p_reg_qnt_noncmb_vbc_rdy (*(volatile byte xdata *) 0xF787)
+#define    p_reg_qnt_noncmb_vbc_rdy 0xF787
+#define reg_qnt_noncmb_vbc_rdy_pos 0
+#define reg_qnt_noncmb_vbc_rdy_len 1
+#define reg_qnt_noncmb_vbc_rdy_lsb 0
+#define xd_p_reg_use_eh2_mean   (*(volatile byte xdata *) 0xF788)
+#define    p_reg_use_eh2_mean   0xF788
+#define reg_use_eh2_mean_pos 0
+#define reg_use_eh2_mean_len 1
+#define reg_use_eh2_mean_lsb 0
+#define xd_p_reg_qnt_vbc_ccid_mode  (*(volatile byte xdata *) 0xF789)
+#define    p_reg_qnt_vbc_ccid_mode  0xF789
+#define reg_qnt_vbc_ccid_mode_pos 0
+#define reg_qnt_vbc_ccid_mode_len 1
+#define reg_qnt_vbc_ccid_mode_lsb 0
+#define xd_p_reg_qnt_cci_bandsize   (*(volatile byte xdata *) 0xF78A)
+#define    p_reg_qnt_cci_bandsize   0xF78A
+#define reg_qnt_cci_bandsize_pos 0
+#define reg_qnt_cci_bandsize_len 4
+#define reg_qnt_cci_bandsize_lsb 0
+#define xd_p_reg_qnt_vbc_sframe_num (*(volatile byte xdata *) 0xF78B)
+#define    p_reg_qnt_vbc_sframe_num 0xF78B
+#define reg_qnt_vbc_sframe_num_pos 0
+#define reg_qnt_vbc_sframe_num_len 8
+#define reg_qnt_vbc_sframe_num_lsb 0
+#define xd_p_reg_sbx_gain_diff_7_0  (*(volatile byte xdata *) 0xF78C)
+#define    p_reg_sbx_gain_diff_7_0  0xF78C
+#define reg_sbx_gain_diff_7_0_pos 0
+#define reg_sbx_gain_diff_7_0_len 8
+#define reg_sbx_gain_diff_7_0_lsb 0
+#define xd_p_reg_sbx_gain_diff_8    (*(volatile byte xdata *) 0xF78D)
+#define    p_reg_sbx_gain_diff_8    0xF78D
+#define reg_sbx_gain_diff_8_pos 0
+#define reg_sbx_gain_diff_8_len 1
+#define reg_sbx_gain_diff_8_lsb 8
+#define xd_p_reg_sbx_gain_diff_rdy  (*(volatile byte xdata *) 0xF78E)
+#define    p_reg_sbx_gain_diff_rdy  0xF78E
+#define reg_sbx_gain_diff_rdy_pos 0
+#define reg_sbx_gain_diff_rdy_len 1
+#define reg_sbx_gain_diff_rdy_lsb 0
+#define xd_p_reg_sbx_noncmb_gain_diff_7_0   (*(volatile byte xdata *) 0xF78F)
+#define    p_reg_sbx_noncmb_gain_diff_7_0   0xF78F
+#define reg_sbx_noncmb_gain_diff_7_0_pos 0
+#define reg_sbx_noncmb_gain_diff_7_0_len 8
+#define reg_sbx_noncmb_gain_diff_7_0_lsb 0
+#define xd_p_reg_sbx_noncmb_gain_diff_8 (*(volatile byte xdata *) 0xF790)
+#define    p_reg_sbx_noncmb_gain_diff_8 0xF790
+#define reg_sbx_noncmb_gain_diff_8_pos 0
+#define reg_sbx_noncmb_gain_diff_8_len 1
+#define reg_sbx_noncmb_gain_diff_8_lsb 8
+#define xd_p_reg_sbx_noncmb_gain_diff_rdy   (*(volatile byte xdata *) 0xF791)
+#define    p_reg_sbx_noncmb_gain_diff_rdy   0xF791
+#define reg_sbx_noncmb_gain_diff_rdy_pos 0
+#define reg_sbx_noncmb_gain_diff_rdy_len 1
+#define reg_sbx_noncmb_gain_diff_rdy_lsb 0
+#define xd_r_reg_qnt_vbc_err_7_0    (*(volatile byte xdata *) 0xF792)
+#define    r_reg_qnt_vbc_err_7_0    0xF792
+#define reg_qnt_vbc_err_7_0_pos 0
+#define reg_qnt_vbc_err_7_0_len 8
+#define reg_qnt_vbc_err_7_0_lsb 0
+#define xd_r_reg_qnt_vbc_err_15_8   (*(volatile byte xdata *) 0xF793)
+#define    r_reg_qnt_vbc_err_15_8   0xF793
+#define reg_qnt_vbc_err_15_8_pos 0
+#define reg_qnt_vbc_err_15_8_len 8
+#define reg_qnt_vbc_err_15_8_lsb 8
+#define xd_r_reg_qnt_vbc_err_23_16  (*(volatile byte xdata *) 0xF794)
+#define    r_reg_qnt_vbc_err_23_16  0xF794
+#define reg_qnt_vbc_err_23_16_pos 0
+#define reg_qnt_vbc_err_23_16_len 8
+#define reg_qnt_vbc_err_23_16_lsb 16
+#define xd_r_reg_qnt_noncmb_vbc_err_7_0 (*(volatile byte xdata *) 0xF795)
+#define    r_reg_qnt_noncmb_vbc_err_7_0 0xF795
+#define reg_qnt_noncmb_vbc_err_7_0_pos 0
+#define reg_qnt_noncmb_vbc_err_7_0_len 8
+#define reg_qnt_noncmb_vbc_err_7_0_lsb 0
+#define xd_r_reg_qnt_noncmb_vbc_err_15_8    (*(volatile byte xdata *) 0xF796)
+#define    r_reg_qnt_noncmb_vbc_err_15_8    0xF796
+#define reg_qnt_noncmb_vbc_err_15_8_pos 0
+#define reg_qnt_noncmb_vbc_err_15_8_len 8
+#define reg_qnt_noncmb_vbc_err_15_8_lsb 8
+#define xd_r_reg_qnt_noncmb_vbc_err_23_16   (*(volatile byte xdata *) 0xF797)
+#define    r_reg_qnt_noncmb_vbc_err_23_16   0xF797
+#define reg_qnt_noncmb_vbc_err_23_16_pos 0
+#define reg_qnt_noncmb_vbc_err_23_16_len 8
+#define reg_qnt_noncmb_vbc_err_23_16_lsb 16
+#define xd_p_reg_sbx_signalquality_threshold    (*(volatile byte xdata *) 0xF798)
+#define    p_reg_sbx_signalquality_threshold    0xF798
+#define reg_sbx_signalquality_threshold_pos 0
+#define reg_sbx_signalquality_threshold_len 4
+#define reg_sbx_signalquality_threshold_lsb 0
+#define xd_r_reg_sbx_signalquality_ind  (*(volatile byte xdata *) 0xF799)
+#define    r_reg_sbx_signalquality_ind  0xF799
+#define reg_sbx_signalquality_ind_pos 0
+#define reg_sbx_signalquality_ind_len 1
+#define reg_sbx_signalquality_ind_lsb 0
+#define xd_p_reg_p_sbxqnt_th1   (*(volatile byte xdata *) 0xF79A)
+#define    p_reg_p_sbxqnt_th1   0xF79A
+#define reg_p_sbxqnt_th1_pos 0
+#define reg_p_sbxqnt_th1_len 8
+#define reg_p_sbxqnt_th1_lsb 0
+#define xd_p_reg_p_sbxqnt_th2   (*(volatile byte xdata *) 0xF79B)
+#define    p_reg_p_sbxqnt_th2   0xF79B
+#define reg_p_sbxqnt_th2_pos 0
+#define reg_p_sbxqnt_th2_len 8
+#define reg_p_sbxqnt_th2_lsb 0
+#define xd_p_reg_p_sbxqnt_th3   (*(volatile byte xdata *) 0xF79C)
+#define    p_reg_p_sbxqnt_th3   0xF79C
+#define reg_p_sbxqnt_th3_pos 0
+#define reg_p_sbxqnt_th3_len 8
+#define reg_p_sbxqnt_th3_lsb 0
+#define xd_p_reg_p_sbxqnt_th4   (*(volatile byte xdata *) 0xF79D)
+#define    p_reg_p_sbxqnt_th4   0xF79D
+#define reg_p_sbxqnt_th4_pos 0
+#define reg_p_sbxqnt_th4_len 8
+#define reg_p_sbxqnt_th4_lsb 0
+#define xd_p_reg_p_sbxqnt_th5   (*(volatile byte xdata *) 0xF79E)
+#define    p_reg_p_sbxqnt_th5   0xF79E
+#define reg_p_sbxqnt_th5_pos 0
+#define reg_p_sbxqnt_th5_len 8
+#define reg_p_sbxqnt_th5_lsb 0
+#define xd_p_reg_p_sbxqnt_th6   (*(volatile byte xdata *) 0xF79F)
+#define    p_reg_p_sbxqnt_th6   0xF79F
+#define reg_p_sbxqnt_th6_pos 0
+#define reg_p_sbxqnt_th6_len 8
+#define reg_p_sbxqnt_th6_lsb 0
+#define xd_p_reg_p_sbxqnt_th7   (*(volatile byte xdata *) 0xF800)
+#define    p_reg_p_sbxqnt_th7   0xF800
+#define reg_p_sbxqnt_th7_pos 0
+#define reg_p_sbxqnt_th7_len 8
+#define reg_p_sbxqnt_th7_lsb 0
+#define xd_p_reg_p_sbxqnt_th8   (*(volatile byte xdata *) 0xF801)
+#define    p_reg_p_sbxqnt_th8   0xF801
+#define reg_p_sbxqnt_th8_pos 0
+#define reg_p_sbxqnt_th8_len 8
+#define reg_p_sbxqnt_th8_lsb 0
+#define xd_p_reg_p_sbxqnt_th9   (*(volatile byte xdata *) 0xF802)
+#define    p_reg_p_sbxqnt_th9   0xF802
+#define reg_p_sbxqnt_th9_pos 0
+#define reg_p_sbxqnt_th9_len 8
+#define reg_p_sbxqnt_th9_lsb 0
+#define xd_p_reg_p_sbxqnt_th10  (*(volatile byte xdata *) 0xF803)
+#define    p_reg_p_sbxqnt_th10  0xF803
+#define reg_p_sbxqnt_th10_pos 0
+#define reg_p_sbxqnt_th10_len 8
+#define reg_p_sbxqnt_th10_lsb 0
+#define xd_p_reg_p_sbxqnt_th11  (*(volatile byte xdata *) 0xF804)
+#define    p_reg_p_sbxqnt_th11  0xF804
+#define reg_p_sbxqnt_th11_pos 0
+#define reg_p_sbxqnt_th11_len 8
+#define reg_p_sbxqnt_th11_lsb 0
+#define xd_p_reg_p_sbxqnt_th12  (*(volatile byte xdata *) 0xF805)
+#define    p_reg_p_sbxqnt_th12  0xF805
+#define reg_p_sbxqnt_th12_pos 0
+#define reg_p_sbxqnt_th12_len 8
+#define reg_p_sbxqnt_th12_lsb 0
+#define xd_p_reg_p_sbxqnt_th13_7_0  (*(volatile byte xdata *) 0xF806)
+#define    p_reg_p_sbxqnt_th13_7_0  0xF806
+#define reg_p_sbxqnt_th13_7_0_pos 0
+#define reg_p_sbxqnt_th13_7_0_len 8
+#define reg_p_sbxqnt_th13_7_0_lsb 0
+#define xd_p_reg_p_sbxqnt_th13_9_8  (*(volatile byte xdata *) 0xF807)
+#define    p_reg_p_sbxqnt_th13_9_8  0xF807
+#define reg_p_sbxqnt_th13_9_8_pos 0
+#define reg_p_sbxqnt_th13_9_8_len 2
+#define reg_p_sbxqnt_th13_9_8_lsb 8
+#define xd_p_reg_p_sbxqnt_th14_7_0  (*(volatile byte xdata *) 0xF808)
+#define    p_reg_p_sbxqnt_th14_7_0  0xF808
+#define reg_p_sbxqnt_th14_7_0_pos 0
+#define reg_p_sbxqnt_th14_7_0_len 8
+#define reg_p_sbxqnt_th14_7_0_lsb 0
+#define xd_p_reg_p_sbxqnt_th14_9_8  (*(volatile byte xdata *) 0xF809)
+#define    p_reg_p_sbxqnt_th14_9_8  0xF809
+#define reg_p_sbxqnt_th14_9_8_pos 0
+#define reg_p_sbxqnt_th14_9_8_len 2
+#define reg_p_sbxqnt_th14_9_8_lsb 8
+#define xd_p_reg_p_sbxqnt_th15_7_0  (*(volatile byte xdata *) 0xF80A)
+#define    p_reg_p_sbxqnt_th15_7_0  0xF80A
+#define reg_p_sbxqnt_th15_7_0_pos 0
+#define reg_p_sbxqnt_th15_7_0_len 8
+#define reg_p_sbxqnt_th15_7_0_lsb 0
+#define xd_p_reg_p_sbxqnt_th15_9_8  (*(volatile byte xdata *) 0xF80B)
+#define    p_reg_p_sbxqnt_th15_9_8  0xF80B
+#define reg_p_sbxqnt_th15_9_8_pos 0
+#define reg_p_sbxqnt_th15_9_8_len 2
+#define reg_p_sbxqnt_th15_9_8_lsb 8
+#define xd_p_reg_p_sbxqnt_vzh2_th0  (*(volatile byte xdata *) 0xF80C)
+#define    p_reg_p_sbxqnt_vzh2_th0  0xF80C
+#define reg_p_sbxqnt_vzh2_th0_pos 0
+#define reg_p_sbxqnt_vzh2_th0_len 8
+#define reg_p_sbxqnt_vzh2_th0_lsb 0
+#define xd_p_reg_p_sbxqnt_vzh2_th1  (*(volatile byte xdata *) 0xF80D)
+#define    p_reg_p_sbxqnt_vzh2_th1  0xF80D
+#define reg_p_sbxqnt_vzh2_th1_pos 0
+#define reg_p_sbxqnt_vzh2_th1_len 8
+#define reg_p_sbxqnt_vzh2_th1_lsb 0
+#define xd_p_reg_p_sbxqnt_vzh2_th2  (*(volatile byte xdata *) 0xF80E)
+#define    p_reg_p_sbxqnt_vzh2_th2  0xF80E
+#define reg_p_sbxqnt_vzh2_th2_pos 0
+#define reg_p_sbxqnt_vzh2_th2_len 8
+#define reg_p_sbxqnt_vzh2_th2_lsb 0
+#define xd_p_reg_p_qnt_w_comp1  (*(volatile byte xdata *) 0xF80F)
+#define    p_reg_p_qnt_w_comp1  0xF80F
+#define reg_p_qnt_w_comp1_pos 0
+#define reg_p_qnt_w_comp1_len 8
+#define reg_p_qnt_w_comp1_lsb 0
+#define xd_p_reg_p_qnt_w_comp2  (*(volatile byte xdata *) 0xF810)
+#define    p_reg_p_qnt_w_comp2  0xF810
+#define reg_p_qnt_w_comp2_pos 0
+#define reg_p_qnt_w_comp2_len 8
+#define reg_p_qnt_w_comp2_lsb 0
+#define xd_p_reg_p_qnt_w_comp3  (*(volatile byte xdata *) 0xF811)
+#define    p_reg_p_qnt_w_comp3  0xF811
+#define reg_p_qnt_w_comp3_pos 0
+#define reg_p_qnt_w_comp3_len 8
+#define reg_p_qnt_w_comp3_lsb 0
+#define xd_p_reg_p_vtb_in_0 (*(volatile byte xdata *) 0xF821)
+#define    p_reg_p_vtb_in_0 0xF821
+#define reg_p_vtb_in_0_pos 0
+#define reg_p_vtb_in_0_len 6
+#define reg_p_vtb_in_0_lsb 0
+#define xd_p_reg_p_vtb_in_1 (*(volatile byte xdata *) 0xF822)
+#define    p_reg_p_vtb_in_1 0xF822
+#define reg_p_vtb_in_1_pos 0
+#define reg_p_vtb_in_1_len 6
+#define reg_p_vtb_in_1_lsb 0
+#define xd_p_reg_p_vtb_in_2 (*(volatile byte xdata *) 0xF823)
+#define    p_reg_p_vtb_in_2 0xF823
+#define reg_p_vtb_in_2_pos 0
+#define reg_p_vtb_in_2_len 6
+#define reg_p_vtb_in_2_lsb 0
+#define xd_p_reg_p_vtb_in_3 (*(volatile byte xdata *) 0xF824)
+#define    p_reg_p_vtb_in_3 0xF824
+#define reg_p_vtb_in_3_pos 0
+#define reg_p_vtb_in_3_len 6
+#define reg_p_vtb_in_3_lsb 0
+#define xd_p_reg_p_vtb_in_4 (*(volatile byte xdata *) 0xF825)
+#define    p_reg_p_vtb_in_4 0xF825
+#define reg_p_vtb_in_4_pos 0
+#define reg_p_vtb_in_4_len 6
+#define reg_p_vtb_in_4_lsb 0
+#define xd_p_reg_p_vtb_in_5 (*(volatile byte xdata *) 0xF826)
+#define    p_reg_p_vtb_in_5 0xF826
+#define reg_p_vtb_in_5_pos 0
+#define reg_p_vtb_in_5_len 6
+#define reg_p_vtb_in_5_lsb 0
+#define xd_p_reg_p_vtb_in_6 (*(volatile byte xdata *) 0xF827)
+#define    p_reg_p_vtb_in_6 0xF827
+#define reg_p_vtb_in_6_pos 0
+#define reg_p_vtb_in_6_len 6
+#define reg_p_vtb_in_6_lsb 0
+#define xd_p_reg_p_vtb_in_7 (*(volatile byte xdata *) 0xF828)
+#define    p_reg_p_vtb_in_7 0xF828
+#define reg_p_vtb_in_7_pos 0
+#define reg_p_vtb_in_7_len 6
+#define reg_p_vtb_in_7_lsb 0
+#define xd_p_reg_p_vtb_in_8 (*(volatile byte xdata *) 0xF829)
+#define    p_reg_p_vtb_in_8 0xF829
+#define reg_p_vtb_in_8_pos 0
+#define reg_p_vtb_in_8_len 6
+#define reg_p_vtb_in_8_lsb 0
+#define xd_p_reg_p_vtb_in_9 (*(volatile byte xdata *) 0xF82A)
+#define    p_reg_p_vtb_in_9 0xF82A
+#define reg_p_vtb_in_9_pos 0
+#define reg_p_vtb_in_9_len 6
+#define reg_p_vtb_in_9_lsb 0
+#define xd_p_reg_p_vtb_in_10    (*(volatile byte xdata *) 0xF82B)
+#define    p_reg_p_vtb_in_10    0xF82B
+#define reg_p_vtb_in_10_pos 0
+#define reg_p_vtb_in_10_len 6
+#define reg_p_vtb_in_10_lsb 0
+#define xd_p_reg_p_vtb_in_11    (*(volatile byte xdata *) 0xF82C)
+#define    p_reg_p_vtb_in_11    0xF82C
+#define reg_p_vtb_in_11_pos 0
+#define reg_p_vtb_in_11_len 6
+#define reg_p_vtb_in_11_lsb 0
+#define xd_p_reg_p_vtb_in_12    (*(volatile byte xdata *) 0xF82D)
+#define    p_reg_p_vtb_in_12    0xF82D
+#define reg_p_vtb_in_12_pos 0
+#define reg_p_vtb_in_12_len 6
+#define reg_p_vtb_in_12_lsb 0
+#define xd_p_reg_p_vtb_in_13    (*(volatile byte xdata *) 0xF82E)
+#define    p_reg_p_vtb_in_13    0xF82E
+#define reg_p_vtb_in_13_pos 0
+#define reg_p_vtb_in_13_len 6
+#define reg_p_vtb_in_13_lsb 0
+#define xd_p_reg_p_vtb_in_14    (*(volatile byte xdata *) 0xF82F)
+#define    p_reg_p_vtb_in_14    0xF82F
+#define reg_p_vtb_in_14_pos 0
+#define reg_p_vtb_in_14_len 6
+#define reg_p_vtb_in_14_lsb 0
+#define xd_p_reg_p_vtb_in_15    (*(volatile byte xdata *) 0xF830)
+#define    p_reg_p_vtb_in_15    0xF830
+#define reg_p_vtb_in_15_pos 0
+#define reg_p_vtb_in_15_len 6
+#define reg_p_vtb_in_15_lsb 0
+#define xd_I2C_i2c_m_slave_addr (*(volatile byte xdata *) 0xF940)
+#define    I2C_i2c_m_slave_addr 0xF940
+#define i2c_m_slave_addr_pos 0
+#define i2c_m_slave_addr_len 8
+#define i2c_m_slave_addr_lsb 0
+#define xd_I2C_i2c_m_data1  (*(volatile byte xdata *) 0xF941)
+#define    I2C_i2c_m_data1  0xF941
+#define i2c_m_data1_pos 0
+#define i2c_m_data1_len 8
+#define i2c_m_data1_lsb 0
+#define xd_I2C_i2c_m_data2  (*(volatile byte xdata *) 0xF942)
+#define    I2C_i2c_m_data2  0xF942
+#define i2c_m_data2_pos 0
+#define i2c_m_data2_len 8
+#define i2c_m_data2_lsb 0
+#define xd_I2C_i2c_m_data3  (*(volatile byte xdata *) 0xF943)
+#define    I2C_i2c_m_data3  0xF943
+#define i2c_m_data3_pos 0
+#define i2c_m_data3_len 8
+#define i2c_m_data3_lsb 0
+#define xd_I2C_i2c_m_data4  (*(volatile byte xdata *) 0xF944)
+#define    I2C_i2c_m_data4  0xF944
+#define i2c_m_data4_pos 0
+#define i2c_m_data4_len 8
+#define i2c_m_data4_lsb 0
+#define xd_I2C_i2c_m_data5  (*(volatile byte xdata *) 0xF945)
+#define    I2C_i2c_m_data5  0xF945
+#define i2c_m_data5_pos 0
+#define i2c_m_data5_len 8
+#define i2c_m_data5_lsb 0
+#define xd_I2C_i2c_m_data6  (*(volatile byte xdata *) 0xF946)
+#define    I2C_i2c_m_data6  0xF946
+#define i2c_m_data6_pos 0
+#define i2c_m_data6_len 8
+#define i2c_m_data6_lsb 0
+#define xd_I2C_i2c_m_data7  (*(volatile byte xdata *) 0xF947)
+#define    I2C_i2c_m_data7  0xF947
+#define i2c_m_data7_pos 0
+#define i2c_m_data7_len 8
+#define i2c_m_data7_lsb 0
+#define xd_I2C_i2c_m_data8  (*(volatile byte xdata *) 0xF948)
+#define    I2C_i2c_m_data8  0xF948
+#define i2c_m_data8_pos 0
+#define i2c_m_data8_len 8
+#define i2c_m_data8_lsb 0
+#define xd_I2C_i2c_m_data9  (*(volatile byte xdata *) 0xF949)
+#define    I2C_i2c_m_data9  0xF949
+#define i2c_m_data9_pos 0
+#define i2c_m_data9_len 8
+#define i2c_m_data9_lsb 0
+#define xd_I2C_i2c_m_data10 (*(volatile byte xdata *) 0xF94A)
+#define    I2C_i2c_m_data10 0xF94A
+#define i2c_m_data10_pos 0
+#define i2c_m_data10_len 8
+#define i2c_m_data10_lsb 0
+#define xd_I2C_i2c_m_data11 (*(volatile byte xdata *) 0xF94B)
+#define    I2C_i2c_m_data11 0xF94B
+#define i2c_m_data11_pos 0
+#define i2c_m_data11_len 8
+#define i2c_m_data11_lsb 0
+#define xd_I2C_i2c_m_data12 (*(volatile byte xdata *) 0xF94C)
+#define    I2C_i2c_m_data12 0xF94C
+#define i2c_m_data12_pos 0
+#define i2c_m_data12_len 8
+#define i2c_m_data12_lsb 0
+#define xd_I2C_i2c_m_data13 (*(volatile byte xdata *) 0xF94D)
+#define    I2C_i2c_m_data13 0xF94D
+#define i2c_m_data13_pos 0
+#define i2c_m_data13_len 8
+#define i2c_m_data13_lsb 0
+#define xd_I2C_i2c_m_data14 (*(volatile byte xdata *) 0xF94E)
+#define    I2C_i2c_m_data14 0xF94E
+#define i2c_m_data14_pos 0
+#define i2c_m_data14_len 8
+#define i2c_m_data14_lsb 0
+#define xd_I2C_i2c_m_data15 (*(volatile byte xdata *) 0xF94F)
+#define    I2C_i2c_m_data15 0xF94F
+#define i2c_m_data15_pos 0
+#define i2c_m_data15_len 8
+#define i2c_m_data15_lsb 0
+#define xd_I2C_i2c_m_data16 (*(volatile byte xdata *) 0xF950)
+#define    I2C_i2c_m_data16 0xF950
+#define i2c_m_data16_pos 0
+#define i2c_m_data16_len 8
+#define i2c_m_data16_lsb 0
+#define xd_I2C_i2c_m_data17 (*(volatile byte xdata *) 0xF951)
+#define    I2C_i2c_m_data17 0xF951
+#define i2c_m_data17_pos 0
+#define i2c_m_data17_len 8
+#define i2c_m_data17_lsb 0
+#define xd_I2C_i2c_m_data18 (*(volatile byte xdata *) 0xF952)
+#define    I2C_i2c_m_data18 0xF952
+#define i2c_m_data18_pos 0
+#define i2c_m_data18_len 8
+#define i2c_m_data18_lsb 0
+#define xd_I2C_i2c_m_data19 (*(volatile byte xdata *) 0xF953)
+#define    I2C_i2c_m_data19 0xF953
+#define i2c_m_data19_pos 0
+#define i2c_m_data19_len 8
+#define i2c_m_data19_lsb 0
+#define xd_I2C_i2c_m_cmd_rw (*(volatile byte xdata *) 0xF954)
+#define    I2C_i2c_m_cmd_rw 0xF954
+#define i2c_m_cmd_rw_pos 0
+#define i2c_m_cmd_rw_len 1
+#define i2c_m_cmd_rw_lsb 0
+#define xd_I2C_i2c_m_cmd_rwlen  (*(volatile byte xdata *) 0xF954)
+#define    I2C_i2c_m_cmd_rwlen  0xF954
+#define i2c_m_cmd_rwlen_pos 3
+#define i2c_m_cmd_rwlen_len 4
+#define i2c_m_cmd_rwlen_lsb 0
+#define xd_I2C_i2c_m_status_cmd_exe (*(volatile byte xdata *) 0xF955)
+#define    I2C_i2c_m_status_cmd_exe 0xF955
+#define i2c_m_status_cmd_exe_pos 0
+#define i2c_m_status_cmd_exe_len 1
+#define i2c_m_status_cmd_exe_lsb 0
+#define xd_I2C_i2c_m_status_wdat_done   (*(volatile byte xdata *) 0xF955)
+#define    I2C_i2c_m_status_wdat_done   0xF955
+#define i2c_m_status_wdat_done_pos 1
+#define i2c_m_status_wdat_done_len 1
+#define i2c_m_status_wdat_done_lsb 0
+#define xd_I2C_i2c_m_status_wdat_fail   (*(volatile byte xdata *) 0xF955)
+#define    I2C_i2c_m_status_wdat_fail   0xF955
+#define i2c_m_status_wdat_fail_pos 2
+#define i2c_m_status_wdat_fail_len 1
+#define i2c_m_status_wdat_fail_lsb 0
+#define xd_I2C_i2c_m_status_rdat_rdy    (*(volatile byte xdata *) 0xF955)
+#define    I2C_i2c_m_status_rdat_rdy    0xF955
+#define i2c_m_status_rdat_rdy_pos 3
+#define i2c_m_status_rdat_rdy_len 1
+#define i2c_m_status_rdat_rdy_lsb 0
+#define xd_I2C_i2c_m_period (*(volatile byte xdata *) 0xF956)
+#define    I2C_i2c_m_period 0xF956
+#define i2c_m_period_pos 0
+#define i2c_m_period_len 8
+#define i2c_m_period_lsb 0
+#define xd_I2C_i2c_m_reg_msb_lsb    (*(volatile byte xdata *) 0xF957)
+#define    I2C_i2c_m_reg_msb_lsb    0xF957
+#define i2c_m_reg_msb_lsb_pos 0
+#define i2c_m_reg_msb_lsb_len 1
+#define i2c_m_reg_msb_lsb_lsb 0
+#define xd_I2C_reg_ofdm_rst (*(volatile byte xdata *) 0xF957)
+#define    I2C_reg_ofdm_rst 0xF957
+#define reg_ofdm_rst_pos 1
+#define reg_ofdm_rst_len 1
+#define reg_ofdm_rst_lsb 0
+#define xd_I2C_reg_sample_period_on_tuner   (*(volatile byte xdata *) 0xF957)
+#define    I2C_reg_sample_period_on_tuner   0xF957
+#define reg_sample_period_on_tuner_pos 2
+#define reg_sample_period_on_tuner_len 1
+#define reg_sample_period_on_tuner_lsb 0
+#define xd_I2C_reg_sel_tuner    (*(volatile byte xdata *) 0xF957)
+#define    I2C_reg_sel_tuner    0xF957
+#define reg_sel_tuner_pos 3
+#define reg_sel_tuner_len 1
+#define reg_sel_tuner_lsb 0
+#define xd_I2C_reg_ofdm_rst_en  (*(volatile byte xdata *) 0xF957)
+#define    I2C_reg_ofdm_rst_en  0xF957
+#define reg_ofdm_rst_en_pos 4
+#define reg_ofdm_rst_en_len 1
+#define reg_ofdm_rst_en_lsb 0
+#define xd_p_mp2if_psb_overflow (*(volatile byte xdata *) 0xF980)
+#define    p_mp2if_psb_overflow 0xF980
+#define mp2if_psb_overflow_pos 0
+#define mp2if_psb_overflow_len 1
+#define mp2if_psb_overflow_lsb 0
+#define xd_p_mp2if_no_modify_tei_bit    (*(volatile byte xdata *) 0xF981)
+#define    p_mp2if_no_modify_tei_bit    0xF981
+#define mp2if_no_modify_tei_bit_pos 0
+#define mp2if_no_modify_tei_bit_len 1
+#define mp2if_no_modify_tei_bit_lsb 0
+#define xd_p_mp2if_keep_sf_sync_byte    (*(volatile byte xdata *) 0xF982)
+#define    p_mp2if_keep_sf_sync_byte    0xF982
+#define mp2if_keep_sf_sync_byte_pos 0
+#define mp2if_keep_sf_sync_byte_len 1
+#define mp2if_keep_sf_sync_byte_lsb 0
+#define xd_p_mp2if_data_access_disable  (*(volatile byte xdata *) 0xF983)
+#define    p_mp2if_data_access_disable  0xF983
+#define mp2if_data_access_disable_pos 0
+#define mp2if_data_access_disable_len 1
+#define mp2if_data_access_disable_lsb 0
+#define xd_p_mp2if_mpeg_ser_do7 (*(volatile byte xdata *) 0xF984)
+#define    p_mp2if_mpeg_ser_do7 0xF984
+#define mp2if_mpeg_ser_do7_pos 0
+#define mp2if_mpeg_ser_do7_len 1
+#define mp2if_mpeg_ser_do7_lsb 0
+#define xd_p_mp2if_mpeg_ser_mode    (*(volatile byte xdata *) 0xF985)
+#define    p_mp2if_mpeg_ser_mode    0xF985
+#define mp2if_mpeg_ser_mode_pos 0
+#define mp2if_mpeg_ser_mode_len 1
+#define mp2if_mpeg_ser_mode_lsb 0
+#define xd_p_mp2if_mpeg_par_mode    (*(volatile byte xdata *) 0xF986)
+#define    p_mp2if_mpeg_par_mode    0xF986
+#define mp2if_mpeg_par_mode_pos 0
+#define mp2if_mpeg_par_mode_len 1
+#define mp2if_mpeg_par_mode_lsb 0
+#define xd_r_mp2if_psb_empty    (*(volatile byte xdata *) 0xF987)
+#define    r_mp2if_psb_empty    0xF987
+#define mp2if_psb_empty_pos 0
+#define mp2if_psb_empty_len 1
+#define mp2if_psb_empty_lsb 0
+#define xd_r_mp2if_ts_not_188   (*(volatile byte xdata *) 0xF988)
+#define    r_mp2if_ts_not_188   0xF988
+#define mp2if_ts_not_188_pos 0
+#define mp2if_ts_not_188_len 1
+#define mp2if_ts_not_188_lsb 0
+#define xd_p_mp2if_mssync_len   (*(volatile byte xdata *) 0xF989)
+#define    p_mp2if_mssync_len   0xF989
+#define mp2if_mssync_len_pos 0
+#define mp2if_mssync_len_len 1
+#define mp2if_mssync_len_lsb 0
+#define xd_p_mp2if_msdo_msb (*(volatile byte xdata *) 0xF98A)
+#define    p_mp2if_msdo_msb 0xF98A
+#define mp2if_msdo_msb_pos 0
+#define mp2if_msdo_msb_len 1
+#define mp2if_msdo_msb_lsb 0
+#define xd_p_mp2if_mpeg_clk_gated   (*(volatile byte xdata *) 0xF98B)
+#define    p_mp2if_mpeg_clk_gated   0xF98B
+#define mp2if_mpeg_clk_gated_pos 0
+#define mp2if_mpeg_clk_gated_len 1
+#define mp2if_mpeg_clk_gated_lsb 0
+#define xd_p_mp2if_mpeg_err_pol (*(volatile byte xdata *) 0xF98C)
+#define    p_mp2if_mpeg_err_pol 0xF98C
+#define mp2if_mpeg_err_pol_pos 0
+#define mp2if_mpeg_err_pol_len 1
+#define mp2if_mpeg_err_pol_lsb 0
+#define xd_p_mp2if_mpeg_sync_pol    (*(volatile byte xdata *) 0xF98D)
+#define    p_mp2if_mpeg_sync_pol    0xF98D
+#define mp2if_mpeg_sync_pol_pos 0
+#define mp2if_mpeg_sync_pol_len 1
+#define mp2if_mpeg_sync_pol_lsb 0
+#define xd_p_mp2if_mpeg_vld_pol (*(volatile byte xdata *) 0xF98E)
+#define    p_mp2if_mpeg_vld_pol 0xF98E
+#define mp2if_mpeg_vld_pol_pos 0
+#define mp2if_mpeg_vld_pol_len 1
+#define mp2if_mpeg_vld_pol_lsb 0
+#define xd_p_mp2if_mpeg_clk_pol (*(volatile byte xdata *) 0xF98F)
+#define    p_mp2if_mpeg_clk_pol 0xF98F
+#define mp2if_mpeg_clk_pol_pos 0
+#define mp2if_mpeg_clk_pol_len 1
+#define mp2if_mpeg_clk_pol_lsb 0
+#define xd_p_reg_mpeg_full_speed    (*(volatile byte xdata *) 0xF990)
+#define    p_reg_mpeg_full_speed    0xF990
+#define reg_mpeg_full_speed_pos 0
+#define reg_mpeg_full_speed_len 1
+#define reg_mpeg_full_speed_lsb 0
+#define xd_p_mp2if_pid_complement   (*(volatile byte xdata *) 0xF991)
+#define    p_mp2if_pid_complement   0xF991
+#define mp2if_pid_complement_pos 0
+#define mp2if_pid_complement_len 1
+#define mp2if_pid_complement_lsb 0
+#define xd_p_mp2if_pid_rst  (*(volatile byte xdata *) 0xF992)
+#define    p_mp2if_pid_rst  0xF992
+#define mp2if_pid_rst_pos 0
+#define mp2if_pid_rst_len 1
+#define mp2if_pid_rst_lsb 0
+#define xd_p_mp2if_pid_en   (*(volatile byte xdata *) 0xF993)
+#define    p_mp2if_pid_en   0xF993
+#define mp2if_pid_en_pos 0
+#define mp2if_pid_en_len 1
+#define mp2if_pid_en_lsb 0
+#define xd_p_mp2if_pid_index_en (*(volatile byte xdata *) 0xF994)
+#define    p_mp2if_pid_index_en 0xF994
+#define mp2if_pid_index_en_pos 0
+#define mp2if_pid_index_en_len 1
+#define mp2if_pid_index_en_lsb 0
+#define xd_p_mp2if_pid_index    (*(volatile byte xdata *) 0xF995)
+#define    p_mp2if_pid_index    0xF995
+#define mp2if_pid_index_pos 0
+#define mp2if_pid_index_len 5
+#define mp2if_pid_index_lsb 0
+#define xd_p_mp2if_pid_dat_l    (*(volatile byte xdata *) 0xF996)
+#define    p_mp2if_pid_dat_l    0xF996
+#define mp2if_pid_dat_l_pos 0
+#define mp2if_pid_dat_l_len 8
+#define mp2if_pid_dat_l_lsb 0
+#define xd_p_mp2if_pid_dat_h    (*(volatile byte xdata *) 0xF997)
+#define    p_mp2if_pid_dat_h    0xF997
+#define mp2if_pid_dat_h_pos 0
+#define mp2if_pid_dat_h_len 5
+#define mp2if_pid_dat_h_lsb 0
+#define xd_p_reg_latch_clk  (*(volatile byte xdata *) 0xF998)
+#define    p_reg_latch_clk  0xF998
+#define reg_latch_clk_pos 0
+#define reg_latch_clk_len 1
+#define reg_latch_clk_lsb 0
+#define xd_r_mp2if_sync_byte_locked (*(volatile byte xdata *) 0xF999)
+#define    r_mp2if_sync_byte_locked 0xF999
+#define mp2if_sync_byte_locked_pos 0
+#define mp2if_sync_byte_locked_len 1
+#define mp2if_sync_byte_locked_lsb 0
+#define xd_p_mp2if_ignore_sync_byte (*(volatile byte xdata *) 0xF99A)
+#define    p_mp2if_ignore_sync_byte 0xF99A
+#define mp2if_ignore_sync_byte_pos 0
+#define mp2if_ignore_sync_byte_len 1
+#define mp2if_ignore_sync_byte_lsb 0
+#define xd_p_reg_mp2if_clk_en   (*(volatile byte xdata *) 0xF99B)
+#define    p_reg_mp2if_clk_en   0xF99B
+#define reg_mp2if_clk_en_pos 0
+#define reg_mp2if_clk_en_len 1
+#define reg_mp2if_clk_en_lsb 0
+#define xd_p_reg_mpeg_vld_tgl   (*(volatile byte xdata *) 0xF99C)
+#define    p_reg_mpeg_vld_tgl   0xF99C
+#define reg_mpeg_vld_tgl_pos 0
+#define reg_mpeg_vld_tgl_len 1
+#define reg_mpeg_vld_tgl_lsb 0
+#define xd_p_reg_mp2_sw_rst (*(volatile byte xdata *) 0xF99D)
+#define    p_reg_mp2_sw_rst 0xF99D
+#define reg_mp2_sw_rst_pos 0
+#define reg_mp2_sw_rst_len 1
+#define reg_mp2_sw_rst_lsb 0
+#define xd_p_mp2if_psb_en   (*(volatile byte xdata *) 0xF99E)
+#define    p_mp2if_psb_en   0xF99E
+#define mp2if_psb_en_pos 0
+#define mp2if_psb_en_len 1
+#define mp2if_psb_en_lsb 0
+#define xd_r_mp2if_usb20_mode   (*(volatile byte xdata *) 0xF99F)
+#define    r_mp2if_usb20_mode   0xF99F
+#define mp2if_usb20_mode_pos 0
+#define mp2if_usb20_mode_len 1
+#define mp2if_usb20_mode_lsb 0
+#define xd_r_mp2if_strap_usb20_mode (*(volatile byte xdata *) 0xF9A0)
+#define    r_mp2if_strap_usb20_mode 0xF9A0
+#define mp2if_strap_usb20_mode_pos 0
+#define mp2if_strap_usb20_mode_len 1
+#define mp2if_strap_usb20_mode_lsb 0
+#define xd_r_mp2if_lost_pkt_cnt_l   (*(volatile byte xdata *) 0xF9A1)
+#define    r_mp2if_lost_pkt_cnt_l   0xF9A1
+#define mp2if_lost_pkt_cnt_l_pos 0
+#define mp2if_lost_pkt_cnt_l_len 8
+#define mp2if_lost_pkt_cnt_l_lsb 0
+#define xd_r_mp2if_lost_pkt_cnt_h   (*(volatile byte xdata *) 0xF9A2)
+#define    r_mp2if_lost_pkt_cnt_h   0xF9A2
+#define mp2if_lost_pkt_cnt_h_pos 0
+#define mp2if_lost_pkt_cnt_h_len 8
+#define mp2if_lost_pkt_cnt_h_lsb 0
+#define xd_p_reg_mp2if2_en  (*(volatile byte xdata *) 0xF9A3)
+#define    p_reg_mp2if2_en  0xF9A3
+#define reg_mp2if2_en_pos 0
+#define reg_mp2if2_en_len 1
+#define reg_mp2if2_en_lsb 0
+#define xd_p_reg_mp2if2_sw_rst  (*(volatile byte xdata *) 0xF9A4)
+#define    p_reg_mp2if2_sw_rst  0xF9A4
+#define reg_mp2if2_sw_rst_pos 0
+#define reg_mp2if2_sw_rst_len 1
+#define reg_mp2if2_sw_rst_lsb 0
+#define xd_p_reg_mp2if2_half_psb    (*(volatile byte xdata *) 0xF9A5)
+#define    p_reg_mp2if2_half_psb    0xF9A5
+#define reg_mp2if2_half_psb_pos 0
+#define reg_mp2if2_half_psb_len 1
+#define reg_mp2if2_half_psb_lsb 0
+#define xd_p_reg_ts_byte_endian (*(volatile byte xdata *) 0xF9A6)
+#define    p_reg_ts_byte_endian 0xF9A6
+#define reg_ts_byte_endian_pos 0
+#define reg_ts_byte_endian_len 1
+#define reg_ts_byte_endian_lsb 0
+#define xd_p_reg_mp2_dioif  (*(volatile byte xdata *) 0xF9A7)
+#define    p_reg_mp2_dioif  0xF9A7
+#define reg_mp2_dioif_pos 0
+#define reg_mp2_dioif_len 1
+#define reg_mp2_dioif_lsb 0
+#define xd_p_reg_mp2_dioif_fast (*(volatile byte xdata *) 0xF9A8)
+#define    p_reg_mp2_dioif_fast 0xF9A8
+#define reg_mp2_dioif_fast_pos 0
+#define reg_mp2_dioif_fast_len 1
+#define reg_mp2_dioif_fast_lsb 0
+#define xd_p_reg_tpsd_bw_mp2if  (*(volatile byte xdata *) 0xF9A9)
+#define    p_reg_tpsd_bw_mp2if  0xF9A9
+#define reg_tpsd_bw_mp2if_pos 0
+#define reg_tpsd_bw_mp2if_len 2
+#define reg_tpsd_bw_mp2if_lsb 0
+#define xd_p_reg_tpsd_gi_mp2if  (*(volatile byte xdata *) 0xF9AA)
+#define    p_reg_tpsd_gi_mp2if  0xF9AA
+#define reg_tpsd_gi_mp2if_pos 0
+#define reg_tpsd_gi_mp2if_len 2
+#define reg_tpsd_gi_mp2if_lsb 0
+#define xd_p_reg_tpsd_cr_mp2if  (*(volatile byte xdata *) 0xF9AB)
+#define    p_reg_tpsd_cr_mp2if  0xF9AB
+#define reg_tpsd_cr_mp2if_pos 0
+#define reg_tpsd_cr_mp2if_len 3
+#define reg_tpsd_cr_mp2if_lsb 0
+#define xd_p_reg_tpsd_cons_mp2if    (*(volatile byte xdata *) 0xF9AC)
+#define    p_reg_tpsd_cons_mp2if    0xF9AC
+#define reg_tpsd_cons_mp2if_pos 0
+#define reg_tpsd_cons_mp2if_len 2
+#define reg_tpsd_cons_mp2if_lsb 0
+#define xd_p_reg_fw_table_en    (*(volatile byte xdata *) 0xF9AD)
+#define    p_reg_fw_table_en    0xF9AD
+#define reg_fw_table_en_pos 0
+#define reg_fw_table_en_len 1
+#define reg_fw_table_en_lsb 0
+#define xd_p_reg_p_aud_pk_gen_aud_pk_size   (*(volatile byte xdata *) 0xF9AD)
+#define    p_reg_p_aud_pk_gen_aud_pk_size   0xF9AD
+#define reg_p_aud_pk_gen_aud_pk_size_pos 1
+#define reg_p_aud_pk_gen_aud_pk_size_len 6
+#define reg_p_aud_pk_gen_aud_pk_size_lsb 0
+#define xd_p_mp2if_psb_num_blk  (*(volatile byte xdata *) 0xF9AE)
+#define    p_mp2if_psb_num_blk  0xF9AE
+#define mp2if_psb_num_blk_pos 0
+#define mp2if_psb_num_blk_len 6
+#define mp2if_psb_num_blk_lsb 0
+#define xd_p_reg_fec_fake   (*(volatile byte xdata *) 0xF9AF)
+#define    p_reg_fec_fake   0xF9AF
+#define reg_fec_fake_pos 0
+#define reg_fec_fake_len 1
+#define reg_fec_fake_lsb 0
+#define xd_p_reg_p_ccir_atv_en  (*(volatile byte xdata *) 0xF9AF)
+#define    p_reg_p_ccir_atv_en  0xF9AF
+#define reg_p_ccir_atv_en_pos 1
+#define reg_p_ccir_atv_en_len 1
+#define reg_p_ccir_atv_en_lsb 0
+#define xd_p_reg_video_stop_n   (*(volatile byte xdata *) 0xF9AF)
+#define    p_reg_video_stop_n   0xF9AF
+#define reg_video_stop_n_pos 2
+#define reg_video_stop_n_len 1
+#define reg_video_stop_n_lsb 0
+#define xd_p_reg_audio_stop_n   (*(volatile byte xdata *) 0xF9AF)
+#define    p_reg_audio_stop_n   0xF9AF
+#define reg_audio_stop_n_pos 3
+#define reg_audio_stop_n_len 1
+#define reg_audio_stop_n_lsb 0
+#define xd_p_mp2if_i2smode  (*(volatile byte xdata *) 0xF9AF)
+#define    p_mp2if_i2smode  0xF9AF
+#define mp2if_i2smode_pos 4
+#define mp2if_i2smode_len 2
+#define mp2if_i2smode_lsb 0
+#define xd_p_mp2if_word_size    (*(volatile byte xdata *) 0xF9AF)
+#define    p_mp2if_word_size    0xF9AF
+#define mp2if_word_size_pos 6
+#define mp2if_word_size_len 2
+#define mp2if_word_size_lsb 0
+#define xd_p_reg_packet_gap (*(volatile byte xdata *) 0xF9B0)
+#define    p_reg_packet_gap 0xF9B0
+#define reg_packet_gap_pos 0
+#define reg_packet_gap_len 8
+#define reg_packet_gap_lsb 0
+#define xd_p_reg_ts_dat_inv (*(volatile byte xdata *) 0xF9B2)
+#define    p_reg_ts_dat_inv 0xF9B2
+#define reg_ts_dat_inv_pos 0
+#define reg_ts_dat_inv_len 1
+#define reg_ts_dat_inv_lsb 0
+#define xd_p_reg_ts_lsb_1st (*(volatile byte xdata *) 0xF9B3)
+#define    p_reg_ts_lsb_1st 0xF9B3
+#define reg_ts_lsb_1st_pos 0
+#define reg_ts_lsb_1st_len 1
+#define reg_ts_lsb_1st_lsb 0
+#define xd_p_reg_ts_capt_bg_sel (*(volatile byte xdata *) 0xF9B4)
+#define    p_reg_ts_capt_bg_sel 0xF9B4
+#define reg_ts_capt_bg_sel_pos 0
+#define reg_ts_capt_bg_sel_len 1
+#define reg_ts_capt_bg_sel_lsb 0
+#define xd_p_reg_mp2if_stop_en  (*(volatile byte xdata *) 0xF9B5)
+#define    p_reg_mp2if_stop_en  0xF9B5
+#define reg_mp2if_stop_en_pos 0
+#define reg_mp2if_stop_en_len 1
+#define reg_mp2if_stop_en_lsb 0
+#define xd_p_reg_mp2if2_pes_base    (*(volatile byte xdata *) 0xF9B6)
+#define    p_reg_mp2if2_pes_base    0xF9B6
+#define reg_mp2if2_pes_base_pos 0
+#define reg_mp2if2_pes_base_len 1
+#define reg_mp2if2_pes_base_lsb 0
+#define xd_p_reg_ts_sync_inv    (*(volatile byte xdata *) 0xF9B7)
+#define    p_reg_ts_sync_inv    0xF9B7
+#define reg_ts_sync_inv_pos 0
+#define reg_ts_sync_inv_len 1
+#define reg_ts_sync_inv_lsb 0
+#define xd_p_reg_ts_vld_inv (*(volatile byte xdata *) 0xF9B8)
+#define    p_reg_ts_vld_inv 0xF9B8
+#define reg_ts_vld_inv_pos 0
+#define reg_ts_vld_inv_len 1
+#define reg_ts_vld_inv_lsb 0
+#define xd_p_reg_sys_buf_overflow   (*(volatile byte xdata *) 0xF9B9)
+#define    p_reg_sys_buf_overflow   0xF9B9
+#define reg_sys_buf_overflow_pos 0
+#define reg_sys_buf_overflow_len 1
+#define reg_sys_buf_overflow_lsb 0
+#define xd_p_reg_top_dummy0 (*(volatile byte xdata *) 0xF9BB)
+#define    p_reg_top_dummy0 0xF9BB
+#define reg_top_dummy0_pos 0
+#define reg_top_dummy0_len 8
+#define reg_top_dummy0_lsb 0
+#define xd_p_reg_top_dummy1 (*(volatile byte xdata *) 0xF9BC)
+#define    p_reg_top_dummy1 0xF9BC
+#define reg_top_dummy1_pos 0
+#define reg_top_dummy1_len 8
+#define reg_top_dummy1_lsb 0
+#define xd_p_reg_top_dummy2 (*(volatile byte xdata *) 0xF9BD)
+#define    p_reg_top_dummy2 0xF9BD
+#define reg_top_dummy2_pos 0
+#define reg_top_dummy2_len 8
+#define reg_top_dummy2_lsb 0
+#define xd_p_reg_top_dummy3 (*(volatile byte xdata *) 0xF9BE)
+#define    p_reg_top_dummy3 0xF9BE
+#define reg_top_dummy3_pos 0
+#define reg_top_dummy3_len 8
+#define reg_top_dummy3_lsb 0
+#define xd_p_reg_top_dummy4 (*(volatile byte xdata *) 0xF9BF)
+#define    p_reg_top_dummy4 0xF9BF
+#define reg_top_dummy4_pos 0
+#define reg_top_dummy4_len 8
+#define reg_top_dummy4_lsb 0
+#define xd_p_reg_top_dummy5 (*(volatile byte xdata *) 0xF9C0)
+#define    p_reg_top_dummy5 0xF9C0
+#define reg_top_dummy5_pos 0
+#define reg_top_dummy5_len 8
+#define reg_top_dummy5_lsb 0
+#define xd_p_reg_top_dummy6 (*(volatile byte xdata *) 0xF9C1)
+#define    p_reg_top_dummy6 0xF9C1
+#define reg_top_dummy6_pos 0
+#define reg_top_dummy6_len 8
+#define reg_top_dummy6_lsb 0
+#define xd_p_reg_top_dummy7 (*(volatile byte xdata *) 0xF9C2)
+#define    p_reg_top_dummy7 0xF9C2
+#define reg_top_dummy7_pos 0
+#define reg_top_dummy7_len 8
+#define reg_top_dummy7_lsb 0
+#define xd_p_reg_top_dummy8 (*(volatile byte xdata *) 0xF9C3)
+#define    p_reg_top_dummy8 0xF9C3
+#define reg_top_dummy8_pos 0
+#define reg_top_dummy8_len 8
+#define reg_top_dummy8_lsb 0
+#define xd_p_reg_top_dummy9 (*(volatile byte xdata *) 0xF9C4)
+#define    p_reg_top_dummy9 0xF9C4
+#define reg_top_dummy9_pos 0
+#define reg_top_dummy9_len 8
+#define reg_top_dummy9_lsb 0
+#define xd_p_reg_top_dummyA (*(volatile byte xdata *) 0xF9C5)
+#define    p_reg_top_dummyA 0xF9C5
+#define reg_top_dummyA_pos 0
+#define reg_top_dummyA_len 8
+#define reg_top_dummyA_lsb 0
+#define xd_p_reg_top_dummyB (*(volatile byte xdata *) 0xF9C6)
+#define    p_reg_top_dummyB 0xF9C6
+#define reg_top_dummyB_pos 0
+#define reg_top_dummyB_len 8
+#define reg_top_dummyB_lsb 0
+#define xd_p_reg_top_dummyC (*(volatile byte xdata *) 0xF9C7)
+#define    p_reg_top_dummyC 0xF9C7
+#define reg_top_dummyC_pos 0
+#define reg_top_dummyC_len 8
+#define reg_top_dummyC_lsb 0
+#define xd_p_reg_top_dummyD (*(volatile byte xdata *) 0xF9C8)
+#define    p_reg_top_dummyD 0xF9C8
+#define reg_top_dummyD_pos 0
+#define reg_top_dummyD_len 8
+#define reg_top_dummyD_lsb 0
+#define xd_p_reg_top_dummyE (*(volatile byte xdata *) 0xF9C9)
+#define    p_reg_top_dummyE 0xF9C9
+#define reg_top_dummyE_pos 0
+#define reg_top_dummyE_len 8
+#define reg_top_dummyE_lsb 0
+#define xd_p_reg_top_dummyF (*(volatile byte xdata *) 0xF9CA)
+#define    p_reg_top_dummyF 0xF9CA
+#define reg_top_dummyF_pos 0
+#define reg_top_dummyF_len 8
+#define reg_top_dummyF_lsb 0
+#define xd_p_reg_mp2if_clk_coeff    (*(volatile byte xdata *) 0xF9CB)
+#define    p_reg_mp2if_clk_coeff    0xF9CB
+#define reg_mp2if_clk_coeff_pos 0
+#define reg_mp2if_clk_coeff_len 7
+#define reg_mp2if_clk_coeff_lsb 0
+#define xd_p_reg_tsip_en    (*(volatile byte xdata *) 0xF9CC)
+#define    p_reg_tsip_en    0xF9CC
+#define reg_tsip_en_pos 0
+#define reg_tsip_en_len 1
+#define reg_tsip_en_lsb 0
+#define xd_p_reg_tsis_en    (*(volatile byte xdata *) 0xF9CD)
+#define    p_reg_tsis_en    0xF9CD
+#define reg_tsis_en_pos 0
+#define reg_tsis_en_len 1
+#define reg_tsis_en_lsb 0
+#define xd_p_reg_tsip_br    (*(volatile byte xdata *) 0xF9CE)
+#define    p_reg_tsip_br    0xF9CE
+#define reg_tsip_br_pos 0
+#define reg_tsip_br_len 1
+#define reg_tsip_br_lsb 0
+#define xd_p_reg_tsip_frm_inv   (*(volatile byte xdata *) 0xF9D0)
+#define    p_reg_tsip_frm_inv   0xF9D0
+#define reg_tsip_frm_inv_pos 0
+#define reg_tsip_frm_inv_len 1
+#define reg_tsip_frm_inv_lsb 0
+#define xd_p_reg_tsip_str_inv   (*(volatile byte xdata *) 0xF9D1)
+#define    p_reg_tsip_str_inv   0xF9D1
+#define reg_tsip_str_inv_pos 0
+#define reg_tsip_str_inv_len 1
+#define reg_tsip_str_inv_lsb 0
+#define xd_p_reg_tsip_fail_inv  (*(volatile byte xdata *) 0xF9D2)
+#define    p_reg_tsip_fail_inv  0xF9D2
+#define reg_tsip_fail_inv_pos 0
+#define reg_tsip_fail_inv_len 1
+#define reg_tsip_fail_inv_lsb 0
+#define xd_p_reg_tsip_frm_ignore    (*(volatile byte xdata *) 0xF9D3)
+#define    p_reg_tsip_frm_ignore    0xF9D3
+#define reg_tsip_frm_ignore_pos 0
+#define reg_tsip_frm_ignore_len 1
+#define reg_tsip_frm_ignore_lsb 0
+#define xd_p_reg_tsip_str_ignore    (*(volatile byte xdata *) 0xF9D4)
+#define    p_reg_tsip_str_ignore    0xF9D4
+#define reg_tsip_str_ignore_pos 0
+#define reg_tsip_str_ignore_len 1
+#define reg_tsip_str_ignore_lsb 0
+#define xd_p_reg_tsip_fail_ignore   (*(volatile byte xdata *) 0xF9D5)
+#define    p_reg_tsip_fail_ignore   0xF9D5
+#define reg_tsip_fail_ignore_pos 0
+#define reg_tsip_fail_ignore_len 1
+#define reg_tsip_fail_ignore_lsb 0
+#define xd_p_reg_tsip_endian    (*(volatile byte xdata *) 0xF9D6)
+#define    p_reg_tsip_endian    0xF9D6
+#define reg_tsip_endian_pos 0
+#define reg_tsip_endian_len 1
+#define reg_tsip_endian_lsb 0
+#define xd_p_reg_tsip_overflow  (*(volatile byte xdata *) 0xF9D7)
+#define    p_reg_tsip_overflow  0xF9D7
+#define reg_tsip_overflow_pos 0
+#define reg_tsip_overflow_len 1
+#define reg_tsip_overflow_lsb 0
+#define xd_p_reg_ts_in_src  (*(volatile byte xdata *) 0xF9D8)
+#define    p_reg_ts_in_src  0xF9D8
+#define reg_ts_in_src_pos 0
+#define reg_ts_in_src_len 1
+#define reg_ts_in_src_lsb 0
+#define xd_r_reg_clk_sel    (*(volatile byte xdata *) 0xF9D9)
+#define    r_reg_clk_sel    0xF9D9
+#define reg_clk_sel_pos 0
+#define reg_clk_sel_len 2
+#define reg_clk_sel_lsb 0
+#define xd_r_reg_tog_sel    (*(volatile byte xdata *) 0xF9DA)
+#define    r_reg_tog_sel    0xF9DA
+#define reg_tog_sel_pos 0
+#define reg_tog_sel_len 2
+#define reg_tog_sel_lsb 0
+#define xd_p_reg_ts_str_ignore  (*(volatile byte xdata *) 0xF9DB)
+#define    p_reg_ts_str_ignore  0xF9DB
+#define reg_ts_str_ignore_pos 0
+#define reg_ts_str_ignore_len 1
+#define reg_ts_str_ignore_lsb 0
+#define xd_p_reg_ts_frm_ignore  (*(volatile byte xdata *) 0xF9DC)
+#define    p_reg_ts_frm_ignore  0xF9DC
+#define reg_ts_frm_ignore_pos 0
+#define reg_ts_frm_ignore_len 1
+#define reg_ts_frm_ignore_lsb 0
+#define xd_p_reg_clk_sel_fix    (*(volatile byte xdata *) 0xF9DD)
+#define    p_reg_clk_sel_fix    0xF9DD
+#define reg_clk_sel_fix_pos 0
+#define reg_clk_sel_fix_len 2
+#define reg_clk_sel_fix_lsb 0
+#define xd_p_reg_tog_sel_fix    (*(volatile byte xdata *) 0xF9DE)
+#define    p_reg_tog_sel_fix    0xF9DE
+#define reg_tog_sel_fix_pos 0
+#define reg_tog_sel_fix_len 2
+#define reg_tog_sel_fix_lsb 0
+#define xd_p_reg_en_fix (*(volatile byte xdata *) 0xF9DF)
+#define    p_reg_en_fix 0xF9DF
+#define reg_en_fix_pos 0
+#define reg_en_fix_len 1
+#define reg_en_fix_lsb 0
+#define xd_p_reg_check_tpsd_hier    (*(volatile byte xdata *) 0xF9E0)
+#define    p_reg_check_tpsd_hier    0xF9E0
+#define reg_check_tpsd_hier_pos 0
+#define reg_check_tpsd_hier_len 1
+#define reg_check_tpsd_hier_lsb 0
+#define xd_p_reg_p_i2s_master_mode  (*(volatile byte xdata *) 0xF9E1)
+#define    p_reg_p_i2s_master_mode  0xF9E1
+#define reg_p_i2s_master_mode_pos 0
+#define reg_p_i2s_master_mode_len 1
+#define reg_p_i2s_master_mode_lsb 0
+#define xd_p_reg_p_sc_lr_ratio  (*(volatile byte xdata *) 0xF9E2)
+#define    p_reg_p_sc_lr_ratio  0xF9E2
+#define reg_p_sc_lr_ratio_pos 0
+#define reg_p_sc_lr_ratio_len 2
+#define reg_p_sc_lr_ratio_lsb 0
+#define xd_p_reg_p_i2s_fs_type  (*(volatile byte xdata *) 0xF9E2)
+#define    p_reg_p_i2s_fs_type  0xF9E2
+#define reg_p_i2s_fs_type_pos 2
+#define reg_p_i2s_fs_type_len 2
+#define reg_p_i2s_fs_type_lsb 0
+#define xd_r_reg_r_pp_fullq (*(volatile byte xdata *) 0xF9E3)
+#define    r_reg_r_pp_fullq 0xF9E3
+#define reg_r_pp_fullq_pos 0
+#define reg_r_pp_fullq_len 1
+#define reg_r_pp_fullq_lsb 0
+#define xd_p_reg_r_ccir_rst (*(volatile byte xdata *) 0xF9E3)
+#define    p_reg_r_ccir_rst 0xF9E3
+#define reg_r_ccir_rst_pos 1
+#define reg_r_ccir_rst_len 1
+#define reg_r_ccir_rst_lsb 0
+#define xd_p_reg_p_full_en  (*(volatile byte xdata *) 0xF9E3)
+#define    p_reg_p_full_en  0xF9E3
+#define reg_p_full_en_pos 2
+#define reg_p_full_en_len 1
+#define reg_p_full_en_lsb 0
+#define xd_p_reg_p_vbi_dis  (*(volatile byte xdata *) 0xF9E3)
+#define    p_reg_p_vbi_dis  0xF9E3
+#define reg_p_vbi_dis_pos 3
+#define reg_p_vbi_dis_len 1
+#define reg_p_vbi_dis_lsb 0
+#define xd_p_reg_p_ccir_all (*(volatile byte xdata *) 0xF9E3)
+#define    p_reg_p_ccir_all 0xF9E3
+#define reg_p_ccir_all_pos 4
+#define reg_p_ccir_all_len 1
+#define reg_p_ccir_all_lsb 0
+#define xd_p_reg_p_ccir_vbi_raw_en  (*(volatile byte xdata *) 0xF9E3)
+#define    p_reg_p_ccir_vbi_raw_en  0xF9E3
+#define reg_p_ccir_vbi_raw_en_pos 5
+#define reg_p_ccir_vbi_raw_en_len 1
+#define reg_p_ccir_vbi_raw_en_lsb 0
+#define xd_p_reg_err_byte_en    (*(volatile byte xdata *) 0xF9E4)
+#define    p_reg_err_byte_en    0xF9E4
+#define reg_err_byte_en_pos 0
+#define reg_err_byte_en_len 1
+#define reg_err_byte_en_lsb 0
+#define xd_p_reg_mp2_f_adc_7_0  (*(volatile byte xdata *) 0xF9E5)
+#define    p_reg_mp2_f_adc_7_0  0xF9E5
+#define reg_mp2_f_adc_7_0_pos 0
+#define reg_mp2_f_adc_7_0_len 8
+#define reg_mp2_f_adc_7_0_lsb 0
+#define xd_p_reg_mp2_f_adc_15_8 (*(volatile byte xdata *) 0xF9E6)
+#define    p_reg_mp2_f_adc_15_8 0xF9E6
+#define reg_mp2_f_adc_15_8_pos 0
+#define reg_mp2_f_adc_15_8_len 8
+#define reg_mp2_f_adc_15_8_lsb 8
+#define xd_p_reg_mp2_f_adc_23_16    (*(volatile byte xdata *) 0xF9E7)
+#define    p_reg_mp2_f_adc_23_16    0xF9E7
+#define reg_mp2_f_adc_23_16_pos 0
+#define reg_mp2_f_adc_23_16_len 8
+#define reg_mp2_f_adc_23_16_lsb 16
+#define xd_p_reg_set_util   (*(volatile byte xdata *) 0xF9E8)
+#define    p_reg_set_util   0xF9E8
+#define reg_set_util_pos 0
+#define reg_set_util_len 8
+#define reg_set_util_lsb 0
+#define xd_r_reg_err_byte   (*(volatile byte xdata *) 0xF9E9)
+#define    r_reg_err_byte   0xF9E9
+#define reg_err_byte_pos 0
+#define reg_err_byte_len 8
+#define reg_err_byte_lsb 0
+#define xd_p_reg_p_ln_num1  (*(volatile byte xdata *) 0xF9EA)
+#define    p_reg_p_ln_num1  0xF9EA
+#define reg_p_ln_num1_pos 0
+#define reg_p_ln_num1_len 5
+#define reg_p_ln_num1_lsb 0
+#define xd_p_reg_p_ln_num2_2_0  (*(volatile byte xdata *) 0xF9EA)
+#define    p_reg_p_ln_num2_2_0  0xF9EA
+#define reg_p_ln_num2_2_0_pos 5
+#define reg_p_ln_num2_2_0_len 3
+#define reg_p_ln_num2_2_0_lsb 0
+#define xd_p_reg_p_ln_num2_4_3  (*(volatile byte xdata *) 0xF9EB)
+#define    p_reg_p_ln_num2_4_3  0xF9EB
+#define reg_p_ln_num2_4_3_pos 0
+#define reg_p_ln_num2_4_3_len 2
+#define reg_p_ln_num2_4_3_lsb 3
+#define xd_p_reg_p_ln_num3_5_0  (*(volatile byte xdata *) 0xF9EB)
+#define    p_reg_p_ln_num3_5_0  0xF9EB
+#define reg_p_ln_num3_5_0_pos 2
+#define reg_p_ln_num3_5_0_len 6
+#define reg_p_ln_num3_5_0_lsb 0
+#define xd_p_reg_p_ln_num3_8_6  (*(volatile byte xdata *) 0xF9EC)
+#define    p_reg_p_ln_num3_8_6  0xF9EC
+#define reg_p_ln_num3_8_6_pos 0
+#define reg_p_ln_num3_8_6_len 3
+#define reg_p_ln_num3_8_6_lsb 6
+#define xd_p_reg_p_ln_num4_4_0  (*(volatile byte xdata *) 0xF9EC)
+#define    p_reg_p_ln_num4_4_0  0xF9EC
+#define reg_p_ln_num4_4_0_pos 3
+#define reg_p_ln_num4_4_0_len 5
+#define reg_p_ln_num4_4_0_lsb 0
+#define xd_p_reg_p_ln_num4_8_5  (*(volatile byte xdata *) 0xF9ED)
+#define    p_reg_p_ln_num4_8_5  0xF9ED
+#define reg_p_ln_num4_8_5_pos 0
+#define reg_p_ln_num4_8_5_len 4
+#define reg_p_ln_num4_8_5_lsb 5
+#define xd_p_reg_p_ln_num5_3_0  (*(volatile byte xdata *) 0xF9ED)
+#define    p_reg_p_ln_num5_3_0  0xF9ED
+#define reg_p_ln_num5_3_0_pos 4
+#define reg_p_ln_num5_3_0_len 4
+#define reg_p_ln_num5_3_0_lsb 0
+#define xd_p_reg_p_ln_num5_8_4  (*(volatile byte xdata *) 0xF9EE)
+#define    p_reg_p_ln_num5_8_4  0xF9EE
+#define reg_p_ln_num5_8_4_pos 0
+#define reg_p_ln_num5_8_4_len 5
+#define reg_p_ln_num5_8_4_lsb 4
+#define xd_p_reg_p_ln_num6_2_0  (*(volatile byte xdata *) 0xF9EE)
+#define    p_reg_p_ln_num6_2_0  0xF9EE
+#define reg_p_ln_num6_2_0_pos 5
+#define reg_p_ln_num6_2_0_len 3
+#define reg_p_ln_num6_2_0_lsb 0
+#define xd_p_reg_p_ln_num6_8_3  (*(volatile byte xdata *) 0xF9EF)
+#define    p_reg_p_ln_num6_8_3  0xF9EF
+#define reg_p_ln_num6_8_3_pos 0
+#define reg_p_ln_num6_8_3_len 6
+#define reg_p_ln_num6_8_3_lsb 3
+#define xd_p_reg_p_pixel_num_7_0    (*(volatile byte xdata *) 0xF9F0)
+#define    p_reg_p_pixel_num_7_0    0xF9F0
+#define reg_p_pixel_num_7_0_pos 0
+#define reg_p_pixel_num_7_0_len 8
+#define reg_p_pixel_num_7_0_lsb 0
+#define xd_p_reg_p_pixel_num_10_8   (*(volatile byte xdata *) 0xF9F1)
+#define    p_reg_p_pixel_num_10_8   0xF9F1
+#define reg_p_pixel_num_10_8_pos 0
+#define reg_p_pixel_num_10_8_len 3
+#define reg_p_pixel_num_10_8_lsb 8
+#define xd_p_reg_p_ccir_yuv_en  (*(volatile byte xdata *) 0xF9F1)
+#define    p_reg_p_ccir_yuv_en  0xF9F1
+#define reg_p_ccir_yuv_en_pos 3
+#define reg_p_ccir_yuv_en_len 1
+#define reg_p_ccir_yuv_en_lsb 0
+#define xd_p_reg_p_ccir_size_sft    (*(volatile byte xdata *) 0xF9F1)
+#define    p_reg_p_ccir_size_sft    0xF9F1
+#define reg_p_ccir_size_sft_pos 4
+#define reg_p_ccir_size_sft_len 2
+#define reg_p_ccir_size_sft_lsb 0
+#define xd_p_reg_p_psb_cnt_sft  (*(volatile byte xdata *) 0xF9F1)
+#define    p_reg_p_psb_cnt_sft  0xF9F1
+#define reg_p_psb_cnt_sft_pos 6
+#define reg_p_psb_cnt_sft_len 2
+#define reg_p_psb_cnt_sft_lsb 0
+#define xd_p_reg_p_tpsd_lock_trigger    (*(volatile byte xdata *) 0xF9F2)
+#define    p_reg_p_tpsd_lock_trigger    0xF9F2
+#define reg_p_tpsd_lock_trigger_pos 0
+#define reg_p_tpsd_lock_trigger_len 1
+#define reg_p_tpsd_lock_trigger_lsb 0
+#define xd_p_reg_p_ccir_clk_sel (*(volatile byte xdata *) 0xF9F3)
+#define    p_reg_p_ccir_clk_sel 0xF9F3
+#define reg_p_ccir_clk_sel_pos 0
+#define reg_p_ccir_clk_sel_len 1
+#define reg_p_ccir_clk_sel_lsb 0
+#define xd_p_reg_i2c_16_8_data_sel  (*(volatile byte xdata *) 0xFB00)
+#define    p_reg_i2c_16_8_data_sel  0xFB00
+#define reg_i2c_16_8_data_sel_pos 0
+#define reg_i2c_16_8_data_sel_len 1
+#define reg_i2c_16_8_data_sel_lsb 0
+#define xd_p_reg_i2c_slave_trigger_byte (*(volatile byte xdata *) 0xFB01)
+#define    p_reg_i2c_slave_trigger_byte 0xFB01
+#define reg_i2c_slave_trigger_byte_pos 0
+#define reg_i2c_slave_trigger_byte_len 1
+#define reg_i2c_slave_trigger_byte_lsb 0
+#define xd_p_reg_wdti_level (*(volatile byte xdata *) 0xFB05)
+#define    p_reg_wdti_level 0xFB05
+#define reg_wdti_level_pos 0
+#define reg_wdti_level_len 1
+#define reg_wdti_level_lsb 0
+#define xd_p_reg_rssi_avg_sel_lat   (*(volatile byte xdata *) 0xFB06)
+#define    p_reg_rssi_avg_sel_lat   0xFB06
+#define reg_rssi_avg_sel_lat_pos 0
+#define reg_rssi_avg_sel_lat_len 2
+#define reg_rssi_avg_sel_lat_lsb 0
+#define xd_r_ofsm_rssi_avg_7_0  (*(volatile byte xdata *) 0xFB07)
+#define    r_ofsm_rssi_avg_7_0  0xFB07
+#define ofsm_rssi_avg_7_0_pos 0
+#define ofsm_rssi_avg_7_0_len 8
+#define ofsm_rssi_avg_7_0_lsb 0
+#define xd_r_ofsm_rssi_avg_9_8  (*(volatile byte xdata *) 0xFB08)
+#define    r_ofsm_rssi_avg_9_8  0xFB08
+#define ofsm_rssi_avg_9_8_pos 0
+#define ofsm_rssi_avg_9_8_len 2
+#define ofsm_rssi_avg_9_8_lsb 8
+#define xd_r_ofsm_mbist_fail_mon51  (*(volatile byte xdata *) 0xFB09)
+#define    r_ofsm_mbist_fail_mon51  0xFB09
+#define ofsm_mbist_fail_mon51_pos 0
+#define ofsm_mbist_fail_mon51_len 1
+#define ofsm_mbist_fail_mon51_lsb 0
+#define xd_r_ofsm_mbist_fail_com    (*(volatile byte xdata *) 0xFB0A)
+#define    r_ofsm_mbist_fail_com    0xFB0A
+#define ofsm_mbist_fail_com_pos 0
+#define ofsm_mbist_fail_com_len 1
+#define ofsm_mbist_fail_com_lsb 0
+#define xd_r_ofsm_mbist_fail_fft    (*(volatile byte xdata *) 0xFB0B)
+#define    r_ofsm_mbist_fail_fft    0xFB0B
+#define ofsm_mbist_fail_fft_pos 0
+#define ofsm_mbist_fail_fft_len 1
+#define ofsm_mbist_fail_fft_lsb 0
+#define xd_r_ofsm_mbist_fail_fd (*(volatile byte xdata *) 0xFB0C)
+#define    r_ofsm_mbist_fail_fd 0xFB0C
+#define ofsm_mbist_fail_fd_pos 0
+#define ofsm_mbist_fail_fd_len 1
+#define ofsm_mbist_fail_fd_lsb 0
+#define xd_r_ofsm_mbist_fail_link   (*(volatile byte xdata *) 0xFB0D)
+#define    r_ofsm_mbist_fail_link   0xFB0D
+#define ofsm_mbist_fail_link_pos 0
+#define ofsm_mbist_fail_link_len 1
+#define ofsm_mbist_fail_link_lsb 0
+#define xd_r_ofsm_mbist_fail_mpe    (*(volatile byte xdata *) 0xFB0E)
+#define    r_ofsm_mbist_fail_mpe    0xFB0E
+#define ofsm_mbist_fail_mpe_pos 0
+#define ofsm_mbist_fail_mpe_len 1
+#define ofsm_mbist_fail_mpe_lsb 0
+#define xd_r_ofsm_mbist_done_mpe    (*(volatile byte xdata *) 0xFB0F)
+#define    r_ofsm_mbist_done_mpe    0xFB0F
+#define ofsm_mbist_done_mpe_pos 0
+#define ofsm_mbist_done_mpe_len 1
+#define ofsm_mbist_done_mpe_lsb 0
+#define xd_r_ofsm_mbist_mode_mpe    (*(volatile byte xdata *) 0xFB10)
+#define    r_ofsm_mbist_mode_mpe    0xFB10
+#define ofsm_mbist_mode_mpe_pos 0
+#define ofsm_mbist_mode_mpe_len 1
+#define ofsm_mbist_mode_mpe_lsb 0
+#define xd_p_ofsm_cmd_reg   (*(volatile byte xdata *) 0xFB11)
+#define    p_ofsm_cmd_reg   0xFB11
+#define ofsm_cmd_reg_pos 0
+#define ofsm_cmd_reg_len 8
+#define ofsm_cmd_reg_lsb 0
+#define xd_p_ofsm_addr_reg_h    (*(volatile byte xdata *) 0xFB12)
+#define    p_ofsm_addr_reg_h    0xFB12
+#define ofsm_addr_reg_h_pos 0
+#define ofsm_addr_reg_h_len 8
+#define ofsm_addr_reg_h_lsb 0
+#define xd_p_ofsm_addr_reg_l    (*(volatile byte xdata *) 0xFB13)
+#define    p_ofsm_addr_reg_l    0xFB13
+#define ofsm_addr_reg_l_pos 0
+#define ofsm_addr_reg_l_len 8
+#define ofsm_addr_reg_l_lsb 0
+#define xd_p_ofsm_data_reg_0    (*(volatile byte xdata *) 0xFB14)
+#define    p_ofsm_data_reg_0    0xFB14
+#define ofsm_data_reg_0_pos 0
+#define ofsm_data_reg_0_len 8
+#define ofsm_data_reg_0_lsb 0
+#define xd_p_ofsm_data_reg_1    (*(volatile byte xdata *) 0xFB15)
+#define    p_ofsm_data_reg_1    0xFB15
+#define ofsm_data_reg_1_pos 0
+#define ofsm_data_reg_1_len 8
+#define ofsm_data_reg_1_lsb 0
+#define xd_p_ofsm_data_reg_2    (*(volatile byte xdata *) 0xFB16)
+#define    p_ofsm_data_reg_2    0xFB16
+#define ofsm_data_reg_2_pos 0
+#define ofsm_data_reg_2_len 8
+#define ofsm_data_reg_2_lsb 0
+#define xd_p_ofsm_data_reg_3    (*(volatile byte xdata *) 0xFB17)
+#define    p_ofsm_data_reg_3    0xFB17
+#define ofsm_data_reg_3_pos 0
+#define ofsm_data_reg_3_len 8
+#define ofsm_data_reg_3_lsb 0
+#define xd_p_ofsm_data_reg_4    (*(volatile byte xdata *) 0xFB18)
+#define    p_ofsm_data_reg_4    0xFB18
+#define ofsm_data_reg_4_pos 0
+#define ofsm_data_reg_4_len 8
+#define ofsm_data_reg_4_lsb 0
+#define xd_p_ofsm_data_reg_5    (*(volatile byte xdata *) 0xFB19)
+#define    p_ofsm_data_reg_5    0xFB19
+#define ofsm_data_reg_5_pos 0
+#define ofsm_data_reg_5_len 8
+#define ofsm_data_reg_5_lsb 0
+#define xd_p_ofsm_data_reg_6    (*(volatile byte xdata *) 0xFB1A)
+#define    p_ofsm_data_reg_6    0xFB1A
+#define ofsm_data_reg_6_pos 0
+#define ofsm_data_reg_6_len 8
+#define ofsm_data_reg_6_lsb 0
+#define xd_p_ofsm_data_reg_7    (*(volatile byte xdata *) 0xFB1B)
+#define    p_ofsm_data_reg_7    0xFB1B
+#define ofsm_data_reg_7_pos 0
+#define ofsm_data_reg_7_len 8
+#define ofsm_data_reg_7_lsb 0
+#define xd_p_ofsm_data_reg_8    (*(volatile byte xdata *) 0xFB1C)
+#define    p_ofsm_data_reg_8    0xFB1C
+#define ofsm_data_reg_8_pos 0
+#define ofsm_data_reg_8_len 8
+#define ofsm_data_reg_8_lsb 0
+#define xd_p_ofsm_data_reg_9    (*(volatile byte xdata *) 0xFB1D)
+#define    p_ofsm_data_reg_9    0xFB1D
+#define ofsm_data_reg_9_pos 0
+#define ofsm_data_reg_9_len 8
+#define ofsm_data_reg_9_lsb 0
+#define xd_p_ofsm_data_reg_10   (*(volatile byte xdata *) 0xFB1E)
+#define    p_ofsm_data_reg_10   0xFB1E
+#define ofsm_data_reg_10_pos 0
+#define ofsm_data_reg_10_len 8
+#define ofsm_data_reg_10_lsb 0
+#define xd_p_ofsm_data_reg_11   (*(volatile byte xdata *) 0xFB1F)
+#define    p_ofsm_data_reg_11   0xFB1F
+#define ofsm_data_reg_11_pos 0
+#define ofsm_data_reg_11_len 8
+#define ofsm_data_reg_11_lsb 0
+#define xd_p_ofsm_data_reg_12   (*(volatile byte xdata *) 0xFB20)
+#define    p_ofsm_data_reg_12   0xFB20
+#define ofsm_data_reg_12_pos 0
+#define ofsm_data_reg_12_len 8
+#define ofsm_data_reg_12_lsb 0
+#define xd_p_ofsm_data_reg_13   (*(volatile byte xdata *) 0xFB21)
+#define    p_ofsm_data_reg_13   0xFB21
+#define ofsm_data_reg_13_pos 0
+#define ofsm_data_reg_13_len 8
+#define ofsm_data_reg_13_lsb 0
+#define xd_p_ofsm_data_reg_14   (*(volatile byte xdata *) 0xFB22)
+#define    p_ofsm_data_reg_14   0xFB22
+#define ofsm_data_reg_14_pos 0
+#define ofsm_data_reg_14_len 8
+#define ofsm_data_reg_14_lsb 0
+#define xd_p_ofsm_data_reg_15   (*(volatile byte xdata *) 0xFB23)
+#define    p_ofsm_data_reg_15   0xFB23
+#define ofsm_data_reg_15_pos 0
+#define ofsm_data_reg_15_len 8
+#define ofsm_data_reg_15_lsb 0
+#define xd_p_reg_afe_mem0   (*(volatile byte xdata *) 0xFB24)
+#define    p_reg_afe_mem0   0xFB24
+#define reg_afe_mem0_pos 0
+#define reg_afe_mem0_len 8
+#define reg_afe_mem0_lsb 0
+#define xd_p_reg_afe_mem1   (*(volatile byte xdata *) 0xFB25)
+#define    p_reg_afe_mem1   0xFB25
+#define reg_afe_mem1_pos 0
+#define reg_afe_mem1_len 8
+#define reg_afe_mem1_lsb 0
+#define xd_p_reg_afe_mem2   (*(volatile byte xdata *) 0xFB26)
+#define    p_reg_afe_mem2   0xFB26
+#define reg_afe_mem2_pos 0
+#define reg_afe_mem2_len 8
+#define reg_afe_mem2_lsb 0
+#define xd_p_reg_afe_mem3   (*(volatile byte xdata *) 0xFB27)
+#define    p_reg_afe_mem3   0xFB27
+#define reg_afe_mem3_pos 0
+#define reg_afe_mem3_len 8
+#define reg_afe_mem3_lsb 0
+#define xd_p_reg_afe_mem4   (*(volatile byte xdata *) 0xFB28)
+#define    p_reg_afe_mem4   0xFB28
+#define reg_afe_mem4_pos 0
+#define reg_afe_mem4_len 8
+#define reg_afe_mem4_lsb 0
+#define xd_p_reg_afe_mem5   (*(volatile byte xdata *) 0xFB29)
+#define    p_reg_afe_mem5   0xFB29
+#define reg_afe_mem5_pos 0
+#define reg_afe_mem5_len 8
+#define reg_afe_mem5_lsb 0
+#define xd_p_reg_afe_mem6   (*(volatile byte xdata *) 0xFB2A)
+#define    p_reg_afe_mem6   0xFB2A
+#define reg_afe_mem6_pos 0
+#define reg_afe_mem6_len 8
+#define reg_afe_mem6_lsb 0
+#define xd_p_reg_afe_mem7   (*(volatile byte xdata *) 0xFB2B)
+#define    p_reg_afe_mem7   0xFB2B
+#define reg_afe_mem7_pos 0
+#define reg_afe_mem7_len 8
+#define reg_afe_mem7_lsb 0
+#define xd_p_reg_i2cbootreq (*(volatile byte xdata *) 0xFB2C)
+#define    p_reg_i2cbootreq 0xFB2C
+#define reg_i2cbootreq_pos 0
+#define reg_i2cbootreq_len 1
+#define reg_i2cbootreq_lsb 0
+#define xd_p_reg_rst_i2cm   (*(volatile byte xdata *) 0xFB30)
+#define    p_reg_rst_i2cm   0xFB30
+#define reg_rst_i2cm_pos 0
+#define reg_rst_i2cm_len 1
+#define reg_rst_i2cm_lsb 0
+#define xd_p_reg_rst_i2cs   (*(volatile byte xdata *) 0xFB31)
+#define    p_reg_rst_i2cs   0xFB31
+#define reg_rst_i2cs_pos 0
+#define reg_rst_i2cs_len 1
+#define reg_rst_i2cs_lsb 0
+#define xd_r_reg_top_gpioscli   (*(volatile byte xdata *) 0xFB32)
+#define    r_reg_top_gpioscli   0xFB32
+#define reg_top_gpioscli_pos 0
+#define reg_top_gpioscli_len 1
+#define reg_top_gpioscli_lsb 0
+#define xd_p_reg_top_gpiosclo   (*(volatile byte xdata *) 0xFB33)
+#define    p_reg_top_gpiosclo   0xFB33
+#define reg_top_gpiosclo_pos 0
+#define reg_top_gpiosclo_len 1
+#define reg_top_gpiosclo_lsb 0
+#define xd_p_reg_top_gpiosclen  (*(volatile byte xdata *) 0xFB34)
+#define    p_reg_top_gpiosclen  0xFB34
+#define reg_top_gpiosclen_pos 0
+#define reg_top_gpiosclen_len 1
+#define reg_top_gpiosclen_lsb 0
+#define xd_p_reg_top_gpiosclon  (*(volatile byte xdata *) 0xFB35)
+#define    p_reg_top_gpiosclon  0xFB35
+#define reg_top_gpiosclon_pos 0
+#define reg_top_gpiosclon_len 1
+#define reg_top_gpiosclon_lsb 0
+#define xd_r_reg_top_gpiosdai   (*(volatile byte xdata *) 0xFB36)
+#define    r_reg_top_gpiosdai   0xFB36
+#define reg_top_gpiosdai_pos 0
+#define reg_top_gpiosdai_len 1
+#define reg_top_gpiosdai_lsb 0
+#define xd_p_reg_top_gpiosdao   (*(volatile byte xdata *) 0xFB37)
+#define    p_reg_top_gpiosdao   0xFB37
+#define reg_top_gpiosdao_pos 0
+#define reg_top_gpiosdao_len 1
+#define reg_top_gpiosdao_lsb 0
+#define xd_p_reg_top_gpiosdaen  (*(volatile byte xdata *) 0xFB38)
+#define    p_reg_top_gpiosdaen  0xFB38
+#define reg_top_gpiosdaen_pos 0
+#define reg_top_gpiosdaen_len 1
+#define reg_top_gpiosdaen_lsb 0
+#define xd_p_reg_top_gpiosdaon  (*(volatile byte xdata *) 0xFB39)
+#define    p_reg_top_gpiosdaon  0xFB39
+#define reg_top_gpiosdaon_pos 0
+#define reg_top_gpiosdaon_len 1
+#define reg_top_gpiosdaon_lsb 0
+#define xd_p_reg_fix_rom_en (*(volatile byte xdata *) 0xFB3A)
+#define    p_reg_fix_rom_en 0xFB3A
+#define reg_fix_rom_en_pos 0
+#define reg_fix_rom_en_len 1
+#define reg_fix_rom_en_lsb 0
+#define xd_p_reg_ofsm_bug_addh_0    (*(volatile byte xdata *) 0xFB3B)
+#define    p_reg_ofsm_bug_addh_0    0xFB3B
+#define reg_ofsm_bug_addh_0_pos 0
+#define reg_ofsm_bug_addh_0_len 8
+#define reg_ofsm_bug_addh_0_lsb 0
+#define xd_p_reg_ofsm_bug_addl_0    (*(volatile byte xdata *) 0xFB3C)
+#define    p_reg_ofsm_bug_addl_0    0xFB3C
+#define reg_ofsm_bug_addl_0_pos 0
+#define reg_ofsm_bug_addl_0_len 8
+#define reg_ofsm_bug_addl_0_lsb 0
+#define xd_p_reg_ofsm_bug_addh_1    (*(volatile byte xdata *) 0xFB3D)
+#define    p_reg_ofsm_bug_addh_1    0xFB3D
+#define reg_ofsm_bug_addh_1_pos 0
+#define reg_ofsm_bug_addh_1_len 8
+#define reg_ofsm_bug_addh_1_lsb 0
+#define xd_p_reg_ofsm_bug_addl_1    (*(volatile byte xdata *) 0xFB3E)
+#define    p_reg_ofsm_bug_addl_1    0xFB3E
+#define reg_ofsm_bug_addl_1_pos 0
+#define reg_ofsm_bug_addl_1_len 8
+#define reg_ofsm_bug_addl_1_lsb 0
+#define xd_p_reg_ofsm_bug_addh_2    (*(volatile byte xdata *) 0xFB3F)
+#define    p_reg_ofsm_bug_addh_2    0xFB3F
+#define reg_ofsm_bug_addh_2_pos 0
+#define reg_ofsm_bug_addh_2_len 8
+#define reg_ofsm_bug_addh_2_lsb 0
+#define xd_p_reg_ofsm_bug_addl_2    (*(volatile byte xdata *) 0xFB40)
+#define    p_reg_ofsm_bug_addl_2    0xFB40
+#define reg_ofsm_bug_addl_2_pos 0
+#define reg_ofsm_bug_addl_2_len 8
+#define reg_ofsm_bug_addl_2_lsb 0
+#define xd_p_reg_ofsm_bug_addh_3    (*(volatile byte xdata *) 0xFB41)
+#define    p_reg_ofsm_bug_addh_3    0xFB41
+#define reg_ofsm_bug_addh_3_pos 0
+#define reg_ofsm_bug_addh_3_len 8
+#define reg_ofsm_bug_addh_3_lsb 0
+#define xd_p_reg_ofsm_bug_addl_3    (*(volatile byte xdata *) 0xFB42)
+#define    p_reg_ofsm_bug_addl_3    0xFB42
+#define reg_ofsm_bug_addl_3_pos 0
+#define reg_ofsm_bug_addl_3_len 8
+#define reg_ofsm_bug_addl_3_lsb 0
+#define xd_p_reg_ofsm_bug_addh_4    (*(volatile byte xdata *) 0xFB43)
+#define    p_reg_ofsm_bug_addh_4    0xFB43
+#define reg_ofsm_bug_addh_4_pos 0
+#define reg_ofsm_bug_addh_4_len 8
+#define reg_ofsm_bug_addh_4_lsb 0
+#define xd_p_reg_ofsm_bug_addl_4    (*(volatile byte xdata *) 0xFB44)
+#define    p_reg_ofsm_bug_addl_4    0xFB44
+#define reg_ofsm_bug_addl_4_pos 0
+#define reg_ofsm_bug_addl_4_len 8
+#define reg_ofsm_bug_addl_4_lsb 0
+#define xd_p_reg_ofsm_bug_addh_5    (*(volatile byte xdata *) 0xFB45)
+#define    p_reg_ofsm_bug_addh_5    0xFB45
+#define reg_ofsm_bug_addh_5_pos 0
+#define reg_ofsm_bug_addh_5_len 8
+#define reg_ofsm_bug_addh_5_lsb 0
+#define xd_p_reg_ofsm_bug_addl_5    (*(volatile byte xdata *) 0xFB46)
+#define    p_reg_ofsm_bug_addl_5    0xFB46
+#define reg_ofsm_bug_addl_5_pos 0
+#define reg_ofsm_bug_addl_5_len 8
+#define reg_ofsm_bug_addl_5_lsb 0
+#define xd_p_reg_ofsm_bug_addh_6    (*(volatile byte xdata *) 0xFB47)
+#define    p_reg_ofsm_bug_addh_6    0xFB47
+#define reg_ofsm_bug_addh_6_pos 0
+#define reg_ofsm_bug_addh_6_len 8
+#define reg_ofsm_bug_addh_6_lsb 0
+#define xd_p_reg_ofsm_bug_addl_6    (*(volatile byte xdata *) 0xFB48)
+#define    p_reg_ofsm_bug_addl_6    0xFB48
+#define reg_ofsm_bug_addl_6_pos 0
+#define reg_ofsm_bug_addl_6_len 8
+#define reg_ofsm_bug_addl_6_lsb 0
+#define xd_p_reg_ofsm_bug_addh_7    (*(volatile byte xdata *) 0xFB49)
+#define    p_reg_ofsm_bug_addh_7    0xFB49
+#define reg_ofsm_bug_addh_7_pos 0
+#define reg_ofsm_bug_addh_7_len 8
+#define reg_ofsm_bug_addh_7_lsb 0
+#define xd_p_reg_ofsm_bug_addl_7    (*(volatile byte xdata *) 0xFB4A)
+#define    p_reg_ofsm_bug_addl_7    0xFB4A
+#define reg_ofsm_bug_addl_7_pos 0
+#define reg_ofsm_bug_addl_7_len 8
+#define reg_ofsm_bug_addl_7_lsb 0
+#define xd_p_reg_ofsm_bug_addh_8    (*(volatile byte xdata *) 0xFB4B)
+#define    p_reg_ofsm_bug_addh_8    0xFB4B
+#define reg_ofsm_bug_addh_8_pos 0
+#define reg_ofsm_bug_addh_8_len 8
+#define reg_ofsm_bug_addh_8_lsb 0
+#define xd_p_reg_ofsm_bug_addl_8    (*(volatile byte xdata *) 0xFB4C)
+#define    p_reg_ofsm_bug_addl_8    0xFB4C
+#define reg_ofsm_bug_addl_8_pos 0
+#define reg_ofsm_bug_addl_8_len 8
+#define reg_ofsm_bug_addl_8_lsb 0
+#define xd_p_reg_ofsm_bug_addh_9    (*(volatile byte xdata *) 0xFB4D)
+#define    p_reg_ofsm_bug_addh_9    0xFB4D
+#define reg_ofsm_bug_addh_9_pos 0
+#define reg_ofsm_bug_addh_9_len 8
+#define reg_ofsm_bug_addh_9_lsb 0
+#define xd_p_reg_ofsm_bug_addl_9    (*(volatile byte xdata *) 0xFB4E)
+#define    p_reg_ofsm_bug_addl_9    0xFB4E
+#define reg_ofsm_bug_addl_9_pos 0
+#define reg_ofsm_bug_addl_9_len 8
+#define reg_ofsm_bug_addl_9_lsb 0
+#define xd_p_reg_ofsm_bug_addh_10   (*(volatile byte xdata *) 0xFB4F)
+#define    p_reg_ofsm_bug_addh_10   0xFB4F
+#define reg_ofsm_bug_addh_10_pos 0
+#define reg_ofsm_bug_addh_10_len 8
+#define reg_ofsm_bug_addh_10_lsb 0
+#define xd_p_reg_ofsm_bug_addl_10   (*(volatile byte xdata *) 0xFB50)
+#define    p_reg_ofsm_bug_addl_10   0xFB50
+#define reg_ofsm_bug_addl_10_pos 0
+#define reg_ofsm_bug_addl_10_len 8
+#define reg_ofsm_bug_addl_10_lsb 0
+#define xd_p_reg_ofsm_bug_addh_11   (*(volatile byte xdata *) 0xFB51)
+#define    p_reg_ofsm_bug_addh_11   0xFB51
+#define reg_ofsm_bug_addh_11_pos 0
+#define reg_ofsm_bug_addh_11_len 8
+#define reg_ofsm_bug_addh_11_lsb 0
+#define xd_p_reg_ofsm_bug_addl_11   (*(volatile byte xdata *) 0xFB52)
+#define    p_reg_ofsm_bug_addl_11   0xFB52
+#define reg_ofsm_bug_addl_11_pos 0
+#define reg_ofsm_bug_addl_11_len 8
+#define reg_ofsm_bug_addl_11_lsb 0
+#define xd_p_reg_ofsm_bug_addh_12   (*(volatile byte xdata *) 0xFB53)
+#define    p_reg_ofsm_bug_addh_12   0xFB53
+#define reg_ofsm_bug_addh_12_pos 0
+#define reg_ofsm_bug_addh_12_len 8
+#define reg_ofsm_bug_addh_12_lsb 0
+#define xd_p_reg_ofsm_bug_addl_12   (*(volatile byte xdata *) 0xFB54)
+#define    p_reg_ofsm_bug_addl_12   0xFB54
+#define reg_ofsm_bug_addl_12_pos 0
+#define reg_ofsm_bug_addl_12_len 8
+#define reg_ofsm_bug_addl_12_lsb 0
+#define xd_p_reg_ofsm_bug_addh_13   (*(volatile byte xdata *) 0xFB55)
+#define    p_reg_ofsm_bug_addh_13   0xFB55
+#define reg_ofsm_bug_addh_13_pos 0
+#define reg_ofsm_bug_addh_13_len 8
+#define reg_ofsm_bug_addh_13_lsb 0
+#define xd_p_reg_ofsm_bug_addl_13   (*(volatile byte xdata *) 0xFB56)
+#define    p_reg_ofsm_bug_addl_13   0xFB56
+#define reg_ofsm_bug_addl_13_pos 0
+#define reg_ofsm_bug_addl_13_len 8
+#define reg_ofsm_bug_addl_13_lsb 0
+#define xd_p_reg_ofsm_bug_addh_14   (*(volatile byte xdata *) 0xFB57)
+#define    p_reg_ofsm_bug_addh_14   0xFB57
+#define reg_ofsm_bug_addh_14_pos 0
+#define reg_ofsm_bug_addh_14_len 8
+#define reg_ofsm_bug_addh_14_lsb 0
+#define xd_p_reg_ofsm_bug_addl_14   (*(volatile byte xdata *) 0xFB58)
+#define    p_reg_ofsm_bug_addl_14   0xFB58
+#define reg_ofsm_bug_addl_14_pos 0
+#define reg_ofsm_bug_addl_14_len 8
+#define reg_ofsm_bug_addl_14_lsb 0
+#define xd_p_reg_ofsm_bug_addh_15   (*(volatile byte xdata *) 0xFB59)
+#define    p_reg_ofsm_bug_addh_15   0xFB59
+#define reg_ofsm_bug_addh_15_pos 0
+#define reg_ofsm_bug_addh_15_len 8
+#define reg_ofsm_bug_addh_15_lsb 0
+#define xd_p_reg_ofsm_bug_addl_15   (*(volatile byte xdata *) 0xFB5A)
+#define    p_reg_ofsm_bug_addl_15   0xFB5A
+#define reg_ofsm_bug_addl_15_pos 0
+#define reg_ofsm_bug_addl_15_len 8
+#define reg_ofsm_bug_addl_15_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_0    (*(volatile byte xdata *) 0xFB5B)
+#define    p_reg_ofsm_jmp_addh_0    0xFB5B
+#define reg_ofsm_jmp_addh_0_pos 0
+#define reg_ofsm_jmp_addh_0_len 8
+#define reg_ofsm_jmp_addh_0_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_0    (*(volatile byte xdata *) 0xFB5C)
+#define    p_reg_ofsm_jmp_addl_0    0xFB5C
+#define reg_ofsm_jmp_addl_0_pos 0
+#define reg_ofsm_jmp_addl_0_len 8
+#define reg_ofsm_jmp_addl_0_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_1    (*(volatile byte xdata *) 0xFB5D)
+#define    p_reg_ofsm_jmp_addh_1    0xFB5D
+#define reg_ofsm_jmp_addh_1_pos 0
+#define reg_ofsm_jmp_addh_1_len 8
+#define reg_ofsm_jmp_addh_1_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_1    (*(volatile byte xdata *) 0xFB5E)
+#define    p_reg_ofsm_jmp_addl_1    0xFB5E
+#define reg_ofsm_jmp_addl_1_pos 0
+#define reg_ofsm_jmp_addl_1_len 8
+#define reg_ofsm_jmp_addl_1_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_2    (*(volatile byte xdata *) 0xFB5F)
+#define    p_reg_ofsm_jmp_addh_2    0xFB5F
+#define reg_ofsm_jmp_addh_2_pos 0
+#define reg_ofsm_jmp_addh_2_len 8
+#define reg_ofsm_jmp_addh_2_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_2    (*(volatile byte xdata *) 0xFB60)
+#define    p_reg_ofsm_jmp_addl_2    0xFB60
+#define reg_ofsm_jmp_addl_2_pos 0
+#define reg_ofsm_jmp_addl_2_len 8
+#define reg_ofsm_jmp_addl_2_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_3    (*(volatile byte xdata *) 0xFB61)
+#define    p_reg_ofsm_jmp_addh_3    0xFB61
+#define reg_ofsm_jmp_addh_3_pos 0
+#define reg_ofsm_jmp_addh_3_len 8
+#define reg_ofsm_jmp_addh_3_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_3    (*(volatile byte xdata *) 0xFB62)
+#define    p_reg_ofsm_jmp_addl_3    0xFB62
+#define reg_ofsm_jmp_addl_3_pos 0
+#define reg_ofsm_jmp_addl_3_len 8
+#define reg_ofsm_jmp_addl_3_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_4    (*(volatile byte xdata *) 0xFB63)
+#define    p_reg_ofsm_jmp_addh_4    0xFB63
+#define reg_ofsm_jmp_addh_4_pos 0
+#define reg_ofsm_jmp_addh_4_len 8
+#define reg_ofsm_jmp_addh_4_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_4    (*(volatile byte xdata *) 0xFB64)
+#define    p_reg_ofsm_jmp_addl_4    0xFB64
+#define reg_ofsm_jmp_addl_4_pos 0
+#define reg_ofsm_jmp_addl_4_len 8
+#define reg_ofsm_jmp_addl_4_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_5    (*(volatile byte xdata *) 0xFB65)
+#define    p_reg_ofsm_jmp_addh_5    0xFB65
+#define reg_ofsm_jmp_addh_5_pos 0
+#define reg_ofsm_jmp_addh_5_len 8
+#define reg_ofsm_jmp_addh_5_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_5    (*(volatile byte xdata *) 0xFB66)
+#define    p_reg_ofsm_jmp_addl_5    0xFB66
+#define reg_ofsm_jmp_addl_5_pos 0
+#define reg_ofsm_jmp_addl_5_len 8
+#define reg_ofsm_jmp_addl_5_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_6    (*(volatile byte xdata *) 0xFB67)
+#define    p_reg_ofsm_jmp_addh_6    0xFB67
+#define reg_ofsm_jmp_addh_6_pos 0
+#define reg_ofsm_jmp_addh_6_len 8
+#define reg_ofsm_jmp_addh_6_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_6    (*(volatile byte xdata *) 0xFB68)
+#define    p_reg_ofsm_jmp_addl_6    0xFB68
+#define reg_ofsm_jmp_addl_6_pos 0
+#define reg_ofsm_jmp_addl_6_len 8
+#define reg_ofsm_jmp_addl_6_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_7    (*(volatile byte xdata *) 0xFB69)
+#define    p_reg_ofsm_jmp_addh_7    0xFB69
+#define reg_ofsm_jmp_addh_7_pos 0
+#define reg_ofsm_jmp_addh_7_len 8
+#define reg_ofsm_jmp_addh_7_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_7    (*(volatile byte xdata *) 0xFB6A)
+#define    p_reg_ofsm_jmp_addl_7    0xFB6A
+#define reg_ofsm_jmp_addl_7_pos 0
+#define reg_ofsm_jmp_addl_7_len 8
+#define reg_ofsm_jmp_addl_7_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_8    (*(volatile byte xdata *) 0xFB6B)
+#define    p_reg_ofsm_jmp_addh_8    0xFB6B
+#define reg_ofsm_jmp_addh_8_pos 0
+#define reg_ofsm_jmp_addh_8_len 8
+#define reg_ofsm_jmp_addh_8_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_8    (*(volatile byte xdata *) 0xFB6C)
+#define    p_reg_ofsm_jmp_addl_8    0xFB6C
+#define reg_ofsm_jmp_addl_8_pos 0
+#define reg_ofsm_jmp_addl_8_len 8
+#define reg_ofsm_jmp_addl_8_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_9    (*(volatile byte xdata *) 0xFB6D)
+#define    p_reg_ofsm_jmp_addh_9    0xFB6D
+#define reg_ofsm_jmp_addh_9_pos 0
+#define reg_ofsm_jmp_addh_9_len 8
+#define reg_ofsm_jmp_addh_9_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_9    (*(volatile byte xdata *) 0xFB6E)
+#define    p_reg_ofsm_jmp_addl_9    0xFB6E
+#define reg_ofsm_jmp_addl_9_pos 0
+#define reg_ofsm_jmp_addl_9_len 8
+#define reg_ofsm_jmp_addl_9_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_10   (*(volatile byte xdata *) 0xFB6F)
+#define    p_reg_ofsm_jmp_addh_10   0xFB6F
+#define reg_ofsm_jmp_addh_10_pos 0
+#define reg_ofsm_jmp_addh_10_len 8
+#define reg_ofsm_jmp_addh_10_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_10   (*(volatile byte xdata *) 0xFB70)
+#define    p_reg_ofsm_jmp_addl_10   0xFB70
+#define reg_ofsm_jmp_addl_10_pos 0
+#define reg_ofsm_jmp_addl_10_len 8
+#define reg_ofsm_jmp_addl_10_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_11   (*(volatile byte xdata *) 0xFB71)
+#define    p_reg_ofsm_jmp_addh_11   0xFB71
+#define reg_ofsm_jmp_addh_11_pos 0
+#define reg_ofsm_jmp_addh_11_len 8
+#define reg_ofsm_jmp_addh_11_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_11   (*(volatile byte xdata *) 0xFB72)
+#define    p_reg_ofsm_jmp_addl_11   0xFB72
+#define reg_ofsm_jmp_addl_11_pos 0
+#define reg_ofsm_jmp_addl_11_len 8
+#define reg_ofsm_jmp_addl_11_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_12   (*(volatile byte xdata *) 0xFB73)
+#define    p_reg_ofsm_jmp_addh_12   0xFB73
+#define reg_ofsm_jmp_addh_12_pos 0
+#define reg_ofsm_jmp_addh_12_len 8
+#define reg_ofsm_jmp_addh_12_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_12   (*(volatile byte xdata *) 0xFB74)
+#define    p_reg_ofsm_jmp_addl_12   0xFB74
+#define reg_ofsm_jmp_addl_12_pos 0
+#define reg_ofsm_jmp_addl_12_len 8
+#define reg_ofsm_jmp_addl_12_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_13   (*(volatile byte xdata *) 0xFB75)
+#define    p_reg_ofsm_jmp_addh_13   0xFB75
+#define reg_ofsm_jmp_addh_13_pos 0
+#define reg_ofsm_jmp_addh_13_len 8
+#define reg_ofsm_jmp_addh_13_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_13   (*(volatile byte xdata *) 0xFB76)
+#define    p_reg_ofsm_jmp_addl_13   0xFB76
+#define reg_ofsm_jmp_addl_13_pos 0
+#define reg_ofsm_jmp_addl_13_len 8
+#define reg_ofsm_jmp_addl_13_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_14   (*(volatile byte xdata *) 0xFB77)
+#define    p_reg_ofsm_jmp_addh_14   0xFB77
+#define reg_ofsm_jmp_addh_14_pos 0
+#define reg_ofsm_jmp_addh_14_len 8
+#define reg_ofsm_jmp_addh_14_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_14   (*(volatile byte xdata *) 0xFB78)
+#define    p_reg_ofsm_jmp_addl_14   0xFB78
+#define reg_ofsm_jmp_addl_14_pos 0
+#define reg_ofsm_jmp_addl_14_len 8
+#define reg_ofsm_jmp_addl_14_lsb 0
+#define xd_p_reg_ofsm_jmp_addh_15   (*(volatile byte xdata *) 0xFB79)
+#define    p_reg_ofsm_jmp_addh_15   0xFB79
+#define reg_ofsm_jmp_addh_15_pos 0
+#define reg_ofsm_jmp_addh_15_len 8
+#define reg_ofsm_jmp_addh_15_lsb 0
+#define xd_p_reg_ofsm_jmp_addl_15   (*(volatile byte xdata *) 0xFB7A)
+#define    p_reg_ofsm_jmp_addl_15   0xFB7A
+#define reg_ofsm_jmp_addl_15_pos 0
+#define reg_ofsm_jmp_addl_15_len 8
+#define reg_ofsm_jmp_addl_15_lsb 0
+#define xd_p_reg_sw_mon51   (*(volatile byte xdata *) 0xFB7B)
+#define    p_reg_sw_mon51   0xFB7B
+#define reg_sw_mon51_pos 0
+#define reg_sw_mon51_len 7
+#define reg_sw_mon51_lsb 0
+#define xd_p_reg_ofdm_mon51_flag    (*(volatile byte xdata *) 0xFB7C)
+#define    p_reg_ofdm_mon51_flag    0xFB7C
+#define reg_ofdm_mon51_flag_pos 0
+#define reg_ofdm_mon51_flag_len 1
+#define reg_ofdm_mon51_flag_lsb 0
+#define xd_p_reg_ofdm_force_mon51   (*(volatile byte xdata *) 0xFB7D)
+#define    p_reg_ofdm_force_mon51   0xFB7D
+#define reg_ofdm_force_mon51_pos 0
+#define reg_ofdm_force_mon51_len 1
+#define reg_ofdm_force_mon51_lsb 0
+#define xd_p_reg_ofdm_which_cpu (*(volatile byte xdata *) 0xFB7E)
+#define    p_reg_ofdm_which_cpu 0xFB7E
+#define reg_ofdm_which_cpu_pos 0
+#define reg_ofdm_which_cpu_len 1
+#define reg_ofdm_which_cpu_lsb 0
+#define xd_p_reg_ofdm_code_ready    (*(volatile byte xdata *) 0xFB7F)
+#define    p_reg_ofdm_code_ready    0xFB7F
+#define reg_ofdm_code_ready_pos 0
+#define reg_ofdm_code_ready_len 1
+#define reg_ofdm_code_ready_lsb 0
+#define xd_p_reg_ofdm_mailbox_wend  (*(volatile byte xdata *) 0xFB80)
+#define    p_reg_ofdm_mailbox_wend  0xFB80
+#define reg_ofdm_mailbox_wend_pos 0
+#define reg_ofdm_mailbox_wend_len 1
+#define reg_ofdm_mailbox_wend_lsb 0
+#define xd_r_reg_fast_slow_train    (*(volatile byte xdata *) 0xFB81)
+#define    r_reg_fast_slow_train    0xFB81
+#define reg_fast_slow_train_pos 0
+#define reg_fast_slow_train_len 1
+#define reg_fast_slow_train_lsb 0
+#define xd_p_reg_ofdm_mailbox_wptr  (*(volatile byte xdata *) 0xFB82)
+#define    p_reg_ofdm_mailbox_wptr  0xFB82
+#define reg_ofdm_mailbox_wptr_pos 0
+#define reg_ofdm_mailbox_wptr_len 8
+#define reg_ofdm_mailbox_wptr_lsb 0
+#define xd_p_reg_ofdm_mailbox_int   (*(volatile byte xdata *) 0xFB86)
+#define    p_reg_ofdm_mailbox_int   0xFB86
+#define reg_ofdm_mailbox_int_pos 0
+#define reg_ofdm_mailbox_int_len 1
+#define reg_ofdm_mailbox_int_lsb 0
+#define xd_p_reg_ofdm_lnk2ofdm_int  (*(volatile byte xdata *) 0xFB87)
+#define    p_reg_ofdm_lnk2ofdm_int  0xFB87
+#define reg_ofdm_lnk2ofdm_int_pos 0
+#define reg_ofdm_lnk2ofdm_int_len 1
+#define reg_ofdm_lnk2ofdm_int_lsb 0
+#define xd_p_reg_ofdm_ofdm2lnk_int  (*(volatile byte xdata *) 0xFB88)
+#define    p_reg_ofdm_ofdm2lnk_int  0xFB88
+#define reg_ofdm_ofdm2lnk_int_pos 0
+#define reg_ofdm_ofdm2lnk_int_len 1
+#define reg_ofdm_ofdm2lnk_int_lsb 0
+#define xd_r_reg_load_ofdm_reg  (*(volatile byte xdata *) 0xFB8F)
+#define    r_reg_load_ofdm_reg  0xFB8F
+#define reg_load_ofdm_reg_pos 0
+#define reg_load_ofdm_reg_len 1
+#define reg_load_ofdm_reg_lsb 0
+#define xd_p_reg_lnk_mbx_rd_length_7_0  (*(volatile byte xdata *) 0xFB90)
+#define    p_reg_lnk_mbx_rd_length_7_0  0xFB90
+#define reg_lnk_mbx_rd_length_7_0_pos 0
+#define reg_lnk_mbx_rd_length_7_0_len 8
+#define reg_lnk_mbx_rd_length_7_0_lsb 0
+#define xd_p_reg_lnk_mbx_rd_length_15_8 (*(volatile byte xdata *) 0xFB91)
+#define    p_reg_lnk_mbx_rd_length_15_8 0xFB91
+#define reg_lnk_mbx_rd_length_15_8_pos 0
+#define reg_lnk_mbx_rd_length_15_8_len 8
+#define reg_lnk_mbx_rd_length_15_8_lsb 8
+#define xd_p_reg_lnk_mbx_rd_length_17_16    (*(volatile byte xdata *) 0xFB92)
+#define    p_reg_lnk_mbx_rd_length_17_16    0xFB92
+#define reg_lnk_mbx_rd_length_17_16_pos 0
+#define reg_lnk_mbx_rd_length_17_16_len 2
+#define reg_lnk_mbx_rd_length_17_16_lsb 16
+#define xd_p_reg_lnk_rd_data_sel    (*(volatile byte xdata *) 0xFB93)
+#define    p_reg_lnk_rd_data_sel    0xFB93
+#define reg_lnk_rd_data_sel_pos 0
+#define reg_lnk_rd_data_sel_len 2
+#define reg_lnk_rd_data_sel_lsb 0
+#define xd_p_reg_ofdm2lnk_data_7_0  (*(volatile byte xdata *) 0xFB96)
+#define    p_reg_ofdm2lnk_data_7_0  0xFB96
+#define reg_ofdm2lnk_data_7_0_pos 0
+#define reg_ofdm2lnk_data_7_0_len 8
+#define reg_ofdm2lnk_data_7_0_lsb 0
+#define xd_p_reg_ofdm2lnk_data_15_8 (*(volatile byte xdata *) 0xFB97)
+#define    p_reg_ofdm2lnk_data_15_8 0xFB97
+#define reg_ofdm2lnk_data_15_8_pos 0
+#define reg_ofdm2lnk_data_15_8_len 8
+#define reg_ofdm2lnk_data_15_8_lsb 8
+#define xd_p_reg_ofdm2lnk_data_23_16    (*(volatile byte xdata *) 0xFB98)
+#define    p_reg_ofdm2lnk_data_23_16    0xFB98
+#define reg_ofdm2lnk_data_23_16_pos 0
+#define reg_ofdm2lnk_data_23_16_len 8
+#define reg_ofdm2lnk_data_23_16_lsb 16
+#define xd_p_reg_ofdm2lnk_data_31_24    (*(volatile byte xdata *) 0xFB99)
+#define    p_reg_ofdm2lnk_data_31_24    0xFB99
+#define reg_ofdm2lnk_data_31_24_pos 0
+#define reg_ofdm2lnk_data_31_24_len 8
+#define reg_ofdm2lnk_data_31_24_lsb 24
+#define xd_p_reg_ofdm2lnk_data_39_32    (*(volatile byte xdata *) 0xFB9A)
+#define    p_reg_ofdm2lnk_data_39_32    0xFB9A
+#define reg_ofdm2lnk_data_39_32_pos 0
+#define reg_ofdm2lnk_data_39_32_len 8
+#define reg_ofdm2lnk_data_39_32_lsb 32
+#define xd_p_reg_ofdm2lnk_data_47_40    (*(volatile byte xdata *) 0xFB9B)
+#define    p_reg_ofdm2lnk_data_47_40    0xFB9B
+#define reg_ofdm2lnk_data_47_40_pos 0
+#define reg_ofdm2lnk_data_47_40_len 8
+#define reg_ofdm2lnk_data_47_40_lsb 40
+#define xd_p_reg_ofdm2lnk_data_55_48    (*(volatile byte xdata *) 0xFB9C)
+#define    p_reg_ofdm2lnk_data_55_48    0xFB9C
+#define reg_ofdm2lnk_data_55_48_pos 0
+#define reg_ofdm2lnk_data_55_48_len 8
+#define reg_ofdm2lnk_data_55_48_lsb 48
+#define xd_p_reg_ofdm2lnk_data_63_56    (*(volatile byte xdata *) 0xFB9D)
+#define    p_reg_ofdm2lnk_data_63_56    0xFB9D
+#define reg_ofdm2lnk_data_63_56_pos 0
+#define reg_ofdm2lnk_data_63_56_len 8
+#define reg_ofdm2lnk_data_63_56_lsb 56
+#define xd_p_reg_lnktoofdm_data_7_0 (*(volatile byte xdata *) 0xFB9E)
+#define    p_reg_lnktoofdm_data_7_0 0xFB9E
+#define reg_lnktoofdm_data_7_0_pos 0
+#define reg_lnktoofdm_data_7_0_len 8
+#define reg_lnktoofdm_data_7_0_lsb 0
+#define xd_p_reg_lnktoofdm_data_15_8    (*(volatile byte xdata *) 0xFB9F)
+#define    p_reg_lnktoofdm_data_15_8    0xFB9F
+#define reg_lnktoofdm_data_15_8_pos 0
+#define reg_lnktoofdm_data_15_8_len 8
+#define reg_lnktoofdm_data_15_8_lsb 8
+#define xd_p_reg_lnktoofdm_data_23_16   (*(volatile byte xdata *) 0xFBA0)
+#define    p_reg_lnktoofdm_data_23_16   0xFBA0
+#define reg_lnktoofdm_data_23_16_pos 0
+#define reg_lnktoofdm_data_23_16_len 8
+#define reg_lnktoofdm_data_23_16_lsb 16
+#define xd_p_reg_lnktoofdm_data_31_24   (*(volatile byte xdata *) 0xFBA1)
+#define    p_reg_lnktoofdm_data_31_24   0xFBA1
+#define reg_lnktoofdm_data_31_24_pos 0
+#define reg_lnktoofdm_data_31_24_len 8
+#define reg_lnktoofdm_data_31_24_lsb 24
+#define xd_p_reg_lnktoofdm_data_39_32   (*(volatile byte xdata *) 0xFBA2)
+#define    p_reg_lnktoofdm_data_39_32   0xFBA2
+#define reg_lnktoofdm_data_39_32_pos 0
+#define reg_lnktoofdm_data_39_32_len 8
+#define reg_lnktoofdm_data_39_32_lsb 32
+#define xd_p_reg_lnktoofdm_data_47_40   (*(volatile byte xdata *) 0xFBA3)
+#define    p_reg_lnktoofdm_data_47_40   0xFBA3
+#define reg_lnktoofdm_data_47_40_pos 0
+#define reg_lnktoofdm_data_47_40_len 8
+#define reg_lnktoofdm_data_47_40_lsb 40
+#define xd_p_reg_lnktoofdm_data_55_48   (*(volatile byte xdata *) 0xFBA4)
+#define    p_reg_lnktoofdm_data_55_48   0xFBA4
+#define reg_lnktoofdm_data_55_48_pos 0
+#define reg_lnktoofdm_data_55_48_len 8
+#define reg_lnktoofdm_data_55_48_lsb 48
+#define xd_p_reg_lnktoofdm_data_63_56   (*(volatile byte xdata *) 0xFBA5)
+#define    p_reg_lnktoofdm_data_63_56   0xFBA5
+#define reg_lnktoofdm_data_63_56_pos 0
+#define reg_lnktoofdm_data_63_56_len 8
+#define reg_lnktoofdm_data_63_56_lsb 56
+#define xd_p_reg_dbgif32_sel    (*(volatile byte xdata *) 0xFBA6)
+#define    p_reg_dbgif32_sel    0xFBA6
+#define reg_dbgif32_sel_pos 0
+#define reg_dbgif32_sel_len 2
+#define reg_dbgif32_sel_lsb 0
+#define xd_p_reg_dyn1_clk   (*(volatile byte xdata *) 0xFBA7)
+#define    p_reg_dyn1_clk   0xFBA7
+#define reg_dyn1_clk_pos 0
+#define reg_dyn1_clk_len 1
+#define reg_dyn1_clk_lsb 0
+#define xd_p_reg_dyn0_clk   (*(volatile byte xdata *) 0xFBA8)
+#define    p_reg_dyn0_clk   0xFBA8
+#define reg_dyn0_clk_pos 0
+#define reg_dyn0_clk_len 1
+#define reg_dyn0_clk_lsb 0
+#define xd_p_reg_free_clk   (*(volatile byte xdata *) 0xFBA9)
+#define    p_reg_free_clk   0xFBA9
+#define reg_free_clk_pos 0
+#define reg_free_clk_len 1
+#define reg_free_clk_lsb 0
+#define xd_p_reg_ofdm_stick_mem_end_7_0 (*(volatile byte xdata *) 0xFBAD)
+#define    p_reg_ofdm_stick_mem_end_7_0 0xFBAD
+#define reg_ofdm_stick_mem_end_7_0_pos 0
+#define reg_ofdm_stick_mem_end_7_0_len 8
+#define reg_ofdm_stick_mem_end_7_0_lsb 0
+#define xd_p_reg_ofdm_stick_mem_end_15_8    (*(volatile byte xdata *) 0xFBAE)
+#define    p_reg_ofdm_stick_mem_end_15_8    0xFBAE
+#define reg_ofdm_stick_mem_end_15_8_pos 0
+#define reg_ofdm_stick_mem_end_15_8_len 8
+#define reg_ofdm_stick_mem_end_15_8_lsb 8
+#define xd_p_reg_ofdm_cpu_reset (*(volatile byte xdata *) 0xFBAF)
+#define    p_reg_ofdm_cpu_reset 0xFBAF
+#define reg_ofdm_cpu_reset_pos 0
+#define reg_ofdm_cpu_reset_len 1
+#define reg_ofdm_cpu_reset_lsb 0
+#define xd_p_reg_ofdm_bank_float_en (*(volatile byte xdata *) 0xFBB0)
+#define    p_reg_ofdm_bank_float_en 0xFBB0
+#define reg_ofdm_bank_float_en_pos 0
+#define reg_ofdm_bank_float_en_len 1
+#define reg_ofdm_bank_float_en_lsb 0
+#define xd_p_reg_ofdm_bank_float_start  (*(volatile byte xdata *) 0xFBB1)
+#define    p_reg_ofdm_bank_float_start  0xFBB1
+#define reg_ofdm_bank_float_start_pos 0
+#define reg_ofdm_bank_float_start_len 8
+#define reg_ofdm_bank_float_start_lsb 0
+#define xd_p_reg_ofdm_bank_float_stop   (*(volatile byte xdata *) 0xFBB2)
+#define    p_reg_ofdm_bank_float_stop   0xFBB2
+#define reg_ofdm_bank_float_stop_pos 0
+#define reg_ofdm_bank_float_stop_len 8
+#define reg_ofdm_bank_float_stop_lsb 0
+#define xd_r_ofsm_bond0_i   (*(volatile byte xdata *) 0xFBB3)
+#define    r_ofsm_bond0_i   0xFBB3
+#define ofsm_bond0_i_pos 0
+#define ofsm_bond0_i_len 1
+#define ofsm_bond0_i_lsb 0
+#define xd_r_ofsm_bond1_i   (*(volatile byte xdata *) 0xFBB4)
+#define    r_ofsm_bond1_i   0xFBB4
+#define ofsm_bond1_i_pos 0
+#define ofsm_bond1_i_len 1
+#define ofsm_bond1_i_lsb 0
+#define xd_r_io_mux_pwron_clk_strap (*(volatile byte xdata *) 0xD800)
+#define    r_io_mux_pwron_clk_strap 0xD800
+#define io_mux_pwron_clk_strap_pos 0
+#define io_mux_pwron_clk_strap_len 4
+#define io_mux_pwron_clk_strap_lsb 0
+#define xd_r_io_mux_pwron_mode_strap    (*(volatile byte xdata *) 0xD801)
+#define    r_io_mux_pwron_mode_strap    0xD801
+#define io_mux_pwron_mode_strap_pos 0
+#define io_mux_pwron_mode_strap_len 4
+#define io_mux_pwron_mode_strap_lsb 0
+#define xd_r_io_mux_pwron_hosta (*(volatile byte xdata *) 0xD802)
+#define    r_io_mux_pwron_hosta 0xD802
+#define io_mux_pwron_hosta_pos 0
+#define io_mux_pwron_hosta_len 1
+#define io_mux_pwron_hosta_lsb 0
+#define xd_r_reg_top_revid  (*(volatile byte xdata *) 0xD803)
+#define    r_reg_top_revid  0xD803
+#define reg_top_revid_pos 0
+#define reg_top_revid_len 4
+#define reg_top_revid_lsb 0
+#define xd_r_io_mux_bond0_i (*(volatile byte xdata *) 0xD804)
+#define    r_io_mux_bond0_i 0xD804
+#define io_mux_bond0_i_pos 0
+#define io_mux_bond0_i_len 1
+#define io_mux_bond0_i_lsb 0
+#define xd_r_io_mux_bondu0_i    (*(volatile byte xdata *) 0xD805)
+#define    r_io_mux_bondu0_i    0xD805
+#define io_mux_bondu0_i_pos 0
+#define io_mux_bondu0_i_len 1
+#define io_mux_bondu0_i_lsb 0
+#define xd_p_reg_ofsm_suspend   (*(volatile byte xdata *) 0xD806)
+#define    p_reg_ofsm_suspend   0xD806
+#define reg_ofsm_suspend_pos 0
+#define reg_ofsm_suspend_len 1
+#define reg_ofsm_suspend_lsb 0
+#define xd_p_reg_tslice_off (*(volatile byte xdata *) 0xD807)
+#define    p_reg_tslice_off 0xD807
+#define reg_tslice_off_pos 0
+#define reg_tslice_off_len 1
+#define reg_tslice_off_lsb 0
+#define xd_p_io_mux_wake_int    (*(volatile byte xdata *) 0xD808)
+#define    p_io_mux_wake_int    0xD808
+#define io_mux_wake_int_pos 0
+#define io_mux_wake_int_len 1
+#define io_mux_wake_int_lsb 0
+#define xd_p_reg_top_pwrdw_hwen (*(volatile byte xdata *) 0xD809)
+#define    p_reg_top_pwrdw_hwen 0xD809
+#define reg_top_pwrdw_hwen_pos 0
+#define reg_top_pwrdw_hwen_len 1
+#define reg_top_pwrdw_hwen_lsb 0
+#define xd_p_reg_top_pwrdw_inv  (*(volatile byte xdata *) 0xD80A)
+#define    p_reg_top_pwrdw_inv  0xD80A
+#define reg_top_pwrdw_inv_pos 0
+#define reg_top_pwrdw_inv_len 1
+#define reg_top_pwrdw_inv_lsb 0
+#define xd_p_reg_top_pwrdw  (*(volatile byte xdata *) 0xD80B)
+#define    p_reg_top_pwrdw  0xD80B
+#define reg_top_pwrdw_pos 0
+#define reg_top_pwrdw_len 1
+#define reg_top_pwrdw_lsb 0
+#define xd_p_io_mux_wake_int_en (*(volatile byte xdata *) 0xD80C)
+#define    p_io_mux_wake_int_en 0xD80C
+#define io_mux_wake_int_en_pos 0
+#define io_mux_wake_int_en_len 1
+#define io_mux_wake_int_en_lsb 0
+#define xd_p_io_mux_pwrdw_int   (*(volatile byte xdata *) 0xD80D)
+#define    p_io_mux_pwrdw_int   0xD80D
+#define io_mux_pwrdw_int_pos 0
+#define io_mux_pwrdw_int_len 1
+#define io_mux_pwrdw_int_lsb 0
+#define xd_p_reg_top_adcdly (*(volatile byte xdata *) 0xD80E)
+#define    p_reg_top_adcdly 0xD80E
+#define reg_top_adcdly_pos 0
+#define reg_top_adcdly_len 2
+#define reg_top_adcdly_lsb 0
+#define xd_p_reg_top_debug  (*(volatile byte xdata *) 0xD80F)
+#define    p_reg_top_debug  0xD80F
+#define reg_top_debug_pos 0
+#define reg_top_debug_len 1
+#define reg_top_debug_lsb 0
+#define xd_p_reg_top_pcout  (*(volatile byte xdata *) 0xD810)
+#define    p_reg_top_pcout  0xD810
+#define reg_top_pcout_pos 0
+#define reg_top_pcout_len 1
+#define reg_top_pcout_lsb 0
+#define xd_p_reg_top_rs232  (*(volatile byte xdata *) 0xD811)
+#define    p_reg_top_rs232  0xD811
+#define reg_top_rs232_pos 0
+#define reg_top_rs232_len 1
+#define reg_top_rs232_lsb 0
+#define xd_p_reg_iqmode (*(volatile byte xdata *) 0xD812)
+#define    p_reg_iqmode 0xD812
+#define reg_iqmode_pos 0
+#define reg_iqmode_len 1
+#define reg_iqmode_lsb 0
+#define xd_p_reg_top_rstfd  (*(volatile byte xdata *) 0xD813)
+#define    p_reg_top_rstfd  0xD813
+#define reg_top_rstfd_pos 0
+#define reg_top_rstfd_len 1
+#define reg_top_rstfd_lsb 0
+#define xd_p_reg_sdio_clksel    (*(volatile byte xdata *) 0xD814)
+#define    p_reg_sdio_clksel    0xD814
+#define reg_sdio_clksel_pos 0
+#define reg_sdio_clksel_len 1
+#define reg_sdio_clksel_lsb 0
+#define xd_p_reg_utmi_clksel    (*(volatile byte xdata *) 0xD815)
+#define    p_reg_utmi_clksel    0xD815
+#define reg_utmi_clksel_pos 0
+#define reg_utmi_clksel_len 8
+#define reg_utmi_clksel_lsb 0
+#define xd_p_reg_top_suscnt (*(volatile byte xdata *) 0xD816)
+#define    p_reg_top_suscnt 0xD816
+#define reg_top_suscnt_pos 0
+#define reg_top_suscnt_len 2
+#define reg_top_suscnt_lsb 0
+#define xd_p_reg_top_dist2f (*(volatile byte xdata *) 0xD817)
+#define    p_reg_top_dist2f 0xD817
+#define reg_top_dist2f_pos 0
+#define reg_top_dist2f_len 1
+#define reg_top_dist2f_lsb 0
+#define xd_p_reg_top_extusb (*(volatile byte xdata *) 0xD818)
+#define    p_reg_top_extusb 0xD818
+#define reg_top_extusb_pos 0
+#define reg_top_extusb_len 1
+#define reg_top_extusb_lsb 0
+#define xd_p_reg_top_adcfifo    (*(volatile byte xdata *) 0xD819)
+#define    p_reg_top_adcfifo    0xD819
+#define reg_top_adcfifo_pos 0
+#define reg_top_adcfifo_len 1
+#define reg_top_adcfifo_lsb 0
+#define xd_p_reg_top_clkoen (*(volatile byte xdata *) 0xD81A)
+#define    p_reg_top_clkoen 0xD81A
+#define reg_top_clkoen_pos 0
+#define reg_top_clkoen_len 1
+#define reg_top_clkoen_lsb 0
+#define xd_p_reg_top_stpck  (*(volatile byte xdata *) 0xD81B)
+#define    p_reg_top_stpck  0xD81B
+#define reg_top_stpck_pos 0
+#define reg_top_stpck_len 1
+#define reg_top_stpck_lsb 0
+#define xd_p_reg_top_freeck (*(volatile byte xdata *) 0xD81C)
+#define    p_reg_top_freeck 0xD81C
+#define reg_top_freeck_pos 0
+#define reg_top_freeck_len 1
+#define reg_top_freeck_lsb 0
+#define xd_p_reg_top_dio_sel    (*(volatile byte xdata *) 0xD81D)
+#define    p_reg_top_dio_sel    0xD81D
+#define reg_top_dio_sel_pos 0
+#define reg_top_dio_sel_len 1
+#define reg_top_dio_sel_lsb 0
+#define xd_p_reg_top_int_en (*(volatile byte xdata *) 0xD81E)
+#define    p_reg_top_int_en 0xD81E
+#define reg_top_int_en_pos 0
+#define reg_top_int_en_len 1
+#define reg_top_int_en_lsb 0
+#define xd_p_reg_top_int_inv    (*(volatile byte xdata *) 0xD81F)
+#define    p_reg_top_int_inv    0xD81F
+#define reg_top_int_inv_pos 0
+#define reg_top_int_inv_len 1
+#define reg_top_int_inv_lsb 0
+#define xd_p_reg_tsip_clk_inv   (*(volatile byte xdata *) 0xD820)
+#define    p_reg_tsip_clk_inv   0xD820
+#define reg_tsip_clk_inv_pos 0
+#define reg_tsip_clk_inv_len 1
+#define reg_tsip_clk_inv_lsb 0
+#define xd_p_reg_ts_clk_inv (*(volatile byte xdata *) 0xD821)
+#define    p_reg_ts_clk_inv 0xD821
+#define reg_ts_clk_inv_pos 0
+#define reg_ts_clk_inv_len 1
+#define reg_ts_clk_inv_lsb 0
+#define xd_p_reg_ts_hybrid  (*(volatile byte xdata *) 0xD822)
+#define    p_reg_ts_hybrid  0xD822
+#define reg_ts_hybrid_pos 0
+#define reg_ts_hybrid_len 1
+#define reg_ts_hybrid_lsb 0
+#define xd_p_reg_ccir_sel   (*(volatile byte xdata *) 0xD823)
+#define    p_reg_ccir_sel   0xD823
+#define reg_ccir_sel_pos 0
+#define reg_ccir_sel_len 4
+#define reg_ccir_sel_lsb 0
+#define xd_p_reg_top_sys_gate   (*(volatile byte xdata *) 0xD824)
+#define    p_reg_top_sys_gate   0xD824
+#define reg_top_sys_gate_pos 0
+#define reg_top_sys_gate_len 1
+#define reg_top_sys_gate_lsb 0
+#define xd_p_reg_top_padpu  (*(volatile byte xdata *) 0xD825)
+#define    p_reg_top_padpu  0xD825
+#define reg_top_padpu_pos 0
+#define reg_top_padpu_len 1
+#define reg_top_padpu_lsb 0
+#define xd_p_reg_top_padpd  (*(volatile byte xdata *) 0xD826)
+#define    p_reg_top_padpd  0xD826
+#define reg_top_padpd_pos 0
+#define reg_top_padpd_len 1
+#define reg_top_padpd_lsb 0
+#define xd_p_reg_top_padodpu    (*(volatile byte xdata *) 0xD827)
+#define    p_reg_top_padodpu    0xD827
+#define reg_top_padodpu_pos 0
+#define reg_top_padodpu_len 1
+#define reg_top_padodpu_lsb 0
+#define xd_p_reg_top_thirdodpu  (*(volatile byte xdata *) 0xD828)
+#define    p_reg_top_thirdodpu  0xD828
+#define reg_top_thirdodpu_pos 0
+#define reg_top_thirdodpu_len 1
+#define reg_top_thirdodpu_lsb 0
+#define xd_p_reg_top_agc_od (*(volatile byte xdata *) 0xD829)
+#define    p_reg_top_agc_od 0xD829
+#define reg_top_agc_od_pos 0
+#define reg_top_agc_od_len 1
+#define reg_top_agc_od_lsb 0
+#define xd_p_reg_top_padmpdr2   (*(volatile byte xdata *) 0xD82A)
+#define    p_reg_top_padmpdr2   0xD82A
+#define reg_top_padmpdr2_pos 0
+#define reg_top_padmpdr2_len 1
+#define reg_top_padmpdr2_lsb 0
+#define xd_p_reg_top_padmpdr4   (*(volatile byte xdata *) 0xD82B)
+#define    p_reg_top_padmpdr4   0xD82B
+#define reg_top_padmpdr4_pos 0
+#define reg_top_padmpdr4_len 1
+#define reg_top_padmpdr4_lsb 0
+#define xd_p_reg_top_padmpdr8   (*(volatile byte xdata *) 0xD82C)
+#define    p_reg_top_padmpdr8   0xD82C
+#define reg_top_padmpdr8_pos 0
+#define reg_top_padmpdr8_len 1
+#define reg_top_padmpdr8_lsb 0
+#define xd_p_reg_top_padmpdrsr  (*(volatile byte xdata *) 0xD82D)
+#define    p_reg_top_padmpdrsr  0xD82D
+#define reg_top_padmpdrsr_pos 0
+#define reg_top_padmpdrsr_len 1
+#define reg_top_padmpdrsr_lsb 0
+#define xd_p_reg_top_padmppu    (*(volatile byte xdata *) 0xD82E)
+#define    p_reg_top_padmppu    0xD82E
+#define reg_top_padmppu_pos 0
+#define reg_top_padmppu_len 1
+#define reg_top_padmppu_lsb 0
+#define xd_p_reg_top_padmppd    (*(volatile byte xdata *) 0xD82F)
+#define    p_reg_top_padmppd    0xD82F
+#define reg_top_padmppd_pos 0
+#define reg_top_padmppd_len 1
+#define reg_top_padmppd_lsb 0
+#define xd_p_reg_top_padmiscdr2 (*(volatile byte xdata *) 0xD830)
+#define    p_reg_top_padmiscdr2 0xD830
+#define reg_top_padmiscdr2_pos 0
+#define reg_top_padmiscdr2_len 1
+#define reg_top_padmiscdr2_lsb 0
+#define xd_p_reg_top_padmiscdr4 (*(volatile byte xdata *) 0xD831)
+#define    p_reg_top_padmiscdr4 0xD831
+#define reg_top_padmiscdr4_pos 0
+#define reg_top_padmiscdr4_len 1
+#define reg_top_padmiscdr4_lsb 0
+#define xd_p_reg_top_padmiscdr8 (*(volatile byte xdata *) 0xD832)
+#define    p_reg_top_padmiscdr8 0xD832
+#define reg_top_padmiscdr8_pos 0
+#define reg_top_padmiscdr8_len 1
+#define reg_top_padmiscdr8_lsb 0
+#define xd_p_reg_top_padmiscdrsr    (*(volatile byte xdata *) 0xD833)
+#define    p_reg_top_padmiscdrsr    0xD833
+#define reg_top_padmiscdrsr_pos 0
+#define reg_top_padmiscdrsr_len 1
+#define reg_top_padmiscdrsr_lsb 0
+#define xd_p_reg_top_padmiscpu  (*(volatile byte xdata *) 0xD834)
+#define    p_reg_top_padmiscpu  0xD834
+#define reg_top_padmiscpu_pos 0
+#define reg_top_padmiscpu_len 1
+#define reg_top_padmiscpu_lsb 0
+#define xd_p_reg_top_padmiscpd  (*(volatile byte xdata *) 0xD835)
+#define    p_reg_top_padmiscpd  0xD835
+#define reg_top_padmiscpd_pos 0
+#define reg_top_padmiscpd_len 1
+#define reg_top_padmiscpd_lsb 0
+#define xd_p_reg_host_b0_smt    (*(volatile byte xdata *) 0xD836)
+#define    p_reg_host_b0_smt    0xD836
+#define reg_host_b0_smt_pos 0
+#define reg_host_b0_smt_len 1
+#define reg_host_b0_smt_lsb 0
+#define xd_p_reg_host_b1_smt    (*(volatile byte xdata *) 0xD837)
+#define    p_reg_host_b1_smt    0xD837
+#define reg_host_b1_smt_pos 0
+#define reg_host_b1_smt_len 1
+#define reg_host_b1_smt_lsb 0
+#define xd_p_reg_host_b2_smt    (*(volatile byte xdata *) 0xD838)
+#define    p_reg_host_b2_smt    0xD838
+#define reg_host_b2_smt_pos 0
+#define reg_host_b2_smt_len 1
+#define reg_host_b2_smt_lsb 0
+#define xd_p_reg_host_b3_smt    (*(volatile byte xdata *) 0xD839)
+#define    p_reg_host_b3_smt    0xD839
+#define reg_host_b3_smt_pos 0
+#define reg_host_b3_smt_len 1
+#define reg_host_b3_smt_lsb 0
+#define xd_p_reg_host_b4_smt    (*(volatile byte xdata *) 0xD83A)
+#define    p_reg_host_b4_smt    0xD83A
+#define reg_host_b4_smt_pos 0
+#define reg_host_b4_smt_len 1
+#define reg_host_b4_smt_lsb 0
+#define xd_p_reg_host_b5_smt    (*(volatile byte xdata *) 0xD83B)
+#define    p_reg_host_b5_smt    0xD83B
+#define reg_host_b5_smt_pos 0
+#define reg_host_b5_smt_len 1
+#define reg_host_b5_smt_lsb 0
+#define xd_p_reg_host_b6_smt    (*(volatile byte xdata *) 0xD83C)
+#define    p_reg_host_b6_smt    0xD83C
+#define reg_host_b6_smt_pos 0
+#define reg_host_b6_smt_len 1
+#define reg_host_b6_smt_lsb 0
+#define xd_p_reg_host_b7_smt    (*(volatile byte xdata *) 0xD83D)
+#define    p_reg_host_b7_smt    0xD83D
+#define reg_host_b7_smt_pos 0
+#define reg_host_b7_smt_len 1
+#define reg_host_b7_smt_lsb 0
+#define xd_p_reg_host_b8_smt    (*(volatile byte xdata *) 0xD83E)
+#define    p_reg_host_b8_smt    0xD83E
+#define reg_host_b8_smt_pos 0
+#define reg_host_b8_smt_len 1
+#define reg_host_b8_smt_lsb 0
+#define xd_p_reg_host_b9_smt    (*(volatile byte xdata *) 0xD83F)
+#define    p_reg_host_b9_smt    0xD83F
+#define reg_host_b9_smt_pos 0
+#define reg_host_b9_smt_len 1
+#define reg_host_b9_smt_lsb 0
+#define xd_p_reg_host_b10_smt   (*(volatile byte xdata *) 0xD840)
+#define    p_reg_host_b10_smt   0xD840
+#define reg_host_b10_smt_pos 0
+#define reg_host_b10_smt_len 1
+#define reg_host_b10_smt_lsb 0
+#define xd_p_reg_host_b11_smt   (*(volatile byte xdata *) 0xD841)
+#define    p_reg_host_b11_smt   0xD841
+#define reg_host_b11_smt_pos 0
+#define reg_host_b11_smt_len 1
+#define reg_host_b11_smt_lsb 0
+#define xd_p_reg_host_a0_smt    (*(volatile byte xdata *) 0xD842)
+#define    p_reg_host_a0_smt    0xD842
+#define reg_host_a0_smt_pos 0
+#define reg_host_a0_smt_len 1
+#define reg_host_a0_smt_lsb 0
+#define xd_p_reg_host_a1_smt    (*(volatile byte xdata *) 0xD843)
+#define    p_reg_host_a1_smt    0xD843
+#define reg_host_a1_smt_pos 0
+#define reg_host_a1_smt_len 1
+#define reg_host_a1_smt_lsb 0
+#define xd_p_reg_host_a2_smt    (*(volatile byte xdata *) 0xD844)
+#define    p_reg_host_a2_smt    0xD844
+#define reg_host_a2_smt_pos 0
+#define reg_host_a2_smt_len 1
+#define reg_host_a2_smt_lsb 0
+#define xd_p_reg_host_a3_smt    (*(volatile byte xdata *) 0xD845)
+#define    p_reg_host_a3_smt    0xD845
+#define reg_host_a3_smt_pos 0
+#define reg_host_a3_smt_len 1
+#define reg_host_a3_smt_lsb 0
+#define xd_p_reg_host_a4_smt    (*(volatile byte xdata *) 0xD846)
+#define    p_reg_host_a4_smt    0xD846
+#define reg_host_a4_smt_pos 0
+#define reg_host_a4_smt_len 1
+#define reg_host_a4_smt_lsb 0
+#define xd_p_reg_host_a5_smt    (*(volatile byte xdata *) 0xD847)
+#define    p_reg_host_a5_smt    0xD847
+#define reg_host_a5_smt_pos 0
+#define reg_host_a5_smt_len 1
+#define reg_host_a5_smt_lsb 0
+#define xd_p_reg_host_a6_smt    (*(volatile byte xdata *) 0xD848)
+#define    p_reg_host_a6_smt    0xD848
+#define reg_host_a6_smt_pos 0
+#define reg_host_a6_smt_len 1
+#define reg_host_a6_smt_lsb 0
+#define xd_p_reg_host_a7_smt    (*(volatile byte xdata *) 0xD849)
+#define    p_reg_host_a7_smt    0xD849
+#define reg_host_a7_smt_pos 0
+#define reg_host_a7_smt_len 1
+#define reg_host_a7_smt_lsb 0
+#define xd_p_reg_host_a8_smt    (*(volatile byte xdata *) 0xD84A)
+#define    p_reg_host_a8_smt    0xD84A
+#define reg_host_a8_smt_pos 0
+#define reg_host_a8_smt_len 1
+#define reg_host_a8_smt_lsb 0
+#define xd_p_reg_host_a9_smt    (*(volatile byte xdata *) 0xD84B)
+#define    p_reg_host_a9_smt    0xD84B
+#define reg_host_a9_smt_pos 0
+#define reg_host_a9_smt_len 1
+#define reg_host_a9_smt_lsb 0
+#define xd_p_reg_host_a10_smt   (*(volatile byte xdata *) 0xD84C)
+#define    p_reg_host_a10_smt   0xD84C
+#define reg_host_a10_smt_pos 0
+#define reg_host_a10_smt_len 1
+#define reg_host_a10_smt_lsb 0
+#define xd_p_reg_host_a11_smt   (*(volatile byte xdata *) 0xD84D)
+#define    p_reg_host_a11_smt   0xD84D
+#define reg_host_a11_smt_pos 0
+#define reg_host_a11_smt_len 1
+#define reg_host_a11_smt_lsb 0
+#define xd_p_reg_testmode_pds   (*(volatile byte xdata *) 0xD84E)
+#define    p_reg_testmode_pds   0xD84E
+#define reg_testmode_pds_pos 0
+#define reg_testmode_pds_len 3
+#define reg_testmode_pds_lsb 0
+#define xd_p_reg_debug31_pds    (*(volatile byte xdata *) 0xD84F)
+#define    p_reg_debug31_pds    0xD84F
+#define reg_debug31_pds_pos 0
+#define reg_debug31_pds_len 3
+#define reg_debug31_pds_lsb 0
+#define xd_p_reg_debug30_pds    (*(volatile byte xdata *) 0xD850)
+#define    p_reg_debug30_pds    0xD850
+#define reg_debug30_pds_pos 0
+#define reg_debug30_pds_len 3
+#define reg_debug30_pds_lsb 0
+#define xd_p_reg_debug29_pds    (*(volatile byte xdata *) 0xD851)
+#define    p_reg_debug29_pds    0xD851
+#define reg_debug29_pds_pos 0
+#define reg_debug29_pds_len 3
+#define reg_debug29_pds_lsb 0
+#define xd_p_reg_debug28_pds    (*(volatile byte xdata *) 0xD852)
+#define    p_reg_debug28_pds    0xD852
+#define reg_debug28_pds_pos 0
+#define reg_debug28_pds_len 3
+#define reg_debug28_pds_lsb 0
+#define xd_p_reg_debug27_pds    (*(volatile byte xdata *) 0xD853)
+#define    p_reg_debug27_pds    0xD853
+#define reg_debug27_pds_pos 0
+#define reg_debug27_pds_len 3
+#define reg_debug27_pds_lsb 0
+#define xd_p_reg_debug26_pds    (*(volatile byte xdata *) 0xD854)
+#define    p_reg_debug26_pds    0xD854
+#define reg_debug26_pds_pos 0
+#define reg_debug26_pds_len 3
+#define reg_debug26_pds_lsb 0
+#define xd_p_reg_debug25_pds    (*(volatile byte xdata *) 0xD855)
+#define    p_reg_debug25_pds    0xD855
+#define reg_debug25_pds_pos 0
+#define reg_debug25_pds_len 3
+#define reg_debug25_pds_lsb 0
+#define xd_p_reg_debug24_pds    (*(volatile byte xdata *) 0xD856)
+#define    p_reg_debug24_pds    0xD856
+#define reg_debug24_pds_pos 0
+#define reg_debug24_pds_len 3
+#define reg_debug24_pds_lsb 0
+#define xd_p_reg_debug23_pds    (*(volatile byte xdata *) 0xD857)
+#define    p_reg_debug23_pds    0xD857
+#define reg_debug23_pds_pos 0
+#define reg_debug23_pds_len 3
+#define reg_debug23_pds_lsb 0
+#define xd_p_reg_debug22_pds    (*(volatile byte xdata *) 0xD858)
+#define    p_reg_debug22_pds    0xD858
+#define reg_debug22_pds_pos 0
+#define reg_debug22_pds_len 3
+#define reg_debug22_pds_lsb 0
+#define xd_p_reg_gpioh1_pds (*(volatile byte xdata *) 0xD859)
+#define    p_reg_gpioh1_pds 0xD859
+#define reg_gpioh1_pds_pos 0
+#define reg_gpioh1_pds_len 3
+#define reg_gpioh1_pds_lsb 0
+#define xd_p_reg_gpioh2_pds (*(volatile byte xdata *) 0xD85A)
+#define    p_reg_gpioh2_pds 0xD85A
+#define reg_gpioh2_pds_pos 0
+#define reg_gpioh2_pds_len 3
+#define reg_gpioh2_pds_lsb 0
+#define xd_p_reg_gpioh3_pds (*(volatile byte xdata *) 0xD85B)
+#define    p_reg_gpioh3_pds 0xD85B
+#define reg_gpioh3_pds_pos 0
+#define reg_gpioh3_pds_len 3
+#define reg_gpioh3_pds_lsb 0
+#define xd_p_reg_gpioh4_pds (*(volatile byte xdata *) 0xD85C)
+#define    p_reg_gpioh4_pds 0xD85C
+#define reg_gpioh4_pds_pos 0
+#define reg_gpioh4_pds_len 3
+#define reg_gpioh4_pds_lsb 0
+#define xd_p_reg_iosda_pds  (*(volatile byte xdata *) 0xD85D)
+#define    p_reg_iosda_pds  0xD85D
+#define reg_iosda_pds_pos 0
+#define reg_iosda_pds_len 3
+#define reg_iosda_pds_lsb 0
+#define xd_p_reg_ioscl_pds  (*(volatile byte xdata *) 0xD85E)
+#define    p_reg_ioscl_pds  0xD85E
+#define reg_ioscl_pds_pos 0
+#define reg_ioscl_pds_len 3
+#define reg_ioscl_pds_lsb 0
+#define xd_p_reg_gpioh5_pds (*(volatile byte xdata *) 0xD85F)
+#define    p_reg_gpioh5_pds 0xD85F
+#define reg_gpioh5_pds_pos 0
+#define reg_gpioh5_pds_len 3
+#define reg_gpioh5_pds_lsb 0
+#define xd_p_reg_bond0_pds  (*(volatile byte xdata *) 0xD860)
+#define    p_reg_bond0_pds  0xD860
+#define reg_bond0_pds_pos 0
+#define reg_bond0_pds_len 3
+#define reg_bond0_pds_lsb 0
+#define xd_p_reg_i2caddr6_pds   (*(volatile byte xdata *) 0xD861)
+#define    p_reg_i2caddr6_pds   0xD861
+#define reg_i2caddr6_pds_pos 0
+#define reg_i2caddr6_pds_len 3
+#define reg_i2caddr6_pds_lsb 0
+#define xd_p_reg_i2caddr5_pds   (*(volatile byte xdata *) 0xD862)
+#define    p_reg_i2caddr5_pds   0xD862
+#define reg_i2caddr5_pds_pos 0
+#define reg_i2caddr5_pds_len 3
+#define reg_i2caddr5_pds_lsb 0
+#define xd_p_reg_i2caddr4_pds   (*(volatile byte xdata *) 0xD863)
+#define    p_reg_i2caddr4_pds   0xD863
+#define reg_i2caddr4_pds_pos 0
+#define reg_i2caddr4_pds_len 3
+#define reg_i2caddr4_pds_lsb 0
+#define xd_p_reg_host_a0_pds    (*(volatile byte xdata *) 0xD864)
+#define    p_reg_host_a0_pds    0xD864
+#define reg_host_a0_pds_pos 0
+#define reg_host_a0_pds_len 3
+#define reg_host_a0_pds_lsb 0
+#define xd_p_reg_host_a1_pds    (*(volatile byte xdata *) 0xD865)
+#define    p_reg_host_a1_pds    0xD865
+#define reg_host_a1_pds_pos 0
+#define reg_host_a1_pds_len 3
+#define reg_host_a1_pds_lsb 0
+#define xd_p_reg_debug21_pds    (*(volatile byte xdata *) 0xD866)
+#define    p_reg_debug21_pds    0xD866
+#define reg_debug21_pds_pos 0
+#define reg_debug21_pds_len 3
+#define reg_debug21_pds_lsb 0
+#define xd_p_reg_debug20_pds    (*(volatile byte xdata *) 0xD867)
+#define    p_reg_debug20_pds    0xD867
+#define reg_debug20_pds_pos 0
+#define reg_debug20_pds_len 3
+#define reg_debug20_pds_lsb 0
+#define xd_p_reg_debug19_pds    (*(volatile byte xdata *) 0xD868)
+#define    p_reg_debug19_pds    0xD868
+#define reg_debug19_pds_pos 0
+#define reg_debug19_pds_len 3
+#define reg_debug19_pds_lsb 0
+#define xd_p_reg_debug18_pds    (*(volatile byte xdata *) 0xD869)
+#define    p_reg_debug18_pds    0xD869
+#define reg_debug18_pds_pos 0
+#define reg_debug18_pds_len 3
+#define reg_debug18_pds_lsb 0
+#define xd_p_reg_debug17_pds    (*(volatile byte xdata *) 0xD86A)
+#define    p_reg_debug17_pds    0xD86A
+#define reg_debug17_pds_pos 0
+#define reg_debug17_pds_len 3
+#define reg_debug17_pds_lsb 0
+#define xd_p_reg_host_a2_pds    (*(volatile byte xdata *) 0xD86B)
+#define    p_reg_host_a2_pds    0xD86B
+#define reg_host_a2_pds_pos 0
+#define reg_host_a2_pds_len 3
+#define reg_host_a2_pds_lsb 0
+#define xd_p_reg_host_a3_pds    (*(volatile byte xdata *) 0xD86C)
+#define    p_reg_host_a3_pds    0xD86C
+#define reg_host_a3_pds_pos 0
+#define reg_host_a3_pds_len 3
+#define reg_host_a3_pds_lsb 0
+#define xd_p_reg_host_a4_pds    (*(volatile byte xdata *) 0xD86D)
+#define    p_reg_host_a4_pds    0xD86D
+#define reg_host_a4_pds_pos 0
+#define reg_host_a4_pds_len 3
+#define reg_host_a4_pds_lsb 0
+#define xd_p_reg_host_a5_pds    (*(volatile byte xdata *) 0xD86E)
+#define    p_reg_host_a5_pds    0xD86E
+#define reg_host_a5_pds_pos 0
+#define reg_host_a5_pds_len 3
+#define reg_host_a5_pds_lsb 0
+#define xd_p_reg_host_a6_pds    (*(volatile byte xdata *) 0xD86F)
+#define    p_reg_host_a6_pds    0xD86F
+#define reg_host_a6_pds_pos 0
+#define reg_host_a6_pds_len 3
+#define reg_host_a6_pds_lsb 0
+#define xd_p_reg_p160sel_pds    (*(volatile byte xdata *) 0xD870)
+#define    p_reg_p160sel_pds    0xD870
+#define reg_p160sel_pds_pos 0
+#define reg_p160sel_pds_len 3
+#define reg_p160sel_pds_lsb 0
+#define xd_p_reg_gpioh13_pds    (*(volatile byte xdata *) 0xD871)
+#define    p_reg_gpioh13_pds    0xD871
+#define reg_gpioh13_pds_pos 0
+#define reg_gpioh13_pds_len 3
+#define reg_gpioh13_pds_lsb 0
+#define xd_p_reg_gpioh12_pds    (*(volatile byte xdata *) 0xD872)
+#define    p_reg_gpioh12_pds    0xD872
+#define reg_gpioh12_pds_pos 0
+#define reg_gpioh12_pds_len 3
+#define reg_gpioh12_pds_lsb 0
+#define xd_p_reg_gpioh11_pds    (*(volatile byte xdata *) 0xD873)
+#define    p_reg_gpioh11_pds    0xD873
+#define reg_gpioh11_pds_pos 0
+#define reg_gpioh11_pds_len 3
+#define reg_gpioh11_pds_lsb 0
+#define xd_p_reg_host_a7_pds    (*(volatile byte xdata *) 0xD874)
+#define    p_reg_host_a7_pds    0xD874
+#define reg_host_a7_pds_pos 0
+#define reg_host_a7_pds_len 3
+#define reg_host_a7_pds_lsb 0
+#define xd_p_reg_host_a8_pds    (*(volatile byte xdata *) 0xD875)
+#define    p_reg_host_a8_pds    0xD875
+#define reg_host_a8_pds_pos 0
+#define reg_host_a8_pds_len 3
+#define reg_host_a8_pds_lsb 0
+#define xd_p_reg_host_a9_pds    (*(volatile byte xdata *) 0xD876)
+#define    p_reg_host_a9_pds    0xD876
+#define reg_host_a9_pds_pos 0
+#define reg_host_a9_pds_len 3
+#define reg_host_a9_pds_lsb 0
+#define xd_p_reg_host_a10_pds   (*(volatile byte xdata *) 0xD877)
+#define    p_reg_host_a10_pds   0xD877
+#define reg_host_a10_pds_pos 0
+#define reg_host_a10_pds_len 3
+#define reg_host_a10_pds_lsb 0
+#define xd_p_reg_host_a11_pds   (*(volatile byte xdata *) 0xD878)
+#define    p_reg_host_a11_pds   0xD878
+#define reg_host_a11_pds_pos 0
+#define reg_host_a11_pds_len 3
+#define reg_host_a11_pds_lsb 0
+#define xd_p_reg_bondu0_pds (*(volatile byte xdata *) 0xD879)
+#define    p_reg_bondu0_pds 0xD879
+#define reg_bondu0_pds_pos 0
+#define reg_bondu0_pds_len 3
+#define reg_bondu0_pds_lsb 0
+#define xd_p_reg_host_b0_pds    (*(volatile byte xdata *) 0xD87A)
+#define    p_reg_host_b0_pds    0xD87A
+#define reg_host_b0_pds_pos 0
+#define reg_host_b0_pds_len 3
+#define reg_host_b0_pds_lsb 0
+#define xd_p_reg_host_b1_pds    (*(volatile byte xdata *) 0xD87B)
+#define    p_reg_host_b1_pds    0xD87B
+#define reg_host_b1_pds_pos 0
+#define reg_host_b1_pds_len 3
+#define reg_host_b1_pds_lsb 0
+#define xd_p_reg_host_b2_pds    (*(volatile byte xdata *) 0xD87C)
+#define    p_reg_host_b2_pds    0xD87C
+#define reg_host_b2_pds_pos 0
+#define reg_host_b2_pds_len 3
+#define reg_host_b2_pds_lsb 0
+#define xd_p_reg_host_b3_pds    (*(volatile byte xdata *) 0xD87D)
+#define    p_reg_host_b3_pds    0xD87D
+#define reg_host_b3_pds_pos 0
+#define reg_host_b3_pds_len 3
+#define reg_host_b3_pds_lsb 0
+#define xd_p_reg_host_b4_pds    (*(volatile byte xdata *) 0xD87E)
+#define    p_reg_host_b4_pds    0xD87E
+#define reg_host_b4_pds_pos 0
+#define reg_host_b4_pds_len 3
+#define reg_host_b4_pds_lsb 0
+#define xd_p_reg_host_b5_pds    (*(volatile byte xdata *) 0xD87F)
+#define    p_reg_host_b5_pds    0xD87F
+#define reg_host_b5_pds_pos 0
+#define reg_host_b5_pds_len 3
+#define reg_host_b5_pds_lsb 0
+#define xd_p_reg_host_b6_pds    (*(volatile byte xdata *) 0xD880)
+#define    p_reg_host_b6_pds    0xD880
+#define reg_host_b6_pds_pos 0
+#define reg_host_b6_pds_len 3
+#define reg_host_b6_pds_lsb 0
+#define xd_p_reg_host_b7_pds    (*(volatile byte xdata *) 0xD881)
+#define    p_reg_host_b7_pds    0xD881
+#define reg_host_b7_pds_pos 0
+#define reg_host_b7_pds_len 3
+#define reg_host_b7_pds_lsb 0
+#define xd_p_reg_afe_f12_pds    (*(volatile byte xdata *) 0xD882)
+#define    p_reg_afe_f12_pds    0xD882
+#define reg_afe_f12_pds_pos 0
+#define reg_afe_f12_pds_len 3
+#define reg_afe_f12_pds_lsb 0
+#define xd_p_reg_host_b8_pds    (*(volatile byte xdata *) 0xD883)
+#define    p_reg_host_b8_pds    0xD883
+#define reg_host_b8_pds_pos 0
+#define reg_host_b8_pds_len 3
+#define reg_host_b8_pds_lsb 0
+#define xd_p_reg_host_b9_pds    (*(volatile byte xdata *) 0xD884)
+#define    p_reg_host_b9_pds    0xD884
+#define reg_host_b9_pds_pos 0
+#define reg_host_b9_pds_len 3
+#define reg_host_b9_pds_lsb 0
+#define xd_p_reg_host_b10_pds   (*(volatile byte xdata *) 0xD885)
+#define    p_reg_host_b10_pds   0xD885
+#define reg_host_b10_pds_pos 0
+#define reg_host_b10_pds_len 3
+#define reg_host_b10_pds_lsb 0
+#define xd_p_reg_host_b11_pds   (*(volatile byte xdata *) 0xD886)
+#define    p_reg_host_b11_pds   0xD886
+#define reg_host_b11_pds_pos 0
+#define reg_host_b11_pds_len 3
+#define reg_host_b11_pds_lsb 0
+#define xd_p_reg_debug16_pds    (*(volatile byte xdata *) 0xD887)
+#define    p_reg_debug16_pds    0xD887
+#define reg_debug16_pds_pos 0
+#define reg_debug16_pds_len 3
+#define reg_debug16_pds_lsb 0
+#define xd_p_reg_debug15_pds    (*(volatile byte xdata *) 0xD888)
+#define    p_reg_debug15_pds    0xD888
+#define reg_debug15_pds_pos 0
+#define reg_debug15_pds_len 3
+#define reg_debug15_pds_lsb 0
+#define xd_p_reg_debug14_pds    (*(volatile byte xdata *) 0xD889)
+#define    p_reg_debug14_pds    0xD889
+#define reg_debug14_pds_pos 0
+#define reg_debug14_pds_len 3
+#define reg_debug14_pds_lsb 0
+#define xd_p_reg_debug13_pds    (*(volatile byte xdata *) 0xD88A)
+#define    p_reg_debug13_pds    0xD88A
+#define reg_debug13_pds_pos 0
+#define reg_debug13_pds_len 3
+#define reg_debug13_pds_lsb 0
+#define xd_p_reg_debug12_pds    (*(volatile byte xdata *) 0xD88B)
+#define    p_reg_debug12_pds    0xD88B
+#define reg_debug12_pds_pos 0
+#define reg_debug12_pds_len 3
+#define reg_debug12_pds_lsb 0
+#define xd_p_reg_debug11_pds    (*(volatile byte xdata *) 0xD88C)
+#define    p_reg_debug11_pds    0xD88C
+#define reg_debug11_pds_pos 0
+#define reg_debug11_pds_len 3
+#define reg_debug11_pds_lsb 0
+#define xd_p_reg_debug10_pds    (*(volatile byte xdata *) 0xD88D)
+#define    p_reg_debug10_pds    0xD88D
+#define reg_debug10_pds_pos 0
+#define reg_debug10_pds_len 3
+#define reg_debug10_pds_lsb 0
+#define xd_p_reg_debug9_pds (*(volatile byte xdata *) 0xD88E)
+#define    p_reg_debug9_pds 0xD88E
+#define reg_debug9_pds_pos 0
+#define reg_debug9_pds_len 3
+#define reg_debug9_pds_lsb 0
+#define xd_p_reg_debug8_pds (*(volatile byte xdata *) 0xD88F)
+#define    p_reg_debug8_pds 0xD88F
+#define reg_debug8_pds_pos 0
+#define reg_debug8_pds_len 3
+#define reg_debug8_pds_lsb 0
+#define xd_p_reg_debug7_pds (*(volatile byte xdata *) 0xD890)
+#define    p_reg_debug7_pds 0xD890
+#define reg_debug7_pds_pos 0
+#define reg_debug7_pds_len 3
+#define reg_debug7_pds_lsb 0
+#define xd_p_reg_debug6_pds (*(volatile byte xdata *) 0xD891)
+#define    p_reg_debug6_pds 0xD891
+#define reg_debug6_pds_pos 0
+#define reg_debug6_pds_len 3
+#define reg_debug6_pds_lsb 0
+#define xd_p_reg_debug5_pds (*(volatile byte xdata *) 0xD892)
+#define    p_reg_debug5_pds 0xD892
+#define reg_debug5_pds_pos 0
+#define reg_debug5_pds_len 3
+#define reg_debug5_pds_lsb 0
+#define xd_p_reg_debug4_pds (*(volatile byte xdata *) 0xD893)
+#define    p_reg_debug4_pds 0xD893
+#define reg_debug4_pds_pos 0
+#define reg_debug4_pds_len 3
+#define reg_debug4_pds_lsb 0
+#define xd_p_reg_clko_pds   (*(volatile byte xdata *) 0xD894)
+#define    p_reg_clko_pds   0xD894
+#define reg_clko_pds_pos 0
+#define reg_clko_pds_len 3
+#define reg_clko_pds_lsb 0
+#define xd_p_reg_gpioh6_pds (*(volatile byte xdata *) 0xD895)
+#define    p_reg_gpioh6_pds 0xD895
+#define reg_gpioh6_pds_pos 0
+#define reg_gpioh6_pds_len 3
+#define reg_gpioh6_pds_lsb 0
+#define xd_p_reg_gpioh7_pds (*(volatile byte xdata *) 0xD896)
+#define    p_reg_gpioh7_pds 0xD896
+#define reg_gpioh7_pds_pos 0
+#define reg_gpioh7_pds_len 3
+#define reg_gpioh7_pds_lsb 0
+#define xd_p_reg_gpioh8_pds (*(volatile byte xdata *) 0xD897)
+#define    p_reg_gpioh8_pds 0xD897
+#define reg_gpioh8_pds_pos 0
+#define reg_gpioh8_pds_len 3
+#define reg_gpioh8_pds_lsb 0
+#define xd_p_reg_gpioh9_pds (*(volatile byte xdata *) 0xD898)
+#define    p_reg_gpioh9_pds 0xD898
+#define reg_gpioh9_pds_pos 0
+#define reg_gpioh9_pds_len 3
+#define reg_gpioh9_pds_lsb 0
+#define xd_p_reg_gpioh10_pds    (*(volatile byte xdata *) 0xD899)
+#define    p_reg_gpioh10_pds    0xD899
+#define reg_gpioh10_pds_pos 0
+#define reg_gpioh10_pds_len 3
+#define reg_gpioh10_pds_lsb 0
+#define xd_p_reg_debug3_pds (*(volatile byte xdata *) 0xD89A)
+#define    p_reg_debug3_pds 0xD89A
+#define reg_debug3_pds_pos 0
+#define reg_debug3_pds_len 3
+#define reg_debug3_pds_lsb 0
+#define xd_p_reg_debug2_pds (*(volatile byte xdata *) 0xD89B)
+#define    p_reg_debug2_pds 0xD89B
+#define reg_debug2_pds_pos 0
+#define reg_debug2_pds_len 3
+#define reg_debug2_pds_lsb 0
+#define xd_p_reg_debug1_pds (*(volatile byte xdata *) 0xD89C)
+#define    p_reg_debug1_pds 0xD89C
+#define reg_debug1_pds_pos 0
+#define reg_debug1_pds_len 3
+#define reg_debug1_pds_lsb 0
+#define xd_p_reg_debug0_pds (*(volatile byte xdata *) 0xD89D)
+#define    p_reg_debug0_pds 0xD89D
+#define reg_debug0_pds_pos 0
+#define reg_debug0_pds_len 3
+#define reg_debug0_pds_lsb 0
+#define xd_p_reg_gpiot1_pds (*(volatile byte xdata *) 0xD89E)
+#define    p_reg_gpiot1_pds 0xD89E
+#define reg_gpiot1_pds_pos 0
+#define reg_gpiot1_pds_len 3
+#define reg_gpiot1_pds_lsb 0
+#define xd_p_reg_gpiot2_pds (*(volatile byte xdata *) 0xD89F)
+#define    p_reg_gpiot2_pds 0xD89F
+#define reg_gpiot2_pds_pos 0
+#define reg_gpiot2_pds_len 3
+#define reg_gpiot2_pds_lsb 0
+#define xd_p_reg_rfagc_pds  (*(volatile byte xdata *) 0xD8A0)
+#define    p_reg_rfagc_pds  0xD8A0
+#define reg_rfagc_pds_pos 0
+#define reg_rfagc_pds_len 3
+#define reg_rfagc_pds_lsb 0
+#define xd_p_reg_ifagc_pds  (*(volatile byte xdata *) 0xD8A1)
+#define    p_reg_ifagc_pds  0xD8A1
+#define reg_ifagc_pds_pos 0
+#define reg_ifagc_pds_len 3
+#define reg_ifagc_pds_lsb 0
+#define xd_p_reg_gpiot3_pds (*(volatile byte xdata *) 0xD8A2)
+#define    p_reg_gpiot3_pds 0xD8A2
+#define reg_gpiot3_pds_pos 0
+#define reg_gpiot3_pds_len 3
+#define reg_gpiot3_pds_lsb 0
+#define xd_p_reg_i2caddr3_pds   (*(volatile byte xdata *) 0xD8A3)
+#define    p_reg_i2caddr3_pds   0xD8A3
+#define reg_i2caddr3_pds_pos 0
+#define reg_i2caddr3_pds_len 3
+#define reg_i2caddr3_pds_lsb 0
+#define xd_p_reg_i2caddr2_pds   (*(volatile byte xdata *) 0xD8A4)
+#define    p_reg_i2caddr2_pds   0xD8A4
+#define reg_i2caddr2_pds_pos 0
+#define reg_i2caddr2_pds_len 3
+#define reg_i2caddr2_pds_lsb 0
+#define xd_p_reg_i2caddr1_pds   (*(volatile byte xdata *) 0xD8A5)
+#define    p_reg_i2caddr1_pds   0xD8A5
+#define reg_i2caddr1_pds_pos 0
+#define reg_i2caddr1_pds_len 3
+#define reg_i2caddr1_pds_lsb 0
+#define xd_p_reg_afe_sel33_pds  (*(volatile byte xdata *) 0xD8A6)
+#define    p_reg_afe_sel33_pds  0xD8A6
+#define reg_afe_sel33_pds_pos 0
+#define reg_afe_sel33_pds_len 3
+#define reg_afe_sel33_pds_lsb 0
+#define xd_p_reg_iotunscl_pds   (*(volatile byte xdata *) 0xD8A7)
+#define    p_reg_iotunscl_pds   0xD8A7
+#define reg_iotunscl_pds_pos 0
+#define reg_iotunscl_pds_len 3
+#define reg_iotunscl_pds_lsb 0
+#define xd_p_reg_iotunsda_pds   (*(volatile byte xdata *) 0xD8A8)
+#define    p_reg_iotunsda_pds   0xD8A8
+#define reg_iotunsda_pds_pos 0
+#define reg_iotunsda_pds_len 3
+#define reg_iotunsda_pds_lsb 0
+#define xd_p_reg_rxdofsm_pds    (*(volatile byte xdata *) 0xD8A9)
+#define    p_reg_rxdofsm_pds    0xD8A9
+#define reg_rxdofsm_pds_pos 0
+#define reg_rxdofsm_pds_len 3
+#define reg_rxdofsm_pds_lsb 0
+#define xd_p_reg_txdofsm_pds    (*(volatile byte xdata *) 0xD8AA)
+#define    p_reg_txdofsm_pds    0xD8AA
+#define reg_txdofsm_pds_pos 0
+#define reg_txdofsm_pds_len 3
+#define reg_txdofsm_pds_lsb 0
+#define xd_p_reg_rxdlink_pds    (*(volatile byte xdata *) 0xD8AB)
+#define    p_reg_rxdlink_pds    0xD8AB
+#define reg_rxdlink_pds_pos 0
+#define reg_rxdlink_pds_len 3
+#define reg_rxdlink_pds_lsb 0
+#define xd_p_reg_txdlink_pds    (*(volatile byte xdata *) 0xD8AC)
+#define    p_reg_txdlink_pds    0xD8AC
+#define reg_txdlink_pds_pos 0
+#define reg_txdlink_pds_len 3
+#define reg_txdlink_pds_lsb 0
+#define xd_p_reg_ck_test_pds    (*(volatile byte xdata *) 0xD8AD)
+#define    p_reg_ck_test_pds    0xD8AD
+#define reg_ck_test_pds_pos 0
+#define reg_ck_test_pds_len 3
+#define reg_ck_test_pds_lsb 0
+#define xd_r_reg_top_gpioh1_i   (*(volatile byte xdata *) 0xD8AE)
+#define    r_reg_top_gpioh1_i   0xD8AE
+#define reg_top_gpioh1_i_pos 0
+#define reg_top_gpioh1_i_len 1
+#define reg_top_gpioh1_i_lsb 0
+#define xd_p_reg_top_gpioh1_o   (*(volatile byte xdata *) 0xD8AF)
+#define    p_reg_top_gpioh1_o   0xD8AF
+#define reg_top_gpioh1_o_pos 0
+#define reg_top_gpioh1_o_len 1
+#define reg_top_gpioh1_o_lsb 0
+#define xd_p_reg_top_gpioh1_en  (*(volatile byte xdata *) 0xD8B0)
+#define    p_reg_top_gpioh1_en  0xD8B0
+#define reg_top_gpioh1_en_pos 0
+#define reg_top_gpioh1_en_len 1
+#define reg_top_gpioh1_en_lsb 0
+#define xd_p_reg_top_gpioh1_on  (*(volatile byte xdata *) 0xD8B1)
+#define    p_reg_top_gpioh1_on  0xD8B1
+#define reg_top_gpioh1_on_pos 0
+#define reg_top_gpioh1_on_len 1
+#define reg_top_gpioh1_on_lsb 0
+#define xd_r_reg_top_gpioh3_i   (*(volatile byte xdata *) 0xD8B2)
+#define    r_reg_top_gpioh3_i   0xD8B2
+#define reg_top_gpioh3_i_pos 0
+#define reg_top_gpioh3_i_len 1
+#define reg_top_gpioh3_i_lsb 0
+#define xd_p_reg_top_gpioh3_o   (*(volatile byte xdata *) 0xD8B3)
+#define    p_reg_top_gpioh3_o   0xD8B3
+#define reg_top_gpioh3_o_pos 0
+#define reg_top_gpioh3_o_len 1
+#define reg_top_gpioh3_o_lsb 0
+#define xd_p_reg_top_gpioh3_en  (*(volatile byte xdata *) 0xD8B4)
+#define    p_reg_top_gpioh3_en  0xD8B4
+#define reg_top_gpioh3_en_pos 0
+#define reg_top_gpioh3_en_len 1
+#define reg_top_gpioh3_en_lsb 0
+#define xd_p_reg_top_gpioh3_on  (*(volatile byte xdata *) 0xD8B5)
+#define    p_reg_top_gpioh3_on  0xD8B5
+#define reg_top_gpioh3_on_pos 0
+#define reg_top_gpioh3_on_len 1
+#define reg_top_gpioh3_on_lsb 0
+#define xd_r_reg_top_gpioh2_i   (*(volatile byte xdata *) 0xD8B6)
+#define    r_reg_top_gpioh2_i   0xD8B6
+#define reg_top_gpioh2_i_pos 0
+#define reg_top_gpioh2_i_len 1
+#define reg_top_gpioh2_i_lsb 0
+#define xd_p_reg_top_gpioh2_o   (*(volatile byte xdata *) 0xD8B7)
+#define    p_reg_top_gpioh2_o   0xD8B7
+#define reg_top_gpioh2_o_pos 0
+#define reg_top_gpioh2_o_len 1
+#define reg_top_gpioh2_o_lsb 0
+#define xd_p_reg_top_gpioh2_en  (*(volatile byte xdata *) 0xD8B8)
+#define    p_reg_top_gpioh2_en  0xD8B8
+#define reg_top_gpioh2_en_pos 0
+#define reg_top_gpioh2_en_len 1
+#define reg_top_gpioh2_en_lsb 0
+#define xd_p_reg_top_gpioh2_on  (*(volatile byte xdata *) 0xD8B9)
+#define    p_reg_top_gpioh2_on  0xD8B9
+#define reg_top_gpioh2_on_pos 0
+#define reg_top_gpioh2_on_len 1
+#define reg_top_gpioh2_on_lsb 0
+#define xd_r_reg_top_gpioh5_i   (*(volatile byte xdata *) 0xD8BA)
+#define    r_reg_top_gpioh5_i   0xD8BA
+#define reg_top_gpioh5_i_pos 0
+#define reg_top_gpioh5_i_len 1
+#define reg_top_gpioh5_i_lsb 0
+#define xd_p_reg_top_gpioh5_o   (*(volatile byte xdata *) 0xD8BB)
+#define    p_reg_top_gpioh5_o   0xD8BB
+#define reg_top_gpioh5_o_pos 0
+#define reg_top_gpioh5_o_len 1
+#define reg_top_gpioh5_o_lsb 0
+#define xd_p_reg_top_gpioh5_en  (*(volatile byte xdata *) 0xD8BC)
+#define    p_reg_top_gpioh5_en  0xD8BC
+#define reg_top_gpioh5_en_pos 0
+#define reg_top_gpioh5_en_len 1
+#define reg_top_gpioh5_en_lsb 0
+#define xd_p_reg_top_gpioh5_on  (*(volatile byte xdata *) 0xD8BD)
+#define    p_reg_top_gpioh5_on  0xD8BD
+#define reg_top_gpioh5_on_pos 0
+#define reg_top_gpioh5_on_len 1
+#define reg_top_gpioh5_on_lsb 0
+#define xd_r_reg_top_gpioh4_i   (*(volatile byte xdata *) 0xD8BE)
+#define    r_reg_top_gpioh4_i   0xD8BE
+#define reg_top_gpioh4_i_pos 0
+#define reg_top_gpioh4_i_len 1
+#define reg_top_gpioh4_i_lsb 0
+#define xd_p_reg_top_gpioh4_o   (*(volatile byte xdata *) 0xD8BF)
+#define    p_reg_top_gpioh4_o   0xD8BF
+#define reg_top_gpioh4_o_pos 0
+#define reg_top_gpioh4_o_len 1
+#define reg_top_gpioh4_o_lsb 0
+#define xd_p_reg_top_gpioh4_en  (*(volatile byte xdata *) 0xD8C0)
+#define    p_reg_top_gpioh4_en  0xD8C0
+#define reg_top_gpioh4_en_pos 0
+#define reg_top_gpioh4_en_len 1
+#define reg_top_gpioh4_en_lsb 0
+#define xd_p_reg_top_gpioh4_on  (*(volatile byte xdata *) 0xD8C1)
+#define    p_reg_top_gpioh4_on  0xD8C1
+#define reg_top_gpioh4_on_pos 0
+#define reg_top_gpioh4_on_len 1
+#define reg_top_gpioh4_on_lsb 0
+#define xd_r_reg_top_gpioh7_i   (*(volatile byte xdata *) 0xD8C2)
+#define    r_reg_top_gpioh7_i   0xD8C2
+#define reg_top_gpioh7_i_pos 0
+#define reg_top_gpioh7_i_len 1
+#define reg_top_gpioh7_i_lsb 0
+#define xd_p_reg_top_gpioh7_o   (*(volatile byte xdata *) 0xD8C3)
+#define    p_reg_top_gpioh7_o   0xD8C3
+#define reg_top_gpioh7_o_pos 0
+#define reg_top_gpioh7_o_len 1
+#define reg_top_gpioh7_o_lsb 0
+#define xd_p_reg_top_gpioh7_en  (*(volatile byte xdata *) 0xD8C4)
+#define    p_reg_top_gpioh7_en  0xD8C4
+#define reg_top_gpioh7_en_pos 0
+#define reg_top_gpioh7_en_len 1
+#define reg_top_gpioh7_en_lsb 0
+#define xd_p_reg_top_gpioh7_on  (*(volatile byte xdata *) 0xD8C5)
+#define    p_reg_top_gpioh7_on  0xD8C5
+#define reg_top_gpioh7_on_pos 0
+#define reg_top_gpioh7_on_len 1
+#define reg_top_gpioh7_on_lsb 0
+#define xd_r_reg_top_gpioh6_i   (*(volatile byte xdata *) 0xD8C6)
+#define    r_reg_top_gpioh6_i   0xD8C6
+#define reg_top_gpioh6_i_pos 0
+#define reg_top_gpioh6_i_len 1
+#define reg_top_gpioh6_i_lsb 0
+#define xd_p_reg_top_gpioh6_o   (*(volatile byte xdata *) 0xD8C7)
+#define    p_reg_top_gpioh6_o   0xD8C7
+#define reg_top_gpioh6_o_pos 0
+#define reg_top_gpioh6_o_len 1
+#define reg_top_gpioh6_o_lsb 0
+#define xd_p_reg_top_gpioh6_en  (*(volatile byte xdata *) 0xD8C8)
+#define    p_reg_top_gpioh6_en  0xD8C8
+#define reg_top_gpioh6_en_pos 0
+#define reg_top_gpioh6_en_len 1
+#define reg_top_gpioh6_en_lsb 0
+#define xd_p_reg_top_gpioh6_on  (*(volatile byte xdata *) 0xD8C9)
+#define    p_reg_top_gpioh6_on  0xD8C9
+#define reg_top_gpioh6_on_pos 0
+#define reg_top_gpioh6_on_len 1
+#define reg_top_gpioh6_on_lsb 0
+#define xd_r_reg_top_gpioh9_i   (*(volatile byte xdata *) 0xD8CA)
+#define    r_reg_top_gpioh9_i   0xD8CA
+#define reg_top_gpioh9_i_pos 0
+#define reg_top_gpioh9_i_len 1
+#define reg_top_gpioh9_i_lsb 0
+#define xd_p_reg_top_gpioh9_o   (*(volatile byte xdata *) 0xD8CB)
+#define    p_reg_top_gpioh9_o   0xD8CB
+#define reg_top_gpioh9_o_pos 0
+#define reg_top_gpioh9_o_len 1
+#define reg_top_gpioh9_o_lsb 0
+#define xd_p_reg_top_gpioh9_en  (*(volatile byte xdata *) 0xD8CC)
+#define    p_reg_top_gpioh9_en  0xD8CC
+#define reg_top_gpioh9_en_pos 0
+#define reg_top_gpioh9_en_len 1
+#define reg_top_gpioh9_en_lsb 0
+#define xd_p_reg_top_gpioh9_on  (*(volatile byte xdata *) 0xD8CD)
+#define    p_reg_top_gpioh9_on  0xD8CD
+#define reg_top_gpioh9_on_pos 0
+#define reg_top_gpioh9_on_len 1
+#define reg_top_gpioh9_on_lsb 0
+#define xd_r_reg_top_gpioh8_i   (*(volatile byte xdata *) 0xD8CE)
+#define    r_reg_top_gpioh8_i   0xD8CE
+#define reg_top_gpioh8_i_pos 0
+#define reg_top_gpioh8_i_len 1
+#define reg_top_gpioh8_i_lsb 0
+#define xd_p_reg_top_gpioh8_o   (*(volatile byte xdata *) 0xD8CF)
+#define    p_reg_top_gpioh8_o   0xD8CF
+#define reg_top_gpioh8_o_pos 0
+#define reg_top_gpioh8_o_len 1
+#define reg_top_gpioh8_o_lsb 0
+#define xd_p_reg_top_gpioh8_en  (*(volatile byte xdata *) 0xD8D0)
+#define    p_reg_top_gpioh8_en  0xD8D0
+#define reg_top_gpioh8_en_pos 0
+#define reg_top_gpioh8_en_len 1
+#define reg_top_gpioh8_en_lsb 0
+#define xd_p_reg_top_gpioh8_on  (*(volatile byte xdata *) 0xD8D1)
+#define    p_reg_top_gpioh8_on  0xD8D1
+#define reg_top_gpioh8_on_pos 0
+#define reg_top_gpioh8_on_len 1
+#define reg_top_gpioh8_on_lsb 0
+#define xd_r_reg_top_gpioh11_i  (*(volatile byte xdata *) 0xD8D2)
+#define    r_reg_top_gpioh11_i  0xD8D2
+#define reg_top_gpioh11_i_pos 0
+#define reg_top_gpioh11_i_len 1
+#define reg_top_gpioh11_i_lsb 0
+#define xd_p_reg_top_gpioh11_o  (*(volatile byte xdata *) 0xD8D3)
+#define    p_reg_top_gpioh11_o  0xD8D3
+#define reg_top_gpioh11_o_pos 0
+#define reg_top_gpioh11_o_len 1
+#define reg_top_gpioh11_o_lsb 0
+#define xd_p_reg_top_gpioh11_en (*(volatile byte xdata *) 0xD8D4)
+#define    p_reg_top_gpioh11_en 0xD8D4
+#define reg_top_gpioh11_en_pos 0
+#define reg_top_gpioh11_en_len 1
+#define reg_top_gpioh11_en_lsb 0
+#define xd_p_reg_top_gpioh11_on (*(volatile byte xdata *) 0xD8D5)
+#define    p_reg_top_gpioh11_on 0xD8D5
+#define reg_top_gpioh11_on_pos 0
+#define reg_top_gpioh11_on_len 1
+#define reg_top_gpioh11_on_lsb 0
+#define xd_r_reg_top_gpioh10_i  (*(volatile byte xdata *) 0xD8D6)
+#define    r_reg_top_gpioh10_i  0xD8D6
+#define reg_top_gpioh10_i_pos 0
+#define reg_top_gpioh10_i_len 1
+#define reg_top_gpioh10_i_lsb 0
+#define xd_p_reg_top_gpioh10_o  (*(volatile byte xdata *) 0xD8D7)
+#define    p_reg_top_gpioh10_o  0xD8D7
+#define reg_top_gpioh10_o_pos 0
+#define reg_top_gpioh10_o_len 1
+#define reg_top_gpioh10_o_lsb 0
+#define xd_p_reg_top_gpioh10_en (*(volatile byte xdata *) 0xD8D8)
+#define    p_reg_top_gpioh10_en 0xD8D8
+#define reg_top_gpioh10_en_pos 0
+#define reg_top_gpioh10_en_len 1
+#define reg_top_gpioh10_en_lsb 0
+#define xd_p_reg_top_gpioh10_on (*(volatile byte xdata *) 0xD8D9)
+#define    p_reg_top_gpioh10_on 0xD8D9
+#define reg_top_gpioh10_on_pos 0
+#define reg_top_gpioh10_on_len 1
+#define reg_top_gpioh10_on_lsb 0
+#define xd_r_reg_top_gpioh13_i  (*(volatile byte xdata *) 0xD8DA)
+#define    r_reg_top_gpioh13_i  0xD8DA
+#define reg_top_gpioh13_i_pos 0
+#define reg_top_gpioh13_i_len 1
+#define reg_top_gpioh13_i_lsb 0
+#define xd_p_reg_top_gpioh13_o  (*(volatile byte xdata *) 0xD8DB)
+#define    p_reg_top_gpioh13_o  0xD8DB
+#define reg_top_gpioh13_o_pos 0
+#define reg_top_gpioh13_o_len 1
+#define reg_top_gpioh13_o_lsb 0
+#define xd_p_reg_top_gpioh13_en (*(volatile byte xdata *) 0xD8DC)
+#define    p_reg_top_gpioh13_en 0xD8DC
+#define reg_top_gpioh13_en_pos 0
+#define reg_top_gpioh13_en_len 1
+#define reg_top_gpioh13_en_lsb 0
+#define xd_p_reg_top_gpioh13_on (*(volatile byte xdata *) 0xD8DD)
+#define    p_reg_top_gpioh13_on 0xD8DD
+#define reg_top_gpioh13_on_pos 0
+#define reg_top_gpioh13_on_len 1
+#define reg_top_gpioh13_on_lsb 0
+#define xd_r_reg_top_gpioh12_i  (*(volatile byte xdata *) 0xD8DE)
+#define    r_reg_top_gpioh12_i  0xD8DE
+#define reg_top_gpioh12_i_pos 0
+#define reg_top_gpioh12_i_len 1
+#define reg_top_gpioh12_i_lsb 0
+#define xd_p_reg_top_gpioh12_o  (*(volatile byte xdata *) 0xD8DF)
+#define    p_reg_top_gpioh12_o  0xD8DF
+#define reg_top_gpioh12_o_pos 0
+#define reg_top_gpioh12_o_len 1
+#define reg_top_gpioh12_o_lsb 0
+#define xd_p_reg_top_gpioh12_en (*(volatile byte xdata *) 0xD8E0)
+#define    p_reg_top_gpioh12_en 0xD8E0
+#define reg_top_gpioh12_en_pos 0
+#define reg_top_gpioh12_en_len 1
+#define reg_top_gpioh12_en_lsb 0
+#define xd_p_reg_top_gpioh12_on (*(volatile byte xdata *) 0xD8E1)
+#define    p_reg_top_gpioh12_on 0xD8E1
+#define reg_top_gpioh12_on_pos 0
+#define reg_top_gpioh12_on_len 1
+#define reg_top_gpioh12_on_lsb 0
+#define xd_r_reg_top_gpiot1_i   (*(volatile byte xdata *) 0xD8E2)
+#define    r_reg_top_gpiot1_i   0xD8E2
+#define reg_top_gpiot1_i_pos 0
+#define reg_top_gpiot1_i_len 1
+#define reg_top_gpiot1_i_lsb 0
+#define xd_p_reg_top_gpiot1_o   (*(volatile byte xdata *) 0xD8E3)
+#define    p_reg_top_gpiot1_o   0xD8E3
+#define reg_top_gpiot1_o_pos 0
+#define reg_top_gpiot1_o_len 1
+#define reg_top_gpiot1_o_lsb 0
+#define xd_p_reg_top_gpiot1_en  (*(volatile byte xdata *) 0xD8E4)
+#define    p_reg_top_gpiot1_en  0xD8E4
+#define reg_top_gpiot1_en_pos 0
+#define reg_top_gpiot1_en_len 1
+#define reg_top_gpiot1_en_lsb 0
+#define xd_p_reg_top_gpiot1_on  (*(volatile byte xdata *) 0xD8E5)
+#define    p_reg_top_gpiot1_on  0xD8E5
+#define reg_top_gpiot1_on_pos 0
+#define reg_top_gpiot1_on_len 1
+#define reg_top_gpiot1_on_lsb 0
+#define xd_r_reg_top_gpiot3_i   (*(volatile byte xdata *) 0xD8E6)
+#define    r_reg_top_gpiot3_i   0xD8E6
+#define reg_top_gpiot3_i_pos 0
+#define reg_top_gpiot3_i_len 1
+#define reg_top_gpiot3_i_lsb 0
+#define xd_p_reg_top_gpiot3_o   (*(volatile byte xdata *) 0xD8E7)
+#define    p_reg_top_gpiot3_o   0xD8E7
+#define reg_top_gpiot3_o_pos 0
+#define reg_top_gpiot3_o_len 1
+#define reg_top_gpiot3_o_lsb 0
+#define xd_p_reg_top_gpiot3_en  (*(volatile byte xdata *) 0xD8E8)
+#define    p_reg_top_gpiot3_en  0xD8E8
+#define reg_top_gpiot3_en_pos 0
+#define reg_top_gpiot3_en_len 1
+#define reg_top_gpiot3_en_lsb 0
+#define xd_p_reg_top_gpiot3_on  (*(volatile byte xdata *) 0xD8E9)
+#define    p_reg_top_gpiot3_on  0xD8E9
+#define reg_top_gpiot3_on_pos 0
+#define reg_top_gpiot3_on_len 1
+#define reg_top_gpiot3_on_lsb 0
+#define xd_r_reg_top_gpiot2_i   (*(volatile byte xdata *) 0xD8EA)
+#define    r_reg_top_gpiot2_i   0xD8EA
+#define reg_top_gpiot2_i_pos 0
+#define reg_top_gpiot2_i_len 1
+#define reg_top_gpiot2_i_lsb 0
+#define xd_p_reg_top_gpiot2_o   (*(volatile byte xdata *) 0xD8EB)
+#define    p_reg_top_gpiot2_o   0xD8EB
+#define reg_top_gpiot2_o_pos 0
+#define reg_top_gpiot2_o_len 1
+#define reg_top_gpiot2_o_lsb 0
+#define xd_p_reg_top_gpiot2_en  (*(volatile byte xdata *) 0xD8EC)
+#define    p_reg_top_gpiot2_en  0xD8EC
+#define reg_top_gpiot2_en_pos 0
+#define reg_top_gpiot2_en_len 1
+#define reg_top_gpiot2_en_lsb 0
+#define xd_p_reg_top_gpiot2_on  (*(volatile byte xdata *) 0xD8ED)
+#define    p_reg_top_gpiot2_on  0xD8ED
+#define reg_top_gpiot2_on_pos 0
+#define reg_top_gpiot2_on_len 1
+#define reg_top_gpiot2_on_lsb 0
+#define xd_p_reg_top_lock2_out  (*(volatile byte xdata *) 0xD8EE)
+#define    p_reg_top_lock2_out  0xD8EE
+#define reg_top_lock2_out_pos 0
+#define reg_top_lock2_out_len 1
+#define reg_top_lock2_out_lsb 0
+#define xd_p_reg_top_lock2_tpsd (*(volatile byte xdata *) 0xD8EF)
+#define    p_reg_top_lock2_tpsd 0xD8EF
+#define reg_top_lock2_tpsd_pos 0
+#define reg_top_lock2_tpsd_len 1
+#define reg_top_lock2_tpsd_lsb 0
+#define xd_p_reg_top_lock2_o    (*(volatile byte xdata *) 0xD8F0)
+#define    p_reg_top_lock2_o    0xD8F0
+#define reg_top_lock2_o_pos 0
+#define reg_top_lock2_o_len 1
+#define reg_top_lock2_o_lsb 0
+#define xd_p_reg_top_lock2_en   (*(volatile byte xdata *) 0xD8F1)
+#define    p_reg_top_lock2_en   0xD8F1
+#define reg_top_lock2_en_pos 0
+#define reg_top_lock2_en_len 1
+#define reg_top_lock2_en_lsb 0
+#define xd_p_reg_top_lock2_on   (*(volatile byte xdata *) 0xD8F2)
+#define    p_reg_top_lock2_on   0xD8F2
+#define reg_top_lock2_on_pos 0
+#define reg_top_lock2_on_len 1
+#define reg_top_lock2_on_lsb 0
+#define xd_p_reg_top_lock1_out  (*(volatile byte xdata *) 0xD8F3)
+#define    p_reg_top_lock1_out  0xD8F3
+#define reg_top_lock1_out_pos 0
+#define reg_top_lock1_out_len 1
+#define reg_top_lock1_out_lsb 0
+#define xd_p_reg_top_lock1_tpsd (*(volatile byte xdata *) 0xD8F4)
+#define    p_reg_top_lock1_tpsd 0xD8F4
+#define reg_top_lock1_tpsd_pos 0
+#define reg_top_lock1_tpsd_len 1
+#define reg_top_lock1_tpsd_lsb 0
+#define xd_p_reg_top_lock1_o    (*(volatile byte xdata *) 0xD8F5)
+#define    p_reg_top_lock1_o    0xD8F5
+#define reg_top_lock1_o_pos 0
+#define reg_top_lock1_o_len 1
+#define reg_top_lock1_o_lsb 0
+#define xd_p_reg_top_lock1_en   (*(volatile byte xdata *) 0xD8F6)
+#define    p_reg_top_lock1_en   0xD8F6
+#define reg_top_lock1_en_pos 0
+#define reg_top_lock1_en_len 1
+#define reg_top_lock1_en_lsb 0
+#define xd_p_reg_top_lock1_on   (*(volatile byte xdata *) 0xD8F7)
+#define    p_reg_top_lock1_on   0xD8F7
+#define reg_top_lock1_on_pos 0
+#define reg_top_lock1_on_len 1
+#define reg_top_lock1_on_lsb 0
+#define xd_p_reg_top_lock4_out  (*(volatile byte xdata *) 0xD8F8)
+#define    p_reg_top_lock4_out  0xD8F8
+#define reg_top_lock4_out_pos 0
+#define reg_top_lock4_out_len 1
+#define reg_top_lock4_out_lsb 0
+#define xd_p_reg_top_lock4_tpsd (*(volatile byte xdata *) 0xD8F9)
+#define    p_reg_top_lock4_tpsd 0xD8F9
+#define reg_top_lock4_tpsd_pos 0
+#define reg_top_lock4_tpsd_len 1
+#define reg_top_lock4_tpsd_lsb 0
+#define xd_p_reg_top_lock4_o    (*(volatile byte xdata *) 0xD8FA)
+#define    p_reg_top_lock4_o    0xD8FA
+#define reg_top_lock4_o_pos 0
+#define reg_top_lock4_o_len 1
+#define reg_top_lock4_o_lsb 0
+#define xd_p_reg_top_lock4_en   (*(volatile byte xdata *) 0xD8FB)
+#define    p_reg_top_lock4_en   0xD8FB
+#define reg_top_lock4_en_pos 0
+#define reg_top_lock4_en_len 1
+#define reg_top_lock4_en_lsb 0
+#define xd_p_reg_top_lock4_on   (*(volatile byte xdata *) 0xD8FC)
+#define    p_reg_top_lock4_on   0xD8FC
+#define reg_top_lock4_on_pos 0
+#define reg_top_lock4_on_len 1
+#define reg_top_lock4_on_lsb 0
+#define xd_p_reg_top_lock3_out  (*(volatile byte xdata *) 0xD8FD)
+#define    p_reg_top_lock3_out  0xD8FD
+#define reg_top_lock3_out_pos 0
+#define reg_top_lock3_out_len 1
+#define reg_top_lock3_out_lsb 0
+#define xd_p_reg_top_lock3_tpsd (*(volatile byte xdata *) 0xD8FE)
+#define    p_reg_top_lock3_tpsd 0xD8FE
+#define reg_top_lock3_tpsd_pos 0
+#define reg_top_lock3_tpsd_len 1
+#define reg_top_lock3_tpsd_lsb 0
+#define xd_p_reg_top_lock3_o    (*(volatile byte xdata *) 0xD8FF)
+#define    p_reg_top_lock3_o    0xD8FF
+#define reg_top_lock3_o_pos 0
+#define reg_top_lock3_o_len 1
+#define reg_top_lock3_o_lsb 0
+#define xd_p_reg_top_lock3_en   (*(volatile byte xdata *) 0xD900)
+#define    p_reg_top_lock3_en   0xD900
+#define reg_top_lock3_en_pos 0
+#define reg_top_lock3_en_len 1
+#define reg_top_lock3_en_lsb 0
+#define xd_p_reg_top_lock3_on   (*(volatile byte xdata *) 0xD901)
+#define    p_reg_top_lock3_on   0xD901
+#define reg_top_lock3_on_pos 0
+#define reg_top_lock3_on_len 1
+#define reg_top_lock3_on_lsb 0
+#define xd_p_reg_top_pwm0_en    (*(volatile byte xdata *) 0xD902)
+#define    p_reg_top_pwm0_en    0xD902
+#define reg_top_pwm0_en_pos 0
+#define reg_top_pwm0_en_len 1
+#define reg_top_pwm0_en_lsb 0
+#define xd_p_reg_top_pwm1_en    (*(volatile byte xdata *) 0xD903)
+#define    p_reg_top_pwm1_en    0xD903
+#define reg_top_pwm1_en_pos 0
+#define reg_top_pwm1_en_len 1
+#define reg_top_pwm1_en_lsb 0
+#define xd_p_reg_top_pwm2_en    (*(volatile byte xdata *) 0xD904)
+#define    p_reg_top_pwm2_en    0xD904
+#define reg_top_pwm2_en_pos 0
+#define reg_top_pwm2_en_len 1
+#define reg_top_pwm2_en_lsb 0
+#define xd_p_reg_top_pwm3_en    (*(volatile byte xdata *) 0xD905)
+#define    p_reg_top_pwm3_en    0xD905
+#define reg_top_pwm3_en_pos 0
+#define reg_top_pwm3_en_len 1
+#define reg_top_pwm3_en_lsb 0
+#define xd_p_reg_top_pwm0_gpio  (*(volatile byte xdata *) 0xD906)
+#define    p_reg_top_pwm0_gpio  0xD906
+#define reg_top_pwm0_gpio_pos 0
+#define reg_top_pwm0_gpio_len 1
+#define reg_top_pwm0_gpio_lsb 0
+#define xd_p_reg_top_pwm0_pos   (*(volatile byte xdata *) 0xD907)
+#define    p_reg_top_pwm0_pos   0xD907
+#define reg_top_pwm0_pos_pos 0
+#define reg_top_pwm0_pos_len 3
+#define reg_top_pwm0_pos_lsb 0
+#define xd_p_reg_top_pwm0_width (*(volatile byte xdata *) 0xD908)
+#define    p_reg_top_pwm0_width 0xD908
+#define reg_top_pwm0_width_pos 0
+#define reg_top_pwm0_width_len 2
+#define reg_top_pwm0_width_lsb 0
+#define xd_p_reg_top_pwm0_duration  (*(volatile byte xdata *) 0xD909)
+#define    p_reg_top_pwm0_duration  0xD909
+#define reg_top_pwm0_duration_pos 0
+#define reg_top_pwm0_duration_len 8
+#define reg_top_pwm0_duration_lsb 0
+#define xd_p_reg_top_pwm1_gpio  (*(volatile byte xdata *) 0xD90A)
+#define    p_reg_top_pwm1_gpio  0xD90A
+#define reg_top_pwm1_gpio_pos 0
+#define reg_top_pwm1_gpio_len 1
+#define reg_top_pwm1_gpio_lsb 0
+#define xd_p_reg_top_pwm1_pos   (*(volatile byte xdata *) 0xD90B)
+#define    p_reg_top_pwm1_pos   0xD90B
+#define reg_top_pwm1_pos_pos 0
+#define reg_top_pwm1_pos_len 3
+#define reg_top_pwm1_pos_lsb 0
+#define xd_p_reg_top_pwm1_width (*(volatile byte xdata *) 0xD90C)
+#define    p_reg_top_pwm1_width 0xD90C
+#define reg_top_pwm1_width_pos 0
+#define reg_top_pwm1_width_len 2
+#define reg_top_pwm1_width_lsb 0
+#define xd_p_reg_top_pwm1_duration  (*(volatile byte xdata *) 0xD90D)
+#define    p_reg_top_pwm1_duration  0xD90D
+#define reg_top_pwm1_duration_pos 0
+#define reg_top_pwm1_duration_len 8
+#define reg_top_pwm1_duration_lsb 0
+#define xd_p_reg_top_pwm2_gpio  (*(volatile byte xdata *) 0xD90E)
+#define    p_reg_top_pwm2_gpio  0xD90E
+#define reg_top_pwm2_gpio_pos 0
+#define reg_top_pwm2_gpio_len 1
+#define reg_top_pwm2_gpio_lsb 0
+#define xd_p_reg_top_pwm2_pos   (*(volatile byte xdata *) 0xD90F)
+#define    p_reg_top_pwm2_pos   0xD90F
+#define reg_top_pwm2_pos_pos 0
+#define reg_top_pwm2_pos_len 3
+#define reg_top_pwm2_pos_lsb 0
+#define xd_p_reg_top_pwm2_width (*(volatile byte xdata *) 0xD910)
+#define    p_reg_top_pwm2_width 0xD910
+#define reg_top_pwm2_width_pos 0
+#define reg_top_pwm2_width_len 2
+#define reg_top_pwm2_width_lsb 0
+#define xd_p_reg_top_pwm2_duration  (*(volatile byte xdata *) 0xD911)
+#define    p_reg_top_pwm2_duration  0xD911
+#define reg_top_pwm2_duration_pos 0
+#define reg_top_pwm2_duration_len 8
+#define reg_top_pwm2_duration_lsb 0
+#define xd_p_reg_top_pwm3_gpio  (*(volatile byte xdata *) 0xD912)
+#define    p_reg_top_pwm3_gpio  0xD912
+#define reg_top_pwm3_gpio_pos 0
+#define reg_top_pwm3_gpio_len 1
+#define reg_top_pwm3_gpio_lsb 0
+#define xd_p_reg_top_pwm3_pos   (*(volatile byte xdata *) 0xD913)
+#define    p_reg_top_pwm3_pos   0xD913
+#define reg_top_pwm3_pos_pos 0
+#define reg_top_pwm3_pos_len 3
+#define reg_top_pwm3_pos_lsb 0
+#define xd_p_reg_top_pwm3_width (*(volatile byte xdata *) 0xD914)
+#define    p_reg_top_pwm3_width 0xD914
+#define reg_top_pwm3_width_pos 0
+#define reg_top_pwm3_width_len 2
+#define reg_top_pwm3_width_lsb 0
+#define xd_p_reg_top_pwm3_duration  (*(volatile byte xdata *) 0xD915)
+#define    p_reg_top_pwm3_duration  0xD915
+#define reg_top_pwm3_duration_pos 0
+#define reg_top_pwm3_duration_len 8
+#define reg_top_pwm3_duration_lsb 0
+#define xd_p_reg_top_hosta_mpeg_par_mode    (*(volatile byte xdata *) 0xD916)
+#define    p_reg_top_hosta_mpeg_par_mode    0xD916
+#define reg_top_hosta_mpeg_par_mode_pos 0
+#define reg_top_hosta_mpeg_par_mode_len 1
+#define reg_top_hosta_mpeg_par_mode_lsb 0
+#define xd_p_reg_top_hosta_mpeg_ser_mode    (*(volatile byte xdata *) 0xD917)
+#define    p_reg_top_hosta_mpeg_ser_mode    0xD917
+#define reg_top_hosta_mpeg_ser_mode_pos 0
+#define reg_top_hosta_mpeg_ser_mode_len 1
+#define reg_top_hosta_mpeg_ser_mode_lsb 0
+#define xd_p_reg_top_hosta_mpeg_ser_do7 (*(volatile byte xdata *) 0xD918)
+#define    p_reg_top_hosta_mpeg_ser_do7 0xD918
+#define reg_top_hosta_mpeg_ser_do7_pos 0
+#define reg_top_hosta_mpeg_ser_do7_len 1
+#define reg_top_hosta_mpeg_ser_do7_lsb 0
+#define xd_p_reg_top_hosta_dca_upper    (*(volatile byte xdata *) 0xD919)
+#define    p_reg_top_hosta_dca_upper    0xD919
+#define reg_top_hosta_dca_upper_pos 0
+#define reg_top_hosta_dca_upper_len 1
+#define reg_top_hosta_dca_upper_lsb 0
+#define xd_p_reg_top_hosta_dca_lower    (*(volatile byte xdata *) 0xD91A)
+#define    p_reg_top_hosta_dca_lower    0xD91A
+#define reg_top_hosta_dca_lower_pos 0
+#define reg_top_hosta_dca_lower_len 1
+#define reg_top_hosta_dca_lower_lsb 0
+#define xd_p_reg_top_hostb_mpeg_par_mode    (*(volatile byte xdata *) 0xD91B)
+#define    p_reg_top_hostb_mpeg_par_mode    0xD91B
+#define reg_top_hostb_mpeg_par_mode_pos 0
+#define reg_top_hostb_mpeg_par_mode_len 1
+#define reg_top_hostb_mpeg_par_mode_lsb 0
+#define xd_p_reg_top_hostb_mpeg_ser_mode    (*(volatile byte xdata *) 0xD91C)
+#define    p_reg_top_hostb_mpeg_ser_mode    0xD91C
+#define reg_top_hostb_mpeg_ser_mode_pos 0
+#define reg_top_hostb_mpeg_ser_mode_len 1
+#define reg_top_hostb_mpeg_ser_mode_lsb 0
+#define xd_p_reg_top_hostb_mpeg_ser_do7 (*(volatile byte xdata *) 0xD91D)
+#define    p_reg_top_hostb_mpeg_ser_do7 0xD91D
+#define reg_top_hostb_mpeg_ser_do7_pos 0
+#define reg_top_hostb_mpeg_ser_do7_len 1
+#define reg_top_hostb_mpeg_ser_do7_lsb 0
+#define xd_p_reg_top_hostb_dca_upper    (*(volatile byte xdata *) 0xD91E)
+#define    p_reg_top_hostb_dca_upper    0xD91E
+#define reg_top_hostb_dca_upper_pos 0
+#define reg_top_hostb_dca_upper_len 1
+#define reg_top_hostb_dca_upper_lsb 0
+#define xd_p_reg_top_hostb_dca_lower    (*(volatile byte xdata *) 0xD91F)
+#define    p_reg_top_hostb_dca_lower    0xD91F
+#define reg_top_hostb_dca_lower_pos 0
+#define reg_top_hostb_dca_lower_len 1
+#define reg_top_hostb_dca_lower_lsb 0
+#define xd_p_reg_top_host_reverse   (*(volatile byte xdata *) 0xD920)
+#define    p_reg_top_host_reverse   0xD920
+#define reg_top_host_reverse_pos 0
+#define reg_top_host_reverse_len 1
+#define reg_top_host_reverse_lsb 0
+#define xd_p_reg_top_hosta_ccir (*(volatile byte xdata *) 0xD921)
+#define    p_reg_top_hosta_ccir 0xD921
+#define reg_top_hosta_ccir_pos 0
+#define reg_top_hosta_ccir_len 1
+#define reg_top_hosta_ccir_lsb 0
+#define xd_p_reg_top_hostb_ccir (*(volatile byte xdata *) 0xD922)
+#define    p_reg_top_hostb_ccir 0xD922
+#define reg_top_hostb_ccir_pos 0
+#define reg_top_hostb_ccir_len 1
+#define reg_top_hostb_ccir_lsb 0
+#define xd_p_reg_top_i2s_master_mode    (*(volatile byte xdata *) 0xD923)
+#define    p_reg_top_i2s_master_mode    0xD923
+#define reg_top_i2s_master_mode_pos 0
+#define reg_top_i2s_master_mode_len 1
+#define reg_top_i2s_master_mode_lsb 0
+#define xd_p_reg_usb_cfg_speed  (*(volatile byte xdata *) 0xDD00)
+#define    p_reg_usb_cfg_speed  0xDD00
+#define reg_usb_cfg_speed_pos 0
+#define reg_usb_cfg_speed_len 1
+#define reg_usb_cfg_speed_lsb 0
+#define xd_p_reg_usb_cfg_utmi16 (*(volatile byte xdata *) 0xDD00)
+#define    p_reg_usb_cfg_utmi16 0xDD00
+#define reg_usb_cfg_utmi16_pos 1
+#define reg_usb_cfg_utmi16_len 1
+#define reg_usb_cfg_utmi16_lsb 0
+#define xd_p_reg_usb_cfg_test   (*(volatile byte xdata *) 0xDD00)
+#define    p_reg_usb_cfg_test   0xDD00
+#define reg_usb_cfg_test_pos 3
+#define reg_usb_cfg_test_len 3
+#define reg_usb_cfg_test_lsb 0
+#define xd_p_reg_usb_port_sim_reset (*(volatile byte xdata *) 0xDD00)
+#define    p_reg_usb_port_sim_reset 0xDD00
+#define reg_usb_port_sim_reset_pos 6
+#define reg_usb_port_sim_reset_len 1
+#define reg_usb_port_sim_reset_lsb 0
+#define xd_p_reg_usb_port_run   (*(volatile byte xdata *) 0xDD00)
+#define    p_reg_usb_port_run   0xDD00
+#define reg_usb_port_run_pos 7
+#define reg_usb_port_run_len 1
+#define reg_usb_port_run_lsb 0
+#define xd_r_usb_line_state_0   (*(volatile byte xdata *) 0xDD01)
+#define    r_usb_line_state_0   0xDD01
+#define usb_line_state_0_pos 0
+#define usb_line_state_0_len 1
+#define usb_line_state_0_lsb 0
+#define xd_r_usb_line_state_1   (*(volatile byte xdata *) 0xDD01)
+#define    r_usb_line_state_1   0xDD01
+#define usb_line_state_1_pos 1
+#define usb_line_state_1_len 1
+#define usb_line_state_1_lsb 0
+#define xd_r_reg_usb_status_speed   (*(volatile byte xdata *) 0xDD01)
+#define    r_reg_usb_status_speed   0xDD01
+#define reg_usb_status_speed_pos 2
+#define reg_usb_status_speed_len 1
+#define reg_usb_status_speed_lsb 0
+#define xd_r_reg_usb_status_connect (*(volatile byte xdata *) 0xDD01)
+#define    r_reg_usb_status_connect 0xDD01
+#define reg_usb_status_connect_pos 3
+#define reg_usb_status_connect_len 1
+#define reg_usb_status_connect_lsb 0
+#define xd_r_reg_usb_rx_buf (*(volatile byte xdata *) 0xDD01)
+#define    r_reg_usb_rx_buf 0xDD01
+#define reg_usb_rx_buf_pos 4
+#define reg_usb_rx_buf_len 1
+#define reg_usb_rx_buf_lsb 0
+#define xd_r_reg_usb_port_reset (*(volatile byte xdata *) 0xDD01)
+#define    r_reg_usb_port_reset 0xDD01
+#define reg_usb_port_reset_pos 5
+#define reg_usb_port_reset_len 1
+#define reg_usb_port_reset_lsb 0
+#define xd_r_reg_usb_port_suspend   (*(volatile byte xdata *) 0xDD01)
+#define    r_reg_usb_port_suspend   0xDD01
+#define reg_usb_port_suspend_pos 6
+#define reg_usb_port_suspend_len 1
+#define reg_usb_port_suspend_lsb 0
+#define xd_p_reg_ep1_tx_type    (*(volatile byte xdata *) 0xDD07)
+#define    p_reg_ep1_tx_type    0xDD07
+#define reg_ep1_tx_type_pos 2
+#define reg_ep1_tx_type_len 1
+#define reg_ep1_tx_type_lsb 0
+#define xd_p_reg_ep2_rx_type    (*(volatile byte xdata *) 0xDD07)
+#define    p_reg_ep2_rx_type    0xDD07
+#define reg_ep2_rx_type_pos 3
+#define reg_ep2_rx_type_len 1
+#define reg_ep2_rx_type_lsb 0
+#define xd_p_reg_ep3_tx_type    (*(volatile byte xdata *) 0xDD07)
+#define    p_reg_ep3_tx_type    0xDD07
+#define reg_ep3_tx_type_pos 4
+#define reg_ep3_tx_type_len 1
+#define reg_ep3_tx_type_lsb 0
+#define xd_p_reg_ep4_tx_type    (*(volatile byte xdata *) 0xDD07)
+#define    p_reg_ep4_tx_type    0xDD07
+#define reg_ep4_tx_type_pos 5
+#define reg_ep4_tx_type_len 1
+#define reg_ep4_tx_type_lsb 0
+#define xd_p_reg_ep5_tx_type    (*(volatile byte xdata *) 0xDD07)
+#define    p_reg_ep5_tx_type    0xDD07
+#define reg_ep5_tx_type_pos 6
+#define reg_ep5_tx_type_len 1
+#define reg_ep5_tx_type_lsb 0
+#define xd_p_reg_ep6_tx_type    (*(volatile byte xdata *) 0xDD07)
+#define    p_reg_ep6_tx_type    0xDD07
+#define reg_ep6_tx_type_pos 7
+#define reg_ep6_tx_type_len 1
+#define reg_ep6_tx_type_lsb 0
+#define xd_p_reg_ep0_max_pkt    (*(volatile byte xdata *) 0xDD08)
+#define    p_reg_ep0_max_pkt    0xDD08
+#define reg_ep0_max_pkt_pos 0
+#define reg_ep0_max_pkt_len 8
+#define reg_ep0_max_pkt_lsb 0
+#define xd_p_reg_ep2_max_pkt    (*(volatile byte xdata *) 0xDD0A)
+#define    p_reg_ep2_max_pkt    0xDD0A
+#define reg_ep2_max_pkt_pos 0
+#define reg_ep2_max_pkt_len 8
+#define reg_ep2_max_pkt_lsb 0
+#define xd_p_reg_ep4_max_pkt    (*(volatile byte xdata *) 0xDD0C)
+#define    p_reg_ep4_max_pkt    0xDD0C
+#define reg_ep4_max_pkt_pos 0
+#define reg_ep4_max_pkt_len 8
+#define reg_ep4_max_pkt_lsb 0
+#define xd_p_reg_ep5_max_pkt    (*(volatile byte xdata *) 0xDD0D)
+#define    p_reg_ep5_max_pkt    0xDD0D
+#define reg_ep5_max_pkt_pos 0
+#define reg_ep5_max_pkt_len 8
+#define reg_ep5_max_pkt_lsb 0
+#define xd_p_reg_ep6_max_pkt_7_0    (*(volatile byte xdata *) 0xDD0E)
+#define    p_reg_ep6_max_pkt_7_0    0xDD0E
+#define reg_ep6_max_pkt_7_0_pos 0
+#define reg_ep6_max_pkt_7_0_len 8
+#define reg_ep6_max_pkt_7_0_lsb 0
+#define xd_p_reg_ep6_max_pkt_15_8   (*(volatile byte xdata *) 0xDD0F)
+#define    p_reg_ep6_max_pkt_15_8   0xDD0F
+#define reg_ep6_max_pkt_15_8_pos 0
+#define reg_ep6_max_pkt_15_8_len 8
+#define reg_ep6_max_pkt_15_8_lsb 8
+#define xd_p_reg_usb_addr   (*(volatile byte xdata *) 0xDD10)
+#define    p_reg_usb_addr   0xDD10
+#define reg_usb_addr_pos 0
+#define reg_usb_addr_len 7
+#define reg_usb_addr_lsb 0
+#define xd_p_reg_usb_addr_now   (*(volatile byte xdata *) 0xDD10)
+#define    p_reg_usb_addr_now   0xDD10
+#define reg_usb_addr_now_pos 7
+#define reg_usb_addr_now_len 1
+#define reg_usb_addr_now_lsb 0
+#define xd_p_reg_ep0_tx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep0_tx_en  0xDD11
+#define reg_ep0_tx_en_pos 0
+#define reg_ep0_tx_en_len 1
+#define reg_ep0_tx_en_lsb 0
+#define xd_p_reg_ep0_rx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep0_rx_en  0xDD11
+#define reg_ep0_rx_en_pos 1
+#define reg_ep0_rx_en_len 1
+#define reg_ep0_rx_en_lsb 0
+#define xd_p_reg_ep1_tx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep1_tx_en  0xDD11
+#define reg_ep1_tx_en_pos 2
+#define reg_ep1_tx_en_len 1
+#define reg_ep1_tx_en_lsb 0
+#define xd_p_reg_ep2_rx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep2_rx_en  0xDD11
+#define reg_ep2_rx_en_pos 3
+#define reg_ep2_rx_en_len 1
+#define reg_ep2_rx_en_lsb 0
+#define xd_p_reg_ep3_tx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep3_tx_en  0xDD11
+#define reg_ep3_tx_en_pos 4
+#define reg_ep3_tx_en_len 1
+#define reg_ep3_tx_en_lsb 0
+#define xd_p_reg_ep4_tx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep4_tx_en  0xDD11
+#define reg_ep4_tx_en_pos 5
+#define reg_ep4_tx_en_len 1
+#define reg_ep4_tx_en_lsb 0
+#define xd_p_reg_ep5_tx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep5_tx_en  0xDD11
+#define reg_ep5_tx_en_pos 6
+#define reg_ep5_tx_en_len 1
+#define reg_ep5_tx_en_lsb 0
+#define xd_p_reg_ep6_tx_en  (*(volatile byte xdata *) 0xDD11)
+#define    p_reg_ep6_tx_en  0xDD11
+#define reg_ep6_tx_en_pos 7
+#define reg_ep6_tx_en_len 1
+#define reg_ep6_tx_en_lsb 0
+#define xd_p_reg_ep0_tx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep0_tx_stall   0xDD12
+#define reg_ep0_tx_stall_pos 0
+#define reg_ep0_tx_stall_len 1
+#define reg_ep0_tx_stall_lsb 0
+#define xd_p_reg_ep0_rx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep0_rx_stall   0xDD12
+#define reg_ep0_rx_stall_pos 1
+#define reg_ep0_rx_stall_len 1
+#define reg_ep0_rx_stall_lsb 0
+#define xd_p_reg_ep1_tx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep1_tx_stall   0xDD12
+#define reg_ep1_tx_stall_pos 2
+#define reg_ep1_tx_stall_len 1
+#define reg_ep1_tx_stall_lsb 0
+#define xd_p_reg_ep2_rx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep2_rx_stall   0xDD12
+#define reg_ep2_rx_stall_pos 3
+#define reg_ep2_rx_stall_len 1
+#define reg_ep2_rx_stall_lsb 0
+#define xd_p_reg_ep3_tx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep3_tx_stall   0xDD12
+#define reg_ep3_tx_stall_pos 4
+#define reg_ep3_tx_stall_len 1
+#define reg_ep3_tx_stall_lsb 0
+#define xd_p_reg_ep4_tx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep4_tx_stall   0xDD12
+#define reg_ep4_tx_stall_pos 5
+#define reg_ep4_tx_stall_len 1
+#define reg_ep4_tx_stall_lsb 0
+#define xd_p_reg_ep5_tx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep5_tx_stall   0xDD12
+#define reg_ep5_tx_stall_pos 6
+#define reg_ep5_tx_stall_len 1
+#define reg_ep5_tx_stall_lsb 0
+#define xd_p_reg_ep6_tx_stall   (*(volatile byte xdata *) 0xDD12)
+#define    p_reg_ep6_tx_stall   0xDD12
+#define reg_ep6_tx_stall_pos 7
+#define reg_ep6_tx_stall_len 1
+#define reg_ep6_tx_stall_lsb 0
+#define xd_p_reg_ep0_tx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep0_tx_nak 0xDD13
+#define reg_ep0_tx_nak_pos 0
+#define reg_ep0_tx_nak_len 1
+#define reg_ep0_tx_nak_lsb 0
+#define xd_p_reg_ep0_rx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep0_rx_nak 0xDD13
+#define reg_ep0_rx_nak_pos 1
+#define reg_ep0_rx_nak_len 1
+#define reg_ep0_rx_nak_lsb 0
+#define xd_p_reg_ep1_tx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep1_tx_nak 0xDD13
+#define reg_ep1_tx_nak_pos 2
+#define reg_ep1_tx_nak_len 1
+#define reg_ep1_tx_nak_lsb 0
+#define xd_p_reg_ep2_rx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep2_rx_nak 0xDD13
+#define reg_ep2_rx_nak_pos 3
+#define reg_ep2_rx_nak_len 1
+#define reg_ep2_rx_nak_lsb 0
+#define xd_p_reg_ep3_tx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep3_tx_nak 0xDD13
+#define reg_ep3_tx_nak_pos 4
+#define reg_ep3_tx_nak_len 1
+#define reg_ep3_tx_nak_lsb 0
+#define xd_p_reg_ep4_tx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep4_tx_nak 0xDD13
+#define reg_ep4_tx_nak_pos 5
+#define reg_ep4_tx_nak_len 1
+#define reg_ep4_tx_nak_lsb 0
+#define xd_p_reg_ep5_tx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep5_tx_nak 0xDD13
+#define reg_ep5_tx_nak_pos 6
+#define reg_ep5_tx_nak_len 1
+#define reg_ep5_tx_nak_lsb 0
+#define xd_p_reg_ep6_tx_nak (*(volatile byte xdata *) 0xDD13)
+#define    p_reg_ep6_tx_nak 0xDD13
+#define reg_ep6_tx_nak_pos 7
+#define reg_ep6_tx_nak_len 1
+#define reg_ep6_tx_nak_lsb 0
+#define xd_p_reg_ep0_tx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep0_tx_nak_int_en  0xDD14
+#define reg_ep0_tx_nak_int_en_pos 0
+#define reg_ep0_tx_nak_int_en_len 1
+#define reg_ep0_tx_nak_int_en_lsb 0
+#define xd_p_reg_ep0_rx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep0_rx_nak_int_en  0xDD14
+#define reg_ep0_rx_nak_int_en_pos 1
+#define reg_ep0_rx_nak_int_en_len 1
+#define reg_ep0_rx_nak_int_en_lsb 0
+#define xd_p_reg_ep1_tx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep1_tx_nak_int_en  0xDD14
+#define reg_ep1_tx_nak_int_en_pos 2
+#define reg_ep1_tx_nak_int_en_len 1
+#define reg_ep1_tx_nak_int_en_lsb 0
+#define xd_p_reg_ep2_rx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep2_rx_nak_int_en  0xDD14
+#define reg_ep2_rx_nak_int_en_pos 3
+#define reg_ep2_rx_nak_int_en_len 1
+#define reg_ep2_rx_nak_int_en_lsb 0
+#define xd_p_reg_ep3_tx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep3_tx_nak_int_en  0xDD14
+#define reg_ep3_tx_nak_int_en_pos 4
+#define reg_ep3_tx_nak_int_en_len 1
+#define reg_ep3_tx_nak_int_en_lsb 0
+#define xd_p_reg_ep4_tx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep4_tx_nak_int_en  0xDD14
+#define reg_ep4_tx_nak_int_en_pos 5
+#define reg_ep4_tx_nak_int_en_len 1
+#define reg_ep4_tx_nak_int_en_lsb 0
+#define xd_p_reg_ep5_tx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep5_tx_nak_int_en  0xDD14
+#define reg_ep5_tx_nak_int_en_pos 6
+#define reg_ep5_tx_nak_int_en_len 1
+#define reg_ep5_tx_nak_int_en_lsb 0
+#define xd_p_reg_ep6_tx_nak_int_en  (*(volatile byte xdata *) 0xDD14)
+#define    p_reg_ep6_tx_nak_int_en  0xDD14
+#define reg_ep6_tx_nak_int_en_pos 7
+#define reg_ep6_tx_nak_int_en_len 1
+#define reg_ep6_tx_nak_int_en_lsb 0
+#define xd_p_reg_ep0_tx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep0_tx_done_int_en 0xDD15
+#define reg_ep0_tx_done_int_en_pos 0
+#define reg_ep0_tx_done_int_en_len 1
+#define reg_ep0_tx_done_int_en_lsb 0
+#define xd_p_reg_ep0_rx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep0_rx_done_int_en 0xDD15
+#define reg_ep0_rx_done_int_en_pos 1
+#define reg_ep0_rx_done_int_en_len 1
+#define reg_ep0_rx_done_int_en_lsb 0
+#define xd_p_reg_ep1_tx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep1_tx_done_int_en 0xDD15
+#define reg_ep1_tx_done_int_en_pos 2
+#define reg_ep1_tx_done_int_en_len 1
+#define reg_ep1_tx_done_int_en_lsb 0
+#define xd_p_reg_ep2_rx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep2_rx_done_int_en 0xDD15
+#define reg_ep2_rx_done_int_en_pos 3
+#define reg_ep2_rx_done_int_en_len 1
+#define reg_ep2_rx_done_int_en_lsb 0
+#define xd_p_reg_ep3_tx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep3_tx_done_int_en 0xDD15
+#define reg_ep3_tx_done_int_en_pos 4
+#define reg_ep3_tx_done_int_en_len 1
+#define reg_ep3_tx_done_int_en_lsb 0
+#define xd_p_reg_ep4_tx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep4_tx_done_int_en 0xDD15
+#define reg_ep4_tx_done_int_en_pos 5
+#define reg_ep4_tx_done_int_en_len 1
+#define reg_ep4_tx_done_int_en_lsb 0
+#define xd_p_reg_ep5_tx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep5_tx_done_int_en 0xDD15
+#define reg_ep5_tx_done_int_en_pos 6
+#define reg_ep5_tx_done_int_en_len 1
+#define reg_ep5_tx_done_int_en_lsb 0
+#define xd_p_reg_ep6_tx_done_int_en (*(volatile byte xdata *) 0xDD15)
+#define    p_reg_ep6_tx_done_int_en 0xDD15
+#define reg_ep6_tx_done_int_en_pos 7
+#define reg_ep6_tx_done_int_en_len 1
+#define reg_ep6_tx_done_int_en_lsb 0
+#define xd_p_reg_ep0_tx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep0_tx_fail_int_en 0xDD16
+#define reg_ep0_tx_fail_int_en_pos 0
+#define reg_ep0_tx_fail_int_en_len 1
+#define reg_ep0_tx_fail_int_en_lsb 0
+#define xd_p_reg_ep0_rx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep0_rx_fail_int_en 0xDD16
+#define reg_ep0_rx_fail_int_en_pos 1
+#define reg_ep0_rx_fail_int_en_len 1
+#define reg_ep0_rx_fail_int_en_lsb 0
+#define xd_p_reg_ep1_tx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep1_tx_fail_int_en 0xDD16
+#define reg_ep1_tx_fail_int_en_pos 2
+#define reg_ep1_tx_fail_int_en_len 1
+#define reg_ep1_tx_fail_int_en_lsb 0
+#define xd_p_reg_ep2_rx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep2_rx_fail_int_en 0xDD16
+#define reg_ep2_rx_fail_int_en_pos 3
+#define reg_ep2_rx_fail_int_en_len 1
+#define reg_ep2_rx_fail_int_en_lsb 0
+#define xd_p_reg_ep3_tx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep3_tx_fail_int_en 0xDD16
+#define reg_ep3_tx_fail_int_en_pos 4
+#define reg_ep3_tx_fail_int_en_len 1
+#define reg_ep3_tx_fail_int_en_lsb 0
+#define xd_p_reg_ep4_tx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep4_tx_fail_int_en 0xDD16
+#define reg_ep4_tx_fail_int_en_pos 5
+#define reg_ep4_tx_fail_int_en_len 1
+#define reg_ep4_tx_fail_int_en_lsb 0
+#define xd_p_reg_ep5_tx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep5_tx_fail_int_en 0xDD16
+#define reg_ep5_tx_fail_int_en_pos 6
+#define reg_ep5_tx_fail_int_en_len 1
+#define reg_ep5_tx_fail_int_en_lsb 0
+#define xd_p_reg_ep6_tx_fail_int_en (*(volatile byte xdata *) 0xDD16)
+#define    p_reg_ep6_tx_fail_int_en 0xDD16
+#define reg_ep6_tx_fail_int_en_pos 7
+#define reg_ep6_tx_fail_int_en_len 1
+#define reg_ep6_tx_fail_int_en_lsb 0
+#define xd_p_reg_suspend_int_en (*(volatile byte xdata *) 0xDD17)
+#define    p_reg_suspend_int_en 0xDD17
+#define reg_suspend_int_en_pos 0
+#define reg_suspend_int_en_len 1
+#define reg_suspend_int_en_lsb 0
+#define xd_p_reg_bus_reset_int_en   (*(volatile byte xdata *) 0xDD17)
+#define    p_reg_bus_reset_int_en   0xDD17
+#define reg_bus_reset_int_en_pos 1
+#define reg_bus_reset_int_en_len 1
+#define reg_bus_reset_int_en_lsb 0
+#define xd_p_reg_ep0_setup_int_en   (*(volatile byte xdata *) 0xDD17)
+#define    p_reg_ep0_setup_int_en   0xDD17
+#define reg_ep0_setup_int_en_pos 2
+#define reg_ep0_setup_int_en_len 1
+#define reg_ep0_setup_int_en_lsb 0
+#define xd_p_reg_ep0_tx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep0_tx_nak_int 0xDD18
+#define reg_ep0_tx_nak_int_pos 0
+#define reg_ep0_tx_nak_int_len 1
+#define reg_ep0_tx_nak_int_lsb 0
+#define xd_p_reg_ep0_rx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep0_rx_nak_int 0xDD18
+#define reg_ep0_rx_nak_int_pos 1
+#define reg_ep0_rx_nak_int_len 1
+#define reg_ep0_rx_nak_int_lsb 0
+#define xd_p_reg_ep1_tx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep1_tx_nak_int 0xDD18
+#define reg_ep1_tx_nak_int_pos 2
+#define reg_ep1_tx_nak_int_len 1
+#define reg_ep1_tx_nak_int_lsb 0
+#define xd_p_reg_ep2_rx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep2_rx_nak_int 0xDD18
+#define reg_ep2_rx_nak_int_pos 3
+#define reg_ep2_rx_nak_int_len 1
+#define reg_ep2_rx_nak_int_lsb 0
+#define xd_p_reg_ep3_tx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep3_tx_nak_int 0xDD18
+#define reg_ep3_tx_nak_int_pos 4
+#define reg_ep3_tx_nak_int_len 1
+#define reg_ep3_tx_nak_int_lsb 0
+#define xd_p_reg_ep4_tx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep4_tx_nak_int 0xDD18
+#define reg_ep4_tx_nak_int_pos 5
+#define reg_ep4_tx_nak_int_len 1
+#define reg_ep4_tx_nak_int_lsb 0
+#define xd_p_reg_ep5_tx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep5_tx_nak_int 0xDD18
+#define reg_ep5_tx_nak_int_pos 6
+#define reg_ep5_tx_nak_int_len 1
+#define reg_ep5_tx_nak_int_lsb 0
+#define xd_p_reg_ep6_tx_nak_int (*(volatile byte xdata *) 0xDD18)
+#define    p_reg_ep6_tx_nak_int 0xDD18
+#define reg_ep6_tx_nak_int_pos 7
+#define reg_ep6_tx_nak_int_len 1
+#define reg_ep6_tx_nak_int_lsb 0
+#define xd_p_reg_ep0_tx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep0_tx_done_int    0xDD19
+#define reg_ep0_tx_done_int_pos 0
+#define reg_ep0_tx_done_int_len 1
+#define reg_ep0_tx_done_int_lsb 0
+#define xd_p_reg_ep0_rx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep0_rx_done_int    0xDD19
+#define reg_ep0_rx_done_int_pos 1
+#define reg_ep0_rx_done_int_len 1
+#define reg_ep0_rx_done_int_lsb 0
+#define xd_p_reg_ep1_tx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep1_tx_done_int    0xDD19
+#define reg_ep1_tx_done_int_pos 2
+#define reg_ep1_tx_done_int_len 1
+#define reg_ep1_tx_done_int_lsb 0
+#define xd_p_reg_ep2_rx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep2_rx_done_int    0xDD19
+#define reg_ep2_rx_done_int_pos 3
+#define reg_ep2_rx_done_int_len 1
+#define reg_ep2_rx_done_int_lsb 0
+#define xd_p_reg_ep3_tx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep3_tx_done_int    0xDD19
+#define reg_ep3_tx_done_int_pos 4
+#define reg_ep3_tx_done_int_len 1
+#define reg_ep3_tx_done_int_lsb 0
+#define xd_p_reg_ep4_tx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep4_tx_done_int    0xDD19
+#define reg_ep4_tx_done_int_pos 5
+#define reg_ep4_tx_done_int_len 1
+#define reg_ep4_tx_done_int_lsb 0
+#define xd_p_reg_ep5_tx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep5_tx_done_int    0xDD19
+#define reg_ep5_tx_done_int_pos 6
+#define reg_ep5_tx_done_int_len 1
+#define reg_ep5_tx_done_int_lsb 0
+#define xd_p_reg_ep6_tx_done_int    (*(volatile byte xdata *) 0xDD19)
+#define    p_reg_ep6_tx_done_int    0xDD19
+#define reg_ep6_tx_done_int_pos 7
+#define reg_ep6_tx_done_int_len 1
+#define reg_ep6_tx_done_int_lsb 0
+#define xd_p_reg_ep0_tx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep0_tx_fail_int    0xDD1A
+#define reg_ep0_tx_fail_int_pos 0
+#define reg_ep0_tx_fail_int_len 1
+#define reg_ep0_tx_fail_int_lsb 0
+#define xd_p_reg_ep0_rx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep0_rx_fail_int    0xDD1A
+#define reg_ep0_rx_fail_int_pos 1
+#define reg_ep0_rx_fail_int_len 1
+#define reg_ep0_rx_fail_int_lsb 0
+#define xd_p_reg_ep1_tx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep1_tx_fail_int    0xDD1A
+#define reg_ep1_tx_fail_int_pos 2
+#define reg_ep1_tx_fail_int_len 1
+#define reg_ep1_tx_fail_int_lsb 0
+#define xd_p_reg_ep2_rx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep2_rx_fail_int    0xDD1A
+#define reg_ep2_rx_fail_int_pos 3
+#define reg_ep2_rx_fail_int_len 1
+#define reg_ep2_rx_fail_int_lsb 0
+#define xd_p_reg_ep3_tx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep3_tx_fail_int    0xDD1A
+#define reg_ep3_tx_fail_int_pos 4
+#define reg_ep3_tx_fail_int_len 1
+#define reg_ep3_tx_fail_int_lsb 0
+#define xd_p_reg_ep4_tx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep4_tx_fail_int    0xDD1A
+#define reg_ep4_tx_fail_int_pos 5
+#define reg_ep4_tx_fail_int_len 1
+#define reg_ep4_tx_fail_int_lsb 0
+#define xd_p_reg_ep5_tx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep5_tx_fail_int    0xDD1A
+#define reg_ep5_tx_fail_int_pos 6
+#define reg_ep5_tx_fail_int_len 1
+#define reg_ep5_tx_fail_int_lsb 0
+#define xd_p_reg_ep6_tx_fail_int    (*(volatile byte xdata *) 0xDD1A)
+#define    p_reg_ep6_tx_fail_int    0xDD1A
+#define reg_ep6_tx_fail_int_pos 7
+#define reg_ep6_tx_fail_int_len 1
+#define reg_ep6_tx_fail_int_lsb 0
+#define xd_p_reg_suspend_int    (*(volatile byte xdata *) 0xDD1B)
+#define    p_reg_suspend_int    0xDD1B
+#define reg_suspend_int_pos 0
+#define reg_suspend_int_len 1
+#define reg_suspend_int_lsb 0
+#define xd_p_reg_bus_reset_int  (*(volatile byte xdata *) 0xDD1B)
+#define    p_reg_bus_reset_int  0xDD1B
+#define reg_bus_reset_int_pos 1
+#define reg_bus_reset_int_len 1
+#define reg_bus_reset_int_lsb 0
+#define xd_p_reg_ep0_setup_int  (*(volatile byte xdata *) 0xDD1B)
+#define    p_reg_ep0_setup_int  0xDD1B
+#define reg_ep0_setup_int_pos 2
+#define reg_ep0_setup_int_len 1
+#define reg_ep0_setup_int_lsb 0
+#define xd_r_usbc_int   (*(volatile byte xdata *) 0xDD1B)
+#define    r_usbc_int   0xDD1B
+#define usbc_int_pos 3
+#define usbc_int_len 1
+#define usbc_int_lsb 0
+#define xd_r_usb_ir_int (*(volatile byte xdata *) 0xDD1B)
+#define    r_usb_ir_int 0xDD1B
+#define usb_ir_int_pos 4
+#define usb_ir_int_len 1
+#define usb_ir_int_lsb 0
+#define xd_p_reg_ep0_tx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep0_tx_rst 0xDD1D
+#define reg_ep0_tx_rst_pos 0
+#define reg_ep0_tx_rst_len 1
+#define reg_ep0_tx_rst_lsb 0
+#define xd_p_reg_ep0_rx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep0_rx_rst 0xDD1D
+#define reg_ep0_rx_rst_pos 1
+#define reg_ep0_rx_rst_len 1
+#define reg_ep0_rx_rst_lsb 0
+#define xd_p_reg_ep1_tx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep1_tx_rst 0xDD1D
+#define reg_ep1_tx_rst_pos 2
+#define reg_ep1_tx_rst_len 1
+#define reg_ep1_tx_rst_lsb 0
+#define xd_p_reg_ep2_rx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep2_rx_rst 0xDD1D
+#define reg_ep2_rx_rst_pos 3
+#define reg_ep2_rx_rst_len 1
+#define reg_ep2_rx_rst_lsb 0
+#define xd_p_reg_ep3_tx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep3_tx_rst 0xDD1D
+#define reg_ep3_tx_rst_pos 4
+#define reg_ep3_tx_rst_len 1
+#define reg_ep3_tx_rst_lsb 0
+#define xd_p_reg_ep4_tx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep4_tx_rst 0xDD1D
+#define reg_ep4_tx_rst_pos 5
+#define reg_ep4_tx_rst_len 1
+#define reg_ep4_tx_rst_lsb 0
+#define xd_p_reg_ep5_tx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep5_tx_rst 0xDD1D
+#define reg_ep5_tx_rst_pos 6
+#define reg_ep5_tx_rst_len 1
+#define reg_ep5_tx_rst_lsb 0
+#define xd_p_reg_ep6_tx_rst (*(volatile byte xdata *) 0xDD1D)
+#define    p_reg_ep6_tx_rst 0xDD1D
+#define reg_ep6_tx_rst_pos 7
+#define reg_ep6_tx_rst_len 1
+#define reg_ep6_tx_rst_lsb 0
+#define xd_r_reg_ep0_tx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep0_tx_active  0xDD1E
+#define reg_ep0_tx_active_pos 0
+#define reg_ep0_tx_active_len 1
+#define reg_ep0_tx_active_lsb 0
+#define xd_r_reg_ep0_rx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep0_rx_active  0xDD1E
+#define reg_ep0_rx_active_pos 1
+#define reg_ep0_rx_active_len 1
+#define reg_ep0_rx_active_lsb 0
+#define xd_r_reg_ep1_tx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep1_tx_active  0xDD1E
+#define reg_ep1_tx_active_pos 2
+#define reg_ep1_tx_active_len 1
+#define reg_ep1_tx_active_lsb 0
+#define xd_r_reg_ep2_rx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep2_rx_active  0xDD1E
+#define reg_ep2_rx_active_pos 3
+#define reg_ep2_rx_active_len 1
+#define reg_ep2_rx_active_lsb 0
+#define xd_r_reg_ep3_tx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep3_tx_active  0xDD1E
+#define reg_ep3_tx_active_pos 4
+#define reg_ep3_tx_active_len 1
+#define reg_ep3_tx_active_lsb 0
+#define xd_r_reg_ep4_tx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep4_tx_active  0xDD1E
+#define reg_ep4_tx_active_pos 5
+#define reg_ep4_tx_active_len 1
+#define reg_ep4_tx_active_lsb 0
+#define xd_r_reg_ep5_tx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep5_tx_active  0xDD1E
+#define reg_ep5_tx_active_pos 6
+#define reg_ep5_tx_active_len 1
+#define reg_ep5_tx_active_lsb 0
+#define xd_r_reg_ep6_tx_active  (*(volatile byte xdata *) 0xDD1E)
+#define    r_reg_ep6_tx_active  0xDD1E
+#define reg_ep6_tx_active_pos 7
+#define reg_ep6_tx_active_len 1
+#define reg_ep6_tx_active_lsb 0
+#define xd_p_reg_usb_setup_reset    (*(volatile byte xdata *) 0xDD1F)
+#define    p_reg_usb_setup_reset    0xDD1F
+#define reg_usb_setup_reset_pos 0
+#define reg_usb_setup_reset_len 1
+#define reg_usb_setup_reset_lsb 0
+#define xd_p_reg_usb_ep4_retry_new  (*(volatile byte xdata *) 0xDD1F)
+#define    p_reg_usb_ep4_retry_new  0xDD1F
+#define reg_usb_ep4_retry_new_pos 1
+#define reg_usb_ep4_retry_new_len 1
+#define reg_usb_ep4_retry_new_lsb 0
+#define xd_p_reg_usb_ep5_retry_new  (*(volatile byte xdata *) 0xDD1F)
+#define    p_reg_usb_ep5_retry_new  0xDD1F
+#define reg_usb_ep5_retry_new_pos 2
+#define reg_usb_ep5_retry_new_len 1
+#define reg_usb_ep5_retry_new_lsb 0
+#define xd_p_reg_usb_ep6_retry_new  (*(volatile byte xdata *) 0xDD1F)
+#define    p_reg_usb_ep6_retry_new  0xDD1F
+#define reg_usb_ep6_retry_new_pos 3
+#define reg_usb_ep6_retry_new_len 1
+#define reg_usb_ep6_retry_new_lsb 0
+#define xd_p_reg_usb_iso_mult_cnt   (*(volatile byte xdata *) 0xDD20)
+#define    p_reg_usb_iso_mult_cnt   0xDD20
+#define reg_usb_iso_mult_cnt_pos 0
+#define reg_usb_iso_mult_cnt_len 2
+#define reg_usb_iso_mult_cnt_lsb 0
+#define xd_p_reg_p_iso_fix_en   (*(volatile byte xdata *) 0xDD21)
+#define    p_reg_p_iso_fix_en   0xDD21
+#define reg_p_iso_fix_en_pos 0
+#define reg_p_iso_fix_en_len 1
+#define reg_p_iso_fix_en_lsb 0
+#define xd_p_reg_p_iso_fix_rst  (*(volatile byte xdata *) 0xDD22)
+#define    p_reg_p_iso_fix_rst  0xDD22
+#define reg_p_iso_fix_rst_pos 0
+#define reg_p_iso_fix_rst_len 1
+#define reg_p_iso_fix_rst_lsb 0
+#define xd_p_reg_p_read_point_7_0   (*(volatile byte xdata *) 0xDD23)
+#define    p_reg_p_read_point_7_0   0xDD23
+#define reg_p_read_point_7_0_pos 0
+#define reg_p_read_point_7_0_len 8
+#define reg_p_read_point_7_0_lsb 0
+#define xd_p_reg_p_read_point_11_8  (*(volatile byte xdata *) 0xDD24)
+#define    p_reg_p_read_point_11_8  0xDD24
+#define reg_p_read_point_11_8_pos 0
+#define reg_p_read_point_11_8_len 4
+#define reg_p_read_point_11_8_lsb 8
+#define xd_p_reg_p_dbg_ctrl (*(volatile byte xdata *) 0xDD25)
+#define    p_reg_p_dbg_ctrl 0xDD25
+#define reg_p_dbg_ctrl_pos 0
+#define reg_p_dbg_ctrl_len 3
+#define reg_p_dbg_ctrl_lsb 0
+#define xd_p_reg_p_data_swap    (*(volatile byte xdata *) 0xDD26)
+#define    p_reg_p_data_swap    0xDD26
+#define reg_p_data_swap_pos 0
+#define reg_p_data_swap_len 2
+#define reg_p_data_swap_lsb 0
+#define xd_p_reg_ep_rx_addr (*(volatile byte xdata *) 0xDD80)
+#define    p_reg_ep_rx_addr 0xDD80
+#define reg_ep_rx_addr_pos 2
+#define reg_ep_rx_addr_len 6
+#define reg_ep_rx_addr_lsb 0
+#define xd_p_reg_ep0_tx_addr    (*(volatile byte xdata *) 0xDD81)
+#define    p_reg_ep0_tx_addr    0xDD81
+#define reg_ep0_tx_addr_pos 2
+#define reg_ep0_tx_addr_len 6
+#define reg_ep0_tx_addr_lsb 0
+#define xd_p_reg_ep1_tx_addr    (*(volatile byte xdata *) 0xDD82)
+#define    p_reg_ep1_tx_addr    0xDD82
+#define reg_ep1_tx_addr_pos 2
+#define reg_ep1_tx_addr_len 6
+#define reg_ep1_tx_addr_lsb 0
+#define xd_p_reg_ep3_tx_addr    (*(volatile byte xdata *) 0xDD83)
+#define    p_reg_ep3_tx_addr    0xDD83
+#define reg_ep3_tx_addr_pos 2
+#define reg_ep3_tx_addr_len 6
+#define reg_ep3_tx_addr_lsb 0
+#define xd_p_reg_ep_rx_len  (*(volatile byte xdata *) 0xDD84)
+#define    p_reg_ep_rx_len  0xDD84
+#define reg_ep_rx_len_pos 0
+#define reg_ep_rx_len_len 8
+#define reg_ep_rx_len_lsb 0
+#define xd_p_reg_ep0_tx_len (*(volatile byte xdata *) 0xDD85)
+#define    p_reg_ep0_tx_len 0xDD85
+#define reg_ep0_tx_len_pos 0
+#define reg_ep0_tx_len_len 8
+#define reg_ep0_tx_len_lsb 0
+#define xd_p_reg_ep1_tx_len (*(volatile byte xdata *) 0xDD86)
+#define    p_reg_ep1_tx_len 0xDD86
+#define reg_ep1_tx_len_pos 0
+#define reg_ep1_tx_len_len 8
+#define reg_ep1_tx_len_lsb 0
+#define xd_p_reg_ep3_tx_len (*(volatile byte xdata *) 0xDD87)
+#define    p_reg_ep3_tx_len 0xDD87
+#define reg_ep3_tx_len_pos 0
+#define reg_ep3_tx_len_len 8
+#define reg_ep3_tx_len_lsb 0
+#define xd_p_reg_ep4_tx_len_7_0 (*(volatile byte xdata *) 0xDD88)
+#define    p_reg_ep4_tx_len_7_0 0xDD88
+#define reg_ep4_tx_len_7_0_pos 0
+#define reg_ep4_tx_len_7_0_len 8
+#define reg_ep4_tx_len_7_0_lsb 0
+#define xd_p_reg_ep4_tx_len_15_8    (*(volatile byte xdata *) 0xDD89)
+#define    p_reg_ep4_tx_len_15_8    0xDD89
+#define reg_ep4_tx_len_15_8_pos 0
+#define reg_ep4_tx_len_15_8_len 8
+#define reg_ep4_tx_len_15_8_lsb 8
+#define xd_p_reg_ep5_tx_len_7_0 (*(volatile byte xdata *) 0xDD8A)
+#define    p_reg_ep5_tx_len_7_0 0xDD8A
+#define reg_ep5_tx_len_7_0_pos 0
+#define reg_ep5_tx_len_7_0_len 8
+#define reg_ep5_tx_len_7_0_lsb 0
+#define xd_p_reg_ep5_tx_len_15_8    (*(volatile byte xdata *) 0xDD8B)
+#define    p_reg_ep5_tx_len_15_8    0xDD8B
+#define reg_ep5_tx_len_15_8_pos 0
+#define reg_ep5_tx_len_15_8_len 8
+#define reg_ep5_tx_len_15_8_lsb 8
+#define xd_p_reg_usb_reset_addr (*(volatile byte xdata *) 0xDD8C)
+#define    p_reg_usb_reset_addr 0xDD8C
+#define reg_usb_reset_addr_pos 0
+#define reg_usb_reset_addr_len 7
+#define reg_usb_reset_addr_lsb 0
+#define xd_p_reg_usb_reset  (*(volatile byte xdata *) 0xDD8C)
+#define    p_reg_usb_reset  0xDD8C
+#define reg_usb_reset_pos 7
+#define reg_usb_reset_len 1
+#define reg_usb_reset_lsb 0
+#define xd_p_reg_usb_sync_in    (*(volatile byte xdata *) 0xDD8D)
+#define    p_reg_usb_sync_in    0xDD8D
+#define reg_usb_sync_in_pos 0
+#define reg_usb_sync_in_len 1
+#define reg_usb_sync_in_lsb 0
+#define xd_p_reg_usb_sync_txready   (*(volatile byte xdata *) 0xDD8D)
+#define    p_reg_usb_sync_txready   0xDD8D
+#define reg_usb_sync_txready_pos 1
+#define reg_usb_sync_txready_len 1
+#define reg_usb_sync_txready_lsb 0
+#define xd_p_reg_utmi_phy_suspend   (*(volatile byte xdata *) 0xDD8D)
+#define    p_reg_utmi_phy_suspend   0xDD8D
+#define reg_utmi_phy_suspend_pos 2
+#define reg_utmi_phy_suspend_len 1
+#define reg_utmi_phy_suspend_lsb 0
+#define xd_p_reg_usb_min_len    (*(volatile byte xdata *) 0xDD8D)
+#define    p_reg_usb_min_len    0xDD8D
+#define reg_usb_min_len_pos 3
+#define reg_usb_min_len_len 1
+#define reg_usb_min_len_lsb 0
+#define xd_p_reg_usb_phy_clksel (*(volatile byte xdata *) 0xDD8D)
+#define    p_reg_usb_phy_clksel 0xDD8D
+#define reg_usb_phy_clksel_pos 4
+#define reg_usb_phy_clksel_len 1
+#define reg_usb_phy_clksel_lsb 0
+#define xd_p_reg_ep6_tx_len_7_0 (*(volatile byte xdata *) 0xDD8E)
+#define    p_reg_ep6_tx_len_7_0 0xDD8E
+#define reg_ep6_tx_len_7_0_pos 0
+#define reg_ep6_tx_len_7_0_len 8
+#define reg_ep6_tx_len_7_0_lsb 0
+#define xd_p_reg_ep6_tx_len_15_8    (*(volatile byte xdata *) 0xDD8F)
+#define    p_reg_ep6_tx_len_15_8    0xDD8F
+#define reg_ep6_tx_len_15_8_pos 0
+#define reg_ep6_tx_len_15_8_len 8
+#define reg_ep6_tx_len_15_8_lsb 8
+#define xd_p_reg_usb_clk_phase  (*(volatile byte xdata *) 0xDD93)
+#define    p_reg_usb_clk_phase  0xDD93
+#define reg_usb_clk_phase_pos 0
+#define reg_usb_clk_phase_len 2
+#define reg_usb_clk_phase_lsb 0
+#define xd_p_reg_usb_clk_sel    (*(volatile byte xdata *) 0xDD93)
+#define    p_reg_usb_clk_sel    0xDD93
+#define reg_usb_clk_sel_pos 4
+#define reg_usb_clk_sel_len 4
+#define reg_usb_clk_sel_lsb 0
+#define xd_p_reg_usb_fifo_ptr   (*(volatile byte xdata *) 0xDD94)
+#define    p_reg_usb_fifo_ptr   0xDD94
+#define reg_usb_fifo_ptr_pos 0
+#define reg_usb_fifo_ptr_len 3
+#define reg_usb_fifo_ptr_lsb 0
+#define xd_p_reg_usb_fifo_byte  (*(volatile byte xdata *) 0xDD94)
+#define    p_reg_usb_fifo_byte  0xDD94
+#define reg_usb_fifo_byte_pos 3
+#define reg_usb_fifo_byte_len 2
+#define reg_usb_fifo_byte_lsb 0
+#define xd_p_reg_usb_fifo_sys   (*(volatile byte xdata *) 0xDD94)
+#define    p_reg_usb_fifo_sys   0xDD94
+#define reg_usb_fifo_sys_pos 5
+#define reg_usb_fifo_sys_len 1
+#define reg_usb_fifo_sys_lsb 0
+#define xd_p_usbdma_utmi_d_ctl_7_0  (*(volatile byte xdata *) 0xDD9E)
+#define    p_usbdma_utmi_d_ctl_7_0  0xDD9E
+#define usbdma_utmi_d_ctl_7_0_pos 0
+#define usbdma_utmi_d_ctl_7_0_len 8
+#define usbdma_utmi_d_ctl_7_0_lsb 0
+#define xd_p_usbdma_utmi_d_ctl_13_8 (*(volatile byte xdata *) 0xDD9F)
+#define    p_usbdma_utmi_d_ctl_13_8 0xDD9F
+#define usbdma_utmi_d_ctl_13_8_pos 0
+#define usbdma_utmi_d_ctl_13_8_len 6
+#define usbdma_utmi_d_ctl_13_8_lsb 8
+#define xd_p_usbdma_utmi_a_ctl_7_0  (*(volatile byte xdata *) 0xDDA0)
+#define    p_usbdma_utmi_a_ctl_7_0  0xDDA0
+#define usbdma_utmi_a_ctl_7_0_pos 0
+#define usbdma_utmi_a_ctl_7_0_len 8
+#define usbdma_utmi_a_ctl_7_0_lsb 0
+#define xd_p_usbdma_utmi_a_ctl_15_8 (*(volatile byte xdata *) 0xDDA1)
+#define    p_usbdma_utmi_a_ctl_15_8 0xDDA1
+#define usbdma_utmi_a_ctl_15_8_pos 0
+#define usbdma_utmi_a_ctl_15_8_len 8
+#define usbdma_utmi_a_ctl_15_8_lsb 8
+#define xd_p_usbdma_utmi_a_ctl_23_16    (*(volatile byte xdata *) 0xDDA2)
+#define    p_usbdma_utmi_a_ctl_23_16    0xDDA2
+#define usbdma_utmi_a_ctl_23_16_pos 0
+#define usbdma_utmi_a_ctl_23_16_len 8
+#define usbdma_utmi_a_ctl_23_16_lsb 16
+#define xd_p_usbdma_utmi_a_ctl_31_24    (*(volatile byte xdata *) 0xDDA3)
+#define    p_usbdma_utmi_a_ctl_31_24    0xDDA3
+#define usbdma_utmi_a_ctl_31_24_pos 0
+#define usbdma_utmi_a_ctl_31_24_len 8
+#define usbdma_utmi_a_ctl_31_24_lsb 24
+#define xd_p_usbdma_utmi_a_ctl_39_32    (*(volatile byte xdata *) 0xDDA4)
+#define    p_usbdma_utmi_a_ctl_39_32    0xDDA4
+#define usbdma_utmi_a_ctl_39_32_pos 0
+#define usbdma_utmi_a_ctl_39_32_len 8
+#define usbdma_utmi_a_ctl_39_32_lsb 32
+#define xd_p_usbdma_utmi_a_ctl_47_40    (*(volatile byte xdata *) 0xDDA5)
+#define    p_usbdma_utmi_a_ctl_47_40    0xDDA5
+#define usbdma_utmi_a_ctl_47_40_pos 0
+#define usbdma_utmi_a_ctl_47_40_len 8
+#define usbdma_utmi_a_ctl_47_40_lsb 40
+#define xd_p_usbdma_utmi_pwrmode    (*(volatile byte xdata *) 0xDDA6)
+#define    p_usbdma_utmi_pwrmode    0xDDA6
+#define usbdma_utmi_pwrmode_pos 3
+#define usbdma_utmi_pwrmode_len 1
+#define usbdma_utmi_pwrmode_lsb 0
+#define xd_p_usbdma_utmi_test_out   (*(volatile byte xdata *) 0xDDA6)
+#define    p_usbdma_utmi_test_out   0xDDA6
+#define usbdma_utmi_test_out_pos 4
+#define usbdma_utmi_test_out_len 1
+#define usbdma_utmi_test_out_lsb 0
+#define xd_p_usbdma_utmi_vbus_int_en    (*(volatile byte xdata *) 0xDDA7)
+#define    p_usbdma_utmi_vbus_int_en    0xDDA7
+#define usbdma_utmi_vbus_int_en_pos 0
+#define usbdma_utmi_vbus_int_en_len 1
+#define usbdma_utmi_vbus_int_en_lsb 0
+#define xd_p_usbdma_utmi_vbus_int_pol   (*(volatile byte xdata *) 0xDDA7)
+#define    p_usbdma_utmi_vbus_int_pol   0xDDA7
+#define usbdma_utmi_vbus_int_pol_pos 1
+#define usbdma_utmi_vbus_int_pol_len 1
+#define usbdma_utmi_vbus_int_pol_lsb 0
+#define xd_r_usbdma_utmi_vbus_int   (*(volatile byte xdata *) 0xDDA8)
+#define    r_usbdma_utmi_vbus_int   0xDDA8
+#define usbdma_utmi_vbus_int_pos 0
+#define usbdma_utmi_vbus_int_len 1
+#define usbdma_utmi_vbus_int_lsb 0
+#define xd_r_usbdma_utmi_vbus_status    (*(volatile byte xdata *) 0xDDA8)
+#define    r_usbdma_utmi_vbus_status    0xDDA8
+#define usbdma_utmi_vbus_status_pos 1
+#define usbdma_utmi_vbus_status_len 1
+#define usbdma_utmi_vbus_status_lsb 0
+#define xd_r_usbdma_utmi_clkrdy (*(volatile byte xdata *) 0xDDA8)
+#define    r_usbdma_utmi_clkrdy 0xDDA8
+#define usbdma_utmi_clkrdy_pos 2
+#define usbdma_utmi_clkrdy_len 1
+#define usbdma_utmi_clkrdy_lsb 0
+#define xd_p_reg_p_usb_iso_ccir_rst (*(volatile byte xdata *) 0xDDA9)
+#define    p_reg_p_usb_iso_ccir_rst 0xDDA9
+#define reg_p_usb_iso_ccir_rst_pos 0
+#define reg_p_usb_iso_ccir_rst_len 1
+#define reg_p_usb_iso_ccir_rst_lsb 0
+#define xd_p_reg_p_usb_iso_ccir (*(volatile byte xdata *) 0xDDA9)
+#define    p_reg_p_usb_iso_ccir 0xDDA9
+#define reg_p_usb_iso_ccir_pos 1
+#define reg_p_usb_iso_ccir_len 1
+#define reg_p_usb_iso_ccir_lsb 0
+#define xd_p_reg_p_ccir_fix_en  (*(volatile byte xdata *) 0xDDAA)
+#define    p_reg_p_ccir_fix_en  0xDDAA
+#define reg_p_ccir_fix_en_pos 0
+#define reg_p_ccir_fix_en_len 1
+#define reg_p_ccir_fix_en_lsb 0
+#define xd_p_ir_sys_clk (*(volatile byte xdata *) 0xDF80)
+#define    p_ir_sys_clk 0xDF80
+#define ir_sys_clk_pos 0
+#define ir_sys_clk_len 8
+#define ir_sys_clk_lsb 0
+#define xd_p_ir_sample_clk  (*(volatile byte xdata *) 0xDF81)
+#define    p_ir_sample_clk  0xDF81
+#define ir_sample_clk_pos 0
+#define ir_sample_clk_len 2
+#define ir_sample_clk_lsb 0
+#define xd_p_ir_idle_polarity   (*(volatile byte xdata *) 0xDF81)
+#define    p_ir_idle_polarity   0xDF81
+#define ir_idle_polarity_pos 2
+#define ir_idle_polarity_len 1
+#define ir_idle_polarity_lsb 0
+#define xd_p_ir_fifo_ovfl   (*(volatile byte xdata *) 0xDF82)
+#define    p_ir_fifo_ovfl   0xDF82
+#define ir_fifo_ovfl_pos 0
+#define ir_fifo_ovfl_len 1
+#define ir_fifo_ovfl_lsb 0
+#define xd_r_ir_fifo_empty  (*(volatile byte xdata *) 0xDF82)
+#define    r_ir_fifo_empty  0xDF82
+#define ir_fifo_empty_pos 1
+#define ir_fifo_empty_len 1
+#define ir_fifo_empty_lsb 0
+#define xd_r_ir_fifo_cnt    (*(volatile byte xdata *) 0xDF82)
+#define    r_ir_fifo_cnt    0xDF82
+#define ir_fifo_cnt_pos 2
+#define ir_fifo_cnt_len 3
+#define ir_fifo_cnt_lsb 0
+#define xd_p_ir_fifo_rst    (*(volatile byte xdata *) 0xDF82)
+#define    p_ir_fifo_rst    0xDF82
+#define ir_fifo_rst_pos 5
+#define ir_fifo_rst_len 1
+#define ir_fifo_rst_lsb 0
+#define xd_p_reg_ir_out_th0_7_0 (*(volatile byte xdata *) 0xDF84)
+#define    p_reg_ir_out_th0_7_0 0xDF84
+#define reg_ir_out_th0_7_0_pos 0
+#define reg_ir_out_th0_7_0_len 8
+#define reg_ir_out_th0_7_0_lsb 0
+#define xd_p_reg_ir_out_th0_14_8    (*(volatile byte xdata *) 0xDF85)
+#define    p_reg_ir_out_th0_14_8    0xDF85
+#define reg_ir_out_th0_14_8_pos 0
+#define reg_ir_out_th0_14_8_len 7
+#define reg_ir_out_th0_14_8_lsb 8
+#define xd_p_reg_ir_out_th1_7_0 (*(volatile byte xdata *) 0xDF86)
+#define    p_reg_ir_out_th1_7_0 0xDF86
+#define reg_ir_out_th1_7_0_pos 0
+#define reg_ir_out_th1_7_0_len 8
+#define reg_ir_out_th1_7_0_lsb 0
+#define xd_p_reg_ir_out_th1_14_8    (*(volatile byte xdata *) 0xDF87)
+#define    p_reg_ir_out_th1_14_8    0xDF87
+#define reg_ir_out_th1_14_8_pos 0
+#define reg_ir_out_th1_14_8_len 7
+#define reg_ir_out_th1_14_8_lsb 8
+#define xd_p_reg_ir_out_th2_7_0 (*(volatile byte xdata *) 0xDF88)
+#define    p_reg_ir_out_th2_7_0 0xDF88
+#define reg_ir_out_th2_7_0_pos 0
+#define reg_ir_out_th2_7_0_len 8
+#define reg_ir_out_th2_7_0_lsb 0
+#define xd_p_reg_ir_out_th2_14_8    (*(volatile byte xdata *) 0xDF89)
+#define    p_reg_ir_out_th2_14_8    0xDF89
+#define reg_ir_out_th2_14_8_pos 0
+#define reg_ir_out_th2_14_8_len 7
+#define reg_ir_out_th2_14_8_lsb 8
+#define xd_p_reg_ir_out_th3_7_0 (*(volatile byte xdata *) 0xDF8A)
+#define    p_reg_ir_out_th3_7_0 0xDF8A
+#define reg_ir_out_th3_7_0_pos 0
+#define reg_ir_out_th3_7_0_len 8
+#define reg_ir_out_th3_7_0_lsb 0
+#define xd_p_reg_ir_out_th3_14_8    (*(volatile byte xdata *) 0xDF8B)
+#define    p_reg_ir_out_th3_14_8    0xDF8B
+#define reg_ir_out_th3_14_8_pos 0
+#define reg_ir_out_th3_14_8_len 7
+#define reg_ir_out_th3_14_8_lsb 8
+#define xd_p_reg_ir_out_th4_7_0 (*(volatile byte xdata *) 0xDF8C)
+#define    p_reg_ir_out_th4_7_0 0xDF8C
+#define reg_ir_out_th4_7_0_pos 0
+#define reg_ir_out_th4_7_0_len 8
+#define reg_ir_out_th4_7_0_lsb 0
+#define xd_p_reg_ir_out_th4_14_8    (*(volatile byte xdata *) 0xDF8D)
+#define    p_reg_ir_out_th4_14_8    0xDF8D
+#define reg_ir_out_th4_14_8_pos 0
+#define reg_ir_out_th4_14_8_len 7
+#define reg_ir_out_th4_14_8_lsb 8
+#define xd_p_reg_ir_out_th5_7_0 (*(volatile byte xdata *) 0xDF8E)
+#define    p_reg_ir_out_th5_7_0 0xDF8E
+#define reg_ir_out_th5_7_0_pos 0
+#define reg_ir_out_th5_7_0_len 8
+#define reg_ir_out_th5_7_0_lsb 0
+#define xd_p_reg_ir_out_th5_14_8    (*(volatile byte xdata *) 0xDF8F)
+#define    p_reg_ir_out_th5_14_8    0xDF8F
+#define reg_ir_out_th5_14_8_pos 0
+#define reg_ir_out_th5_14_8_len 7
+#define reg_ir_out_th5_14_8_lsb 8
+#define xd_p_reg_ir_out_th6_7_0 (*(volatile byte xdata *) 0xDF90)
+#define    p_reg_ir_out_th6_7_0 0xDF90
+#define reg_ir_out_th6_7_0_pos 0
+#define reg_ir_out_th6_7_0_len 8
+#define reg_ir_out_th6_7_0_lsb 0
+#define xd_p_reg_ir_out_th6_14_8    (*(volatile byte xdata *) 0xDF91)
+#define    p_reg_ir_out_th6_14_8    0xDF91
+#define reg_ir_out_th6_14_8_pos 0
+#define reg_ir_out_th6_14_8_len 7
+#define reg_ir_out_th6_14_8_lsb 8
+#define xd_p_reg_ir_out_th7_7_0 (*(volatile byte xdata *) 0xDF92)
+#define    p_reg_ir_out_th7_7_0 0xDF92
+#define reg_ir_out_th7_7_0_pos 0
+#define reg_ir_out_th7_7_0_len 8
+#define reg_ir_out_th7_7_0_lsb 0
+#define xd_p_reg_ir_out_th7_14_8    (*(volatile byte xdata *) 0xDF93)
+#define    p_reg_ir_out_th7_14_8    0xDF93
+#define reg_ir_out_th7_14_8_pos 0
+#define reg_ir_out_th7_14_8_len 7
+#define reg_ir_out_th7_14_8_lsb 8
+#define xd_p_reg_ir_out_th8_7_0 (*(volatile byte xdata *) 0xDF94)
+#define    p_reg_ir_out_th8_7_0 0xDF94
+#define reg_ir_out_th8_7_0_pos 0
+#define reg_ir_out_th8_7_0_len 8
+#define reg_ir_out_th8_7_0_lsb 0
+#define xd_p_reg_ir_out_th8_14_8    (*(volatile byte xdata *) 0xDF95)
+#define    p_reg_ir_out_th8_14_8    0xDF95
+#define reg_ir_out_th8_14_8_pos 0
+#define reg_ir_out_th8_14_8_len 7
+#define reg_ir_out_th8_14_8_lsb 8
+#define xd_p_reg_ir_out_th9_7_0 (*(volatile byte xdata *) 0xDF96)
+#define    p_reg_ir_out_th9_7_0 0xDF96
+#define reg_ir_out_th9_7_0_pos 0
+#define reg_ir_out_th9_7_0_len 8
+#define reg_ir_out_th9_7_0_lsb 0
+#define xd_p_reg_ir_out_th9_14_8    (*(volatile byte xdata *) 0xDF97)
+#define    p_reg_ir_out_th9_14_8    0xDF97
+#define reg_ir_out_th9_14_8_pos 0
+#define reg_ir_out_th9_14_8_len 7
+#define reg_ir_out_th9_14_8_lsb 8
+#define xd_p_reg_ir_out_th10_7_0    (*(volatile byte xdata *) 0xDF98)
+#define    p_reg_ir_out_th10_7_0    0xDF98
+#define reg_ir_out_th10_7_0_pos 0
+#define reg_ir_out_th10_7_0_len 8
+#define reg_ir_out_th10_7_0_lsb 0
+#define xd_p_reg_ir_out_th10_14_8   (*(volatile byte xdata *) 0xDF99)
+#define    p_reg_ir_out_th10_14_8   0xDF99
+#define reg_ir_out_th10_14_8_pos 0
+#define reg_ir_out_th10_14_8_len 7
+#define reg_ir_out_th10_14_8_lsb 8
+#define xd_p_reg_ir_out_th11_7_0    (*(volatile byte xdata *) 0xDF9A)
+#define    p_reg_ir_out_th11_7_0    0xDF9A
+#define reg_ir_out_th11_7_0_pos 0
+#define reg_ir_out_th11_7_0_len 8
+#define reg_ir_out_th11_7_0_lsb 0
+#define xd_p_reg_ir_out_th11_14_8   (*(volatile byte xdata *) 0xDF9B)
+#define    p_reg_ir_out_th11_14_8   0xDF9B
+#define reg_ir_out_th11_14_8_pos 0
+#define reg_ir_out_th11_14_8_len 7
+#define reg_ir_out_th11_14_8_lsb 8
+#define xd_p_reg_ir_out_th12_7_0    (*(volatile byte xdata *) 0xDF9C)
+#define    p_reg_ir_out_th12_7_0    0xDF9C
+#define reg_ir_out_th12_7_0_pos 0
+#define reg_ir_out_th12_7_0_len 8
+#define reg_ir_out_th12_7_0_lsb 0
+#define xd_p_reg_ir_out_th12_14_8   (*(volatile byte xdata *) 0xDF9D)
+#define    p_reg_ir_out_th12_14_8   0xDF9D
+#define reg_ir_out_th12_14_8_pos 0
+#define reg_ir_out_th12_14_8_len 7
+#define reg_ir_out_th12_14_8_lsb 8
+#define xd_p_reg_ir_out_th13_7_0    (*(volatile byte xdata *) 0xDF9E)
+#define    p_reg_ir_out_th13_7_0    0xDF9E
+#define reg_ir_out_th13_7_0_pos 0
+#define reg_ir_out_th13_7_0_len 8
+#define reg_ir_out_th13_7_0_lsb 0
+#define xd_p_reg_ir_out_th13_14_8   (*(volatile byte xdata *) 0xDF9F)
+#define    p_reg_ir_out_th13_14_8   0xDF9F
+#define reg_ir_out_th13_14_8_pos 0
+#define reg_ir_out_th13_14_8_len 7
+#define reg_ir_out_th13_14_8_lsb 8
+#define xd_p_reg_ir_out_th14_7_0    (*(volatile byte xdata *) 0xDFA0)
+#define    p_reg_ir_out_th14_7_0    0xDFA0
+#define reg_ir_out_th14_7_0_pos 0
+#define reg_ir_out_th14_7_0_len 8
+#define reg_ir_out_th14_7_0_lsb 0
+#define xd_p_reg_ir_out_th14_14_8   (*(volatile byte xdata *) 0xDFA1)
+#define    p_reg_ir_out_th14_14_8   0xDFA1
+#define reg_ir_out_th14_14_8_pos 0
+#define reg_ir_out_th14_14_8_len 7
+#define reg_ir_out_th14_14_8_lsb 8
+#define xd_p_reg_tuner_data_7_0 (*(volatile byte xdata *) 0xF000)
+#define    p_reg_tuner_data_7_0 0xF000
+#define reg_tuner_data_7_0_pos 0
+#define reg_tuner_data_7_0_len 8
+#define reg_tuner_data_7_0_lsb 0
+#define xd_p_reg_tuner_data_15_8    (*(volatile byte xdata *) 0xF001)
+#define    p_reg_tuner_data_15_8    0xF001
+#define reg_tuner_data_15_8_pos 0
+#define reg_tuner_data_15_8_len 8
+#define reg_tuner_data_15_8_lsb 8
+#define xd_p_reg_tuner_data_23_16   (*(volatile byte xdata *) 0xF002)
+#define    p_reg_tuner_data_23_16   0xF002
+#define reg_tuner_data_23_16_pos 0
+#define reg_tuner_data_23_16_len 8
+#define reg_tuner_data_23_16_lsb 16
+#define xd_p_reg_tuner_data_31_24   (*(volatile byte xdata *) 0xF003)
+#define    p_reg_tuner_data_31_24   0xF003
+#define reg_tuner_data_31_24_pos 0
+#define reg_tuner_data_31_24_len 8
+#define reg_tuner_data_31_24_lsb 24
+#define xd_p_reg_tuner_data_39_32   (*(volatile byte xdata *) 0xF004)
+#define    p_reg_tuner_data_39_32   0xF004
+#define reg_tuner_data_39_32_pos 0
+#define reg_tuner_data_39_32_len 8
+#define reg_tuner_data_39_32_lsb 32
+#define xd_p_reg_tuner_data_47_40   (*(volatile byte xdata *) 0xF005)
+#define    p_reg_tuner_data_47_40   0xF005
+#define reg_tuner_data_47_40_pos 0
+#define reg_tuner_data_47_40_len 8
+#define reg_tuner_data_47_40_lsb 40
+#define xd_p_reg_tuner_data_55_48   (*(volatile byte xdata *) 0xF006)
+#define    p_reg_tuner_data_55_48   0xF006
+#define reg_tuner_data_55_48_pos 0
+#define reg_tuner_data_55_48_len 8
+#define reg_tuner_data_55_48_lsb 48
+#define xd_p_reg_tuner_data_63_56   (*(volatile byte xdata *) 0xF007)
+#define    p_reg_tuner_data_63_56   0xF007
+#define reg_tuner_data_63_56_pos 0
+#define reg_tuner_data_63_56_len 8
+#define reg_tuner_data_63_56_lsb 56
+#define xd_p_reg_tuner_data_71_64   (*(volatile byte xdata *) 0xF008)
+#define    p_reg_tuner_data_71_64   0xF008
+#define reg_tuner_data_71_64_pos 0
+#define reg_tuner_data_71_64_len 8
+#define reg_tuner_data_71_64_lsb 64
+#define xd_p_reg_tuner_data_79_72   (*(volatile byte xdata *) 0xF009)
+#define    p_reg_tuner_data_79_72   0xF009
+#define reg_tuner_data_79_72_pos 0
+#define reg_tuner_data_79_72_len 8
+#define reg_tuner_data_79_72_lsb 72
+#define xd_p_reg_tuner_data_87_80   (*(volatile byte xdata *) 0xF00A)
+#define    p_reg_tuner_data_87_80   0xF00A
+#define reg_tuner_data_87_80_pos 0
+#define reg_tuner_data_87_80_len 8
+#define reg_tuner_data_87_80_lsb 80
+#define xd_p_reg_tuner_data_95_88   (*(volatile byte xdata *) 0xF00B)
+#define    p_reg_tuner_data_95_88   0xF00B
+#define reg_tuner_data_95_88_pos 0
+#define reg_tuner_data_95_88_len 8
+#define reg_tuner_data_95_88_lsb 88
+#define xd_p_reg_tuner_data_103_96  (*(volatile byte xdata *) 0xF00C)
+#define    p_reg_tuner_data_103_96  0xF00C
+#define reg_tuner_data_103_96_pos 0
+#define reg_tuner_data_103_96_len 8
+#define reg_tuner_data_103_96_lsb 96
+#define xd_p_reg_tuner_data_111_104 (*(volatile byte xdata *) 0xF00D)
+#define    p_reg_tuner_data_111_104 0xF00D
+#define reg_tuner_data_111_104_pos 0
+#define reg_tuner_data_111_104_len 8
+#define reg_tuner_data_111_104_lsb 104
+#define xd_p_reg_tuner_data_119_112 (*(volatile byte xdata *) 0xF00E)
+#define    p_reg_tuner_data_119_112 0xF00E
+#define reg_tuner_data_119_112_pos 0
+#define reg_tuner_data_119_112_len 8
+#define reg_tuner_data_119_112_lsb 112
+#define xd_p_reg_tuner_data_127_120 (*(volatile byte xdata *) 0xF00F)
+#define    p_reg_tuner_data_127_120 0xF00F
+#define reg_tuner_data_127_120_pos 0
+#define reg_tuner_data_127_120_len 8
+#define reg_tuner_data_127_120_lsb 120
+#define xd_p_reg_tuner_data_135_128 (*(volatile byte xdata *) 0xF010)
+#define    p_reg_tuner_data_135_128 0xF010
+#define reg_tuner_data_135_128_pos 0
+#define reg_tuner_data_135_128_len 8
+#define reg_tuner_data_135_128_lsb 128
+#define xd_p_reg_tuner_data_143_136 (*(volatile byte xdata *) 0xF011)
+#define    p_reg_tuner_data_143_136 0xF011
+#define reg_tuner_data_143_136_pos 0
+#define reg_tuner_data_143_136_len 8
+#define reg_tuner_data_143_136_lsb 136
+#define xd_p_reg_tuner_data_151_144 (*(volatile byte xdata *) 0xF012)
+#define    p_reg_tuner_data_151_144 0xF012
+#define reg_tuner_data_151_144_pos 0
+#define reg_tuner_data_151_144_len 8
+#define reg_tuner_data_151_144_lsb 144
+#define xd_p_reg_tuner_data_159_152 (*(volatile byte xdata *) 0xF013)
+#define    p_reg_tuner_data_159_152 0xF013
+#define reg_tuner_data_159_152_pos 0
+#define reg_tuner_data_159_152_len 8
+#define reg_tuner_data_159_152_lsb 152
+#define xd_p_reg_tuner_data_167_160 (*(volatile byte xdata *) 0xF014)
+#define    p_reg_tuner_data_167_160 0xF014
+#define reg_tuner_data_167_160_pos 0
+#define reg_tuner_data_167_160_len 8
+#define reg_tuner_data_167_160_lsb 160
+#define xd_p_reg_tuner_data_175_168 (*(volatile byte xdata *) 0xF015)
+#define    p_reg_tuner_data_175_168 0xF015
+#define reg_tuner_data_175_168_pos 0
+#define reg_tuner_data_175_168_len 8
+#define reg_tuner_data_175_168_lsb 168
+#define xd_p_reg_tuner_data_183_176 (*(volatile byte xdata *) 0xF016)
+#define    p_reg_tuner_data_183_176 0xF016
+#define reg_tuner_data_183_176_pos 0
+#define reg_tuner_data_183_176_len 8
+#define reg_tuner_data_183_176_lsb 176
+#define xd_p_reg_tuner_data_191_184 (*(volatile byte xdata *) 0xF017)
+#define    p_reg_tuner_data_191_184 0xF017
+#define reg_tuner_data_191_184_pos 0
+#define reg_tuner_data_191_184_len 8
+#define reg_tuner_data_191_184_lsb 184
+#define xd_p_reg_tuner_data_199_192 (*(volatile byte xdata *) 0xF018)
+#define    p_reg_tuner_data_199_192 0xF018
+#define reg_tuner_data_199_192_pos 0
+#define reg_tuner_data_199_192_len 8
+#define reg_tuner_data_199_192_lsb 192
+#define xd_p_reg_tuner_data_207_200 (*(volatile byte xdata *) 0xF019)
+#define    p_reg_tuner_data_207_200 0xF019
+#define reg_tuner_data_207_200_pos 0
+#define reg_tuner_data_207_200_len 8
+#define reg_tuner_data_207_200_lsb 200
+#define xd_p_reg_tuner_data_215_208 (*(volatile byte xdata *) 0xF01A)
+#define    p_reg_tuner_data_215_208 0xF01A
+#define reg_tuner_data_215_208_pos 0
+#define reg_tuner_data_215_208_len 8
+#define reg_tuner_data_215_208_lsb 208
+#define xd_p_reg_tuner_data_223_216 (*(volatile byte xdata *) 0xF01B)
+#define    p_reg_tuner_data_223_216 0xF01B
+#define reg_tuner_data_223_216_pos 0
+#define reg_tuner_data_223_216_len 8
+#define reg_tuner_data_223_216_lsb 216
+#define xd_p_reg_tuner_data_231_224 (*(volatile byte xdata *) 0xF01C)
+#define    p_reg_tuner_data_231_224 0xF01C
+#define reg_tuner_data_231_224_pos 0
+#define reg_tuner_data_231_224_len 8
+#define reg_tuner_data_231_224_lsb 224
+#define xd_p_reg_tuner_data_239_232 (*(volatile byte xdata *) 0xF01D)
+#define    p_reg_tuner_data_239_232 0xF01D
+#define reg_tuner_data_239_232_pos 0
+#define reg_tuner_data_239_232_len 8
+#define reg_tuner_data_239_232_lsb 232
+#define xd_p_reg_tuner_data_247_240 (*(volatile byte xdata *) 0xF01E)
+#define    p_reg_tuner_data_247_240 0xF01E
+#define reg_tuner_data_247_240_pos 0
+#define reg_tuner_data_247_240_len 8
+#define reg_tuner_data_247_240_lsb 240
+#define xd_p_reg_tuner_data_255_248 (*(volatile byte xdata *) 0xF01F)
+#define    p_reg_tuner_data_255_248 0xF01F
+#define reg_tuner_data_255_248_pos 0
+#define reg_tuner_data_255_248_len 8
+#define reg_tuner_data_255_248_lsb 248
+#define xd_p_reg_tuner_data_263_256 (*(volatile byte xdata *) 0xF020)
+#define    p_reg_tuner_data_263_256 0xF020
+#define reg_tuner_data_263_256_pos 0
+#define reg_tuner_data_263_256_len 8
+#define reg_tuner_data_263_256_lsb 256
+#define xd_p_reg_tuner_data_271_264 (*(volatile byte xdata *) 0xF021)
+#define    p_reg_tuner_data_271_264 0xF021
+#define reg_tuner_data_271_264_pos 0
+#define reg_tuner_data_271_264_len 8
+#define reg_tuner_data_271_264_lsb 264
+#define xd_p_reg_tuner_data_279_272 (*(volatile byte xdata *) 0xF022)
+#define    p_reg_tuner_data_279_272 0xF022
+#define reg_tuner_data_279_272_pos 0
+#define reg_tuner_data_279_272_len 8
+#define reg_tuner_data_279_272_lsb 272
+#define xd_p_reg_tuner_data_287_280 (*(volatile byte xdata *) 0xF023)
+#define    p_reg_tuner_data_287_280 0xF023
+#define reg_tuner_data_287_280_pos 0
+#define reg_tuner_data_287_280_len 8
+#define reg_tuner_data_287_280_lsb 280
+#define xd_p_reg_tuner_data_295_288 (*(volatile byte xdata *) 0xF024)
+#define    p_reg_tuner_data_295_288 0xF024
+#define reg_tuner_data_295_288_pos 0
+#define reg_tuner_data_295_288_len 8
+#define reg_tuner_data_295_288_lsb 288
+#define xd_p_reg_tuner_data_303_296 (*(volatile byte xdata *) 0xF025)
+#define    p_reg_tuner_data_303_296 0xF025
+#define reg_tuner_data_303_296_pos 0
+#define reg_tuner_data_303_296_len 8
+#define reg_tuner_data_303_296_lsb 296
+#define xd_p_reg_tuner_data_311_304 (*(volatile byte xdata *) 0xF026)
+#define    p_reg_tuner_data_311_304 0xF026
+#define reg_tuner_data_311_304_pos 0
+#define reg_tuner_data_311_304_len 8
+#define reg_tuner_data_311_304_lsb 304
+#define xd_p_reg_tuner_data_319_312 (*(volatile byte xdata *) 0xF027)
+#define    p_reg_tuner_data_319_312 0xF027
+#define reg_tuner_data_319_312_pos 0
+#define reg_tuner_data_319_312_len 8
+#define reg_tuner_data_319_312_lsb 312
+#define xd_p_reg_tuner_data_327_320 (*(volatile byte xdata *) 0xF028)
+#define    p_reg_tuner_data_327_320 0xF028
+#define reg_tuner_data_327_320_pos 0
+#define reg_tuner_data_327_320_len 8
+#define reg_tuner_data_327_320_lsb 320
+#define xd_p_reg_tuner_data_335_328 (*(volatile byte xdata *) 0xF029)
+#define    p_reg_tuner_data_335_328 0xF029
+#define reg_tuner_data_335_328_pos 0
+#define reg_tuner_data_335_328_len 8
+#define reg_tuner_data_335_328_lsb 328
+#define xd_p_reg_tuner_data_343_336 (*(volatile byte xdata *) 0xF02A)
+#define    p_reg_tuner_data_343_336 0xF02A
+#define reg_tuner_data_343_336_pos 0
+#define reg_tuner_data_343_336_len 8
+#define reg_tuner_data_343_336_lsb 336
+#define xd_p_reg_tuner_data_351_344 (*(volatile byte xdata *) 0xF02B)
+#define    p_reg_tuner_data_351_344 0xF02B
+#define reg_tuner_data_351_344_pos 0
+#define reg_tuner_data_351_344_len 8
+#define reg_tuner_data_351_344_lsb 344
+#define xd_p_reg_tuner_data_359_352 (*(volatile byte xdata *) 0xF02C)
+#define    p_reg_tuner_data_359_352 0xF02C
+#define reg_tuner_data_359_352_pos 0
+#define reg_tuner_data_359_352_len 8
+#define reg_tuner_data_359_352_lsb 352
+#define xd_p_reg_tuner_data_367_360 (*(volatile byte xdata *) 0xF02D)
+#define    p_reg_tuner_data_367_360 0xF02D
+#define reg_tuner_data_367_360_pos 0
+#define reg_tuner_data_367_360_len 8
+#define reg_tuner_data_367_360_lsb 360
+#define xd_p_reg_tuner_data_375_368 (*(volatile byte xdata *) 0xF02E)
+#define    p_reg_tuner_data_375_368 0xF02E
+#define reg_tuner_data_375_368_pos 0
+#define reg_tuner_data_375_368_len 8
+#define reg_tuner_data_375_368_lsb 368
+#define xd_p_reg_tuner_data_383_376 (*(volatile byte xdata *) 0xF02F)
+#define    p_reg_tuner_data_383_376 0xF02F
+#define reg_tuner_data_383_376_pos 0
+#define reg_tuner_data_383_376_len 8
+#define reg_tuner_data_383_376_lsb 376
+#define xd_p_reg_tuner_data_391_384 (*(volatile byte xdata *) 0xF030)
+#define    p_reg_tuner_data_391_384 0xF030
+#define reg_tuner_data_391_384_pos 0
+#define reg_tuner_data_391_384_len 8
+#define reg_tuner_data_391_384_lsb 384
+#define xd_p_reg_tuner_data_399_392 (*(volatile byte xdata *) 0xF031)
+#define    p_reg_tuner_data_399_392 0xF031
+#define reg_tuner_data_399_392_pos 0
+#define reg_tuner_data_399_392_len 8
+#define reg_tuner_data_399_392_lsb 392
+#define xd_p_reg_tuner_data_407_400 (*(volatile byte xdata *) 0xF032)
+#define    p_reg_tuner_data_407_400 0xF032
+#define reg_tuner_data_407_400_pos 0
+#define reg_tuner_data_407_400_len 8
+#define reg_tuner_data_407_400_lsb 400
+#define xd_p_reg_tuner_data_415_408 (*(volatile byte xdata *) 0xF033)
+#define    p_reg_tuner_data_415_408 0xF033
+#define reg_tuner_data_415_408_pos 0
+#define reg_tuner_data_415_408_len 8
+#define reg_tuner_data_415_408_lsb 408
+#define xd_p_reg_tuner_data_423_416 (*(volatile byte xdata *) 0xF034)
+#define    p_reg_tuner_data_423_416 0xF034
+#define reg_tuner_data_423_416_pos 0
+#define reg_tuner_data_423_416_len 8
+#define reg_tuner_data_423_416_lsb 416
+#define xd_p_reg_tuner_data_431_424 (*(volatile byte xdata *) 0xF035)
+#define    p_reg_tuner_data_431_424 0xF035
+#define reg_tuner_data_431_424_pos 0
+#define reg_tuner_data_431_424_len 8
+#define reg_tuner_data_431_424_lsb 424
+#define xd_p_reg_tuner_data_439_432 (*(volatile byte xdata *) 0xF036)
+#define    p_reg_tuner_data_439_432 0xF036
+#define reg_tuner_data_439_432_pos 0
+#define reg_tuner_data_439_432_len 8
+#define reg_tuner_data_439_432_lsb 432
+#define xd_p_reg_tuner_data_447_440 (*(volatile byte xdata *) 0xF037)
+#define    p_reg_tuner_data_447_440 0xF037
+#define reg_tuner_data_447_440_pos 0
+#define reg_tuner_data_447_440_len 8
+#define reg_tuner_data_447_440_lsb 440
+#define xd_p_reg_tuner_data_455_448 (*(volatile byte xdata *) 0xF038)
+#define    p_reg_tuner_data_455_448 0xF038
+#define reg_tuner_data_455_448_pos 0
+#define reg_tuner_data_455_448_len 8
+#define reg_tuner_data_455_448_lsb 448
+#define xd_p_reg_tuner_data_463_456 (*(volatile byte xdata *) 0xF039)
+#define    p_reg_tuner_data_463_456 0xF039
+#define reg_tuner_data_463_456_pos 0
+#define reg_tuner_data_463_456_len 8
+#define reg_tuner_data_463_456_lsb 456
+#define xd_p_reg_tuner_data_471_464 (*(volatile byte xdata *) 0xF03A)
+#define    p_reg_tuner_data_471_464 0xF03A
+#define reg_tuner_data_471_464_pos 0
+#define reg_tuner_data_471_464_len 8
+#define reg_tuner_data_471_464_lsb 464
+#define xd_p_reg_tuner_data_479_472 (*(volatile byte xdata *) 0xF03B)
+#define    p_reg_tuner_data_479_472 0xF03B
+#define reg_tuner_data_479_472_pos 0
+#define reg_tuner_data_479_472_len 8
+#define reg_tuner_data_479_472_lsb 472
+#define xd_p_reg_tuner_data_487_480 (*(volatile byte xdata *) 0xF03C)
+#define    p_reg_tuner_data_487_480 0xF03C
+#define reg_tuner_data_487_480_pos 0
+#define reg_tuner_data_487_480_len 8
+#define reg_tuner_data_487_480_lsb 480
+#define xd_p_reg_tuner_data_495_488 (*(volatile byte xdata *) 0xF03D)
+#define    p_reg_tuner_data_495_488 0xF03D
+#define reg_tuner_data_495_488_pos 0
+#define reg_tuner_data_495_488_len 8
+#define reg_tuner_data_495_488_lsb 488
+#define xd_p_reg_tuner_data_503_496 (*(volatile byte xdata *) 0xF03E)
+#define    p_reg_tuner_data_503_496 0xF03E
+#define reg_tuner_data_503_496_pos 0
+#define reg_tuner_data_503_496_len 8
+#define reg_tuner_data_503_496_lsb 496
+#define xd_p_reg_tuner_data_511_504 (*(volatile byte xdata *) 0xF03F)
+#define    p_reg_tuner_data_511_504 0xF03F
+#define reg_tuner_data_511_504_pos 0
+#define reg_tuner_data_511_504_len 8
+#define reg_tuner_data_511_504_lsb 504
+#define xd_p_reg_tuner_data_519_512 (*(volatile byte xdata *) 0xF040)
+#define    p_reg_tuner_data_519_512 0xF040
+#define reg_tuner_data_519_512_pos 0
+#define reg_tuner_data_519_512_len 8
+#define reg_tuner_data_519_512_lsb 512
+#define xd_p_reg_tuner_data_527_520 (*(volatile byte xdata *) 0xF041)
+#define    p_reg_tuner_data_527_520 0xF041
+#define reg_tuner_data_527_520_pos 0
+#define reg_tuner_data_527_520_len 8
+#define reg_tuner_data_527_520_lsb 520
+#define xd_p_reg_tuner_data_535_528 (*(volatile byte xdata *) 0xF042)
+#define    p_reg_tuner_data_535_528 0xF042
+#define reg_tuner_data_535_528_pos 0
+#define reg_tuner_data_535_528_len 8
+#define reg_tuner_data_535_528_lsb 528
+#define xd_p_reg_tuner_data_543_536 (*(volatile byte xdata *) 0xF043)
+#define    p_reg_tuner_data_543_536 0xF043
+#define reg_tuner_data_543_536_pos 0
+#define reg_tuner_data_543_536_len 8
+#define reg_tuner_data_543_536_lsb 536
+#define xd_p_reg_tuner_data_551_544 (*(volatile byte xdata *) 0xF044)
+#define    p_reg_tuner_data_551_544 0xF044
+#define reg_tuner_data_551_544_pos 0
+#define reg_tuner_data_551_544_len 8
+#define reg_tuner_data_551_544_lsb 544
+#define xd_p_reg_tuner_data_559_552 (*(volatile byte xdata *) 0xF045)
+#define    p_reg_tuner_data_559_552 0xF045
+#define reg_tuner_data_559_552_pos 0
+#define reg_tuner_data_559_552_len 8
+#define reg_tuner_data_559_552_lsb 552
+#define xd_p_reg_tuner_data_567_560 (*(volatile byte xdata *) 0xF046)
+#define    p_reg_tuner_data_567_560 0xF046
+#define reg_tuner_data_567_560_pos 0
+#define reg_tuner_data_567_560_len 8
+#define reg_tuner_data_567_560_lsb 560
+#define xd_p_reg_tuner_data_575_568 (*(volatile byte xdata *) 0xF047)
+#define    p_reg_tuner_data_575_568 0xF047
+#define reg_tuner_data_575_568_pos 0
+#define reg_tuner_data_575_568_len 8
+#define reg_tuner_data_575_568_lsb 568
+#define xd_p_reg_tuner_data_583_576 (*(volatile byte xdata *) 0xF048)
+#define    p_reg_tuner_data_583_576 0xF048
+#define reg_tuner_data_583_576_pos 0
+#define reg_tuner_data_583_576_len 8
+#define reg_tuner_data_583_576_lsb 576
+#define xd_p_reg_tuner_data_591_584 (*(volatile byte xdata *) 0xF049)
+#define    p_reg_tuner_data_591_584 0xF049
+#define reg_tuner_data_591_584_pos 0
+#define reg_tuner_data_591_584_len 8
+#define reg_tuner_data_591_584_lsb 584
+#define xd_p_reg_tuner_data_599_592 (*(volatile byte xdata *) 0xF04A)
+#define    p_reg_tuner_data_599_592 0xF04A
+#define reg_tuner_data_599_592_pos 0
+#define reg_tuner_data_599_592_len 8
+#define reg_tuner_data_599_592_lsb 592
+#define xd_p_reg_tuner_data_607_600 (*(volatile byte xdata *) 0xF04B)
+#define    p_reg_tuner_data_607_600 0xF04B
+#define reg_tuner_data_607_600_pos 0
+#define reg_tuner_data_607_600_len 8
+#define reg_tuner_data_607_600_lsb 600
+#define xd_p_reg_tuner_data_615_608 (*(volatile byte xdata *) 0xF04C)
+#define    p_reg_tuner_data_615_608 0xF04C
+#define reg_tuner_data_615_608_pos 0
+#define reg_tuner_data_615_608_len 8
+#define reg_tuner_data_615_608_lsb 608
+#define xd_p_reg_tuner_data_623_616 (*(volatile byte xdata *) 0xF04D)
+#define    p_reg_tuner_data_623_616 0xF04D
+#define reg_tuner_data_623_616_pos 0
+#define reg_tuner_data_623_616_len 8
+#define reg_tuner_data_623_616_lsb 616
+#define xd_p_reg_tuner_data_631_624 (*(volatile byte xdata *) 0xF04E)
+#define    p_reg_tuner_data_631_624 0xF04E
+#define reg_tuner_data_631_624_pos 0
+#define reg_tuner_data_631_624_len 8
+#define reg_tuner_data_631_624_lsb 624
+#define xd_p_reg_tuner_data_639_632 (*(volatile byte xdata *) 0xF04F)
+#define    p_reg_tuner_data_639_632 0xF04F
+#define reg_tuner_data_639_632_pos 0
+#define reg_tuner_data_639_632_len 8
+#define reg_tuner_data_639_632_lsb 632
+#define xd_p_reg_tuner_data_647_640 (*(volatile byte xdata *) 0xF050)
+#define    p_reg_tuner_data_647_640 0xF050
+#define reg_tuner_data_647_640_pos 0
+#define reg_tuner_data_647_640_len 8
+#define reg_tuner_data_647_640_lsb 640
+#define xd_p_reg_tuner_data_655_648 (*(volatile byte xdata *) 0xF051)
+#define    p_reg_tuner_data_655_648 0xF051
+#define reg_tuner_data_655_648_pos 0
+#define reg_tuner_data_655_648_len 8
+#define reg_tuner_data_655_648_lsb 648
+#define xd_p_reg_tuner_data_663_656 (*(volatile byte xdata *) 0xF052)
+#define    p_reg_tuner_data_663_656 0xF052
+#define reg_tuner_data_663_656_pos 0
+#define reg_tuner_data_663_656_len 8
+#define reg_tuner_data_663_656_lsb 656
+#define xd_p_reg_tuner_data_671_664 (*(volatile byte xdata *) 0xF053)
+#define    p_reg_tuner_data_671_664 0xF053
+#define reg_tuner_data_671_664_pos 0
+#define reg_tuner_data_671_664_len 8
+#define reg_tuner_data_671_664_lsb 664
+#define xd_p_reg_tuner_data_679_672 (*(volatile byte xdata *) 0xF054)
+#define    p_reg_tuner_data_679_672 0xF054
+#define reg_tuner_data_679_672_pos 0
+#define reg_tuner_data_679_672_len 8
+#define reg_tuner_data_679_672_lsb 672
+#define xd_p_reg_tuner_data_687_680 (*(volatile byte xdata *) 0xF055)
+#define    p_reg_tuner_data_687_680 0xF055
+#define reg_tuner_data_687_680_pos 0
+#define reg_tuner_data_687_680_len 8
+#define reg_tuner_data_687_680_lsb 680
+#define xd_p_reg_tuner_data_695_688 (*(volatile byte xdata *) 0xF056)
+#define    p_reg_tuner_data_695_688 0xF056
+#define reg_tuner_data_695_688_pos 0
+#define reg_tuner_data_695_688_len 8
+#define reg_tuner_data_695_688_lsb 688
+#define xd_p_reg_tuner_data_703_696 (*(volatile byte xdata *) 0xF057)
+#define    p_reg_tuner_data_703_696 0xF057
+#define reg_tuner_data_703_696_pos 0
+#define reg_tuner_data_703_696_len 8
+#define reg_tuner_data_703_696_lsb 696
+#define xd_p_reg_tuner_data_711_704 (*(volatile byte xdata *) 0xF058)
+#define    p_reg_tuner_data_711_704 0xF058
+#define reg_tuner_data_711_704_pos 0
+#define reg_tuner_data_711_704_len 8
+#define reg_tuner_data_711_704_lsb 704
+#define xd_p_reg_tuner_data_719_712 (*(volatile byte xdata *) 0xF059)
+#define    p_reg_tuner_data_719_712 0xF059
+#define reg_tuner_data_719_712_pos 0
+#define reg_tuner_data_719_712_len 8
+#define reg_tuner_data_719_712_lsb 712
+#define xd_p_reg_tuner_data_727_720 (*(volatile byte xdata *) 0xF05A)
+#define    p_reg_tuner_data_727_720 0xF05A
+#define reg_tuner_data_727_720_pos 0
+#define reg_tuner_data_727_720_len 8
+#define reg_tuner_data_727_720_lsb 720
+#define xd_p_reg_tuner_data_735_728 (*(volatile byte xdata *) 0xF05B)
+#define    p_reg_tuner_data_735_728 0xF05B
+#define reg_tuner_data_735_728_pos 0
+#define reg_tuner_data_735_728_len 8
+#define reg_tuner_data_735_728_lsb 728
+#define xd_p_reg_tuner_data_743_736 (*(volatile byte xdata *) 0xF05C)
+#define    p_reg_tuner_data_743_736 0xF05C
+#define reg_tuner_data_743_736_pos 0
+#define reg_tuner_data_743_736_len 8
+#define reg_tuner_data_743_736_lsb 736
+#define xd_p_reg_tuner_data_751_744 (*(volatile byte xdata *) 0xF05D)
+#define    p_reg_tuner_data_751_744 0xF05D
+#define reg_tuner_data_751_744_pos 0
+#define reg_tuner_data_751_744_len 8
+#define reg_tuner_data_751_744_lsb 744
+#define xd_p_reg_tuner_data_759_752 (*(volatile byte xdata *) 0xF05E)
+#define    p_reg_tuner_data_759_752 0xF05E
+#define reg_tuner_data_759_752_pos 0
+#define reg_tuner_data_759_752_len 8
+#define reg_tuner_data_759_752_lsb 752
+#define xd_p_reg_tuner_data_767_760 (*(volatile byte xdata *) 0xF05F)
+#define    p_reg_tuner_data_767_760 0xF05F
+#define reg_tuner_data_767_760_pos 0
+#define reg_tuner_data_767_760_len 8
+#define reg_tuner_data_767_760_lsb 760
+#define xd_p_reg_tuner_data_775_768 (*(volatile byte xdata *) 0xF060)
+#define    p_reg_tuner_data_775_768 0xF060
+#define reg_tuner_data_775_768_pos 0
+#define reg_tuner_data_775_768_len 8
+#define reg_tuner_data_775_768_lsb 768
+#define xd_p_reg_tuner_data_783_776 (*(volatile byte xdata *) 0xF061)
+#define    p_reg_tuner_data_783_776 0xF061
+#define reg_tuner_data_783_776_pos 0
+#define reg_tuner_data_783_776_len 8
+#define reg_tuner_data_783_776_lsb 776
+#define xd_p_reg_tuner_data_791_784 (*(volatile byte xdata *) 0xF062)
+#define    p_reg_tuner_data_791_784 0xF062
+#define reg_tuner_data_791_784_pos 0
+#define reg_tuner_data_791_784_len 8
+#define reg_tuner_data_791_784_lsb 784
+#define xd_p_reg_tuner_data_799_792 (*(volatile byte xdata *) 0xF063)
+#define    p_reg_tuner_data_799_792 0xF063
+#define reg_tuner_data_799_792_pos 0
+#define reg_tuner_data_799_792_len 8
+#define reg_tuner_data_799_792_lsb 792
+#define xd_p_reg_tuner_data_807_800 (*(volatile byte xdata *) 0xF064)
+#define    p_reg_tuner_data_807_800 0xF064
+#define reg_tuner_data_807_800_pos 0
+#define reg_tuner_data_807_800_len 8
+#define reg_tuner_data_807_800_lsb 800
+#define xd_p_reg_tuner_data_815_808 (*(volatile byte xdata *) 0xF065)
+#define    p_reg_tuner_data_815_808 0xF065
+#define reg_tuner_data_815_808_pos 0
+#define reg_tuner_data_815_808_len 8
+#define reg_tuner_data_815_808_lsb 808
+#define xd_p_reg_tuner_data_823_816 (*(volatile byte xdata *) 0xF066)
+#define    p_reg_tuner_data_823_816 0xF066
+#define reg_tuner_data_823_816_pos 0
+#define reg_tuner_data_823_816_len 8
+#define reg_tuner_data_823_816_lsb 816
+#define xd_p_reg_tuner_data_831_824 (*(volatile byte xdata *) 0xF067)
+#define    p_reg_tuner_data_831_824 0xF067
+#define reg_tuner_data_831_824_pos 0
+#define reg_tuner_data_831_824_len 8
+#define reg_tuner_data_831_824_lsb 824
+#define xd_p_reg_tuner_data_839_832 (*(volatile byte xdata *) 0xF068)
+#define    p_reg_tuner_data_839_832 0xF068
+#define reg_tuner_data_839_832_pos 0
+#define reg_tuner_data_839_832_len 8
+#define reg_tuner_data_839_832_lsb 832
+#define xd_p_reg_tuner_data_847_840 (*(volatile byte xdata *) 0xF069)
+#define    p_reg_tuner_data_847_840 0xF069
+#define reg_tuner_data_847_840_pos 0
+#define reg_tuner_data_847_840_len 8
+#define reg_tuner_data_847_840_lsb 840
+#define xd_p_reg_tuner_data_855_848 (*(volatile byte xdata *) 0xF06A)
+#define    p_reg_tuner_data_855_848 0xF06A
+#define reg_tuner_data_855_848_pos 0
+#define reg_tuner_data_855_848_len 8
+#define reg_tuner_data_855_848_lsb 848
+#define xd_p_reg_tuner_data_863_856 (*(volatile byte xdata *) 0xF06B)
+#define    p_reg_tuner_data_863_856 0xF06B
+#define reg_tuner_data_863_856_pos 0
+#define reg_tuner_data_863_856_len 8
+#define reg_tuner_data_863_856_lsb 856
+#define xd_p_reg_tuner_data_871_864 (*(volatile byte xdata *) 0xF06C)
+#define    p_reg_tuner_data_871_864 0xF06C
+#define reg_tuner_data_871_864_pos 0
+#define reg_tuner_data_871_864_len 8
+#define reg_tuner_data_871_864_lsb 864
+#define xd_p_reg_tuner_data_879_872 (*(volatile byte xdata *) 0xF06D)
+#define    p_reg_tuner_data_879_872 0xF06D
+#define reg_tuner_data_879_872_pos 0
+#define reg_tuner_data_879_872_len 8
+#define reg_tuner_data_879_872_lsb 872
+#define xd_p_reg_tuner_data_887_880 (*(volatile byte xdata *) 0xF06E)
+#define    p_reg_tuner_data_887_880 0xF06E
+#define reg_tuner_data_887_880_pos 0
+#define reg_tuner_data_887_880_len 8
+#define reg_tuner_data_887_880_lsb 880
+#define xd_p_reg_tuner_data_895_888 (*(volatile byte xdata *) 0xF06F)
+#define    p_reg_tuner_data_895_888 0xF06F
+#define reg_tuner_data_895_888_pos 0
+#define reg_tuner_data_895_888_len 8
+#define reg_tuner_data_895_888_lsb 888
+#define xd_p_reg_tuner_data_903_896 (*(volatile byte xdata *) 0xF070)
+#define    p_reg_tuner_data_903_896 0xF070
+#define reg_tuner_data_903_896_pos 0
+#define reg_tuner_data_903_896_len 8
+#define reg_tuner_data_903_896_lsb 896
+#define xd_p_reg_tuner_data_911_904 (*(volatile byte xdata *) 0xF071)
+#define    p_reg_tuner_data_911_904 0xF071
+#define reg_tuner_data_911_904_pos 0
+#define reg_tuner_data_911_904_len 8
+#define reg_tuner_data_911_904_lsb 904
+#define xd_p_reg_tuner_data_919_912 (*(volatile byte xdata *) 0xF072)
+#define    p_reg_tuner_data_919_912 0xF072
+#define reg_tuner_data_919_912_pos 0
+#define reg_tuner_data_919_912_len 8
+#define reg_tuner_data_919_912_lsb 912
+#define xd_p_reg_tuner_data_927_920 (*(volatile byte xdata *) 0xF073)
+#define    p_reg_tuner_data_927_920 0xF073
+#define reg_tuner_data_927_920_pos 0
+#define reg_tuner_data_927_920_len 8
+#define reg_tuner_data_927_920_lsb 920
+#define xd_p_reg_tuner_data_935_928 (*(volatile byte xdata *) 0xF074)
+#define    p_reg_tuner_data_935_928 0xF074
+#define reg_tuner_data_935_928_pos 0
+#define reg_tuner_data_935_928_len 8
+#define reg_tuner_data_935_928_lsb 928
+#define xd_p_reg_tuner_data_943_936 (*(volatile byte xdata *) 0xF075)
+#define    p_reg_tuner_data_943_936 0xF075
+#define reg_tuner_data_943_936_pos 0
+#define reg_tuner_data_943_936_len 8
+#define reg_tuner_data_943_936_lsb 936
+#define xd_p_reg_tuner_data_951_944 (*(volatile byte xdata *) 0xF076)
+#define    p_reg_tuner_data_951_944 0xF076
+#define reg_tuner_data_951_944_pos 0
+#define reg_tuner_data_951_944_len 8
+#define reg_tuner_data_951_944_lsb 944
+#define xd_p_reg_tuner_data_959_952 (*(volatile byte xdata *) 0xF077)
+#define    p_reg_tuner_data_959_952 0xF077
+#define reg_tuner_data_959_952_pos 0
+#define reg_tuner_data_959_952_len 8
+#define reg_tuner_data_959_952_lsb 952
+#define xd_p_reg_tuner_data_967_960 (*(volatile byte xdata *) 0xF078)
+#define    p_reg_tuner_data_967_960 0xF078
+#define reg_tuner_data_967_960_pos 0
+#define reg_tuner_data_967_960_len 8
+#define reg_tuner_data_967_960_lsb 960
+#define xd_p_reg_tuner_data_975_968 (*(volatile byte xdata *) 0xF079)
+#define    p_reg_tuner_data_975_968 0xF079
+#define reg_tuner_data_975_968_pos 0
+#define reg_tuner_data_975_968_len 8
+#define reg_tuner_data_975_968_lsb 968
+#define xd_p_reg_tuner_data_983_976 (*(volatile byte xdata *) 0xF07A)
+#define    p_reg_tuner_data_983_976 0xF07A
+#define reg_tuner_data_983_976_pos 0
+#define reg_tuner_data_983_976_len 8
+#define reg_tuner_data_983_976_lsb 976
+#define xd_p_reg_tuner_data_991_984 (*(volatile byte xdata *) 0xF07B)
+#define    p_reg_tuner_data_991_984 0xF07B
+#define reg_tuner_data_991_984_pos 0
+#define reg_tuner_data_991_984_len 8
+#define reg_tuner_data_991_984_lsb 984
+#define xd_p_reg_tuner_data_999_992 (*(volatile byte xdata *) 0xF07C)
+#define    p_reg_tuner_data_999_992 0xF07C
+#define reg_tuner_data_999_992_pos 0
+#define reg_tuner_data_999_992_len 8
+#define reg_tuner_data_999_992_lsb 992
+#define xd_p_reg_tuner_data_1007_1000   (*(volatile byte xdata *) 0xF07D)
+#define    p_reg_tuner_data_1007_1000   0xF07D
+#define reg_tuner_data_1007_1000_pos 0
+#define reg_tuner_data_1007_1000_len 8
+#define reg_tuner_data_1007_1000_lsb 1000
+#define xd_p_reg_tuner_data_1015_1008   (*(volatile byte xdata *) 0xF07E)
+#define    p_reg_tuner_data_1015_1008   0xF07E
+#define reg_tuner_data_1015_1008_pos 0
+#define reg_tuner_data_1015_1008_len 8
+#define reg_tuner_data_1015_1008_lsb 1008
+#define xd_p_reg_tuner_data_1023_1016   (*(volatile byte xdata *) 0xF07F)
+#define    p_reg_tuner_data_1023_1016   0xF07F
+#define reg_tuner_data_1023_1016_pos 0
+#define reg_tuner_data_1023_1016_len 8
+#define reg_tuner_data_1023_1016_lsb 1016
+#define xd_p_reg_tuner_data_1031_1024   (*(volatile byte xdata *) 0xF080)
+#define    p_reg_tuner_data_1031_1024   0xF080
+#define reg_tuner_data_1031_1024_pos 0
+#define reg_tuner_data_1031_1024_len 8
+#define reg_tuner_data_1031_1024_lsb 1024
+#define xd_p_reg_tuner_data_1039_1032   (*(volatile byte xdata *) 0xF081)
+#define    p_reg_tuner_data_1039_1032   0xF081
+#define reg_tuner_data_1039_1032_pos 0
+#define reg_tuner_data_1039_1032_len 8
+#define reg_tuner_data_1039_1032_lsb 1032
+#define xd_p_reg_tuner_data_1047_1040   (*(volatile byte xdata *) 0xF082)
+#define    p_reg_tuner_data_1047_1040   0xF082
+#define reg_tuner_data_1047_1040_pos 0
+#define reg_tuner_data_1047_1040_len 8
+#define reg_tuner_data_1047_1040_lsb 1040
+#define xd_p_reg_tuner_data_1055_1048   (*(volatile byte xdata *) 0xF083)
+#define    p_reg_tuner_data_1055_1048   0xF083
+#define reg_tuner_data_1055_1048_pos 0
+#define reg_tuner_data_1055_1048_len 8
+#define reg_tuner_data_1055_1048_lsb 1048
+#define xd_p_reg_tuner_data_1063_1056   (*(volatile byte xdata *) 0xF084)
+#define    p_reg_tuner_data_1063_1056   0xF084
+#define reg_tuner_data_1063_1056_pos 0
+#define reg_tuner_data_1063_1056_len 8
+#define reg_tuner_data_1063_1056_lsb 1056
+#define xd_p_reg_tuner_data_1071_1064   (*(volatile byte xdata *) 0xF085)
+#define    p_reg_tuner_data_1071_1064   0xF085
+#define reg_tuner_data_1071_1064_pos 0
+#define reg_tuner_data_1071_1064_len 8
+#define reg_tuner_data_1071_1064_lsb 1064
+#define xd_p_reg_tuner_data_1079_1072   (*(volatile byte xdata *) 0xF086)
+#define    p_reg_tuner_data_1079_1072   0xF086
+#define reg_tuner_data_1079_1072_pos 0
+#define reg_tuner_data_1079_1072_len 8
+#define reg_tuner_data_1079_1072_lsb 1072
+#define xd_p_reg_tuner_data_1087_1080   (*(volatile byte xdata *) 0xF087)
+#define    p_reg_tuner_data_1087_1080   0xF087
+#define reg_tuner_data_1087_1080_pos 0
+#define reg_tuner_data_1087_1080_len 8
+#define reg_tuner_data_1087_1080_lsb 1080
+#define xd_p_reg_tuner_data_1095_1088   (*(volatile byte xdata *) 0xF088)
+#define    p_reg_tuner_data_1095_1088   0xF088
+#define reg_tuner_data_1095_1088_pos 0
+#define reg_tuner_data_1095_1088_len 8
+#define reg_tuner_data_1095_1088_lsb 1088
+#define xd_p_reg_tuner_data_1103_1096   (*(volatile byte xdata *) 0xF089)
+#define    p_reg_tuner_data_1103_1096   0xF089
+#define reg_tuner_data_1103_1096_pos 0
+#define reg_tuner_data_1103_1096_len 8
+#define reg_tuner_data_1103_1096_lsb 1096
+#define xd_p_reg_tuner_data_1111_1104   (*(volatile byte xdata *) 0xF08A)
+#define    p_reg_tuner_data_1111_1104   0xF08A
+#define reg_tuner_data_1111_1104_pos 0
+#define reg_tuner_data_1111_1104_len 8
+#define reg_tuner_data_1111_1104_lsb 1104
+#define xd_p_reg_tuner_data_1119_1112   (*(volatile byte xdata *) 0xF08B)
+#define    p_reg_tuner_data_1119_1112   0xF08B
+#define reg_tuner_data_1119_1112_pos 0
+#define reg_tuner_data_1119_1112_len 8
+#define reg_tuner_data_1119_1112_lsb 1112
+#define xd_p_reg_tuner_data_1127_1120   (*(volatile byte xdata *) 0xF08C)
+#define    p_reg_tuner_data_1127_1120   0xF08C
+#define reg_tuner_data_1127_1120_pos 0
+#define reg_tuner_data_1127_1120_len 8
+#define reg_tuner_data_1127_1120_lsb 1120
+#define xd_p_reg_tuner_data_1135_1128   (*(volatile byte xdata *) 0xF08D)
+#define    p_reg_tuner_data_1135_1128   0xF08D
+#define reg_tuner_data_1135_1128_pos 0
+#define reg_tuner_data_1135_1128_len 8
+#define reg_tuner_data_1135_1128_lsb 1128
+#define xd_p_reg_tuner_data_1143_1136   (*(volatile byte xdata *) 0xF08E)
+#define    p_reg_tuner_data_1143_1136   0xF08E
+#define reg_tuner_data_1143_1136_pos 0
+#define reg_tuner_data_1143_1136_len 8
+#define reg_tuner_data_1143_1136_lsb 1136
+#define xd_p_reg_tuner_data_1151_1144   (*(volatile byte xdata *) 0xF08F)
+#define    p_reg_tuner_data_1151_1144   0xF08F
+#define reg_tuner_data_1151_1144_pos 0
+#define reg_tuner_data_1151_1144_len 8
+#define reg_tuner_data_1151_1144_lsb 1144
+#define xd_p_reg_tuner_data_1159_1152   (*(volatile byte xdata *) 0xF090)
+#define    p_reg_tuner_data_1159_1152   0xF090
+#define reg_tuner_data_1159_1152_pos 0
+#define reg_tuner_data_1159_1152_len 8
+#define reg_tuner_data_1159_1152_lsb 1152
+#define xd_p_reg_tuner_data_1167_1160   (*(volatile byte xdata *) 0xF091)
+#define    p_reg_tuner_data_1167_1160   0xF091
+#define reg_tuner_data_1167_1160_pos 0
+#define reg_tuner_data_1167_1160_len 8
+#define reg_tuner_data_1167_1160_lsb 1160
+#define xd_p_reg_tuner_data_1175_1168   (*(volatile byte xdata *) 0xF092)
+#define    p_reg_tuner_data_1175_1168   0xF092
+#define reg_tuner_data_1175_1168_pos 0
+#define reg_tuner_data_1175_1168_len 8
+#define reg_tuner_data_1175_1168_lsb 1168
+#define xd_p_reg_tuner_data_1183_1176   (*(volatile byte xdata *) 0xF093)
+#define    p_reg_tuner_data_1183_1176   0xF093
+#define reg_tuner_data_1183_1176_pos 0
+#define reg_tuner_data_1183_1176_len 8
+#define reg_tuner_data_1183_1176_lsb 1176
+#define xd_p_reg_tuner_data_1191_1184   (*(volatile byte xdata *) 0xF094)
+#define    p_reg_tuner_data_1191_1184   0xF094
+#define reg_tuner_data_1191_1184_pos 0
+#define reg_tuner_data_1191_1184_len 8
+#define reg_tuner_data_1191_1184_lsb 1184
+#define xd_p_reg_tuner_data_1199_1192   (*(volatile byte xdata *) 0xF095)
+#define    p_reg_tuner_data_1199_1192   0xF095
+#define reg_tuner_data_1199_1192_pos 0
+#define reg_tuner_data_1199_1192_len 8
+#define reg_tuner_data_1199_1192_lsb 1192
+#define xd_p_reg_tuner_data_1207_1200   (*(volatile byte xdata *) 0xF096)
+#define    p_reg_tuner_data_1207_1200   0xF096
+#define reg_tuner_data_1207_1200_pos 0
+#define reg_tuner_data_1207_1200_len 8
+#define reg_tuner_data_1207_1200_lsb 1200
+#define xd_p_reg_tuner_data_1215_1208   (*(volatile byte xdata *) 0xF097)
+#define    p_reg_tuner_data_1215_1208   0xF097
+#define reg_tuner_data_1215_1208_pos 0
+#define reg_tuner_data_1215_1208_len 8
+#define reg_tuner_data_1215_1208_lsb 1208
+#define xd_p_reg_tuner_data_1223_1216   (*(volatile byte xdata *) 0xF098)
+#define    p_reg_tuner_data_1223_1216   0xF098
+#define reg_tuner_data_1223_1216_pos 0
+#define reg_tuner_data_1223_1216_len 8
+#define reg_tuner_data_1223_1216_lsb 1216
+#define xd_p_reg_tuner_data_1231_1224   (*(volatile byte xdata *) 0xF099)
+#define    p_reg_tuner_data_1231_1224   0xF099
+#define reg_tuner_data_1231_1224_pos 0
+#define reg_tuner_data_1231_1224_len 8
+#define reg_tuner_data_1231_1224_lsb 1224
+#define xd_p_reg_tuner_data_1239_1232   (*(volatile byte xdata *) 0xF09A)
+#define    p_reg_tuner_data_1239_1232   0xF09A
+#define reg_tuner_data_1239_1232_pos 0
+#define reg_tuner_data_1239_1232_len 8
+#define reg_tuner_data_1239_1232_lsb 1232
+#define xd_p_reg_tuner_data_1247_1240   (*(volatile byte xdata *) 0xF09B)
+#define    p_reg_tuner_data_1247_1240   0xF09B
+#define reg_tuner_data_1247_1240_pos 0
+#define reg_tuner_data_1247_1240_len 8
+#define reg_tuner_data_1247_1240_lsb 1240
+#define xd_p_reg_tuner_data_1255_1248   (*(volatile byte xdata *) 0xF09C)
+#define    p_reg_tuner_data_1255_1248   0xF09C
+#define reg_tuner_data_1255_1248_pos 0
+#define reg_tuner_data_1255_1248_len 8
+#define reg_tuner_data_1255_1248_lsb 1248
+#define xd_p_reg_tuner_data_1263_1256   (*(volatile byte xdata *) 0xF09D)
+#define    p_reg_tuner_data_1263_1256   0xF09D
+#define reg_tuner_data_1263_1256_pos 0
+#define reg_tuner_data_1263_1256_len 8
+#define reg_tuner_data_1263_1256_lsb 1256
+#define xd_p_reg_tuner_data_1271_1264   (*(volatile byte xdata *) 0xF09E)
+#define    p_reg_tuner_data_1271_1264   0xF09E
+#define reg_tuner_data_1271_1264_pos 0
+#define reg_tuner_data_1271_1264_len 8
+#define reg_tuner_data_1271_1264_lsb 1264
+#define xd_p_reg_tuner_data_1279_1272   (*(volatile byte xdata *) 0xF09F)
+#define    p_reg_tuner_data_1279_1272   0xF09F
+#define reg_tuner_data_1279_1272_pos 0
+#define reg_tuner_data_1279_1272_len 8
+#define reg_tuner_data_1279_1272_lsb 1272
+#define xd_p_reg_tuner_data_1287_1280   (*(volatile byte xdata *) 0xF0A0)
+#define    p_reg_tuner_data_1287_1280   0xF0A0
+#define reg_tuner_data_1287_1280_pos 0
+#define reg_tuner_data_1287_1280_len 8
+#define reg_tuner_data_1287_1280_lsb 1280
+#define xd_p_reg_tuner_data_1295_1288   (*(volatile byte xdata *) 0xF0A1)
+#define    p_reg_tuner_data_1295_1288   0xF0A1
+#define reg_tuner_data_1295_1288_pos 0
+#define reg_tuner_data_1295_1288_len 8
+#define reg_tuner_data_1295_1288_lsb 1288
+#define xd_p_reg_tuner_data_1303_1296   (*(volatile byte xdata *) 0xF0A2)
+#define    p_reg_tuner_data_1303_1296   0xF0A2
+#define reg_tuner_data_1303_1296_pos 0
+#define reg_tuner_data_1303_1296_len 8
+#define reg_tuner_data_1303_1296_lsb 1296
+#define xd_p_reg_tuner_data_1311_1304   (*(volatile byte xdata *) 0xF0A3)
+#define    p_reg_tuner_data_1311_1304   0xF0A3
+#define reg_tuner_data_1311_1304_pos 0
+#define reg_tuner_data_1311_1304_len 8
+#define reg_tuner_data_1311_1304_lsb 1304
+#define xd_p_reg_tuner_data_1319_1312   (*(volatile byte xdata *) 0xF0A4)
+#define    p_reg_tuner_data_1319_1312   0xF0A4
+#define reg_tuner_data_1319_1312_pos 0
+#define reg_tuner_data_1319_1312_len 8
+#define reg_tuner_data_1319_1312_lsb 1312
+#define xd_p_reg_tuner_data_1327_1320   (*(volatile byte xdata *) 0xF0A5)
+#define    p_reg_tuner_data_1327_1320   0xF0A5
+#define reg_tuner_data_1327_1320_pos 0
+#define reg_tuner_data_1327_1320_len 8
+#define reg_tuner_data_1327_1320_lsb 1320
+#define xd_p_reg_tuner_data_1335_1328   (*(volatile byte xdata *) 0xF0A6)
+#define    p_reg_tuner_data_1335_1328   0xF0A6
+#define reg_tuner_data_1335_1328_pos 0
+#define reg_tuner_data_1335_1328_len 8
+#define reg_tuner_data_1335_1328_lsb 1328
+#define xd_p_reg_tuner_data_1343_1336   (*(volatile byte xdata *) 0xF0A7)
+#define    p_reg_tuner_data_1343_1336   0xF0A7
+#define reg_tuner_data_1343_1336_pos 0
+#define reg_tuner_data_1343_1336_len 8
+#define reg_tuner_data_1343_1336_lsb 1336
+#define xd_p_reg_tuner_data_1351_1344   (*(volatile byte xdata *) 0xF0A8)
+#define    p_reg_tuner_data_1351_1344   0xF0A8
+#define reg_tuner_data_1351_1344_pos 0
+#define reg_tuner_data_1351_1344_len 8
+#define reg_tuner_data_1351_1344_lsb 1344
+#define xd_p_reg_tuner_data_1359_1352   (*(volatile byte xdata *) 0xF0A9)
+#define    p_reg_tuner_data_1359_1352   0xF0A9
+#define reg_tuner_data_1359_1352_pos 0
+#define reg_tuner_data_1359_1352_len 8
+#define reg_tuner_data_1359_1352_lsb 1352
+#define xd_p_reg_tuner_data_1367_1360   (*(volatile byte xdata *) 0xF0AA)
+#define    p_reg_tuner_data_1367_1360   0xF0AA
+#define reg_tuner_data_1367_1360_pos 0
+#define reg_tuner_data_1367_1360_len 8
+#define reg_tuner_data_1367_1360_lsb 1360
+#define xd_p_reg_tuner_data_1375_1368   (*(volatile byte xdata *) 0xF0AB)
+#define    p_reg_tuner_data_1375_1368   0xF0AB
+#define reg_tuner_data_1375_1368_pos 0
+#define reg_tuner_data_1375_1368_len 8
+#define reg_tuner_data_1375_1368_lsb 1368
+#define xd_p_reg_tuner_data_1383_1376   (*(volatile byte xdata *) 0xF0AC)
+#define    p_reg_tuner_data_1383_1376   0xF0AC
+#define reg_tuner_data_1383_1376_pos 0
+#define reg_tuner_data_1383_1376_len 8
+#define reg_tuner_data_1383_1376_lsb 1376
+#define xd_p_reg_tuner_data_1391_1384   (*(volatile byte xdata *) 0xF0AD)
+#define    p_reg_tuner_data_1391_1384   0xF0AD
+#define reg_tuner_data_1391_1384_pos 0
+#define reg_tuner_data_1391_1384_len 8
+#define reg_tuner_data_1391_1384_lsb 1384
+#define xd_p_reg_tuner_data_1399_1392   (*(volatile byte xdata *) 0xF0AE)
+#define    p_reg_tuner_data_1399_1392   0xF0AE
+#define reg_tuner_data_1399_1392_pos 0
+#define reg_tuner_data_1399_1392_len 8
+#define reg_tuner_data_1399_1392_lsb 1392
+#define xd_p_reg_tuner_data_1407_1400   (*(volatile byte xdata *) 0xF0AF)
+#define    p_reg_tuner_data_1407_1400   0xF0AF
+#define reg_tuner_data_1407_1400_pos 0
+#define reg_tuner_data_1407_1400_len 8
+#define reg_tuner_data_1407_1400_lsb 1400
+#define xd_p_reg_tuner_data_1415_1408   (*(volatile byte xdata *) 0xF0B0)
+#define    p_reg_tuner_data_1415_1408   0xF0B0
+#define reg_tuner_data_1415_1408_pos 0
+#define reg_tuner_data_1415_1408_len 8
+#define reg_tuner_data_1415_1408_lsb 1408
+#define xd_p_reg_tuner_data_1423_1416   (*(volatile byte xdata *) 0xF0B1)
+#define    p_reg_tuner_data_1423_1416   0xF0B1
+#define reg_tuner_data_1423_1416_pos 0
+#define reg_tuner_data_1423_1416_len 8
+#define reg_tuner_data_1423_1416_lsb 1416
+#define xd_p_reg_tuner_data_1431_1424   (*(volatile byte xdata *) 0xF0B2)
+#define    p_reg_tuner_data_1431_1424   0xF0B2
+#define reg_tuner_data_1431_1424_pos 0
+#define reg_tuner_data_1431_1424_len 8
+#define reg_tuner_data_1431_1424_lsb 1424
+#define xd_p_reg_tuner_data_1439_1432   (*(volatile byte xdata *) 0xF0B3)
+#define    p_reg_tuner_data_1439_1432   0xF0B3
+#define reg_tuner_data_1439_1432_pos 0
+#define reg_tuner_data_1439_1432_len 8
+#define reg_tuner_data_1439_1432_lsb 1432
+#define xd_p_reg_tuner_data_1447_1440   (*(volatile byte xdata *) 0xF0B4)
+#define    p_reg_tuner_data_1447_1440   0xF0B4
+#define reg_tuner_data_1447_1440_pos 0
+#define reg_tuner_data_1447_1440_len 8
+#define reg_tuner_data_1447_1440_lsb 1440
+#define xd_p_reg_tuner_data_1455_1448   (*(volatile byte xdata *) 0xF0B5)
+#define    p_reg_tuner_data_1455_1448   0xF0B5
+#define reg_tuner_data_1455_1448_pos 0
+#define reg_tuner_data_1455_1448_len 8
+#define reg_tuner_data_1455_1448_lsb 1448
+#define xd_p_reg_tuner_data_1463_1456   (*(volatile byte xdata *) 0xF0B6)
+#define    p_reg_tuner_data_1463_1456   0xF0B6
+#define reg_tuner_data_1463_1456_pos 0
+#define reg_tuner_data_1463_1456_len 8
+#define reg_tuner_data_1463_1456_lsb 1456
+#define xd_p_reg_tuner_data_1471_1464   (*(volatile byte xdata *) 0xF0B7)
+#define    p_reg_tuner_data_1471_1464   0xF0B7
+#define reg_tuner_data_1471_1464_pos 0
+#define reg_tuner_data_1471_1464_len 8
+#define reg_tuner_data_1471_1464_lsb 1464
+#define xd_p_reg_tuner_data_1479_1472   (*(volatile byte xdata *) 0xF0B8)
+#define    p_reg_tuner_data_1479_1472   0xF0B8
+#define reg_tuner_data_1479_1472_pos 0
+#define reg_tuner_data_1479_1472_len 8
+#define reg_tuner_data_1479_1472_lsb 1472
+#define xd_p_reg_tuner_data_1487_1480   (*(volatile byte xdata *) 0xF0B9)
+#define    p_reg_tuner_data_1487_1480   0xF0B9
+#define reg_tuner_data_1487_1480_pos 0
+#define reg_tuner_data_1487_1480_len 8
+#define reg_tuner_data_1487_1480_lsb 1480
+#define xd_p_reg_tuner_data_1495_1488   (*(volatile byte xdata *) 0xF0BA)
+#define    p_reg_tuner_data_1495_1488   0xF0BA
+#define reg_tuner_data_1495_1488_pos 0
+#define reg_tuner_data_1495_1488_len 8
+#define reg_tuner_data_1495_1488_lsb 1488
+#define xd_p_reg_tuner_data_1503_1496   (*(volatile byte xdata *) 0xF0BB)
+#define    p_reg_tuner_data_1503_1496   0xF0BB
+#define reg_tuner_data_1503_1496_pos 0
+#define reg_tuner_data_1503_1496_len 8
+#define reg_tuner_data_1503_1496_lsb 1496
+#define xd_p_reg_tuner_data_1511_1504   (*(volatile byte xdata *) 0xF0BC)
+#define    p_reg_tuner_data_1511_1504   0xF0BC
+#define reg_tuner_data_1511_1504_pos 0
+#define reg_tuner_data_1511_1504_len 8
+#define reg_tuner_data_1511_1504_lsb 1504
+#define xd_p_reg_tuner_data_1519_1512   (*(volatile byte xdata *) 0xF0BD)
+#define    p_reg_tuner_data_1519_1512   0xF0BD
+#define reg_tuner_data_1519_1512_pos 0
+#define reg_tuner_data_1519_1512_len 8
+#define reg_tuner_data_1519_1512_lsb 1512
+#define xd_p_reg_tuner_data_1527_1520   (*(volatile byte xdata *) 0xF0BE)
+#define    p_reg_tuner_data_1527_1520   0xF0BE
+#define reg_tuner_data_1527_1520_pos 0
+#define reg_tuner_data_1527_1520_len 8
+#define reg_tuner_data_1527_1520_lsb 1520
+#define xd_p_reg_tuner_data_1535_1528   (*(volatile byte xdata *) 0xF0BF)
+#define    p_reg_tuner_data_1535_1528   0xF0BF
+#define reg_tuner_data_1535_1528_pos 0
+#define reg_tuner_data_1535_1528_len 8
+#define reg_tuner_data_1535_1528_lsb 1528
+#define xd_p_reg_tuner_data_1543_1536   (*(volatile byte xdata *) 0xF0C0)
+#define    p_reg_tuner_data_1543_1536   0xF0C0
+#define reg_tuner_data_1543_1536_pos 0
+#define reg_tuner_data_1543_1536_len 8
+#define reg_tuner_data_1543_1536_lsb 1536
+#define xd_p_reg_tuner_data_1551_1544   (*(volatile byte xdata *) 0xF0C1)
+#define    p_reg_tuner_data_1551_1544   0xF0C1
+#define reg_tuner_data_1551_1544_pos 0
+#define reg_tuner_data_1551_1544_len 8
+#define reg_tuner_data_1551_1544_lsb 1544
+#define xd_p_reg_tuner_data_1559_1552   (*(volatile byte xdata *) 0xF0C2)
+#define    p_reg_tuner_data_1559_1552   0xF0C2
+#define reg_tuner_data_1559_1552_pos 0
+#define reg_tuner_data_1559_1552_len 8
+#define reg_tuner_data_1559_1552_lsb 1552
+#define xd_p_reg_tuner_data_1567_1560   (*(volatile byte xdata *) 0xF0C3)
+#define    p_reg_tuner_data_1567_1560   0xF0C3
+#define reg_tuner_data_1567_1560_pos 0
+#define reg_tuner_data_1567_1560_len 8
+#define reg_tuner_data_1567_1560_lsb 1560
+#define xd_p_reg_tuner_data_1575_1568   (*(volatile byte xdata *) 0xF0C4)
+#define    p_reg_tuner_data_1575_1568   0xF0C4
+#define reg_tuner_data_1575_1568_pos 0
+#define reg_tuner_data_1575_1568_len 8
+#define reg_tuner_data_1575_1568_lsb 1568
+#define xd_p_reg_tuner_data_1583_1576   (*(volatile byte xdata *) 0xF0C5)
+#define    p_reg_tuner_data_1583_1576   0xF0C5
+#define reg_tuner_data_1583_1576_pos 0
+#define reg_tuner_data_1583_1576_len 8
+#define reg_tuner_data_1583_1576_lsb 1576
+#define xd_p_reg_tuner_data_1591_1584   (*(volatile byte xdata *) 0xF0C6)
+#define    p_reg_tuner_data_1591_1584   0xF0C6
+#define reg_tuner_data_1591_1584_pos 0
+#define reg_tuner_data_1591_1584_len 8
+#define reg_tuner_data_1591_1584_lsb 1584
+#define xd_p_reg_tuner_data_1599_1592   (*(volatile byte xdata *) 0xF0C7)
+#define    p_reg_tuner_data_1599_1592   0xF0C7
+#define reg_tuner_data_1599_1592_pos 0
+#define reg_tuner_data_1599_1592_len 8
+#define reg_tuner_data_1599_1592_lsb 1592
+#define xd_p_reg_tuner_data_1607_1600   (*(volatile byte xdata *) 0xF0C8)
+#define    p_reg_tuner_data_1607_1600   0xF0C8
+#define reg_tuner_data_1607_1600_pos 0
+#define reg_tuner_data_1607_1600_len 8
+#define reg_tuner_data_1607_1600_lsb 1600
+#define xd_p_reg_tuner_data_1615_1608   (*(volatile byte xdata *) 0xF0C9)
+#define    p_reg_tuner_data_1615_1608   0xF0C9
+#define reg_tuner_data_1615_1608_pos 0
+#define reg_tuner_data_1615_1608_len 8
+#define reg_tuner_data_1615_1608_lsb 1608
+#define xd_p_reg_tuner_data_1623_1616   (*(volatile byte xdata *) 0xF0CA)
+#define    p_reg_tuner_data_1623_1616   0xF0CA
+#define reg_tuner_data_1623_1616_pos 0
+#define reg_tuner_data_1623_1616_len 8
+#define reg_tuner_data_1623_1616_lsb 1616
+#define xd_p_reg_tuner_data_1631_1624   (*(volatile byte xdata *) 0xF0CB)
+#define    p_reg_tuner_data_1631_1624   0xF0CB
+#define reg_tuner_data_1631_1624_pos 0
+#define reg_tuner_data_1631_1624_len 8
+#define reg_tuner_data_1631_1624_lsb 1624
+#define xd_p_reg_tuner_data_1639_1632   (*(volatile byte xdata *) 0xF0CC)
+#define    p_reg_tuner_data_1639_1632   0xF0CC
+#define reg_tuner_data_1639_1632_pos 0
+#define reg_tuner_data_1639_1632_len 8
+#define reg_tuner_data_1639_1632_lsb 1632
+#define xd_p_reg_tuner_data_1647_1640   (*(volatile byte xdata *) 0xF0CD)
+#define    p_reg_tuner_data_1647_1640   0xF0CD
+#define reg_tuner_data_1647_1640_pos 0
+#define reg_tuner_data_1647_1640_len 8
+#define reg_tuner_data_1647_1640_lsb 1640
+#define xd_p_reg_tuner_data_1655_1648   (*(volatile byte xdata *) 0xF0CE)
+#define    p_reg_tuner_data_1655_1648   0xF0CE
+#define reg_tuner_data_1655_1648_pos 0
+#define reg_tuner_data_1655_1648_len 8
+#define reg_tuner_data_1655_1648_lsb 1648
+#define xd_p_reg_tuner_data_1663_1656   (*(volatile byte xdata *) 0xF0CF)
+#define    p_reg_tuner_data_1663_1656   0xF0CF
+#define reg_tuner_data_1663_1656_pos 0
+#define reg_tuner_data_1663_1656_len 8
+#define reg_tuner_data_1663_1656_lsb 1656
+#define xd_p_reg_tuner_data_1671_1664   (*(volatile byte xdata *) 0xF0D0)
+#define    p_reg_tuner_data_1671_1664   0xF0D0
+#define reg_tuner_data_1671_1664_pos 0
+#define reg_tuner_data_1671_1664_len 8
+#define reg_tuner_data_1671_1664_lsb 1664
+#define xd_p_reg_tuner_data_1679_1672   (*(volatile byte xdata *) 0xF0D1)
+#define    p_reg_tuner_data_1679_1672   0xF0D1
+#define reg_tuner_data_1679_1672_pos 0
+#define reg_tuner_data_1679_1672_len 8
+#define reg_tuner_data_1679_1672_lsb 1672
+#define xd_p_reg_tuner_data_1687_1680   (*(volatile byte xdata *) 0xF0D2)
+#define    p_reg_tuner_data_1687_1680   0xF0D2
+#define reg_tuner_data_1687_1680_pos 0
+#define reg_tuner_data_1687_1680_len 8
+#define reg_tuner_data_1687_1680_lsb 1680
+#define xd_p_reg_tuner_data_1695_1688   (*(volatile byte xdata *) 0xF0D3)
+#define    p_reg_tuner_data_1695_1688   0xF0D3
+#define reg_tuner_data_1695_1688_pos 0
+#define reg_tuner_data_1695_1688_len 8
+#define reg_tuner_data_1695_1688_lsb 1688
+#define xd_p_reg_tuner_data_1703_1696   (*(volatile byte xdata *) 0xF0D4)
+#define    p_reg_tuner_data_1703_1696   0xF0D4
+#define reg_tuner_data_1703_1696_pos 0
+#define reg_tuner_data_1703_1696_len 8
+#define reg_tuner_data_1703_1696_lsb 1696
+#define xd_p_reg_tuner_data_1711_1704   (*(volatile byte xdata *) 0xF0D5)
+#define    p_reg_tuner_data_1711_1704   0xF0D5
+#define reg_tuner_data_1711_1704_pos 0
+#define reg_tuner_data_1711_1704_len 8
+#define reg_tuner_data_1711_1704_lsb 1704
+#define xd_p_reg_tuner_data_1719_1712   (*(volatile byte xdata *) 0xF0D6)
+#define    p_reg_tuner_data_1719_1712   0xF0D6
+#define reg_tuner_data_1719_1712_pos 0
+#define reg_tuner_data_1719_1712_len 8
+#define reg_tuner_data_1719_1712_lsb 1712
+#define xd_p_reg_tuner_data_1727_1720   (*(volatile byte xdata *) 0xF0D7)
+#define    p_reg_tuner_data_1727_1720   0xF0D7
+#define reg_tuner_data_1727_1720_pos 0
+#define reg_tuner_data_1727_1720_len 8
+#define reg_tuner_data_1727_1720_lsb 1720
+#define xd_p_reg_tuner_data_1735_1728   (*(volatile byte xdata *) 0xF0D8)
+#define    p_reg_tuner_data_1735_1728   0xF0D8
+#define reg_tuner_data_1735_1728_pos 0
+#define reg_tuner_data_1735_1728_len 8
+#define reg_tuner_data_1735_1728_lsb 1728
+#define xd_p_reg_tuner_data_1743_1736   (*(volatile byte xdata *) 0xF0D9)
+#define    p_reg_tuner_data_1743_1736   0xF0D9
+#define reg_tuner_data_1743_1736_pos 0
+#define reg_tuner_data_1743_1736_len 8
+#define reg_tuner_data_1743_1736_lsb 1736
+#define xd_p_reg_tuner_data_1751_1744   (*(volatile byte xdata *) 0xF0DA)
+#define    p_reg_tuner_data_1751_1744   0xF0DA
+#define reg_tuner_data_1751_1744_pos 0
+#define reg_tuner_data_1751_1744_len 8
+#define reg_tuner_data_1751_1744_lsb 1744
+#define xd_p_reg_tuner_data_1759_1752   (*(volatile byte xdata *) 0xF0DB)
+#define    p_reg_tuner_data_1759_1752   0xF0DB
+#define reg_tuner_data_1759_1752_pos 0
+#define reg_tuner_data_1759_1752_len 8
+#define reg_tuner_data_1759_1752_lsb 1752
+#define xd_p_reg_tuner_data_1767_1760   (*(volatile byte xdata *) 0xF0DC)
+#define    p_reg_tuner_data_1767_1760   0xF0DC
+#define reg_tuner_data_1767_1760_pos 0
+#define reg_tuner_data_1767_1760_len 8
+#define reg_tuner_data_1767_1760_lsb 1760
+#define xd_p_reg_tuner_data_1775_1768   (*(volatile byte xdata *) 0xF0DD)
+#define    p_reg_tuner_data_1775_1768   0xF0DD
+#define reg_tuner_data_1775_1768_pos 0
+#define reg_tuner_data_1775_1768_len 8
+#define reg_tuner_data_1775_1768_lsb 1768
+#define xd_p_reg_tuner_data_1783_1776   (*(volatile byte xdata *) 0xF0DE)
+#define    p_reg_tuner_data_1783_1776   0xF0DE
+#define reg_tuner_data_1783_1776_pos 0
+#define reg_tuner_data_1783_1776_len 8
+#define reg_tuner_data_1783_1776_lsb 1776
+#define xd_p_reg_tuner_data_1791_1784   (*(volatile byte xdata *) 0xF0DF)
+#define    p_reg_tuner_data_1791_1784   0xF0DF
+#define reg_tuner_data_1791_1784_pos 0
+#define reg_tuner_data_1791_1784_len 8
+#define reg_tuner_data_1791_1784_lsb 1784
+#define xd_p_reg_tuner_data_1799_1792   (*(volatile byte xdata *) 0xF0E0)
+#define    p_reg_tuner_data_1799_1792   0xF0E0
+#define reg_tuner_data_1799_1792_pos 0
+#define reg_tuner_data_1799_1792_len 8
+#define reg_tuner_data_1799_1792_lsb 1792
+#define xd_p_reg_tuner_data_1807_1800   (*(volatile byte xdata *) 0xF0E1)
+#define    p_reg_tuner_data_1807_1800   0xF0E1
+#define reg_tuner_data_1807_1800_pos 0
+#define reg_tuner_data_1807_1800_len 8
+#define reg_tuner_data_1807_1800_lsb 1800
+#define xd_p_reg_tuner_data_1815_1808   (*(volatile byte xdata *) 0xF0E2)
+#define    p_reg_tuner_data_1815_1808   0xF0E2
+#define reg_tuner_data_1815_1808_pos 0
+#define reg_tuner_data_1815_1808_len 8
+#define reg_tuner_data_1815_1808_lsb 1808
+#define xd_p_reg_tuner_data_1823_1816   (*(volatile byte xdata *) 0xF0E3)
+#define    p_reg_tuner_data_1823_1816   0xF0E3
+#define reg_tuner_data_1823_1816_pos 0
+#define reg_tuner_data_1823_1816_len 8
+#define reg_tuner_data_1823_1816_lsb 1816
+#define xd_p_reg_tuner_data_1831_1824   (*(volatile byte xdata *) 0xF0E4)
+#define    p_reg_tuner_data_1831_1824   0xF0E4
+#define reg_tuner_data_1831_1824_pos 0
+#define reg_tuner_data_1831_1824_len 8
+#define reg_tuner_data_1831_1824_lsb 1824
+#define xd_p_reg_tuner_data_1839_1832   (*(volatile byte xdata *) 0xF0E5)
+#define    p_reg_tuner_data_1839_1832   0xF0E5
+#define reg_tuner_data_1839_1832_pos 0
+#define reg_tuner_data_1839_1832_len 8
+#define reg_tuner_data_1839_1832_lsb 1832
+#define xd_p_reg_tuner_data_1847_1840   (*(volatile byte xdata *) 0xF0E6)
+#define    p_reg_tuner_data_1847_1840   0xF0E6
+#define reg_tuner_data_1847_1840_pos 0
+#define reg_tuner_data_1847_1840_len 8
+#define reg_tuner_data_1847_1840_lsb 1840
+#define xd_p_reg_tuner_data_1855_1848   (*(volatile byte xdata *) 0xF0E7)
+#define    p_reg_tuner_data_1855_1848   0xF0E7
+#define reg_tuner_data_1855_1848_pos 0
+#define reg_tuner_data_1855_1848_len 8
+#define reg_tuner_data_1855_1848_lsb 1848
+#define xd_p_reg_tuner_data_1863_1856   (*(volatile byte xdata *) 0xF0E8)
+#define    p_reg_tuner_data_1863_1856   0xF0E8
+#define reg_tuner_data_1863_1856_pos 0
+#define reg_tuner_data_1863_1856_len 8
+#define reg_tuner_data_1863_1856_lsb 1856
+#define xd_p_reg_tuner_data_1871_1864   (*(volatile byte xdata *) 0xF0E9)
+#define    p_reg_tuner_data_1871_1864   0xF0E9
+#define reg_tuner_data_1871_1864_pos 0
+#define reg_tuner_data_1871_1864_len 8
+#define reg_tuner_data_1871_1864_lsb 1864
+#define xd_p_reg_tuner_data_1879_1872   (*(volatile byte xdata *) 0xF0EA)
+#define    p_reg_tuner_data_1879_1872   0xF0EA
+#define reg_tuner_data_1879_1872_pos 0
+#define reg_tuner_data_1879_1872_len 8
+#define reg_tuner_data_1879_1872_lsb 1872
+#define xd_p_reg_tuner_data_1887_1880   (*(volatile byte xdata *) 0xF0EB)
+#define    p_reg_tuner_data_1887_1880   0xF0EB
+#define reg_tuner_data_1887_1880_pos 0
+#define reg_tuner_data_1887_1880_len 8
+#define reg_tuner_data_1887_1880_lsb 1880
+#define xd_p_reg_tuner_data_1895_1888   (*(volatile byte xdata *) 0xF0EC)
+#define    p_reg_tuner_data_1895_1888   0xF0EC
+#define reg_tuner_data_1895_1888_pos 0
+#define reg_tuner_data_1895_1888_len 8
+#define reg_tuner_data_1895_1888_lsb 1888
+#define xd_p_reg_tuner_data_1903_1896   (*(volatile byte xdata *) 0xF0ED)
+#define    p_reg_tuner_data_1903_1896   0xF0ED
+#define reg_tuner_data_1903_1896_pos 0
+#define reg_tuner_data_1903_1896_len 8
+#define reg_tuner_data_1903_1896_lsb 1896
+#define xd_p_reg_tuner_data_1911_1904   (*(volatile byte xdata *) 0xF0EE)
+#define    p_reg_tuner_data_1911_1904   0xF0EE
+#define reg_tuner_data_1911_1904_pos 0
+#define reg_tuner_data_1911_1904_len 8
+#define reg_tuner_data_1911_1904_lsb 1904
+#define xd_p_reg_tuner_data_1919_1912   (*(volatile byte xdata *) 0xF0EF)
+#define    p_reg_tuner_data_1919_1912   0xF0EF
+#define reg_tuner_data_1919_1912_pos 0
+#define reg_tuner_data_1919_1912_len 8
+#define reg_tuner_data_1919_1912_lsb 1912
+#define xd_p_reg_tuner_data_1927_1920   (*(volatile byte xdata *) 0xF0F0)
+#define    p_reg_tuner_data_1927_1920   0xF0F0
+#define reg_tuner_data_1927_1920_pos 0
+#define reg_tuner_data_1927_1920_len 8
+#define reg_tuner_data_1927_1920_lsb 1920
+#define xd_p_reg_tuner_data_1935_1928   (*(volatile byte xdata *) 0xF0F1)
+#define    p_reg_tuner_data_1935_1928   0xF0F1
+#define reg_tuner_data_1935_1928_pos 0
+#define reg_tuner_data_1935_1928_len 8
+#define reg_tuner_data_1935_1928_lsb 1928
+#define xd_p_reg_tuner_data_1943_1936   (*(volatile byte xdata *) 0xF0F2)
+#define    p_reg_tuner_data_1943_1936   0xF0F2
+#define reg_tuner_data_1943_1936_pos 0
+#define reg_tuner_data_1943_1936_len 8
+#define reg_tuner_data_1943_1936_lsb 1936
+#define xd_p_reg_tuner_data_1951_1944   (*(volatile byte xdata *) 0xF0F3)
+#define    p_reg_tuner_data_1951_1944   0xF0F3
+#define reg_tuner_data_1951_1944_pos 0
+#define reg_tuner_data_1951_1944_len 8
+#define reg_tuner_data_1951_1944_lsb 1944
+#define xd_p_reg_tuner_data_1959_1952   (*(volatile byte xdata *) 0xF0F4)
+#define    p_reg_tuner_data_1959_1952   0xF0F4
+#define reg_tuner_data_1959_1952_pos 0
+#define reg_tuner_data_1959_1952_len 8
+#define reg_tuner_data_1959_1952_lsb 1952
+#define xd_p_reg_tuner_data_1967_1960   (*(volatile byte xdata *) 0xF0F5)
+#define    p_reg_tuner_data_1967_1960   0xF0F5
+#define reg_tuner_data_1967_1960_pos 0
+#define reg_tuner_data_1967_1960_len 8
+#define reg_tuner_data_1967_1960_lsb 1960
+#define xd_p_reg_tuner_data_1975_1968   (*(volatile byte xdata *) 0xF0F6)
+#define    p_reg_tuner_data_1975_1968   0xF0F6
+#define reg_tuner_data_1975_1968_pos 0
+#define reg_tuner_data_1975_1968_len 8
+#define reg_tuner_data_1975_1968_lsb 1968
+#define xd_p_reg_tuner_data_1983_1976   (*(volatile byte xdata *) 0xF0F7)
+#define    p_reg_tuner_data_1983_1976   0xF0F7
+#define reg_tuner_data_1983_1976_pos 0
+#define reg_tuner_data_1983_1976_len 8
+#define reg_tuner_data_1983_1976_lsb 1976
+#define xd_p_reg_tuner_data_1991_1984   (*(volatile byte xdata *) 0xF0F8)
+#define    p_reg_tuner_data_1991_1984   0xF0F8
+#define reg_tuner_data_1991_1984_pos 0
+#define reg_tuner_data_1991_1984_len 8
+#define reg_tuner_data_1991_1984_lsb 1984
+#define xd_p_reg_tuner_data_1999_1992   (*(volatile byte xdata *) 0xF0F9)
+#define    p_reg_tuner_data_1999_1992   0xF0F9
+#define reg_tuner_data_1999_1992_pos 0
+#define reg_tuner_data_1999_1992_len 8
+#define reg_tuner_data_1999_1992_lsb 1992
+#define xd_p_reg_tuner_data_2007_2000   (*(volatile byte xdata *) 0xF0FA)
+#define    p_reg_tuner_data_2007_2000   0xF0FA
+#define reg_tuner_data_2007_2000_pos 0
+#define reg_tuner_data_2007_2000_len 8
+#define reg_tuner_data_2007_2000_lsb 2000
+#define xd_p_reg_tuner_data_2015_2008   (*(volatile byte xdata *) 0xF0FB)
+#define    p_reg_tuner_data_2015_2008   0xF0FB
+#define reg_tuner_data_2015_2008_pos 0
+#define reg_tuner_data_2015_2008_len 8
+#define reg_tuner_data_2015_2008_lsb 2008
+#define xd_p_reg_tuner_data_2023_2016   (*(volatile byte xdata *) 0xF0FC)
+#define    p_reg_tuner_data_2023_2016   0xF0FC
+#define reg_tuner_data_2023_2016_pos 0
+#define reg_tuner_data_2023_2016_len 8
+#define reg_tuner_data_2023_2016_lsb 2016
+#define xd_p_reg_tuner_data_2031_2024   (*(volatile byte xdata *) 0xF0FD)
+#define    p_reg_tuner_data_2031_2024   0xF0FD
+#define reg_tuner_data_2031_2024_pos 0
+#define reg_tuner_data_2031_2024_len 8
+#define reg_tuner_data_2031_2024_lsb 2024
+#define xd_p_reg_tuner_data_2039_2032   (*(volatile byte xdata *) 0xF0FE)
+#define    p_reg_tuner_data_2039_2032   0xF0FE
+#define reg_tuner_data_2039_2032_pos 0
+#define reg_tuner_data_2039_2032_len 8
+#define reg_tuner_data_2039_2032_lsb 2032
+#define xd_p_reg_tuner_data_2047_2040   (*(volatile byte xdata *) 0xF0FF)
+#define    p_reg_tuner_data_2047_2040   0xF0FF
+#define reg_tuner_data_2047_2040_pos 0
+#define reg_tuner_data_2047_2040_len 8
+#define reg_tuner_data_2047_2040_lsb 2040
+#define xd_p_reg_tuner_master_rd_wr (*(volatile byte xdata *) 0xF100)
+#define    p_reg_tuner_master_rd_wr 0xF100
+#define reg_tuner_master_rd_wr_pos 0
+#define reg_tuner_master_rd_wr_len 1
+#define reg_tuner_master_rd_wr_lsb 0
+#define xd_p_reg_tuner_master_length    (*(volatile byte xdata *) 0xF101)
+#define    p_reg_tuner_master_length    0xF101
+#define reg_tuner_master_length_pos 0
+#define reg_tuner_master_length_len 8
+#define reg_tuner_master_length_lsb 0
+#define xd_p_reg_tuner_cmd_exe  (*(volatile byte xdata *) 0xF102)
+#define    p_reg_tuner_cmd_exe  0xF102
+#define reg_tuner_cmd_exe_pos 0
+#define reg_tuner_cmd_exe_len 1
+#define reg_tuner_cmd_exe_lsb 0
+#define xd_p_reg_tuner_wdat_done    (*(volatile byte xdata *) 0xF102)
+#define    p_reg_tuner_wdat_done    0xF102
+#define reg_tuner_wdat_done_pos 1
+#define reg_tuner_wdat_done_len 1
+#define reg_tuner_wdat_done_lsb 0
+#define xd_p_reg_tuner_wdat_fail    (*(volatile byte xdata *) 0xF102)
+#define    p_reg_tuner_wdat_fail    0xF102
+#define reg_tuner_wdat_fail_pos 2
+#define reg_tuner_wdat_fail_len 1
+#define reg_tuner_wdat_fail_lsb 0
+#define xd_p_reg_tuner_ofsm_i2cm_rdat_rdy   (*(volatile byte xdata *) 0xF102)
+#define    p_reg_tuner_ofsm_i2cm_rdat_rdy   0xF102
+#define reg_tuner_ofsm_i2cm_rdat_rdy_pos 3
+#define reg_tuner_ofsm_i2cm_rdat_rdy_len 1
+#define reg_tuner_ofsm_i2cm_rdat_rdy_lsb 0
+#define xd_p_reg_tuner_current_state    (*(volatile byte xdata *) 0xF102)
+#define    p_reg_tuner_current_state    0xF102
+#define reg_tuner_current_state_pos 4
+#define reg_tuner_current_state_len 3
+#define reg_tuner_current_state_lsb 0
+#define xd_p_reg_one_cycle_counter_tuner    (*(volatile byte xdata *) 0xF103)
+#define    p_reg_one_cycle_counter_tuner    0xF103
+#define reg_one_cycle_counter_tuner_pos 0
+#define reg_one_cycle_counter_tuner_len 8
+#define reg_one_cycle_counter_tuner_lsb 0
+#define xd_p_reg_msb_lsb    (*(volatile byte xdata *) 0xF104)
+#define    p_reg_msb_lsb    0xF104
+#define reg_msb_lsb_pos 0
+#define reg_msb_lsb_len 1
+#define reg_msb_lsb_lsb 0
+#define xd_p_reg_ofdm_rst   (*(volatile byte xdata *) 0xF104)
+#define    p_reg_ofdm_rst   0xF104
+#define xd_p_reg_sel_thirdi2c   (*(volatile byte xdata *) 0xF104)
+#define    p_reg_sel_thirdi2c   0xF104
+#define reg_sel_thirdi2c_pos 2
+#define reg_sel_thirdi2c_len 1
+#define reg_sel_thirdi2c_lsb 0
+#define xd_p_reg_sel_tuner  (*(volatile byte xdata *) 0xF104)
+#define    p_reg_sel_tuner  0xF104
+#define xd_p_reg_ofdm_rst_en    (*(volatile byte xdata *) 0xF104)
+#define    p_reg_ofdm_rst_en    0xF104
+#define xd_p_reg_sdio_cccr_v    (*(volatile byte xdata *) 0xF140)
+#define    p_reg_sdio_cccr_v    0xF140
+#define reg_sdio_cccr_v_pos 0
+#define reg_sdio_cccr_v_len 4
+#define reg_sdio_cccr_v_lsb 0
+#define xd_p_reg_sdio_sdio_v    (*(volatile byte xdata *) 0xF140)
+#define    p_reg_sdio_sdio_v    0xF140
+#define reg_sdio_sdio_v_pos 4
+#define reg_sdio_sdio_v_len 4
+#define reg_sdio_sdio_v_lsb 0
+#define xd_p_reg_sdioc_sd_v (*(volatile byte xdata *) 0xF141)
+#define    p_reg_sdioc_sd_v 0xF141
+#define reg_sdioc_sd_v_pos 0
+#define reg_sdioc_sd_v_len 4
+#define reg_sdioc_sd_v_lsb 0
+#define xd_p_reg_sdioc_ior1 (*(volatile byte xdata *) 0xF143)
+#define    p_reg_sdioc_ior1 0xF143
+#define reg_sdioc_ior1_pos 1
+#define reg_sdioc_ior1_len 1
+#define reg_sdioc_ior1_lsb 0
+#define xd_p_reg_sdioc_int1 (*(volatile byte xdata *) 0xF145)
+#define    p_reg_sdioc_int1 0xF145
+#define reg_sdioc_int1_pos 1
+#define reg_sdioc_int1_len 1
+#define reg_sdioc_int1_lsb 0
+#define xd_p_reg_sdioc_scsi (*(volatile byte xdata *) 0xF147)
+#define    p_reg_sdioc_scsi 0xF147
+#define reg_sdioc_scsi_pos 6
+#define reg_sdioc_scsi_len 1
+#define reg_sdioc_scsi_lsb 0
+#define xd_p_reg_sdioc_sdc  (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_sdc  0xF148
+#define reg_sdioc_sdc_pos 0
+#define reg_sdioc_sdc_len 1
+#define reg_sdioc_sdc_lsb 0
+#define xd_p_reg_sdioc_smb  (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_smb  0xF148
+#define reg_sdioc_smb_pos 1
+#define reg_sdioc_smb_len 1
+#define reg_sdioc_smb_lsb 0
+#define xd_p_reg_sdioc_srw  (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_srw  0xF148
+#define reg_sdioc_srw_pos 2
+#define reg_sdioc_srw_len 1
+#define reg_sdioc_srw_lsb 0
+#define xd_p_reg_sdioc_sbs  (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_sbs  0xF148
+#define reg_sdioc_sbs_pos 3
+#define reg_sdioc_sbs_len 1
+#define reg_sdioc_sbs_lsb 0
+#define xd_p_reg_sdioc_s4mi (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_s4mi 0xF148
+#define reg_sdioc_s4mi_pos 4
+#define reg_sdioc_s4mi_len 1
+#define reg_sdioc_s4mi_lsb 0
+#define xd_p_reg_sdioc_lsc  (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_lsc  0xF148
+#define reg_sdioc_lsc_pos 6
+#define reg_sdioc_lsc_len 1
+#define reg_sdioc_lsc_lsb 0
+#define xd_p_reg_sdioc_4bls (*(volatile byte xdata *) 0xF148)
+#define    p_reg_sdioc_4bls 0xF148
+#define reg_sdioc_4bls_pos 7
+#define reg_sdioc_4bls_len 1
+#define reg_sdioc_4bls_lsb 0
+#define xd_p_reg_sdioc_cis_7_0  (*(volatile byte xdata *) 0xF149)
+#define    p_reg_sdioc_cis_7_0  0xF149
+#define reg_sdioc_cis_7_0_pos 0
+#define reg_sdioc_cis_7_0_len 8
+#define reg_sdioc_cis_7_0_lsb 0
+#define xd_p_reg_sdioc_cis_15_8 (*(volatile byte xdata *) 0xF14A)
+#define    p_reg_sdioc_cis_15_8 0xF14A
+#define reg_sdioc_cis_15_8_pos 0
+#define reg_sdioc_cis_15_8_len 8
+#define reg_sdioc_cis_15_8_lsb 8
+#define xd_p_reg_sdioc_cis_23_16    (*(volatile byte xdata *) 0xF14B)
+#define    p_reg_sdioc_cis_23_16    0xF14B
+#define reg_sdioc_cis_23_16_pos 0
+#define reg_sdioc_cis_23_16_len 8
+#define reg_sdioc_cis_23_16_lsb 16
+#define xd_p_reg_sdioc_fs   (*(volatile byte xdata *) 0xF14D)
+#define    p_reg_sdioc_fs   0xF14D
+#define reg_sdioc_fs_pos 0
+#define reg_sdioc_fs_len 4
+#define reg_sdioc_fs_lsb 0
+#define xd_p_reg_sdioc_df   (*(volatile byte xdata *) 0xF14D)
+#define    p_reg_sdioc_df   0xF14D
+#define reg_sdioc_df_pos 7
+#define reg_sdioc_df_len 1
+#define reg_sdioc_df_lsb 0
+#define xd_p_reg_sdioc_ex1  (*(volatile byte xdata *) 0xF14E)
+#define    p_reg_sdioc_ex1  0xF14E
+#define reg_sdioc_ex1_pos 1
+#define reg_sdioc_ex1_len 1
+#define reg_sdioc_ex1_lsb 0
+#define xd_p_reg_sdioc_rf1  (*(volatile byte xdata *) 0xF14F)
+#define    p_reg_sdioc_rf1  0xF14F
+#define reg_sdioc_rf1_pos 1
+#define reg_sdioc_rf1_len 1
+#define reg_sdioc_rf1_lsb 0
+#define xd_p_reg_sdioc_smpc (*(volatile byte xdata *) 0xF152)
+#define    p_reg_sdioc_smpc 0xF152
+#define reg_sdioc_smpc_pos 0
+#define reg_sdioc_smpc_len 1
+#define reg_sdioc_smpc_lsb 0
+#define xd_p_reg_sdioc_f1_code  (*(volatile byte xdata *) 0xF160)
+#define    p_reg_sdioc_f1_code  0xF160
+#define reg_sdioc_f1_code_pos 0
+#define reg_sdioc_f1_code_len 4
+#define reg_sdioc_f1_code_lsb 0
+#define xd_p_reg_sdioc_scsa (*(volatile byte xdata *) 0xF160)
+#define    p_reg_sdioc_scsa 0xF160
+#define reg_sdioc_scsa_pos 6
+#define reg_sdioc_scsa_len 1
+#define reg_sdioc_scsa_lsb 0
+#define xd_p_reg_sdioc_csa_en   (*(volatile byte xdata *) 0xF160)
+#define    p_reg_sdioc_csa_en   0xF160
+#define reg_sdioc_csa_en_pos 7
+#define reg_sdioc_csa_en_len 1
+#define reg_sdioc_csa_en_lsb 0
+#define xd_p_reg_sdioc_f1_ext_code  (*(volatile byte xdata *) 0xF161)
+#define    p_reg_sdioc_f1_ext_code  0xF161
+#define reg_sdioc_f1_ext_code_pos 0
+#define reg_sdioc_f1_ext_code_len 8
+#define reg_sdioc_f1_ext_code_lsb 0
+#define xd_p_reg_sdioc_sps  (*(volatile byte xdata *) 0xF162)
+#define    p_reg_sdioc_sps  0xF162
+#define reg_sdioc_sps_pos 0
+#define reg_sdioc_sps_len 1
+#define reg_sdioc_sps_lsb 0
+#define xd_p_reg_sdioc_func1_cis_ptr_7_0    (*(volatile byte xdata *) 0xF169)
+#define    p_reg_sdioc_func1_cis_ptr_7_0    0xF169
+#define reg_sdioc_func1_cis_ptr_7_0_pos 0
+#define reg_sdioc_func1_cis_ptr_7_0_len 8
+#define reg_sdioc_func1_cis_ptr_7_0_lsb 0
+#define xd_p_reg_sdioc_func1_cis_ptr_15_8   (*(volatile byte xdata *) 0xF16A)
+#define    p_reg_sdioc_func1_cis_ptr_15_8   0xF16A
+#define reg_sdioc_func1_cis_ptr_15_8_pos 0
+#define reg_sdioc_func1_cis_ptr_15_8_len 8
+#define reg_sdioc_func1_cis_ptr_15_8_lsb 8
+#define xd_p_reg_sdioc_func1_cis_ptr_23_16  (*(volatile byte xdata *) 0xF16B)
+#define    p_reg_sdioc_func1_cis_ptr_23_16  0xF16B
+#define reg_sdioc_func1_cis_ptr_23_16_pos 0
+#define reg_sdioc_func1_cis_ptr_23_16_len 8
+#define reg_sdioc_func1_cis_ptr_23_16_lsb 16
+#define xd_p_reg_sdio_FUNCID0_0 (*(volatile byte xdata *) 0xF180)
+#define    p_reg_sdio_FUNCID0_0 0xF180
+#define reg_sdio_FUNCID0_0_pos 0
+#define reg_sdio_FUNCID0_0_len 8
+#define reg_sdio_FUNCID0_0_lsb 0
+#define xd_p_reg_sdio_FUNCID0_1 (*(volatile byte xdata *) 0xF181)
+#define    p_reg_sdio_FUNCID0_1 0xF181
+#define reg_sdio_FUNCID0_1_pos 0
+#define reg_sdio_FUNCID0_1_len 8
+#define reg_sdio_FUNCID0_1_lsb 0
+#define xd_p_reg_sdio_FUNCID0_2 (*(volatile byte xdata *) 0xF182)
+#define    p_reg_sdio_FUNCID0_2 0xF182
+#define reg_sdio_FUNCID0_2_pos 0
+#define reg_sdio_FUNCID0_2_len 8
+#define reg_sdio_FUNCID0_2_lsb 0
+#define xd_p_reg_sdio_FUNCID0_3 (*(volatile byte xdata *) 0xF183)
+#define    p_reg_sdio_FUNCID0_3 0xF183
+#define reg_sdio_FUNCID0_3_pos 0
+#define reg_sdio_FUNCID0_3_len 8
+#define reg_sdio_FUNCID0_3_lsb 0
+#define xd_p_reg_sdio_MANFID0_0 (*(volatile byte xdata *) 0xF184)
+#define    p_reg_sdio_MANFID0_0 0xF184
+#define reg_sdio_MANFID0_0_pos 0
+#define reg_sdio_MANFID0_0_len 8
+#define reg_sdio_MANFID0_0_lsb 0
+#define xd_p_reg_sdio_MANFID0_1 (*(volatile byte xdata *) 0xF185)
+#define    p_reg_sdio_MANFID0_1 0xF185
+#define reg_sdio_MANFID0_1_pos 0
+#define reg_sdio_MANFID0_1_len 8
+#define reg_sdio_MANFID0_1_lsb 0
+#define xd_p_reg_sdio_MANFID0_2_7_0 (*(volatile byte xdata *) 0xF186)
+#define    p_reg_sdio_MANFID0_2_7_0 0xF186
+#define reg_sdio_MANFID0_2_7_0_pos 0
+#define reg_sdio_MANFID0_2_7_0_len 8
+#define reg_sdio_MANFID0_2_7_0_lsb 0
+#define xd_p_reg_sdio_MANFID0_2_15_8    (*(volatile byte xdata *) 0xF187)
+#define    p_reg_sdio_MANFID0_2_15_8    0xF187
+#define reg_sdio_MANFID0_2_15_8_pos 0
+#define reg_sdio_MANFID0_2_15_8_len 8
+#define reg_sdio_MANFID0_2_15_8_lsb 8
+#define xd_p_reg_sdio_MANFID0_4_7_0 (*(volatile byte xdata *) 0xF188)
+#define    p_reg_sdio_MANFID0_4_7_0 0xF188
+#define reg_sdio_MANFID0_4_7_0_pos 0
+#define reg_sdio_MANFID0_4_7_0_len 8
+#define reg_sdio_MANFID0_4_7_0_lsb 0
+#define xd_p_reg_sdio_MANFID0_4_15_8    (*(volatile byte xdata *) 0xF189)
+#define    p_reg_sdio_MANFID0_4_15_8    0xF189
+#define reg_sdio_MANFID0_4_15_8_pos 0
+#define reg_sdio_MANFID0_4_15_8_len 8
+#define reg_sdio_MANFID0_4_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE0_0  (*(volatile byte xdata *) 0xF18A)
+#define    p_reg_sdio_FUNCE0_0  0xF18A
+#define reg_sdio_FUNCE0_0_pos 0
+#define reg_sdio_FUNCE0_0_len 8
+#define reg_sdio_FUNCE0_0_lsb 0
+#define xd_p_reg_sdio_FUNCE0_1  (*(volatile byte xdata *) 0xF18B)
+#define    p_reg_sdio_FUNCE0_1  0xF18B
+#define reg_sdio_FUNCE0_1_pos 0
+#define reg_sdio_FUNCE0_1_len 8
+#define reg_sdio_FUNCE0_1_lsb 0
+#define xd_p_reg_sdio_FUNCE0_2  (*(volatile byte xdata *) 0xF18C)
+#define    p_reg_sdio_FUNCE0_2  0xF18C
+#define reg_sdio_FUNCE0_2_pos 0
+#define reg_sdio_FUNCE0_2_len 8
+#define reg_sdio_FUNCE0_2_lsb 0
+#define xd_p_reg_sdio_FUNCE0_3_7_0  (*(volatile byte xdata *) 0xF18D)
+#define    p_reg_sdio_FUNCE0_3_7_0  0xF18D
+#define reg_sdio_FUNCE0_3_7_0_pos 0
+#define reg_sdio_FUNCE0_3_7_0_len 8
+#define reg_sdio_FUNCE0_3_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE0_3_15_8 (*(volatile byte xdata *) 0xF18E)
+#define    p_reg_sdio_FUNCE0_3_15_8 0xF18E
+#define reg_sdio_FUNCE0_3_15_8_pos 0
+#define reg_sdio_FUNCE0_3_15_8_len 8
+#define reg_sdio_FUNCE0_3_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE0_5  (*(volatile byte xdata *) 0xF18F)
+#define    p_reg_sdio_FUNCE0_5  0xF18F
+#define reg_sdio_FUNCE0_5_pos 0
+#define reg_sdio_FUNCE0_5_len 8
+#define reg_sdio_FUNCE0_5_lsb 0
+#define xd_p_reg_sdio_VERS_10_0 (*(volatile byte xdata *) 0xF190)
+#define    p_reg_sdio_VERS_10_0 0xF190
+#define reg_sdio_VERS_10_0_pos 0
+#define reg_sdio_VERS_10_0_len 8
+#define reg_sdio_VERS_10_0_lsb 0
+#define xd_p_reg_sdio_VERS_10_1 (*(volatile byte xdata *) 0xF191)
+#define    p_reg_sdio_VERS_10_1 0xF191
+#define reg_sdio_VERS_10_1_pos 0
+#define reg_sdio_VERS_10_1_len 8
+#define reg_sdio_VERS_10_1_lsb 0
+#define xd_p_reg_sdio_VERS_10_2 (*(volatile byte xdata *) 0xF192)
+#define    p_reg_sdio_VERS_10_2 0xF192
+#define reg_sdio_VERS_10_2_pos 0
+#define reg_sdio_VERS_10_2_len 8
+#define reg_sdio_VERS_10_2_lsb 0
+#define xd_p_reg_sdio_VERS_10_3 (*(volatile byte xdata *) 0xF193)
+#define    p_reg_sdio_VERS_10_3 0xF193
+#define reg_sdio_VERS_10_3_pos 0
+#define reg_sdio_VERS_10_3_len 8
+#define reg_sdio_VERS_10_3_lsb 0
+#define xd_p_reg_sdio_VERS_10_4 (*(volatile byte xdata *) 0xF194)
+#define    p_reg_sdio_VERS_10_4 0xF194
+#define reg_sdio_VERS_10_4_pos 0
+#define reg_sdio_VERS_10_4_len 8
+#define reg_sdio_VERS_10_4_lsb 0
+#define xd_p_reg_sdio_VERS_10_5 (*(volatile byte xdata *) 0xF195)
+#define    p_reg_sdio_VERS_10_5 0xF195
+#define reg_sdio_VERS_10_5_pos 0
+#define reg_sdio_VERS_10_5_len 8
+#define reg_sdio_VERS_10_5_lsb 0
+#define xd_p_reg_sdio_VERS_10_6 (*(volatile byte xdata *) 0xF196)
+#define    p_reg_sdio_VERS_10_6 0xF196
+#define reg_sdio_VERS_10_6_pos 0
+#define reg_sdio_VERS_10_6_len 8
+#define reg_sdio_VERS_10_6_lsb 0
+#define xd_p_reg_sdio_VERS_10_7 (*(volatile byte xdata *) 0xF197)
+#define    p_reg_sdio_VERS_10_7 0xF197
+#define reg_sdio_VERS_10_7_pos 0
+#define reg_sdio_VERS_10_7_len 8
+#define reg_sdio_VERS_10_7_lsb 0
+#define xd_p_reg_sdio_VERS_10_8 (*(volatile byte xdata *) 0xF198)
+#define    p_reg_sdio_VERS_10_8 0xF198
+#define reg_sdio_VERS_10_8_pos 0
+#define reg_sdio_VERS_10_8_len 8
+#define reg_sdio_VERS_10_8_lsb 0
+#define xd_p_reg_sdio_VERS_10_9 (*(volatile byte xdata *) 0xF199)
+#define    p_reg_sdio_VERS_10_9 0xF199
+#define reg_sdio_VERS_10_9_pos 0
+#define reg_sdio_VERS_10_9_len 8
+#define reg_sdio_VERS_10_9_lsb 0
+#define xd_p_reg_sdio_VERS_10_A (*(volatile byte xdata *) 0xF19A)
+#define    p_reg_sdio_VERS_10_A 0xF19A
+#define reg_sdio_VERS_10_A_pos 0
+#define reg_sdio_VERS_10_A_len 8
+#define reg_sdio_VERS_10_A_lsb 0
+#define xd_p_reg_sdio_VERS_10_B (*(volatile byte xdata *) 0xF19B)
+#define    p_reg_sdio_VERS_10_B 0xF19B
+#define reg_sdio_VERS_10_B_pos 0
+#define reg_sdio_VERS_10_B_len 8
+#define reg_sdio_VERS_10_B_lsb 0
+#define xd_p_reg_sdio_VERS_10_C (*(volatile byte xdata *) 0xF19C)
+#define    p_reg_sdio_VERS_10_C 0xF19C
+#define reg_sdio_VERS_10_C_pos 0
+#define reg_sdio_VERS_10_C_len 8
+#define reg_sdio_VERS_10_C_lsb 0
+#define xd_p_reg_sdio_VERS_10_D (*(volatile byte xdata *) 0xF19D)
+#define    p_reg_sdio_VERS_10_D 0xF19D
+#define reg_sdio_VERS_10_D_pos 0
+#define reg_sdio_VERS_10_D_len 8
+#define reg_sdio_VERS_10_D_lsb 0
+#define xd_p_reg_sdio_VERS_10_E (*(volatile byte xdata *) 0xF19E)
+#define    p_reg_sdio_VERS_10_E 0xF19E
+#define reg_sdio_VERS_10_E_pos 0
+#define reg_sdio_VERS_10_E_len 8
+#define reg_sdio_VERS_10_E_lsb 0
+#define xd_p_reg_sdio_VERS_10_F (*(volatile byte xdata *) 0xF19F)
+#define    p_reg_sdio_VERS_10_F 0xF19F
+#define reg_sdio_VERS_10_F_pos 0
+#define reg_sdio_VERS_10_F_len 8
+#define reg_sdio_VERS_10_F_lsb 0
+#define xd_p_reg_sdio_VERS_10_10    (*(volatile byte xdata *) 0xF1A0)
+#define    p_reg_sdio_VERS_10_10    0xF1A0
+#define reg_sdio_VERS_10_10_pos 0
+#define reg_sdio_VERS_10_10_len 8
+#define reg_sdio_VERS_10_10_lsb 0
+#define xd_p_reg_sdio_VERS_10_11    (*(volatile byte xdata *) 0xF1A1)
+#define    p_reg_sdio_VERS_10_11    0xF1A1
+#define reg_sdio_VERS_10_11_pos 0
+#define reg_sdio_VERS_10_11_len 8
+#define reg_sdio_VERS_10_11_lsb 0
+#define xd_p_reg_sdio_VERS_10_12    (*(volatile byte xdata *) 0xF1A2)
+#define    p_reg_sdio_VERS_10_12    0xF1A2
+#define reg_sdio_VERS_10_12_pos 0
+#define reg_sdio_VERS_10_12_len 8
+#define reg_sdio_VERS_10_12_lsb 0
+#define xd_p_reg_sdio_VERS_10_13    (*(volatile byte xdata *) 0xF1A3)
+#define    p_reg_sdio_VERS_10_13    0xF1A3
+#define reg_sdio_VERS_10_13_pos 0
+#define reg_sdio_VERS_10_13_len 8
+#define reg_sdio_VERS_10_13_lsb 0
+#define xd_p_reg_sdio_VERS_10_14    (*(volatile byte xdata *) 0xF1A4)
+#define    p_reg_sdio_VERS_10_14    0xF1A4
+#define reg_sdio_VERS_10_14_pos 0
+#define reg_sdio_VERS_10_14_len 8
+#define reg_sdio_VERS_10_14_lsb 0
+#define xd_p_reg_sdio_VERS_10_15    (*(volatile byte xdata *) 0xF1A5)
+#define    p_reg_sdio_VERS_10_15    0xF1A5
+#define reg_sdio_VERS_10_15_pos 0
+#define reg_sdio_VERS_10_15_len 8
+#define reg_sdio_VERS_10_15_lsb 0
+#define xd_p_reg_sdio_VERS_10_16    (*(volatile byte xdata *) 0xF1A6)
+#define    p_reg_sdio_VERS_10_16    0xF1A6
+#define reg_sdio_VERS_10_16_pos 0
+#define reg_sdio_VERS_10_16_len 8
+#define reg_sdio_VERS_10_16_lsb 0
+#define xd_p_reg_sdio_VERS_10_17    (*(volatile byte xdata *) 0xF1A7)
+#define    p_reg_sdio_VERS_10_17    0xF1A7
+#define reg_sdio_VERS_10_17_pos 0
+#define reg_sdio_VERS_10_17_len 8
+#define reg_sdio_VERS_10_17_lsb 0
+#define xd_p_reg_sdio_VERS_10_18    (*(volatile byte xdata *) 0xF1A8)
+#define    p_reg_sdio_VERS_10_18    0xF1A8
+#define reg_sdio_VERS_10_18_pos 0
+#define reg_sdio_VERS_10_18_len 8
+#define reg_sdio_VERS_10_18_lsb 0
+#define xd_p_reg_sdio_VERS_10_19    (*(volatile byte xdata *) 0xF1A9)
+#define    p_reg_sdio_VERS_10_19    0xF1A9
+#define reg_sdio_VERS_10_19_pos 0
+#define reg_sdio_VERS_10_19_len 8
+#define reg_sdio_VERS_10_19_lsb 0
+#define xd_p_reg_sdio_VERS_10_1A    (*(volatile byte xdata *) 0xF1AA)
+#define    p_reg_sdio_VERS_10_1A    0xF1AA
+#define reg_sdio_VERS_10_1A_pos 0
+#define reg_sdio_VERS_10_1A_len 8
+#define reg_sdio_VERS_10_1A_lsb 0
+#define xd_p_reg_sdio_VERS_10_1B    (*(volatile byte xdata *) 0xF1AB)
+#define    p_reg_sdio_VERS_10_1B    0xF1AB
+#define reg_sdio_VERS_10_1B_pos 0
+#define reg_sdio_VERS_10_1B_len 8
+#define reg_sdio_VERS_10_1B_lsb 0
+#define xd_p_reg_sdio_VERS_10_1C    (*(volatile byte xdata *) 0xF1AC)
+#define    p_reg_sdio_VERS_10_1C    0xF1AC
+#define reg_sdio_VERS_10_1C_pos 0
+#define reg_sdio_VERS_10_1C_len 8
+#define reg_sdio_VERS_10_1C_lsb 0
+#define xd_p_reg_sdio_VERS_10_1D    (*(volatile byte xdata *) 0xF1AD)
+#define    p_reg_sdio_VERS_10_1D    0xF1AD
+#define reg_sdio_VERS_10_1D_pos 0
+#define reg_sdio_VERS_10_1D_len 8
+#define reg_sdio_VERS_10_1D_lsb 0
+#define xd_p_reg_sdio_VERS_10_1E    (*(volatile byte xdata *) 0xF1AE)
+#define    p_reg_sdio_VERS_10_1E    0xF1AE
+#define reg_sdio_VERS_10_1E_pos 0
+#define reg_sdio_VERS_10_1E_len 8
+#define reg_sdio_VERS_10_1E_lsb 0
+#define xd_p_reg_sdio_VERS_10_1F    (*(volatile byte xdata *) 0xF1AF)
+#define    p_reg_sdio_VERS_10_1F    0xF1AF
+#define reg_sdio_VERS_10_1F_pos 0
+#define reg_sdio_VERS_10_1F_len 8
+#define reg_sdio_VERS_10_1F_lsb 0
+#define xd_p_reg_sdio_VERS_10_20    (*(volatile byte xdata *) 0xF1B0)
+#define    p_reg_sdio_VERS_10_20    0xF1B0
+#define reg_sdio_VERS_10_20_pos 0
+#define reg_sdio_VERS_10_20_len 8
+#define reg_sdio_VERS_10_20_lsb 0
+#define xd_p_reg_sdio_VERS_10_21    (*(volatile byte xdata *) 0xF1B1)
+#define    p_reg_sdio_VERS_10_21    0xF1B1
+#define reg_sdio_VERS_10_21_pos 0
+#define reg_sdio_VERS_10_21_len 8
+#define reg_sdio_VERS_10_21_lsb 0
+#define xd_p_reg_sdio_VERS_10_22    (*(volatile byte xdata *) 0xF1B2)
+#define    p_reg_sdio_VERS_10_22    0xF1B2
+#define reg_sdio_VERS_10_22_pos 0
+#define reg_sdio_VERS_10_22_len 8
+#define reg_sdio_VERS_10_22_lsb 0
+#define xd_p_reg_sdio_VERS_10_23    (*(volatile byte xdata *) 0xF1B3)
+#define    p_reg_sdio_VERS_10_23    0xF1B3
+#define reg_sdio_VERS_10_23_pos 0
+#define reg_sdio_VERS_10_23_len 8
+#define reg_sdio_VERS_10_23_lsb 0
+#define xd_p_reg_sdio_VERS_10_24    (*(volatile byte xdata *) 0xF1B4)
+#define    p_reg_sdio_VERS_10_24    0xF1B4
+#define reg_sdio_VERS_10_24_pos 0
+#define reg_sdio_VERS_10_24_len 8
+#define reg_sdio_VERS_10_24_lsb 0
+#define xd_p_reg_sdio_VERS_10_25    (*(volatile byte xdata *) 0xF1B5)
+#define    p_reg_sdio_VERS_10_25    0xF1B5
+#define reg_sdio_VERS_10_25_pos 0
+#define reg_sdio_VERS_10_25_len 8
+#define reg_sdio_VERS_10_25_lsb 0
+#define xd_p_reg_sdio_VERS_10_26    (*(volatile byte xdata *) 0xF1B6)
+#define    p_reg_sdio_VERS_10_26    0xF1B6
+#define reg_sdio_VERS_10_26_pos 0
+#define reg_sdio_VERS_10_26_len 8
+#define reg_sdio_VERS_10_26_lsb 0
+#define xd_p_reg_sdio_VERS_10_27    (*(volatile byte xdata *) 0xF1B7)
+#define    p_reg_sdio_VERS_10_27    0xF1B7
+#define reg_sdio_VERS_10_27_pos 0
+#define reg_sdio_VERS_10_27_len 8
+#define reg_sdio_VERS_10_27_lsb 0
+#define xd_p_reg_sdio_END0  (*(volatile byte xdata *) 0xF1B8)
+#define    p_reg_sdio_END0  0xF1B8
+#define reg_sdio_END0_pos 0
+#define reg_sdio_END0_len 8
+#define reg_sdio_END0_lsb 0
+#define xd_p_reg_sdio_FUNCID1_0 (*(volatile byte xdata *) 0xF1C0)
+#define    p_reg_sdio_FUNCID1_0 0xF1C0
+#define reg_sdio_FUNCID1_0_pos 0
+#define reg_sdio_FUNCID1_0_len 8
+#define reg_sdio_FUNCID1_0_lsb 0
+#define xd_p_reg_sdio_FUNCID1_1 (*(volatile byte xdata *) 0xF1C1)
+#define    p_reg_sdio_FUNCID1_1 0xF1C1
+#define reg_sdio_FUNCID1_1_pos 0
+#define reg_sdio_FUNCID1_1_len 8
+#define reg_sdio_FUNCID1_1_lsb 0
+#define xd_p_reg_sdio_FUNCID1_2 (*(volatile byte xdata *) 0xF1C2)
+#define    p_reg_sdio_FUNCID1_2 0xF1C2
+#define reg_sdio_FUNCID1_2_pos 0
+#define reg_sdio_FUNCID1_2_len 8
+#define reg_sdio_FUNCID1_2_lsb 0
+#define xd_p_reg_sdio_FUNCID1_3 (*(volatile byte xdata *) 0xF1C3)
+#define    p_reg_sdio_FUNCID1_3 0xF1C3
+#define reg_sdio_FUNCID1_3_pos 0
+#define reg_sdio_FUNCID1_3_len 8
+#define reg_sdio_FUNCID1_3_lsb 0
+#define xd_p_reg_sdio_FUNCE1_0  (*(volatile byte xdata *) 0xF1C4)
+#define    p_reg_sdio_FUNCE1_0  0xF1C4
+#define reg_sdio_FUNCE1_0_pos 0
+#define reg_sdio_FUNCE1_0_len 8
+#define reg_sdio_FUNCE1_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_1  (*(volatile byte xdata *) 0xF1C5)
+#define    p_reg_sdio_FUNCE1_1  0xF1C5
+#define reg_sdio_FUNCE1_1_pos 0
+#define reg_sdio_FUNCE1_1_len 8
+#define reg_sdio_FUNCE1_1_lsb 0
+#define xd_p_reg_sdio_FUNCE1_2  (*(volatile byte xdata *) 0xF1C6)
+#define    p_reg_sdio_FUNCE1_2  0xF1C6
+#define reg_sdio_FUNCE1_2_pos 0
+#define reg_sdio_FUNCE1_2_len 8
+#define reg_sdio_FUNCE1_2_lsb 0
+#define xd_p_reg_sdio_FUNCE1_3  (*(volatile byte xdata *) 0xF1C7)
+#define    p_reg_sdio_FUNCE1_3  0xF1C7
+#define reg_sdio_FUNCE1_3_pos 0
+#define reg_sdio_FUNCE1_3_len 8
+#define reg_sdio_FUNCE1_3_lsb 0
+#define xd_p_reg_sdio_FUNCE1_4  (*(volatile byte xdata *) 0xF1C8)
+#define    p_reg_sdio_FUNCE1_4  0xF1C8
+#define reg_sdio_FUNCE1_4_pos 0
+#define reg_sdio_FUNCE1_4_len 8
+#define reg_sdio_FUNCE1_4_lsb 0
+#define xd_p_reg_sdio_FUNCE1_5_7_0  (*(volatile byte xdata *) 0xF1C9)
+#define    p_reg_sdio_FUNCE1_5_7_0  0xF1C9
+#define reg_sdio_FUNCE1_5_7_0_pos 0
+#define reg_sdio_FUNCE1_5_7_0_len 8
+#define reg_sdio_FUNCE1_5_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_5_15_8 (*(volatile byte xdata *) 0xF1CA)
+#define    p_reg_sdio_FUNCE1_5_15_8 0xF1CA
+#define reg_sdio_FUNCE1_5_15_8_pos 0
+#define reg_sdio_FUNCE1_5_15_8_len 8
+#define reg_sdio_FUNCE1_5_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_5_23_16    (*(volatile byte xdata *) 0xF1CB)
+#define    p_reg_sdio_FUNCE1_5_23_16    0xF1CB
+#define reg_sdio_FUNCE1_5_23_16_pos 0
+#define reg_sdio_FUNCE1_5_23_16_len 8
+#define reg_sdio_FUNCE1_5_23_16_lsb 16
+#define xd_p_reg_sdio_FUNCE1_5_31_24    (*(volatile byte xdata *) 0xF1CC)
+#define    p_reg_sdio_FUNCE1_5_31_24    0xF1CC
+#define reg_sdio_FUNCE1_5_31_24_pos 0
+#define reg_sdio_FUNCE1_5_31_24_len 8
+#define reg_sdio_FUNCE1_5_31_24_lsb 24
+#define xd_p_reg_sdio_FUNCE1_9_7_0  (*(volatile byte xdata *) 0xF1CD)
+#define    p_reg_sdio_FUNCE1_9_7_0  0xF1CD
+#define reg_sdio_FUNCE1_9_7_0_pos 0
+#define reg_sdio_FUNCE1_9_7_0_len 8
+#define reg_sdio_FUNCE1_9_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_9_15_8 (*(volatile byte xdata *) 0xF1CE)
+#define    p_reg_sdio_FUNCE1_9_15_8 0xF1CE
+#define reg_sdio_FUNCE1_9_15_8_pos 0
+#define reg_sdio_FUNCE1_9_15_8_len 8
+#define reg_sdio_FUNCE1_9_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_9_23_16    (*(volatile byte xdata *) 0xF1CF)
+#define    p_reg_sdio_FUNCE1_9_23_16    0xF1CF
+#define reg_sdio_FUNCE1_9_23_16_pos 0
+#define reg_sdio_FUNCE1_9_23_16_len 8
+#define reg_sdio_FUNCE1_9_23_16_lsb 16
+#define xd_p_reg_sdio_FUNCE1_9_31_24    (*(volatile byte xdata *) 0xF1D0)
+#define    p_reg_sdio_FUNCE1_9_31_24    0xF1D0
+#define reg_sdio_FUNCE1_9_31_24_pos 0
+#define reg_sdio_FUNCE1_9_31_24_len 8
+#define reg_sdio_FUNCE1_9_31_24_lsb 24
+#define xd_p_reg_sdio_FUNCE1_D  (*(volatile byte xdata *) 0xF1D1)
+#define    p_reg_sdio_FUNCE1_D  0xF1D1
+#define reg_sdio_FUNCE1_D_pos 0
+#define reg_sdio_FUNCE1_D_len 8
+#define reg_sdio_FUNCE1_D_lsb 0
+#define xd_p_reg_sdio_FUNCE1_E_7_0  (*(volatile byte xdata *) 0xF1D2)
+#define    p_reg_sdio_FUNCE1_E_7_0  0xF1D2
+#define reg_sdio_FUNCE1_E_7_0_pos 0
+#define reg_sdio_FUNCE1_E_7_0_len 8
+#define reg_sdio_FUNCE1_E_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_E_15_8 (*(volatile byte xdata *) 0xF1D3)
+#define    p_reg_sdio_FUNCE1_E_15_8 0xF1D3
+#define reg_sdio_FUNCE1_E_15_8_pos 0
+#define reg_sdio_FUNCE1_E_15_8_len 8
+#define reg_sdio_FUNCE1_E_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_10_7_0 (*(volatile byte xdata *) 0xF1D4)
+#define    p_reg_sdio_FUNCE1_10_7_0 0xF1D4
+#define reg_sdio_FUNCE1_10_7_0_pos 0
+#define reg_sdio_FUNCE1_10_7_0_len 8
+#define reg_sdio_FUNCE1_10_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_10_15_8    (*(volatile byte xdata *) 0xF1D5)
+#define    p_reg_sdio_FUNCE1_10_15_8    0xF1D5
+#define reg_sdio_FUNCE1_10_15_8_pos 0
+#define reg_sdio_FUNCE1_10_15_8_len 8
+#define reg_sdio_FUNCE1_10_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_10_23_16   (*(volatile byte xdata *) 0xF1D6)
+#define    p_reg_sdio_FUNCE1_10_23_16   0xF1D6
+#define reg_sdio_FUNCE1_10_23_16_pos 0
+#define reg_sdio_FUNCE1_10_23_16_len 8
+#define reg_sdio_FUNCE1_10_23_16_lsb 16
+#define xd_p_reg_sdio_FUNCE1_10_31_24   (*(volatile byte xdata *) 0xF1D7)
+#define    p_reg_sdio_FUNCE1_10_31_24   0xF1D7
+#define reg_sdio_FUNCE1_10_31_24_pos 0
+#define reg_sdio_FUNCE1_10_31_24_len 8
+#define reg_sdio_FUNCE1_10_31_24_lsb 24
+#define xd_p_reg_sdio_FUNCE1_14 (*(volatile byte xdata *) 0xF1D8)
+#define    p_reg_sdio_FUNCE1_14 0xF1D8
+#define reg_sdio_FUNCE1_14_pos 0
+#define reg_sdio_FUNCE1_14_len 8
+#define reg_sdio_FUNCE1_14_lsb 0
+#define xd_p_reg_sdio_FUNCE1_15 (*(volatile byte xdata *) 0xF1D9)
+#define    p_reg_sdio_FUNCE1_15 0xF1D9
+#define reg_sdio_FUNCE1_15_pos 0
+#define reg_sdio_FUNCE1_15_len 8
+#define reg_sdio_FUNCE1_15_lsb 0
+#define xd_p_reg_sdio_FUNCE1_16 (*(volatile byte xdata *) 0xF1DA)
+#define    p_reg_sdio_FUNCE1_16 0xF1DA
+#define reg_sdio_FUNCE1_16_pos 0
+#define reg_sdio_FUNCE1_16_len 8
+#define reg_sdio_FUNCE1_16_lsb 0
+#define xd_p_reg_sdio_FUNCE1_17 (*(volatile byte xdata *) 0xF1DB)
+#define    p_reg_sdio_FUNCE1_17 0xF1DB
+#define reg_sdio_FUNCE1_17_pos 0
+#define reg_sdio_FUNCE1_17_len 8
+#define reg_sdio_FUNCE1_17_lsb 0
+#define xd_p_reg_sdio_FUNCE1_18 (*(volatile byte xdata *) 0xF1DC)
+#define    p_reg_sdio_FUNCE1_18 0xF1DC
+#define reg_sdio_FUNCE1_18_pos 0
+#define reg_sdio_FUNCE1_18_len 8
+#define reg_sdio_FUNCE1_18_lsb 0
+#define xd_p_reg_sdio_FUNCE1_19 (*(volatile byte xdata *) 0xF1DD)
+#define    p_reg_sdio_FUNCE1_19 0xF1DD
+#define reg_sdio_FUNCE1_19_pos 0
+#define reg_sdio_FUNCE1_19_len 8
+#define reg_sdio_FUNCE1_19_lsb 0
+#define xd_p_reg_sdio_FUNCE1_1A_7_0 (*(volatile byte xdata *) 0xF1DE)
+#define    p_reg_sdio_FUNCE1_1A_7_0 0xF1DE
+#define reg_sdio_FUNCE1_1A_7_0_pos 0
+#define reg_sdio_FUNCE1_1A_7_0_len 8
+#define reg_sdio_FUNCE1_1A_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_1A_15_8    (*(volatile byte xdata *) 0xF1DF)
+#define    p_reg_sdio_FUNCE1_1A_15_8    0xF1DF
+#define reg_sdio_FUNCE1_1A_15_8_pos 0
+#define reg_sdio_FUNCE1_1A_15_8_len 8
+#define reg_sdio_FUNCE1_1A_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_1C_7_0 (*(volatile byte xdata *) 0xF1E0)
+#define    p_reg_sdio_FUNCE1_1C_7_0 0xF1E0
+#define reg_sdio_FUNCE1_1C_7_0_pos 0
+#define reg_sdio_FUNCE1_1C_7_0_len 8
+#define reg_sdio_FUNCE1_1C_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_1C_15_8    (*(volatile byte xdata *) 0xF1E1)
+#define    p_reg_sdio_FUNCE1_1C_15_8    0xF1E1
+#define reg_sdio_FUNCE1_1C_15_8_pos 0
+#define reg_sdio_FUNCE1_1C_15_8_len 8
+#define reg_sdio_FUNCE1_1C_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_1E_7_0 (*(volatile byte xdata *) 0xF1E2)
+#define    p_reg_sdio_FUNCE1_1E_7_0 0xF1E2
+#define reg_sdio_FUNCE1_1E_7_0_pos 0
+#define reg_sdio_FUNCE1_1E_7_0_len 8
+#define reg_sdio_FUNCE1_1E_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_1E_15_8    (*(volatile byte xdata *) 0xF1E3)
+#define    p_reg_sdio_FUNCE1_1E_15_8    0xF1E3
+#define reg_sdio_FUNCE1_1E_15_8_pos 0
+#define reg_sdio_FUNCE1_1E_15_8_len 8
+#define reg_sdio_FUNCE1_1E_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_20_7_0 (*(volatile byte xdata *) 0xF1E4)
+#define    p_reg_sdio_FUNCE1_20_7_0 0xF1E4
+#define reg_sdio_FUNCE1_20_7_0_pos 0
+#define reg_sdio_FUNCE1_20_7_0_len 8
+#define reg_sdio_FUNCE1_20_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_20_15_8    (*(volatile byte xdata *) 0xF1E5)
+#define    p_reg_sdio_FUNCE1_20_15_8    0xF1E5
+#define reg_sdio_FUNCE1_20_15_8_pos 0
+#define reg_sdio_FUNCE1_20_15_8_len 8
+#define reg_sdio_FUNCE1_20_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_22_7_0 (*(volatile byte xdata *) 0xF1E6)
+#define    p_reg_sdio_FUNCE1_22_7_0 0xF1E6
+#define reg_sdio_FUNCE1_22_7_0_pos 0
+#define reg_sdio_FUNCE1_22_7_0_len 8
+#define reg_sdio_FUNCE1_22_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_22_15_8    (*(volatile byte xdata *) 0xF1E7)
+#define    p_reg_sdio_FUNCE1_22_15_8    0xF1E7
+#define reg_sdio_FUNCE1_22_15_8_pos 0
+#define reg_sdio_FUNCE1_22_15_8_len 8
+#define reg_sdio_FUNCE1_22_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_24_7_0 (*(volatile byte xdata *) 0xF1E8)
+#define    p_reg_sdio_FUNCE1_24_7_0 0xF1E8
+#define reg_sdio_FUNCE1_24_7_0_pos 0
+#define reg_sdio_FUNCE1_24_7_0_len 8
+#define reg_sdio_FUNCE1_24_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_24_15_8    (*(volatile byte xdata *) 0xF1E9)
+#define    p_reg_sdio_FUNCE1_24_15_8    0xF1E9
+#define reg_sdio_FUNCE1_24_15_8_pos 0
+#define reg_sdio_FUNCE1_24_15_8_len 8
+#define reg_sdio_FUNCE1_24_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_26_7_0 (*(volatile byte xdata *) 0xF1EA)
+#define    p_reg_sdio_FUNCE1_26_7_0 0xF1EA
+#define reg_sdio_FUNCE1_26_7_0_pos 0
+#define reg_sdio_FUNCE1_26_7_0_len 8
+#define reg_sdio_FUNCE1_26_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_26_15_8    (*(volatile byte xdata *) 0xF1EB)
+#define    p_reg_sdio_FUNCE1_26_15_8    0xF1EB
+#define reg_sdio_FUNCE1_26_15_8_pos 0
+#define reg_sdio_FUNCE1_26_15_8_len 8
+#define reg_sdio_FUNCE1_26_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_28_7_0 (*(volatile byte xdata *) 0xF1EC)
+#define    p_reg_sdio_FUNCE1_28_7_0 0xF1EC
+#define reg_sdio_FUNCE1_28_7_0_pos 0
+#define reg_sdio_FUNCE1_28_7_0_len 8
+#define reg_sdio_FUNCE1_28_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_28_15_8    (*(volatile byte xdata *) 0xF1ED)
+#define    p_reg_sdio_FUNCE1_28_15_8    0xF1ED
+#define reg_sdio_FUNCE1_28_15_8_pos 0
+#define reg_sdio_FUNCE1_28_15_8_len 8
+#define reg_sdio_FUNCE1_28_15_8_lsb 8
+#define xd_p_reg_sdio_FUNCE1_2A_7_0 (*(volatile byte xdata *) 0xF1EE)
+#define    p_reg_sdio_FUNCE1_2A_7_0 0xF1EE
+#define reg_sdio_FUNCE1_2A_7_0_pos 0
+#define reg_sdio_FUNCE1_2A_7_0_len 8
+#define reg_sdio_FUNCE1_2A_7_0_lsb 0
+#define xd_p_reg_sdio_FUNCE1_2A_15_8    (*(volatile byte xdata *) 0xF1EF)
+#define    p_reg_sdio_FUNCE1_2A_15_8    0xF1EF
+#define reg_sdio_FUNCE1_2A_15_8_pos 0
+#define reg_sdio_FUNCE1_2A_15_8_len 8
+#define reg_sdio_FUNCE1_2A_15_8_lsb 8
+#define xd_p_reg_sdio_END1  (*(volatile byte xdata *) 0xF1F0)
+#define    p_reg_sdio_END1  0xF1F0
+#define reg_sdio_END1_pos 0
+#define reg_sdio_END1_len 8
+#define reg_sdio_END1_lsb 0
+#define xd_r_sdioc_tx_fifo_empty    (*(volatile byte xdata *) 0xF210)
+#define    r_sdioc_tx_fifo_empty    0xF210
+#define sdioc_tx_fifo_empty_pos 0
+#define sdioc_tx_fifo_empty_len 1
+#define sdioc_tx_fifo_empty_lsb 0
+#define xd_p_reg_sdio_53ra  (*(volatile byte xdata *) 0xF210)
+#define    p_reg_sdio_53ra  0xF210
+#define reg_sdio_53ra_pos 1
+#define reg_sdio_53ra_len 1
+#define reg_sdio_53ra_lsb 0
+#define xd_p_reg_sdioc_rd_wait_dly  (*(volatile byte xdata *) 0xF210)
+#define    p_reg_sdioc_rd_wait_dly  0xF210
+#define reg_sdioc_rd_wait_dly_pos 4
+#define reg_sdioc_rd_wait_dly_len 2
+#define reg_sdioc_rd_wait_dly_lsb 0
+#define xd_p_reg_write_mbx_complete (*(volatile byte xdata *) 0xF211)
+#define    p_reg_write_mbx_complete 0xF211
+#define reg_write_mbx_complete_pos 0
+#define reg_write_mbx_complete_len 1
+#define reg_write_mbx_complete_lsb 0
+#define xd_p_reg_sdioc_sw_err   (*(volatile byte xdata *) 0xF211)
+#define    p_reg_sdioc_sw_err   0xF211
+#define reg_sdioc_sw_err_pos 1
+#define reg_sdioc_sw_err_len 1
+#define reg_sdioc_sw_err_lsb 0
+#define xd_p_reg_sdioc_tran_dat_dly (*(volatile byte xdata *) 0xF211)
+#define    p_reg_sdioc_tran_dat_dly 0xF211
+#define reg_sdioc_tran_dat_dly_pos 4
+#define reg_sdioc_tran_dat_dly_len 3
+#define reg_sdioc_tran_dat_dly_lsb 0
+#define xd_p_reg_sdioc_external_int_en  (*(volatile byte xdata *) 0xF212)
+#define    p_reg_sdioc_external_int_en  0xF212
+#define reg_sdioc_external_int_en_pos 1
+#define reg_sdioc_external_int_en_len 1
+#define reg_sdioc_external_int_en_lsb 0
+#define xd_r_reg_sdioc_external_int (*(volatile byte xdata *) 0xF212)
+#define    r_reg_sdioc_external_int 0xF212
+#define reg_sdioc_external_int_pos 2
+#define reg_sdioc_external_int_len 1
+#define reg_sdioc_external_int_lsb 0
+#define xd_p_reg_auto_clrWB_en  (*(volatile byte xdata *) 0xF213)
+#define    p_reg_auto_clrWB_en  0xF213
+#define reg_auto_clrWB_en_pos 0
+#define reg_auto_clrWB_en_len 1
+#define reg_auto_clrWB_en_lsb 0
+#define xd_p_reg_sdioc_crc_s_dly    (*(volatile byte xdata *) 0xF213)
+#define    p_reg_sdioc_crc_s_dly    0xF213
+#define reg_sdioc_crc_s_dly_pos 1
+#define reg_sdioc_crc_s_dly_len 1
+#define reg_sdioc_crc_s_dly_lsb 0
+#define xd_p_reg_sdioc_neg_out_sel  (*(volatile byte xdata *) 0xF213)
+#define    p_reg_sdioc_neg_out_sel  0xF213
+#define reg_sdioc_neg_out_sel_pos 2
+#define reg_sdioc_neg_out_sel_len 1
+#define reg_sdioc_neg_out_sel_lsb 0
+#define xd_p_reg_sdioc_tx_fifo_rst  (*(volatile byte xdata *) 0xF213)
+#define    p_reg_sdioc_tx_fifo_rst  0xF213
+#define reg_sdioc_tx_fifo_rst_pos 4
+#define reg_sdioc_tx_fifo_rst_len 1
+#define reg_sdioc_tx_fifo_rst_lsb 0
+#define xd_p_reg_sdioc_rx_fifo_rst  (*(volatile byte xdata *) 0xF213)
+#define    p_reg_sdioc_rx_fifo_rst  0xF213
+#define reg_sdioc_rx_fifo_rst_pos 5
+#define reg_sdioc_rx_fifo_rst_len 1
+#define reg_sdioc_rx_fifo_rst_lsb 0
+#define xd_p_reg_sdioc_auto_rst_sm_en   (*(volatile byte xdata *) 0xF213)
+#define    p_reg_sdioc_auto_rst_sm_en   0xF213
+#define reg_sdioc_auto_rst_sm_en_pos 6
+#define reg_sdioc_auto_rst_sm_en_len 1
+#define reg_sdioc_auto_rst_sm_en_lsb 0
+#define xd_p_sdio_link_clr_Wbusy_en (*(volatile byte xdata *) 0xF214)
+#define    p_sdio_link_clr_Wbusy_en 0xF214
+#define sdio_link_clr_Wbusy_en_pos 0
+#define sdio_link_clr_Wbusy_en_len 1
+#define sdio_link_clr_Wbusy_en_lsb 0
+#define xd_p_sdio_link_clr_Wbusy    (*(volatile byte xdata *) 0xF214)
+#define    p_sdio_link_clr_Wbusy    0xF214
+#define sdio_link_clr_Wbusy_pos 1
+#define sdio_link_clr_Wbusy_len 1
+#define sdio_link_clr_Wbusy_lsb 0
+#define xd_p_reg_sdioc_dbg_sel  (*(volatile byte xdata *) 0xF214)
+#define    p_reg_sdioc_dbg_sel  0xF214
+#define reg_sdioc_dbg_sel_pos 4
+#define reg_sdioc_dbg_sel_len 4
+#define reg_sdioc_dbg_sel_lsb 0
+#define xd_p_reg_sdioc_skip_ocr (*(volatile byte xdata *) 0xF215)
+#define    p_reg_sdioc_skip_ocr 0xF215
+#define reg_sdioc_skip_ocr_pos 0
+#define reg_sdioc_skip_ocr_len 1
+#define reg_sdioc_skip_ocr_lsb 0
+#define xd_p_reg_sdioc_spi_ns   (*(volatile byte xdata *) 0xF215)
+#define    p_reg_sdioc_spi_ns   0xF215
+#define reg_sdioc_spi_ns_pos 1
+#define reg_sdioc_spi_ns_len 1
+#define reg_sdioc_spi_ns_lsb 0
+#define xd_r_sdio_spi_mode  (*(volatile byte xdata *) 0xF215)
+#define    r_sdio_spi_mode  0xF215
+#define sdio_spi_mode_pos 7
+#define sdio_spi_mode_len 1
+#define sdio_spi_mode_lsb 0
+#define xd_r_link_ofsm_mailbox_int  (*(volatile byte xdata *) 0xF402)
+#define    r_link_ofsm_mailbox_int  0xF402
+#define link_ofsm_mailbox_int_pos 4
+#define link_ofsm_mailbox_int_len 1
+#define link_ofsm_mailbox_int_lsb 0
+#define xd_r_link_ofsm_dvbt_int (*(volatile byte xdata *) 0xF403)
+#define    r_link_ofsm_dvbt_int 0xF403
+#define link_ofsm_dvbt_int_pos 2
+#define link_ofsm_dvbt_int_len 1
+#define link_ofsm_dvbt_int_lsb 0
+#define xd_p_reg_dvbt_intsts    (*(volatile byte xdata *) 0xF404)
+#define    p_reg_dvbt_intsts    0xF404
+#define reg_dvbt_intsts_pos 2
+#define reg_dvbt_intsts_len 1
+#define reg_dvbt_intsts_lsb 0
+#define xd_p_reg_link_mailbox_int   (*(volatile byte xdata *) 0xF405)
+#define    p_reg_link_mailbox_int   0xF405
+#define reg_link_mailbox_int_pos 5
+#define reg_link_mailbox_int_len 1
+#define reg_link_mailbox_int_lsb 0
+#define xd_p_reg_mailbox_wptr_rst   (*(volatile byte xdata *) 0xF408)
+#define    p_reg_mailbox_wptr_rst   0xF408
+#define reg_mailbox_wptr_rst_pos 0
+#define reg_mailbox_wptr_rst_len 1
+#define reg_mailbox_wptr_rst_lsb 0
+#define xd_p_reg_link_mailbox_wptr  (*(volatile byte xdata *) 0xF409)
+#define    p_reg_link_mailbox_wptr  0xF409
+#define reg_link_mailbox_wptr_pos 0
+#define reg_link_mailbox_wptr_len 8
+#define reg_link_mailbox_wptr_lsb 0
+#define xd_p_reg_link_mailbox_wend  (*(volatile byte xdata *) 0xF410)
+#define    p_reg_link_mailbox_wend  0xF410
+#define reg_link_mailbox_wend_pos 0
+#define reg_link_mailbox_wend_len 1
+#define reg_link_mailbox_wend_lsb 0
+#define xd_p_reg_rd_data_sel    (*(volatile byte xdata *) 0xF411)
+#define    p_reg_rd_data_sel    0xF411
+#define reg_rd_data_sel_pos 0
+#define reg_rd_data_sel_len 2
+#define reg_rd_data_sel_lsb 0
+#define xd_p_reg_fifo_rd_length_7_0 (*(volatile byte xdata *) 0xF412)
+#define    p_reg_fifo_rd_length_7_0 0xF412
+#define reg_fifo_rd_length_7_0_pos 0
+#define reg_fifo_rd_length_7_0_len 8
+#define reg_fifo_rd_length_7_0_lsb 0
+#define xd_p_reg_fifo_rd_length_15_8    (*(volatile byte xdata *) 0xF413)
+#define    p_reg_fifo_rd_length_15_8    0xF413
+#define reg_fifo_rd_length_15_8_pos 0
+#define reg_fifo_rd_length_15_8_len 8
+#define reg_fifo_rd_length_15_8_lsb 8
+#define xd_p_reg_fifo_rd_length_17_16   (*(volatile byte xdata *) 0xF414)
+#define    p_reg_fifo_rd_length_17_16   0xF414
+#define reg_fifo_rd_length_17_16_pos 0
+#define reg_fifo_rd_length_17_16_len 2
+#define reg_fifo_rd_length_17_16_lsb 16
+#define xd_p_reg_rst_fifo_rptr  (*(volatile byte xdata *) 0xF414)
+#define    p_reg_rst_fifo_rptr  0xF414
+#define reg_rst_fifo_rptr_pos 6
+#define reg_rst_fifo_rptr_len 1
+#define reg_rst_fifo_rptr_lsb 0
+#define xd_p_reg_force_sel  (*(volatile byte xdata *) 0xF414)
+#define    p_reg_force_sel  0xF414
+#define reg_force_sel_pos 7
+#define reg_force_sel_len 1
+#define reg_force_sel_lsb 0
+#define xd_p_reg_fifo_rptr_7_0  (*(volatile byte xdata *) 0xF415)
+#define    p_reg_fifo_rptr_7_0  0xF415
+#define reg_fifo_rptr_7_0_pos 0
+#define reg_fifo_rptr_7_0_len 8
+#define reg_fifo_rptr_7_0_lsb 0
+#define xd_p_reg_fifo_rptr_15_8 (*(volatile byte xdata *) 0xF416)
+#define    p_reg_fifo_rptr_15_8 0xF416
+#define reg_fifo_rptr_15_8_pos 0
+#define reg_fifo_rptr_15_8_len 8
+#define reg_fifo_rptr_15_8_lsb 8
+#define xd_p_reg_fifo_rptr_17_16    (*(volatile byte xdata *) 0xF417)
+#define    p_reg_fifo_rptr_17_16    0xF417
+#define reg_fifo_rptr_17_16_pos 0
+#define reg_fifo_rptr_17_16_len 2
+#define reg_fifo_rptr_17_16_lsb 16
+#define xd_p_reg_max_package_size_7_0   (*(volatile byte xdata *) 0xF418)
+#define    p_reg_max_package_size_7_0   0xF418
+#define reg_max_package_size_7_0_pos 0
+#define reg_max_package_size_7_0_len 8
+#define reg_max_package_size_7_0_lsb 0
+#define xd_p_reg_max_package_size_11_8  (*(volatile byte xdata *) 0xF419)
+#define    p_reg_max_package_size_11_8  0xF419
+#define reg_max_package_size_11_8_pos 0
+#define reg_max_package_size_11_8_len 4
+#define reg_max_package_size_11_8_lsb 8
+#define xd_p_reg_dvbt_en    (*(volatile byte xdata *) 0xF41A)
+#define    p_reg_dvbt_en    0xF41A
+#define reg_dvbt_en_pos 0
+#define reg_dvbt_en_len 1
+#define reg_dvbt_en_lsb 0
+#define xd_p_reg_dvbt_bufsize   (*(volatile byte xdata *) 0xF41A)
+#define    p_reg_dvbt_bufsize   0xF41A
+#define reg_dvbt_bufsize_pos 1
+#define reg_dvbt_bufsize_len 1
+#define reg_dvbt_bufsize_lsb 0
+#define xd_p_reg_dvbt_path  (*(volatile byte xdata *) 0xF41A)
+#define    p_reg_dvbt_path  0xF41A
+#define reg_dvbt_path_pos 2
+#define reg_dvbt_path_len 1
+#define reg_dvbt_path_lsb 0
+#define xd_p_reg_dvbt_r5    (*(volatile byte xdata *) 0xF41A)
+#define    p_reg_dvbt_r5    0xF41A
+#define reg_dvbt_r5_pos 3
+#define reg_dvbt_r5_len 1
+#define reg_dvbt_r5_lsb 0
+#define xd_p_reg_mailbox_inten  (*(volatile byte xdata *) 0xF41E)
+#define    p_reg_mailbox_inten  0xF41E
+#define reg_mailbox_inten_pos 4
+#define reg_mailbox_inten_len 1
+#define reg_mailbox_inten_lsb 0
+#define xd_p_reg_dvbt_inten (*(volatile byte xdata *) 0xF41F)
+#define    p_reg_dvbt_inten 0xF41F
+#define reg_dvbt_inten_pos 2
+#define reg_dvbt_inten_len 1
+#define reg_dvbt_inten_lsb 0
+#define xd_r_link_ofsm_ip_length_7_0    (*(volatile byte xdata *) 0xF447)
+#define    r_link_ofsm_ip_length_7_0    0xF447
+#define link_ofsm_ip_length_7_0_pos 0
+#define link_ofsm_ip_length_7_0_len 8
+#define link_ofsm_ip_length_7_0_lsb 0
+#define xd_r_link_ofsm_ip_length_11_8   (*(volatile byte xdata *) 0xF448)
+#define    r_link_ofsm_ip_length_11_8   0xF448
+#define link_ofsm_ip_length_11_8_pos 0
+#define link_ofsm_ip_length_11_8_len 4
+#define link_ofsm_ip_length_11_8_lsb 8
+#define xd_r_link_ofsm_ip_valid (*(volatile byte xdata *) 0xF448)
+#define    r_link_ofsm_ip_valid 0xF448
+#define link_ofsm_ip_valid_pos 7
+#define link_ofsm_ip_valid_len 1
+#define link_ofsm_ip_valid_lsb 0
+#define xd_p_reg_spi_master (*(volatile byte xdata *) 0xF600)
+#define    p_reg_spi_master 0xF600
+#define reg_spi_master_pos 0
+#define reg_spi_master_len 1
+#define reg_spi_master_lsb 0
+#define xd_p_reg_spi_bit    (*(volatile byte xdata *) 0xF601)
+#define    p_reg_spi_bit    0xF601
+#define reg_spi_bit_pos 0
+#define reg_spi_bit_len 2
+#define reg_spi_bit_lsb 0
+#define xd_p_reg_spi_cs (*(volatile byte xdata *) 0xF602)
+#define    p_reg_spi_cs 0xF602
+#define reg_spi_cs_pos 0
+#define reg_spi_cs_len 1
+#define reg_spi_cs_lsb 0
+#define xd_p_reg_spi_polarity   (*(volatile byte xdata *) 0xF602)
+#define    p_reg_spi_polarity   0xF602
+#define reg_spi_polarity_pos 1
+#define reg_spi_polarity_len 1
+#define reg_spi_polarity_lsb 0
+#define xd_p_reg_spi_phase  (*(volatile byte xdata *) 0xF602)
+#define    p_reg_spi_phase  0xF602
+#define reg_spi_phase_pos 2
+#define reg_spi_phase_len 1
+#define reg_spi_phase_lsb 0
+#define xd_p_reg_spi_1st_byte   (*(volatile byte xdata *) 0xF603)
+#define    p_reg_spi_1st_byte   0xF603
+#define reg_spi_1st_byte_pos 0
+#define reg_spi_1st_byte_len 4
+#define reg_spi_1st_byte_lsb 0
+#define xd_p_reg_spi_clk_div    (*(volatile byte xdata *) 0xF603)
+#define    p_reg_spi_clk_div    0xF603
+#define reg_spi_clk_div_pos 4
+#define reg_spi_clk_div_len 4
+#define reg_spi_clk_div_lsb 0
+#define xd_p_reg_spi_rst    (*(volatile byte xdata *) 0xF604)
+#define    p_reg_spi_rst    0xF604
+#define reg_spi_rst_pos 0
+#define reg_spi_rst_len 1
+#define reg_spi_rst_lsb 0
+#define xd_r_reg_spi_tx_done    (*(volatile byte xdata *) 0xF604)
+#define    r_reg_spi_tx_done    0xF604
+#define reg_spi_tx_done_pos 1
+#define reg_spi_tx_done_len 1
+#define reg_spi_tx_done_lsb 0
+#define xd_r_reg_spi_rx_done    (*(volatile byte xdata *) 0xF604)
+#define    r_reg_spi_rx_done    0xF604
+#define reg_spi_rx_done_pos 2
+#define reg_spi_rx_done_len 1
+#define reg_spi_rx_done_lsb 0
+#define xd_p_reg_spi_dbg_sel    (*(volatile byte xdata *) 0xF604)
+#define    p_reg_spi_dbg_sel    0xF604
+#define reg_spi_dbg_sel_pos 3
+#define reg_spi_dbg_sel_len 1
+#define reg_spi_dbg_sel_lsb 0
+#define xd_r_reg_spi_crc_err    (*(volatile byte xdata *) 0xF604)
+#define    r_reg_spi_crc_err    0xF604
+#define reg_spi_crc_err_pos 4
+#define reg_spi_crc_err_len 4
+#define reg_spi_crc_err_lsb 0
+#define xd_r_link_ofsm_usb20_mode   (*(volatile byte xdata *) 0xF613)
+#define    r_link_ofsm_usb20_mode   0xF613
+#define link_ofsm_usb20_mode_pos 0
+#define link_ofsm_usb20_mode_len 1
+#define link_ofsm_usb20_mode_lsb 0
+#define xd_r_link_ofsm_strap_usb20_mode (*(volatile byte xdata *) 0xF613)
+#define    r_link_ofsm_strap_usb20_mode 0xF613
+#define link_ofsm_strap_usb20_mode_pos 1
+#define link_ofsm_strap_usb20_mode_len 1
+#define link_ofsm_strap_usb20_mode_lsb 0
+#define xd_p_reg_link_stick_mem_end_7_0 (*(volatile byte xdata *) 0xF618)
+#define    p_reg_link_stick_mem_end_7_0 0xF618
+#define reg_link_stick_mem_end_7_0_pos 0
+#define reg_link_stick_mem_end_7_0_len 8
+#define reg_link_stick_mem_end_7_0_lsb 0
+#define xd_p_reg_link_stick_mem_end_15_8    (*(volatile byte xdata *) 0xF619)
+#define    p_reg_link_stick_mem_end_15_8    0xF619
+#define reg_link_stick_mem_end_15_8_pos 0
+#define reg_link_stick_mem_end_15_8_len 8
+#define reg_link_stick_mem_end_15_8_lsb 8
+#define xd_p_reg_ofdm_auto_write_addr_l (*(volatile byte xdata *) 0xF61A)
+#define    p_reg_ofdm_auto_write_addr_l 0xF61A
+#define reg_ofdm_auto_write_addr_l_pos 0
+#define reg_ofdm_auto_write_addr_l_len 8
+#define reg_ofdm_auto_write_addr_l_lsb 0
+#define xd_p_reg_ofdm_auto_write_addr_h (*(volatile byte xdata *) 0xF61B)
+#define    p_reg_ofdm_auto_write_addr_h 0xF61B
+#define reg_ofdm_auto_write_addr_h_pos 0
+#define reg_ofdm_auto_write_addr_h_len 8
+#define reg_ofdm_auto_write_addr_h_lsb 0
+#define xd_p_reg_link_auto_write_addr_l (*(volatile byte xdata *) 0xF61C)
+#define    p_reg_link_auto_write_addr_l 0xF61C
+#define reg_link_auto_write_addr_l_pos 0
+#define reg_link_auto_write_addr_l_len 8
+#define reg_link_auto_write_addr_l_lsb 0
+#define xd_p_reg_link_auto_write_addr_h (*(volatile byte xdata *) 0xF61D)
+#define    p_reg_link_auto_write_addr_h 0xF61D
+#define reg_link_auto_write_addr_h_pos 0
+#define reg_link_auto_write_addr_h_len 8
+#define reg_link_auto_write_addr_h_lsb 0
+#define xd_p_reg_mailbox_auto_write_addr    (*(volatile byte xdata *) 0xF61E)
+#define    p_reg_mailbox_auto_write_addr    0xF61E
+#define reg_mailbox_auto_write_addr_pos 0
+#define reg_mailbox_auto_write_addr_len 8
+#define reg_mailbox_auto_write_addr_lsb 0
+#define xd_p_reg_usbmem_auto_write_addr (*(volatile byte xdata *) 0xF61F)
+#define    p_reg_usbmem_auto_write_addr 0xF61F
+#define reg_usbmem_auto_write_addr_pos 0
+#define reg_usbmem_auto_write_addr_len 8
+#define reg_usbmem_auto_write_addr_lsb 0
+#define xd_p_reg_mailbox_auto_read_addr (*(volatile byte xdata *) 0xF620)
+#define    p_reg_mailbox_auto_read_addr 0xF620
+#define reg_mailbox_auto_read_addr_pos 0
+#define reg_mailbox_auto_read_addr_len 8
+#define reg_mailbox_auto_read_addr_lsb 0
+#define xd_p_reg_usbmem_auto_read_addr  (*(volatile byte xdata *) 0xF621)
+#define    p_reg_usbmem_auto_read_addr  0xF621
+#define reg_usbmem_auto_read_addr_pos 0
+#define reg_usbmem_auto_read_addr_len 8
+#define reg_usbmem_auto_read_addr_lsb 0
+#define xd_p_reg_auto_write_ofdm    (*(volatile byte xdata *) 0xF622)
+#define    p_reg_auto_write_ofdm    0xF622
+#define reg_auto_write_ofdm_pos 0
+#define reg_auto_write_ofdm_len 1
+#define reg_auto_write_ofdm_lsb 0
+#define xd_p_reg_auto_write_link    (*(volatile byte xdata *) 0xF622)
+#define    p_reg_auto_write_link    0xF622
+#define reg_auto_write_link_pos 1
+#define reg_auto_write_link_len 1
+#define reg_auto_write_link_lsb 0
+#define xd_p_reg_auto_write_mailbox (*(volatile byte xdata *) 0xF622)
+#define    p_reg_auto_write_mailbox 0xF622
+#define reg_auto_write_mailbox_pos 2
+#define reg_auto_write_mailbox_len 1
+#define reg_auto_write_mailbox_lsb 0
+#define xd_p_reg_auto_write_usbmem  (*(volatile byte xdata *) 0xF622)
+#define    p_reg_auto_write_usbmem  0xF622
+#define reg_auto_write_usbmem_pos 3
+#define reg_auto_write_usbmem_len 1
+#define reg_auto_write_usbmem_lsb 0
+#define xd_p_reg_auto_write_i2cm    (*(volatile byte xdata *) 0xF622)
+#define    p_reg_auto_write_i2cm    0xF622
+#define reg_auto_write_i2cm_pos 4
+#define reg_auto_write_i2cm_len 1
+#define reg_auto_write_i2cm_lsb 0
+#define xd_p_reg_auto_read_mailbox  (*(volatile byte xdata *) 0xF623)
+#define    p_reg_auto_read_mailbox  0xF623
+#define reg_auto_read_mailbox_pos 0
+#define reg_auto_read_mailbox_len 1
+#define reg_auto_read_mailbox_lsb 0
+#define xd_p_reg_auto_read_rom  (*(volatile byte xdata *) 0xF623)
+#define    p_reg_auto_read_rom  0xF623
+#define reg_auto_read_rom_pos 1
+#define reg_auto_read_rom_len 1
+#define reg_auto_read_rom_lsb 0
+#define xd_p_reg_auto_sum_l (*(volatile byte xdata *) 0xF624)
+#define    p_reg_auto_sum_l 0xF624
+#define reg_auto_sum_l_pos 0
+#define reg_auto_sum_l_len 8
+#define reg_auto_sum_l_lsb 0
+#define xd_p_reg_auto_sum_h (*(volatile byte xdata *) 0xF625)
+#define    p_reg_auto_sum_h 0xF625
+#define reg_auto_sum_h_pos 0
+#define reg_auto_sum_h_len 8
+#define reg_auto_sum_h_lsb 0
+#define xd_p_reg_auto_sum_to_h  (*(volatile byte xdata *) 0xF626)
+#define    p_reg_auto_sum_to_h  0xF626
+#define reg_auto_sum_to_h_pos 0
+#define reg_auto_sum_to_h_len 1
+#define reg_auto_sum_to_h_lsb 0
+#define xd_p_reg_auto_sum_en    (*(volatile byte xdata *) 0xF627)
+#define    p_reg_auto_sum_en    0xF627
+#define reg_auto_sum_en_pos 0
+#define reg_auto_sum_en_len 1
+#define reg_auto_sum_en_lsb 0
+#define xd_p_reg_rom_remap_begin_7_0    (*(volatile byte xdata *) 0xF628)
+#define    p_reg_rom_remap_begin_7_0    0xF628
+#define reg_rom_remap_begin_7_0_pos 0
+#define reg_rom_remap_begin_7_0_len 8
+#define reg_rom_remap_begin_7_0_lsb 0
+#define xd_p_reg_rom_remap_begin_15_8   (*(volatile byte xdata *) 0xF629)
+#define    p_reg_rom_remap_begin_15_8   0xF629
+#define reg_rom_remap_begin_15_8_pos 0
+#define reg_rom_remap_begin_15_8_len 8
+#define reg_rom_remap_begin_15_8_lsb 8
+#define xd_p_reg_rom_remap_end_7_0  (*(volatile byte xdata *) 0xF62A)
+#define    p_reg_rom_remap_end_7_0  0xF62A
+#define reg_rom_remap_end_7_0_pos 0
+#define reg_rom_remap_end_7_0_len 8
+#define reg_rom_remap_end_7_0_lsb 0
+#define xd_p_reg_rom_remap_end_15_8 (*(volatile byte xdata *) 0xF62B)
+#define    p_reg_rom_remap_end_15_8 0xF62B
+#define reg_rom_remap_end_15_8_pos 0
+#define reg_rom_remap_end_15_8_len 8
+#define reg_rom_remap_end_15_8_lsb 8
+#define xd_p_reg_rom_remap_delta_7_0    (*(volatile byte xdata *) 0xF62C)
+#define    p_reg_rom_remap_delta_7_0    0xF62C
+#define reg_rom_remap_delta_7_0_pos 0
+#define reg_rom_remap_delta_7_0_len 8
+#define reg_rom_remap_delta_7_0_lsb 0
+#define xd_p_reg_rom_remap_delta_15_8   (*(volatile byte xdata *) 0xF62D)
+#define    p_reg_rom_remap_delta_15_8   0xF62D
+#define reg_rom_remap_delta_15_8_pos 0
+#define reg_rom_remap_delta_15_8_len 8
+#define reg_rom_remap_delta_15_8_lsb 8
+#define xd_p_reg_rom_remap_en   (*(volatile byte xdata *) 0xF62E)
+#define    p_reg_rom_remap_en   0xF62E
+#define reg_rom_remap_en_pos 0
+#define reg_rom_remap_en_len 1
+#define reg_rom_remap_en_lsb 0
+#define xd_p_reg_rom_remap_ofdm (*(volatile byte xdata *) 0xF62E)
+#define    p_reg_rom_remap_ofdm 0xF62E
+#define reg_rom_remap_ofdm_pos 1
+#define reg_rom_remap_ofdm_len 1
+#define reg_rom_remap_ofdm_lsb 0
+#define xd_p_reg_link_cpu_reset (*(volatile byte xdata *) 0xF62F)
+#define    p_reg_link_cpu_reset 0xF62F
+#define reg_link_cpu_reset_pos 0
+#define reg_link_cpu_reset_len 1
+#define reg_link_cpu_reset_lsb 0
+#define xd_p_reg_i2cm_auto_write_addr   (*(volatile byte xdata *) 0xF630)
+#define    p_reg_i2cm_auto_write_addr   0xF630
+#define reg_i2cm_auto_write_addr_pos 0
+#define reg_i2cm_auto_write_addr_len 8
+#define reg_i2cm_auto_write_addr_lsb 0
+#define xd_p_reg_link_bank_float_en (*(volatile byte xdata *) 0xF631)
+#define    p_reg_link_bank_float_en 0xF631
+#define reg_link_bank_float_en_pos 0
+#define reg_link_bank_float_en_len 1
+#define reg_link_bank_float_en_lsb 0
+#define xd_p_reg_link_bank_float_start  (*(volatile byte xdata *) 0xF632)
+#define    p_reg_link_bank_float_start  0xF632
+#define reg_link_bank_float_start_pos 0
+#define reg_link_bank_float_start_len 8
+#define reg_link_bank_float_start_lsb 0
+#define xd_p_reg_link_bank_float_stop   (*(volatile byte xdata *) 0xF633)
+#define    p_reg_link_bank_float_stop   0xF633
+#define reg_link_bank_float_stop_pos 0
+#define reg_link_bank_float_stop_len 8
+#define reg_link_bank_float_stop_lsb 0
+#define xd_p_reg_rom_auto_read_addr_7_0 (*(volatile byte xdata *) 0xF638)
+#define    p_reg_rom_auto_read_addr_7_0 0xF638
+#define reg_rom_auto_read_addr_7_0_pos 0
+#define reg_rom_auto_read_addr_7_0_len 8
+#define reg_rom_auto_read_addr_7_0_lsb 0
+#define xd_p_reg_rom_auto_read_addr_15_8    (*(volatile byte xdata *) 0xF639)
+#define    p_reg_rom_auto_read_addr_15_8    0xF639
+#define reg_rom_auto_read_addr_15_8_pos 0
+#define reg_rom_auto_read_addr_15_8_len 8
+#define reg_rom_auto_read_addr_15_8_lsb 8
+#define xd_p_reg_link_ofsm_dummy_7_0    (*(volatile byte xdata *) 0xF640)
+#define    p_reg_link_ofsm_dummy_7_0    0xF640
+#define reg_link_ofsm_dummy_7_0_pos 0
+#define reg_link_ofsm_dummy_7_0_len 8
+#define reg_link_ofsm_dummy_7_0_lsb 0
+#define xd_p_reg_link_ofsm_dummy_15_8   (*(volatile byte xdata *) 0xF641)
+#define    p_reg_link_ofsm_dummy_15_8   0xF641
+#define reg_link_ofsm_dummy_15_8_pos 0
+#define reg_link_ofsm_dummy_15_8_len 8
+#define reg_link_ofsm_dummy_15_8_lsb 8
+#define xd_p_reg_link_ofsm_dummy_23_16  (*(volatile byte xdata *) 0xF642)
+#define    p_reg_link_ofsm_dummy_23_16  0xF642
+#define reg_link_ofsm_dummy_23_16_pos 0
+#define reg_link_ofsm_dummy_23_16_len 8
+#define reg_link_ofsm_dummy_23_16_lsb 16
+#define xd_p_reg_link_ofsm_dummy_31_24  (*(volatile byte xdata *) 0xF643)
+#define    p_reg_link_ofsm_dummy_31_24  0xF643
+#define reg_link_ofsm_dummy_31_24_pos 0
+#define reg_link_ofsm_dummy_31_24_len 8
+#define reg_link_ofsm_dummy_31_24_lsb 24
+#define xd_p_reg_link_ofsm_dummy_39_32  (*(volatile byte xdata *) 0xF644)
+#define    p_reg_link_ofsm_dummy_39_32  0xF644
+#define reg_link_ofsm_dummy_39_32_pos 0
+#define reg_link_ofsm_dummy_39_32_len 8
+#define reg_link_ofsm_dummy_39_32_lsb 32
+#define xd_p_reg_link_ofsm_dummy_47_40  (*(volatile byte xdata *) 0xF645)
+#define    p_reg_link_ofsm_dummy_47_40  0xF645
+#define reg_link_ofsm_dummy_47_40_pos 0
+#define reg_link_ofsm_dummy_47_40_len 8
+#define reg_link_ofsm_dummy_47_40_lsb 40
+#define xd_p_reg_link_ofsm_dummy_55_48  (*(volatile byte xdata *) 0xF646)
+#define    p_reg_link_ofsm_dummy_55_48  0xF646
+#define reg_link_ofsm_dummy_55_48_pos 0
+#define reg_link_ofsm_dummy_55_48_len 8
+#define reg_link_ofsm_dummy_55_48_lsb 48
+#define xd_p_reg_link_ofsm_dummy_63_56  (*(volatile byte xdata *) 0xF647)
+#define    p_reg_link_ofsm_dummy_63_56  0xF647
+#define reg_link_ofsm_dummy_63_56_pos 0
+#define reg_link_ofsm_dummy_63_56_len 8
+#define reg_link_ofsm_dummy_63_56_lsb 56
+#define xd_p_reg_link_ofsm_dummy_71_64  (*(volatile byte xdata *) 0xF648)
+#define    p_reg_link_ofsm_dummy_71_64  0xF648
+#define reg_link_ofsm_dummy_71_64_pos 0
+#define reg_link_ofsm_dummy_71_64_len 8
+#define reg_link_ofsm_dummy_71_64_lsb 64
+#define xd_p_reg_link_ofsm_dummy_79_72  (*(volatile byte xdata *) 0xF649)
+#define    p_reg_link_ofsm_dummy_79_72  0xF649
+#define reg_link_ofsm_dummy_79_72_pos 0
+#define reg_link_ofsm_dummy_79_72_len 8
+#define reg_link_ofsm_dummy_79_72_lsb 72
+#define xd_p_reg_sdio_mode  (*(volatile byte xdata *) 0xF66F)
+#define    p_reg_sdio_mode  0xF66F
+#define reg_sdio_mode_pos 0
+#define reg_sdio_mode_len 1
+#define reg_sdio_mode_lsb 0
+#define xd_p_reg_lnk2ofdm_data_7_0  (*(volatile byte xdata *) 0xF6A0)
+#define    p_reg_lnk2ofdm_data_7_0  0xF6A0
+#define reg_lnk2ofdm_data_7_0_pos 0
+#define reg_lnk2ofdm_data_7_0_len 8
+#define reg_lnk2ofdm_data_7_0_lsb 0
+#define xd_p_reg_lnk2ofdm_data_15_8 (*(volatile byte xdata *) 0xF6A1)
+#define    p_reg_lnk2ofdm_data_15_8 0xF6A1
+#define reg_lnk2ofdm_data_15_8_pos 0
+#define reg_lnk2ofdm_data_15_8_len 8
+#define reg_lnk2ofdm_data_15_8_lsb 8
+#define xd_p_reg_lnk2ofdm_data_23_16    (*(volatile byte xdata *) 0xF6A2)
+#define    p_reg_lnk2ofdm_data_23_16    0xF6A2
+#define reg_lnk2ofdm_data_23_16_pos 0
+#define reg_lnk2ofdm_data_23_16_len 8
+#define reg_lnk2ofdm_data_23_16_lsb 16
+#define xd_p_reg_lnk2ofdm_data_31_24    (*(volatile byte xdata *) 0xF6A3)
+#define    p_reg_lnk2ofdm_data_31_24    0xF6A3
+#define reg_lnk2ofdm_data_31_24_pos 0
+#define reg_lnk2ofdm_data_31_24_len 8
+#define reg_lnk2ofdm_data_31_24_lsb 24
+#define xd_p_reg_lnk2ofdm_data_39_32    (*(volatile byte xdata *) 0xF6A4)
+#define    p_reg_lnk2ofdm_data_39_32    0xF6A4
+#define reg_lnk2ofdm_data_39_32_pos 0
+#define reg_lnk2ofdm_data_39_32_len 8
+#define reg_lnk2ofdm_data_39_32_lsb 32
+#define xd_p_reg_lnk2ofdm_data_47_40    (*(volatile byte xdata *) 0xF6A5)
+#define    p_reg_lnk2ofdm_data_47_40    0xF6A5
+#define reg_lnk2ofdm_data_47_40_pos 0
+#define reg_lnk2ofdm_data_47_40_len 8
+#define reg_lnk2ofdm_data_47_40_lsb 40
+#define xd_p_reg_lnk2ofdm_data_55_48    (*(volatile byte xdata *) 0xF6A6)
+#define    p_reg_lnk2ofdm_data_55_48    0xF6A6
+#define reg_lnk2ofdm_data_55_48_pos 0
+#define reg_lnk2ofdm_data_55_48_len 8
+#define reg_lnk2ofdm_data_55_48_lsb 48
+#define xd_p_reg_lnk2ofdm_data_63_56    (*(volatile byte xdata *) 0xF6A7)
+#define    p_reg_lnk2ofdm_data_63_56    0xF6A7
+#define reg_lnk2ofdm_data_63_56_pos 0
+#define reg_lnk2ofdm_data_63_56_len 8
+#define reg_lnk2ofdm_data_63_56_lsb 56
+#define xd_p_reg_ofdmtolnk_data_7_0 (*(volatile byte xdata *) 0xF6A8)
+#define    p_reg_ofdmtolnk_data_7_0 0xF6A8
+#define reg_ofdmtolnk_data_7_0_pos 0
+#define reg_ofdmtolnk_data_7_0_len 8
+#define reg_ofdmtolnk_data_7_0_lsb 0
+#define xd_p_reg_ofdmtolnk_data_15_8    (*(volatile byte xdata *) 0xF6A9)
+#define    p_reg_ofdmtolnk_data_15_8    0xF6A9
+#define reg_ofdmtolnk_data_15_8_pos 0
+#define reg_ofdmtolnk_data_15_8_len 8
+#define reg_ofdmtolnk_data_15_8_lsb 8
+#define xd_p_reg_ofdmtolnk_data_23_16   (*(volatile byte xdata *) 0xF6AA)
+#define    p_reg_ofdmtolnk_data_23_16   0xF6AA
+#define reg_ofdmtolnk_data_23_16_pos 0
+#define reg_ofdmtolnk_data_23_16_len 8
+#define reg_ofdmtolnk_data_23_16_lsb 16
+#define xd_p_reg_ofdmtolnk_data_31_24   (*(volatile byte xdata *) 0xF6AB)
+#define    p_reg_ofdmtolnk_data_31_24   0xF6AB
+#define reg_ofdmtolnk_data_31_24_pos 0
+#define reg_ofdmtolnk_data_31_24_len 8
+#define reg_ofdmtolnk_data_31_24_lsb 24
+#define xd_p_reg_ofdmtolnk_data_39_32   (*(volatile byte xdata *) 0xF6AC)
+#define    p_reg_ofdmtolnk_data_39_32   0xF6AC
+#define reg_ofdmtolnk_data_39_32_pos 0
+#define reg_ofdmtolnk_data_39_32_len 8
+#define reg_ofdmtolnk_data_39_32_lsb 32
+#define xd_p_reg_ofdmtolnk_data_47_40   (*(volatile byte xdata *) 0xF6AD)
+#define    p_reg_ofdmtolnk_data_47_40   0xF6AD
+#define reg_ofdmtolnk_data_47_40_pos 0
+#define reg_ofdmtolnk_data_47_40_len 8
+#define reg_ofdmtolnk_data_47_40_lsb 40
+#define xd_p_reg_ofdmtolnk_data_55_48   (*(volatile byte xdata *) 0xF6AE)
+#define    p_reg_ofdmtolnk_data_55_48   0xF6AE
+#define reg_ofdmtolnk_data_55_48_pos 0
+#define reg_ofdmtolnk_data_55_48_len 8
+#define reg_ofdmtolnk_data_55_48_lsb 48
+#define xd_p_reg_ofdmtolnk_data_63_56   (*(volatile byte xdata *) 0xF6AF)
+#define    p_reg_ofdmtolnk_data_63_56   0xF6AF
+#define reg_ofdmtolnk_data_63_56_pos 0
+#define reg_ofdmtolnk_data_63_56_len 8
+#define reg_ofdmtolnk_data_63_56_lsb 56
+#define xd_p_reg_mon51_flag (*(volatile byte xdata *) 0xF6B0)
+#define    p_reg_mon51_flag 0xF6B0
+#define reg_mon51_flag_pos 0
+#define reg_mon51_flag_len 1
+#define reg_mon51_flag_lsb 0
+#define xd_p_reg_force_mon51    (*(volatile byte xdata *) 0xF6B1)
+#define    p_reg_force_mon51    0xF6B1
+#define reg_force_mon51_pos 0
+#define reg_force_mon51_len 1
+#define reg_force_mon51_lsb 0
+#define xd_p_reg_which_cpu  (*(volatile byte xdata *) 0xF6B2)
+#define    p_reg_which_cpu  0xF6B2
+#define reg_which_cpu_pos 0
+#define reg_which_cpu_len 1
+#define reg_which_cpu_lsb 0
+#define xd_p_reg_program_ofdm_code_ready    (*(volatile byte xdata *) 0xF6B3)
+#define    p_reg_program_ofdm_code_ready    0xF6B3
+#define reg_program_ofdm_code_ready_pos 0
+#define reg_program_ofdm_code_ready_len 1
+#define reg_program_ofdm_code_ready_lsb 0
+#define xd_p_reg_link_wr_ofdm_en    (*(volatile byte xdata *) 0xF6B3)
+#define    p_reg_link_wr_ofdm_en    0xF6B3
+#define reg_link_wr_ofdm_en_pos 1
+#define reg_link_wr_ofdm_en_len 1
+#define reg_link_wr_ofdm_en_lsb 0
+#define xd_p_reg_i2c_mode   (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_i2c_mode   0xF6B4
+#define reg_i2c_mode_pos 0
+#define reg_i2c_mode_len 1
+#define reg_i2c_mode_lsb 0
+#define xd_p_reg_sw_reset_sdio  (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_sw_reset_sdio  0xF6B4
+#define reg_sw_reset_sdio_pos 1
+#define reg_sw_reset_sdio_len 1
+#define reg_sw_reset_sdio_lsb 0
+#define xd_p_reg_debug_mpefec_sel   (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_debug_mpefec_sel   0xF6B4
+#define reg_debug_mpefec_sel_pos 2
+#define reg_debug_mpefec_sel_len 1
+#define reg_debug_mpefec_sel_lsb 0
+#define xd_p_reg_lnk_dynamic_clk    (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_lnk_dynamic_clk    0xF6B4
+#define reg_lnk_dynamic_clk_pos 3
+#define reg_lnk_dynamic_clk_len 1
+#define reg_lnk_dynamic_clk_lsb 0
+#define xd_p_reg_lnk_free_clk   (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_lnk_free_clk   0xF6B4
+#define reg_lnk_free_clk_pos 4
+#define reg_lnk_free_clk_len 1
+#define reg_lnk_free_clk_lsb 0
+#define xd_p_reg_i2c_sample_rate_up_en  (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_i2c_sample_rate_up_en  0xF6B4
+#define reg_i2c_sample_rate_up_en_pos 5
+#define reg_i2c_sample_rate_up_en_len 1
+#define reg_i2c_sample_rate_up_en_lsb 0
+#define xd_p_reg_i2c_start_patch    (*(volatile byte xdata *) 0xF6B4)
+#define    p_reg_i2c_start_patch    0xF6B4
+#define reg_i2c_start_patch_pos 6
+#define reg_i2c_start_patch_len 1
+#define reg_i2c_start_patch_lsb 0
+#define xd_p_reg_link_i2cs_msb  (*(volatile byte xdata *) 0xF6B5)
+#define    p_reg_link_i2cs_msb  0xF6B5
+#define reg_link_i2cs_msb_pos 1
+#define reg_link_i2cs_msb_len 1
+#define reg_link_i2cs_msb_lsb 0
+#define xd_p_reg_link_ofsm_dbg_en   (*(volatile byte xdata *) 0xF6B5)
+#define    p_reg_link_ofsm_dbg_en   0xF6B5
+#define reg_link_ofsm_dbg_en_pos 4
+#define reg_link_ofsm_dbg_en_len 1
+#define reg_link_ofsm_dbg_en_lsb 0
+#define xd_p_reg_link_i2c_dbg_sel   (*(volatile byte xdata *) 0xF6B5)
+#define    p_reg_link_i2c_dbg_sel   0xF6B5
+#define reg_link_i2c_dbg_sel_pos 5
+#define reg_link_i2c_dbg_sel_len 1
+#define reg_link_i2c_dbg_sel_lsb 0
+#define xd_p_reg_fast_slow_train    (*(volatile byte xdata *) 0xF6DD)
+#define    p_reg_fast_slow_train    0xF6DD
+#define xd_p_reg_lnk2ofdm_int   (*(volatile byte xdata *) 0xF6DE)
+#define    p_reg_lnk2ofdm_int   0xF6DE
+#define reg_lnk2ofdm_int_pos 0
+#define reg_lnk2ofdm_int_len 1
+#define reg_lnk2ofdm_int_lsb 0
+#define xd_p_reg_ofdm2lnk_int   (*(volatile byte xdata *) 0xF6DF)
+#define    p_reg_ofdm2lnk_int   0xF6DF
+#define reg_ofdm2lnk_int_pos 0
+#define reg_ofdm2lnk_int_len 1
+#define reg_ofdm2lnk_int_lsb 0
+#define xd_p_reg_load_ofdm_reg  (*(volatile byte xdata *) 0xF6E4)
+#define    p_reg_load_ofdm_reg  0xF6E4
+#define xd_p_link_ofsm_cmd_reg  (*(volatile byte xdata *) 0xF6EA)
+#define    p_link_ofsm_cmd_reg  0xF6EA
+#define link_ofsm_cmd_reg_pos 0
+#define link_ofsm_cmd_reg_len 8
+#define link_ofsm_cmd_reg_lsb 0
+#define xd_p_link_ofsm_addr_reg_h   (*(volatile byte xdata *) 0xF6EB)
+#define    p_link_ofsm_addr_reg_h   0xF6EB
+#define link_ofsm_addr_reg_h_pos 0
+#define link_ofsm_addr_reg_h_len 8
+#define link_ofsm_addr_reg_h_lsb 0
+#define xd_p_link_ofsm_addr_reg_l   (*(volatile byte xdata *) 0xF6EC)
+#define    p_link_ofsm_addr_reg_l   0xF6EC
+#define link_ofsm_addr_reg_l_pos 0
+#define link_ofsm_addr_reg_l_len 8
+#define link_ofsm_addr_reg_l_lsb 0
+#define xd_p_link_ofsm_data_reg_0   (*(volatile byte xdata *) 0xF6ED)
+#define    p_link_ofsm_data_reg_0   0xF6ED
+#define link_ofsm_data_reg_0_pos 0
+#define link_ofsm_data_reg_0_len 8
+#define link_ofsm_data_reg_0_lsb 0
+#define xd_p_link_ofsm_data_reg_1   (*(volatile byte xdata *) 0xF6EE)
+#define    p_link_ofsm_data_reg_1   0xF6EE
+#define link_ofsm_data_reg_1_pos 0
+#define link_ofsm_data_reg_1_len 8
+#define link_ofsm_data_reg_1_lsb 0
+#define xd_p_link_ofsm_data_reg_2   (*(volatile byte xdata *) 0xF6EF)
+#define    p_link_ofsm_data_reg_2   0xF6EF
+#define link_ofsm_data_reg_2_pos 0
+#define link_ofsm_data_reg_2_len 8
+#define link_ofsm_data_reg_2_lsb 0
+#define xd_p_link_ofsm_data_reg_3   (*(volatile byte xdata *) 0xF6F0)
+#define    p_link_ofsm_data_reg_3   0xF6F0
+#define link_ofsm_data_reg_3_pos 0
+#define link_ofsm_data_reg_3_len 8
+#define link_ofsm_data_reg_3_lsb 0
+#define xd_p_link_ofsm_data_reg_4   (*(volatile byte xdata *) 0xF6F1)
+#define    p_link_ofsm_data_reg_4   0xF6F1
+#define link_ofsm_data_reg_4_pos 0
+#define link_ofsm_data_reg_4_len 8
+#define link_ofsm_data_reg_4_lsb 0
+#define xd_p_link_ofsm_data_reg_5   (*(volatile byte xdata *) 0xF6F2)
+#define    p_link_ofsm_data_reg_5   0xF6F2
+#define link_ofsm_data_reg_5_pos 0
+#define link_ofsm_data_reg_5_len 8
+#define link_ofsm_data_reg_5_lsb 0
+#define xd_p_link_ofsm_data_reg_6   (*(volatile byte xdata *) 0xF6F3)
+#define    p_link_ofsm_data_reg_6   0xF6F3
+#define link_ofsm_data_reg_6_pos 0
+#define link_ofsm_data_reg_6_len 8
+#define link_ofsm_data_reg_6_lsb 0
+#define xd_p_link_ofsm_data_reg_7   (*(volatile byte xdata *) 0xF6F4)
+#define    p_link_ofsm_data_reg_7   0xF6F4
+#define link_ofsm_data_reg_7_pos 0
+#define link_ofsm_data_reg_7_len 8
+#define link_ofsm_data_reg_7_lsb 0
+#define xd_p_link_ofsm_data_reg_8   (*(volatile byte xdata *) 0xF6F5)
+#define    p_link_ofsm_data_reg_8   0xF6F5
+#define link_ofsm_data_reg_8_pos 0
+#define link_ofsm_data_reg_8_len 8
+#define link_ofsm_data_reg_8_lsb 0
+#define xd_p_link_ofsm_data_reg_9   (*(volatile byte xdata *) 0xF6F6)
+#define    p_link_ofsm_data_reg_9   0xF6F6
+#define link_ofsm_data_reg_9_pos 0
+#define link_ofsm_data_reg_9_len 8
+#define link_ofsm_data_reg_9_lsb 0
+#define xd_p_link_ofsm_data_reg_10  (*(volatile byte xdata *) 0xF6F7)
+#define    p_link_ofsm_data_reg_10  0xF6F7
+#define link_ofsm_data_reg_10_pos 0
+#define link_ofsm_data_reg_10_len 8
+#define link_ofsm_data_reg_10_lsb 0
+#define xd_p_link_ofsm_data_reg_11  (*(volatile byte xdata *) 0xF6F8)
+#define    p_link_ofsm_data_reg_11  0xF6F8
+#define link_ofsm_data_reg_11_pos 0
+#define link_ofsm_data_reg_11_len 8
+#define link_ofsm_data_reg_11_lsb 0
+#define xd_p_link_ofsm_data_reg_12  (*(volatile byte xdata *) 0xF6F9)
+#define    p_link_ofsm_data_reg_12  0xF6F9
+#define link_ofsm_data_reg_12_pos 0
+#define link_ofsm_data_reg_12_len 8
+#define link_ofsm_data_reg_12_lsb 0
+#define xd_p_link_ofsm_data_reg_13  (*(volatile byte xdata *) 0xF6FA)
+#define    p_link_ofsm_data_reg_13  0xF6FA
+#define link_ofsm_data_reg_13_pos 0
+#define link_ofsm_data_reg_13_len 8
+#define link_ofsm_data_reg_13_lsb 0
+#define xd_p_link_ofsm_data_reg_14  (*(volatile byte xdata *) 0xF6FB)
+#define    p_link_ofsm_data_reg_14  0xF6FB
+#define link_ofsm_data_reg_14_pos 0
+#define link_ofsm_data_reg_14_len 8
+#define link_ofsm_data_reg_14_lsb 0
+#define xd_p_link_ofsm_data_reg_15  (*(volatile byte xdata *) 0xF6FC)
+#define    p_link_ofsm_data_reg_15  0xF6FC
+#define link_ofsm_data_reg_15_pos 0
+#define link_ofsm_data_reg_15_len 8
+#define link_ofsm_data_reg_15_lsb 0
+#define xd_p_reg_debug_mux  (*(volatile byte xdata *) 0xF6FE)
+#define    p_reg_debug_mux  0xF6FE
+#define reg_debug_mux_pos 3
+#define reg_debug_mux_len 1
+#define reg_debug_mux_lsb 0
+#define xd_p_reg_top_gpioon0    (*(volatile byte xdata *) 0xF6FF)
+#define    p_reg_top_gpioon0    0xF6FF
+#define reg_top_gpioon0_pos 0
+#define reg_top_gpioon0_len 1
+#define reg_top_gpioon0_lsb 0
+#define xd_p_reg_p_dmb_phy_is_dvb   (*(volatile byte xdata *) 0xDC31)
+#define    p_reg_p_dmb_phy_is_dvb   0xDC31
+#define reg_p_dmb_phy_is_dvb_pos 0
+#define reg_p_dmb_phy_is_dvb_len 1
+#define reg_p_dmb_phy_is_dvb_lsb 0
+#define xd_p_reg_p_dmb_xt_reset (*(volatile byte xdata *) 0xDC32)
+#define    p_reg_p_dmb_xt_reset 0xDC32
+#define reg_p_dmb_xt_reset_pos 0
+#define reg_p_dmb_xt_reset_len 1
+#define reg_p_dmb_xt_reset_lsb 0
+#define xd_p_reg_p_dmb_sw_reset (*(volatile byte xdata *) 0xDC33)
+#define    p_reg_p_dmb_sw_reset 0xDC33
+#define reg_p_dmb_sw_reset_pos 0
+#define reg_p_dmb_sw_reset_len 1
+#define reg_p_dmb_sw_reset_lsb 0
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.c	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,4668 @@
+#include "a867_standard.h"
+//#include <math.h>
+#include "a867_cmd.h"
+#include "a867_user.h"
+#include "a867_af903x.h"
+
+// turn on/off debug in this file
+#define DEBUG_STANDARD	0
+
+#if !DEBUG_STANDARD
+	#undef deb_info
+	#define deb_info(fmt, args...) do {} while(0)
+#endif
+
+#include "a867_firmware.h"
+
+#define Standard_MAX_BIT                8
+#define Standard_MAX_CLOCK              12
+#define Standard_MAX_BAND               3
+
+
+const Byte Standard_bitMask[Standard_MAX_BIT] = {
+    0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF
+};
+
+const ClockTable Standard_clockTable[Standard_MAX_CLOCK] =
+{
+    {   20480,      20480000    },      /** FPGA     */
+    {   16384,      20480000    },      /** 16.38MHz */
+    {   20480,      20480000    },      /** 20.48MHz */
+    {   36000,      20250000    },      /** 36.00MHz */
+    {   30000,      20156250    },      /** 30.00MHz */
+    {   26000,      20583333    },      /** 26.00MHz */
+    {   28000,      20416667    },      /** 28.00MHz */
+    {   32000,      20500000    },      /** 32.00MHz */
+    {   34000,      20187500    },      /** 34.00MHz */
+    {   24000,      20500000    },      /** 24.00MHz */
+    {   22000,      20625000    },      /** 22.00MHz */
+    {   12000,      20250000    }       /** 12.00MHz */
+};
+
+const BandTable Standard_bandTable[Standard_MAX_BAND] =
+{
+    {    174000,     230000     },      /** VHF    */
+    {    350000,     900000     },      /** UHF    */
+    {   1670000,    1680000     }       /** L-BAND */
+};
+
+#if User_USE_DRIVER
+Dword Standard_getDriver (
+    IN  Demodulator*    demodulator,
+    OUT Handle*         handle
+) {
+    Dword error = Error_NO_ERROR;
+    TCHAR registry1[100] = TEXT("\\Drivers\\SDCARD\\ClientDrivers\\Custom\\MANF-0296-CARDID-5347-FUNC-1");
+    TCHAR registry2[100] = TEXT("\\Drivers\\SDCARD\\ClientDrivers\\Custom\\MANF-03BE-CARDID-0001-FUNC-1");
+    TCHAR name[256];
+    TCHAR shortBuffer[32];
+    DWORD len = 16;
+    DWORD i;
+    HKEY hKey, hSubKey;
+    DWORD size;
+
+    /** Open the HKLM\Drivers\Active key in registry */
+    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Drivers\\Active"), 0, 0, &hKey) == ERROR_SUCCESS) {
+        /** Get subkeys count */
+        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &i, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
+            /** Browse subkeys in reverse order (pluggable cards are not at the beginning of the list !) */
+            while (i) {
+                i--;
+                /** Select the subkey */
+                size = sizeof(shortBuffer);
+                if (RegEnumKeyEx(hKey, i, shortBuffer, &size, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
+                    /** Open the subkey */
+                    shortBuffer[sizeof(shortBuffer)-1] = '\0';
+                    _stprintf(name, TEXT("Drivers\\Active\\%s"), shortBuffer);
+                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, name, 0, 0, &hSubKey) == ERROR_SUCCESS) {
+                        size = sizeof(name);
+                        if (RegQueryValueEx(hSubKey, TEXT("Key"), NULL, NULL, (LPBYTE) name, &size) == ERROR_SUCCESS) {
+                            if ((_tcsncmp(name, registry1, _tcsclen(registry1)) == 0) || (_tcsncmp(name, registry2, _tcsclen(registry2)) == 0)) {
+                                /** This is the good PnPID, now get the serial com in the "Name" value */
+                                size = len;
+                                if (RegQueryValueEx(hSubKey, TEXT("Name"), NULL, NULL, (LPBYTE) name, &size) == ERROR_SUCCESS) {
+                                    /** Found ! */
+                                    RegCloseKey(hSubKey);
+                                    RegCloseKey(hKey);
+                                    /** OK */
+                                    goto exit;
+                                }
+                            }
+                        }
+
+                    /** Close the subkey */
+                    RegCloseKey(hSubKey);
+                    }
+                }
+            }
+        }
+    }
+    /** Close the key */
+    RegCloseKey(hKey);
+
+exit :
+    *handle = CreateFile (name, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
+
+    return (error);
+}
+#endif
+
+
+Dword Standard_writeRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            value
+) {
+    Dword ret;
+//    deb_info("Enter %s -\n", __FUNCTION__);
+    ret = (Standard_writeRegisters (demodulator, chip, processor, registerAddress, 1, &value));
+    if(ret) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, ret);
+    }
+    return ret;
+		  
+}
+
+
+Dword Standard_writeRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    WriteRegistersRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.processor = processor;
+        request.registerAddress = registerAddress;
+        request.bufferLength = bufferLength;
+        User_memoryCopy (demodulator, request.buffer, buffer, bufferLength);
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_WRITEREGISTERS,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte registerAddressLength;
+    Ganymede* ganymede;
+
+//    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (processor == Processor_LINK) {
+        if (registerAddress > 0x000000FF) {
+            registerAddressLength = 2;
+        } else {
+            registerAddressLength = 1;
+        }
+    } else {
+            registerAddressLength = 2;
+    }
+    if (ganymede->cmdDescription->writeRegisters != NULL) {
+        error = ganymede->cmdDescription->writeRegisters (demodulator, chip, processor, registerAddress, registerAddressLength, bufferLength, buffer);
+    }
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_writeScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+) {
+    Dword error = Error_NO_ERROR;
+    Byte valueSetsAddressLength;
+    Ganymede* ganymede;
+
+//    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (processor == Processor_LINK) {
+        valueSetsAddressLength = 2;
+    } else {
+        valueSetsAddressLength = 2;
+    }
+    if (ganymede->cmdDescription->writeScatterRegisters != NULL) {
+        error = ganymede->cmdDescription->writeScatterRegisters (demodulator, chip, processor, valueSetsAddressLength, valueSetsLength, valueSets);
+    }
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_writeTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->cmdDescription->writeTunerRegisters != NULL) {
+        error = ganymede->cmdDescription->writeTunerRegisters (demodulator, chip, ganymede->tunerDescription->tunerAddress, registerAddress, ganymede->tunerDescription->registerAddressLength, bufferLength, buffer);
+    }
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_writeGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    Byte writeBuffer[256];
+    Byte i;
+    Ganymede* ganymede;
+    Dword error;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    writeBuffer[0] = bufferLength;
+    writeBuffer[1] = interfaceIndex;
+    writeBuffer[2] = slaveAddress;
+
+    for (i = 0; i < bufferLength; i++) {
+        writeBuffer[3 + i] = buffer[i];
+    }
+    error = (Standard_sendCommand (demodulator, Command_GENERIC_WRITE, chip, Processor_LINK, bufferLength + 3, writeBuffer, 0, NULL));
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return error;
+}
+
+
+Dword Standard_writeEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    WriteEepromValuesRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.registerAddress = registerAddress;
+        request.bufferLength = bufferLength;
+        User_memoryCopy (demodulator, request.buffer, buffer, bufferLength);
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_WRITEEEPROMVALUES,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte eepromAddress;
+    Byte registerAddressLength;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Read EEPROM address. */
+    /*error = ganymede->cmdDescription.readRegisters (demodulator, chip, Processor_LINK, 0xBFF0, 1, &eepromAddress);
+    if (error) goto exit;
+    */
+    eepromAddress = 0x01;
+
+    /** Read EEPROM valid length of register. */
+    /*error = ganymede->cmdDescription.readRegisters (demodulator, chip, Processor_LINK, 0xBFF1, 1, &registerAddressLength);
+    if (error) goto exit;
+    */
+    registerAddressLength = 0x01;
+
+    if (ganymede->cmdDescription->writeEepromValues != NULL) {
+        error = ganymede->cmdDescription->writeEepromValues (demodulator, chip, eepromAddress, registerAddress, registerAddressLength, bufferLength, buffer);
+    }
+
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_writeRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    WriteRegisterBitsRequest request;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.processor = processor;
+        request.registerAddress = registerAddress;
+        request.position = position;
+        request.length = length;
+        request.value = value;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_WRITEREGISTERBITS,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte registerAddressLength;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (processor == Processor_LINK) {
+        if (registerAddress > 0x000000FF) {
+            registerAddressLength = 2;
+        } else {
+            registerAddressLength = 1;
+        }
+    } else {
+        registerAddressLength = 2;
+    }
+    if (length == 8) {
+        if (ganymede->cmdDescription->writeRegisters != NULL) {
+            error = ganymede->cmdDescription->writeRegisters (demodulator, chip, processor, registerAddress, registerAddressLength, 1, &value);
+        }
+    } else {
+        if (ganymede->cmdDescription->modifyRegister != NULL) {
+            error = ganymede->cmdDescription->modifyRegister (demodulator, chip, processor, registerAddress, registerAddressLength, position, length, value);
+        }
+    }
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_readRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    OUT Byte*           value
+) {
+    Dword error;
+//    deb_info("Enter %s -\n", __FUNCTION__);
+
+    error = (Standard_readRegisters (demodulator, chip, processor, registerAddress, 1, value));
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return error;
+}
+
+
+Dword Standard_readRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    ReadRegistersRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.processor = processor;
+        request.registerAddress = registerAddress;
+        request.bufferLength = bufferLength;
+        request.buffer = buffer;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_READREGISTERS,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte registerAddressLength;
+    Ganymede* ganymede;
+
+//    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (processor == Processor_LINK) {
+        if (registerAddress > 0x000000FF) {
+            registerAddressLength = 2;
+        } else {
+            registerAddressLength = 1;
+        }
+    } else {
+        registerAddressLength = 2;
+    }
+    if (ganymede->cmdDescription->readRegisters != NULL) {
+        error = ganymede->cmdDescription->readRegisters (demodulator, chip, processor, registerAddress, registerAddressLength, bufferLength, buffer);
+    }
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_readScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+) {
+    Dword error = Error_NO_ERROR;
+    Byte valueSetsAddressLength;
+    Ganymede* ganymede;
+
+//    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (processor == Processor_LINK) {
+        valueSetsAddressLength = 2;
+    } else {
+        valueSetsAddressLength = 2;
+    }
+
+    if (ganymede->cmdDescription->readScatterRegisters != NULL) {
+        error = ganymede->cmdDescription->readScatterRegisters (demodulator, chip, processor, valueSetsAddressLength, valueSetsLength, valueSets);
+    }
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_readTunerRegisters (
+	IN  Demodulator*    demodulator,
+	IN  Byte            chip,
+	IN  Word            registerAddress,
+	IN  Byte            bufferLength,
+	IN  Byte*           buffer
+) {
+	Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+	DWORD number;
+	BOOL result;
+	ReadTunerRegistersRequest request;
+	Ganymede* ganymede;
+
+	ganymede = (Ganymede*) demodulator;
+
+	if (ganymede->driver != NULL) {
+		request.chip = chip;
+		request.registerAddress = registerAddress;
+		request.bufferLength = bufferLength;
+		request.buffer = buffer;
+		result = DeviceIoControl (
+					ganymede->driver,
+					IOCTL_AFA_DEMOD_READTUNERREGISTERS,
+					&request,
+					sizeof (request),
+					NULL,
+					0,
+					&number,
+					NULL
+		);
+		error = request.error;
+	} else {
+		error = Error_DRIVER_INVALID;
+	}
+#else
+	Ganymede* ganymede;
+
+	deb_info("Enter %s -\n", __FUNCTION__);
+	ganymede = (Ganymede*) demodulator;
+
+	if (ganymede->cmdDescription->readTunerRegisters != NULL) {
+
+	if (registerAddress == 0xffff && ganymede->tunerDescription->registerAddressLength == 1)
+	{
+		error = ganymede->cmdDescription->readTunerRegisters (demodulator, chip, 
+		ganymede->tunerDescription->tunerAddress, registerAddress, 0, bufferLength, buffer);
+	}
+	else
+	{
+		error = ganymede->cmdDescription->readTunerRegisters (demodulator, chip, 
+		ganymede->tunerDescription->tunerAddress, registerAddress, 
+		ganymede->tunerDescription->registerAddressLength, bufferLength, buffer);
+	}
+    }
+#endif
+
+	if(error) 
+	{
+		deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+	}
+	return (error);
+}
+
+
+Dword Standard_readGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+) {
+    Byte writeBuffer[3];
+    Ganymede* ganymede;
+    Dword error;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    writeBuffer[0] = bufferLength;
+    writeBuffer[1] = interfaceIndex;
+    writeBuffer[2] = slaveAddress;
+
+    error = (Standard_sendCommand (demodulator, Command_GENERIC_READ, chip, Processor_LINK, 3, writeBuffer, bufferLength, buffer));
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return error;
+}
+
+
+Dword Standard_readEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    ReadEepromValuesRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.registerAddress = registerAddress;
+        request.bufferLength = bufferLength;
+        request.buffer = buffer;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_READEEPROMVALUES,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte eepromAddress;
+    Byte registerAddressLength;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Read EEPROM address. */
+    /*error = ganymede->cmdDescription.readRegisters (demodulator, chip, Processor_LINK, 0xBFF0, 1, &eepromAddress);
+    if (error) goto exit;
+    */
+    eepromAddress = 0x01;
+
+    /** Read EEPROM valid length of register. */
+    /*error = ganymede->cmdDescription.readRegisters (demodulator, chip, Processor_LINK, 0xBFF1, 1, &registerAddressLength);
+    if (error) goto exit;
+    */
+    registerAddressLength = 0x01;
+
+    if (ganymede->cmdDescription->readEepromValues != NULL) {
+        error = ganymede->cmdDescription->readEepromValues (demodulator, chip, eepromAddress, registerAddress, registerAddressLength, bufferLength, buffer);
+    }
+
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_readRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    OUT Byte*           value
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    ReadRegisterBitsRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.processor = processor;
+        request.registerAddress = registerAddress;
+        request.position = position;
+        request.length = length;
+        request.value = value;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_READREGISTERBITS,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte temp = 0;
+    Byte registerAddressLength;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (processor == Processor_LINK) {
+        if (registerAddress > 0x000000FF) {
+            registerAddressLength = 2;
+        } else {
+            registerAddressLength = 1;
+        }
+    } else {
+        registerAddressLength = 2;
+    }
+    if (ganymede->cmdDescription->readRegisters != NULL) {
+        error = ganymede->cmdDescription->readRegisters (demodulator, chip, processor, registerAddress, registerAddressLength, 1, &temp);
+    }
+    if (error) goto exit;
+
+    if (length == 8) {
+        *value = temp;
+    } else {
+        temp = REG_GET (temp, position, length);
+        *value = temp;
+    }
+
+#endif
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_sendCommand (
+    IN  Demodulator*    demodulator,
+    OUT Word            command,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->cmdDescription->sendCommand != NULL) {
+        error = ganymede->cmdDescription->sendCommand (demodulator, command, chip, processor, writeBufferLength, writeBuffer, readBufferLength, readBuffer);
+    }
+#endif
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getHardwareVersion (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          version
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte hwVer0;
+    Byte hwVer1;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_readRegister (demodulator, 0, Processor_OFDM, 0xFFF0, &hwVer0);
+    if (error) goto exit;
+    error = Standard_readRegister (demodulator, 0, Processor_OFDM, 0xFFF1, &hwVer1);
+    if (error) goto exit;
+
+    /** HW Version = HWVer + Top_Ver */
+    *version = (Dword) (hwVer1 << 8) + (Dword) hwVer0;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getFirmwareVersion (
+    IN  Demodulator*    demodulator,
+    IN  Processor       processor,
+    OUT Dword*          version
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    GetFirmwareVersionRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.processor = processor;
+        request.version = version;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_GETFIRMWAREVERSION,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte writeBuffer[1];
+    Byte readBuffer[4];
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if ((ganymede->busId == Bus_I2M) || (ganymede->busId == Bus_I2U)) {
+        *version = 0xFFFFFFFF;
+        goto exit;
+    }
+
+    writeBuffer[0] = 1;
+    error = Standard_sendCommand (demodulator, Command_QUERYINFO, 0, processor, 1, writeBuffer, 4, readBuffer);
+    if (error) goto exit;
+
+    *version = (Dword) (((Dword) readBuffer[0] << 24) + ((Dword) readBuffer[1] << 16) + ((Dword) readBuffer[2] << 8) + (Dword) readBuffer[3]);
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getPostVitBer (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Dword*          postErrorCount,  /** 24 bits */
+    OUT Dword*          postBitCount,    /** 16 bits */
+    OUT Word*           abortCount
+) {
+    Dword error = Error_NO_ERROR;
+    Dword errorCount;
+    Dword bitCount;
+    Byte buffer[7];
+    Word abort;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    *postErrorCount = 0;
+    *postBitCount  = 0;
+
+    error = Standard_readRegisters (demodulator, chip, Processor_OFDM, rsd_abort_packet_cnt_7_0, r_rsd_packet_unit_15_8 - rsd_abort_packet_cnt_7_0 + 1, buffer);
+    if (error) goto exit;
+
+    abort = ((Word) buffer[rsd_abort_packet_cnt_15_8 - rsd_abort_packet_cnt_7_0] << 8) + buffer[rsd_abort_packet_cnt_7_0 - rsd_abort_packet_cnt_7_0];
+    errorCount = ((Dword) buffer[rsd_bit_err_cnt_23_16 - rsd_abort_packet_cnt_7_0] << 16) + ((Dword) buffer[rsd_bit_err_cnt_15_8 - rsd_abort_packet_cnt_7_0] << 8) + buffer[rsd_bit_err_cnt_7_0 - rsd_abort_packet_cnt_7_0];
+    bitCount = ((Dword) buffer[r_rsd_packet_unit_15_8 - rsd_abort_packet_cnt_7_0] << 8) + buffer[r_rsd_packet_unit_7_0 - rsd_abort_packet_cnt_7_0];
+    if (bitCount == 0) {
+        /*error = Error_RSD_PKT_CNT_0;*/
+        *postErrorCount = 1;
+        *postBitCount = 2;
+        *abortCount = 1000;
+        goto exit;
+    }
+
+    *abortCount = abort;
+    bitCount = bitCount - (Dword)abort;
+    if (bitCount == 0) {
+        *postErrorCount = 1;
+        *postBitCount  = 2;
+    } else {
+        *postErrorCount = errorCount - (Dword) abort * 8 * 8;
+        *postBitCount  = bitCount * 204 * 8;
+    }
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_resetPostVitErrorCount (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+) {
+    Dword error = Error_NO_ERROR;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    /** Reset counter for next time we get post Viterbi BER */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_reg_rsd_ber_rdy, reg_rsd_ber_rdy_pos, reg_rsd_ber_rdy_len, 1);
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_wordToInt (
+    IN  Demodulator*    demodulator,
+    short*              value,
+    Word                input
+) {
+    Dword error = Error_NO_ERROR;
+    short volt;
+    //Dword dwUpVoltX100 = 330;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    input = input & 0x03FF;
+
+    if (input >= 512) {
+        volt = (short) input - (short) 0x400ul;
+    } else {
+        volt = (short) input;
+    }
+
+    *value = volt;
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getRfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           rfAgc
+) {
+    Dword   error = Error_NO_ERROR;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+#if User_USE_DRIVER
+#else
+    /** get rf_agc_control */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, r_reg_aagc_rf_gain, reg_aagc_rf_gain_pos, reg_aagc_rf_gain_len, rfAgc);
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getIfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           ifAgc
+) {
+    Dword error = Error_NO_ERROR;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+#if User_USE_DRIVER
+#else
+    /** get if_agc_control */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, r_reg_aagc_if_gain, reg_aagc_if_gain_pos, reg_aagc_if_gain_len, ifAgc);
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Word            registerHi,
+    IN  Word            registerLo,
+    IN  Byte            position,
+    IN  Byte            length,
+    OUT Word            *value
+) {
+    Dword error = Error_NO_ERROR;
+    Byte temp0;
+    Byte temp1;
+    deb_info("Enter %s -\n", __FUNCTION__);
+
+    error = Standard_readRegister (demodulator, 0, Processor_OFDM, registerLo, &temp0);
+    if (error) goto exit;
+    error = Standard_readRegisterBits (demodulator, 0, Processor_OFDM, registerHi, position, length, &temp1);
+    if (error) goto exit;
+
+    *value = (Word) (temp1 << 8) + (Word) temp0;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Word            registerHi,
+    IN  Word            registerLo,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Word            value
+) {
+    Dword error = Error_NO_ERROR;
+    Byte temp0;
+    Byte temp1;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    temp0 = (Byte) (value & 0x00FF);
+    temp1 = (Byte) ((value & 0x0300) >> 8);
+
+    error = Standard_writeRegister (demodulator, 0, Processor_OFDM, registerLo, temp0);
+    if (error) goto exit;
+    error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, registerHi, position, length, temp1);
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_resetAgc (
+    IN  Demodulator*    demodulator
+) {
+    Dword error = Error_NO_ERROR;
+    //Byte temp = 0;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_aagc_top_th_dis, reg_aagc_top_th_dis_pos, reg_aagc_top_th_dis_len, 0x00);
+    if (error) goto exit;
+    error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_aagc_top_reload, reg_aagc_top_reload_pos, reg_aagc_top_reload_len, 0x01);
+    if (error) goto exit;
+    error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_agc_rst, reg_agc_rst_pos, reg_agc_rst_len, 0x01);
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getSignalQuality (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           quality
+) {
+    Dword error = Error_NO_ERROR;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_readRegister (demodulator, chip, Processor_OFDM, signal_quality, quality);
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getSignalStrength (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           strength
+) {
+    Dword error = Error_NO_ERROR;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_readRegister (demodulator, chip, Processor_OFDM, signal_strength, strength);
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getSignalStrengthDbm (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Long            rfpullUpVolt_X10,     /** RF pull up voltage multiplied by 10 */
+    IN  Long            ifpullUpVolt_X10,     /** IF pull up voltage multiplied by 10 */
+    OUT Long*           strengthDbm           /** DBm                                 */
+)
+{
+    Dword error = Error_NO_ERROR;
+    Byte temp;
+    deb_info("Enter %s -\n", __FUNCTION__);
+
+    if ((rfpullUpVolt_X10 == 0) || (ifpullUpVolt_X10 == 0)) {
+        error = Error_INV_PULLUP_VOLT;
+        goto exit;
+    }
+
+    error = Standard_readRegister (demodulator, chip, Processor_OFDM, est_rf_level_dbm, &temp);
+    if (error) goto exit;
+
+    *strengthDbm = (Long) (temp * -1);
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_divider (
+    IN  Demodulator*    demodulator,
+    IN  Dword           a,
+    IN  Dword           b,
+    IN  Dword           x
+) {
+    Dword answer = 0;
+    Dword c = 0;
+    Dword i = 0;
+
+    if (a > b) {
+        c = a / b;
+        a = a - c * b;
+    }
+
+    for (i = 0; i < x; i++) {
+        if (a >= b) {
+            answer += 1;
+            a-=b;
+        }
+        a <<= 1;
+        answer <<= 1;
+    }
+
+    answer = (c << (Long) x) + answer;
+
+    return (answer);
+}
+
+
+Dword Standard_computeCrystal (
+    IN  Demodulator*    demodulator,
+    IN  Long            crystalFrequency,   /** Crystal frequency (Hz) */
+    OUT Dword*          crystal
+) {
+    Dword   error = Error_NO_ERROR;
+    deb_info("Enter %s -\n", __FUNCTION__);
+
+    *crystal = (Long) Standard_divider (demodulator, (Dword) crystalFrequency, 1000000ul, 19ul);
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_computeAdc (
+    IN  Demodulator*    demodulator,
+    IN  Long            adcFrequency,       /** ADC frequency (Hz) */
+    OUT Dword*          adc
+)
+{
+    Dword   error = Error_NO_ERROR;
+    deb_info("Enter %s -\n", __FUNCTION__);
+
+    *adc = (Long) Standard_divider (demodulator, (Dword) adcFrequency, 1000000ul, 19ul);
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_computeFcw (
+    IN  Demodulator*    demodulator,
+    IN  Long            adcFrequency,       /** ADC frequency (Hz)    */
+    IN  Long            ifFrequency,        /** IF frequency (Hz)     */
+    IN  Bool            inversion,          /** RF spectrum inversion */
+    OUT Dword*          fcw
+) {
+    Dword error = Error_NO_ERROR;
+    Long ifFreq;
+    Long adcFreq;
+    Long adcFreqHalf;
+    Long adcFreqSample;
+    Long invBfs;
+    Long controlWord;
+    Byte adcMultiplier;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    adcFreq = adcFrequency;
+    ifFreq = ifFrequency;
+    adcFreqHalf = adcFreq / 2;
+
+    if (inversion == True)
+        ifFreq = -1 * ifFreq;
+
+    adcFreqSample = ifFreq;
+
+    if (adcFreqSample >= 0)
+        invBfs = 1;
+    else {
+        invBfs = -1;
+        adcFreqSample = adcFreqSample * -1;
+    }
+
+    while (adcFreqSample > adcFreqHalf)
+        adcFreqSample = adcFreqSample - adcFreq;
+
+    /** Sample, spectrum at positive frequency */
+    if(adcFreqSample >= 0)
+        invBfs = invBfs * -1;
+    else {
+        invBfs = invBfs * 1;
+        adcFreqSample = adcFreqSample * (-1);       /** Absolute value */
+    }
+
+    controlWord = (Long) Standard_divider (demodulator, (Dword) adcFreqSample, (Dword) adcFreq, 23ul);
+
+    if (invBfs == -1) {
+        controlWord *= -1;
+    }
+
+    /** Get ADC multiplier */
+    error = Standard_readRegister (demodulator, 0, Processor_OFDM, adcx2, &adcMultiplier);
+    if (error) goto exit;
+
+    if (adcMultiplier == 1) {
+        controlWord /= 2;
+    }
+
+    *fcw = controlWord & 0x7FFFFF;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_selectBandwidth (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,          /** KHz              */
+    IN  Dword           adcFrequency        /** Hz, ex: 20480000 */
+) {
+    Dword error = Error_NO_ERROR;
+    Dword coeff1_2048Nu;
+    Dword coeff1_4096Nu;
+    Dword coeff1_8191Nu;
+    Dword coeff1_8192Nu;
+    Dword coeff1_8193Nu;
+    Dword coeff2_2k;
+    Dword coeff2_4k;
+    Dword coeff2_8k;
+    Word bfsfcw_fftindex_ratio;
+    Word fftindex_bfsfcw_ratio;
+
+    Byte temp0;
+    Byte temp1;
+    Byte temp2;
+    Byte temp3;
+    Byte buffer[36];
+    Byte bw;
+    Byte adcMultiplier;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    if (bandwidth == 5000)
+        bw = 3;
+    else if (bandwidth == 6000)
+        bw = 0;
+    else if (bandwidth == 7000)
+        bw = 1;
+    else if (bandwidth == 8000)
+        bw = 2;
+    else {
+        error = Error_INVALID_BW;
+        goto exit;
+    }
+
+    ganymede = (Ganymede*) demodulator;
+
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_bw, reg_bw_pos, reg_bw_len, bw);
+    if (error) goto exit;
+
+    /** Program CFOE */
+    if (adcFrequency == 20156250) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x02449b5c;
+            coeff1_4096Nu = 0x01224dae;
+            coeff1_8191Nu = 0x00912b60;
+            coeff1_8192Nu = 0x009126d7;
+            coeff1_8193Nu = 0x0091224e;
+            coeff2_2k = 0x01224dae;
+            coeff2_4k = 0x009126d7;
+            coeff2_8k = 0x0048936b;
+            bfsfcw_fftindex_ratio = 0x0387;
+            fftindex_bfsfcw_ratio = 0x0122;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02b8ba6e;
+            coeff1_4096Nu = 0x015c5d37;
+            coeff1_8191Nu = 0x00ae340d;
+            coeff1_8192Nu = 0x00ae2e9b;
+            coeff1_8193Nu = 0x00ae292a;
+            coeff2_2k = 0x015c5d37;
+            coeff2_4k = 0x00ae2e9b;
+            coeff2_8k = 0x0057174e;
+            bfsfcw_fftindex_ratio = 0x02f1;
+            fftindex_bfsfcw_ratio = 0x015c;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x032cd980;
+            coeff1_4096Nu = 0x01966cc0;
+            coeff1_8191Nu = 0x00cb3cba;
+            coeff1_8192Nu = 0x00cb3660;
+            coeff1_8193Nu = 0x00cb3007;
+            coeff2_2k = 0x01966cc0;
+            coeff2_4k = 0x00cb3660;
+            coeff2_8k = 0x00659b30;
+            bfsfcw_fftindex_ratio = 0x0285;
+            fftindex_bfsfcw_ratio = 0x0196;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x03a0f893;
+            coeff1_4096Nu = 0x01d07c49;
+            coeff1_8191Nu = 0x00e84567;
+            coeff1_8192Nu = 0x00e83e25;
+            coeff1_8193Nu = 0x00e836e3;
+            coeff2_2k = 0x01d07c49;
+            coeff2_4k = 0x00e83e25;
+            coeff2_8k = 0x00741f12;
+            bfsfcw_fftindex_ratio = 0x0234;
+            fftindex_bfsfcw_ratio = 0x01d0;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20187500) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x0243b546;
+            coeff1_4096Nu = 0x0121daa3;
+            coeff1_8191Nu = 0x0090f1d9;
+            coeff1_8192Nu = 0x0090ed51;
+            coeff1_8193Nu = 0x0090e8ca;
+            coeff2_2k = 0x0121daa3;
+            coeff2_4k = 0x0090ed51;
+            coeff2_8k = 0x004876a9;
+            bfsfcw_fftindex_ratio = 0x0388;
+            fftindex_bfsfcw_ratio = 0x0122;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02b7a654;
+            coeff1_4096Nu = 0x015bd32a;
+            coeff1_8191Nu = 0x00adef04;
+            coeff1_8192Nu = 0x00ade995;
+            coeff1_8193Nu = 0x00ade426;
+            coeff2_2k = 0x015bd32a;
+            coeff2_4k = 0x00ade995;
+            coeff2_8k = 0x0056f4ca;
+            bfsfcw_fftindex_ratio = 0x02f2;
+            fftindex_bfsfcw_ratio = 0x015c;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x032b9761;
+            coeff1_4096Nu = 0x0195cbb1;
+            coeff1_8191Nu = 0x00caec30;
+            coeff1_8192Nu = 0x00cae5d8;
+            coeff1_8193Nu = 0x00cadf81;
+            coeff2_2k = 0x0195cbb1;
+            coeff2_4k = 0x00cae5d8;
+            coeff2_8k = 0x006572ec;
+            bfsfcw_fftindex_ratio = 0x0286;
+            fftindex_bfsfcw_ratio = 0x0196;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x039f886f;
+            coeff1_4096Nu = 0x01cfc438;
+            coeff1_8191Nu = 0x00e7e95b;
+            coeff1_8192Nu = 0x00e7e21c;
+            coeff1_8193Nu = 0x00e7dadd;
+            coeff2_2k = 0x01cfc438;
+            coeff2_4k = 0x00e7e21c;
+            coeff2_8k = 0x0073f10e;
+            bfsfcw_fftindex_ratio = 0x0235;
+            fftindex_bfsfcw_ratio = 0x01d0;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20250000) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x0241eb3b;
+            coeff1_4096Nu = 0x0120f59e;
+            coeff1_8191Nu = 0x00907f53;
+            coeff1_8192Nu = 0x00907acf;
+            coeff1_8193Nu = 0x0090764b;
+            coeff2_2k = 0x0120f59e;
+            coeff2_4k = 0x00907acf;
+            coeff2_8k = 0x00483d67;
+            bfsfcw_fftindex_ratio = 0x038b;
+            fftindex_bfsfcw_ratio = 0x0121;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02b580ad;
+            coeff1_4096Nu = 0x015ac057;
+            coeff1_8191Nu = 0x00ad6597;
+            coeff1_8192Nu = 0x00ad602b;
+            coeff1_8193Nu = 0x00ad5ac1;
+            coeff2_2k = 0x015ac057;
+            coeff2_4k = 0x00ad602b;
+            coeff2_8k = 0x0056b016;
+            bfsfcw_fftindex_ratio = 0x02f4;
+            fftindex_bfsfcw_ratio = 0x015b;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x03291620;
+            coeff1_4096Nu = 0x01948b10;
+            coeff1_8191Nu = 0x00ca4bda;
+            coeff1_8192Nu = 0x00ca4588;
+            coeff1_8193Nu = 0x00ca3f36;
+            coeff2_2k = 0x01948b10;
+            coeff2_4k = 0x00ca4588;
+            coeff2_8k = 0x006522c4;
+            bfsfcw_fftindex_ratio = 0x0288;
+            fftindex_bfsfcw_ratio = 0x0195;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x039cab92;
+            coeff1_4096Nu = 0x01ce55c9;
+            coeff1_8191Nu = 0x00e7321e;
+            coeff1_8192Nu = 0x00e72ae4;
+            coeff1_8193Nu = 0x00e723ab;
+            coeff2_2k = 0x01ce55c9;
+            coeff2_4k = 0x00e72ae4;
+            coeff2_8k = 0x00739572;
+            bfsfcw_fftindex_ratio = 0x0237;
+            fftindex_bfsfcw_ratio = 0x01ce;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20583333) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x02402402;
+            coeff1_4096Nu = 0x01201201;
+            coeff1_8191Nu = 0x00900d81;
+            coeff1_8192Nu = 0x00900901;
+            coeff1_8193Nu = 0x00900480;
+            coeff2_2k = 0x01201201;
+            coeff2_4k = 0x00900901;
+            coeff2_8k = 0x00480480;
+            bfsfcw_fftindex_ratio = 0x038e;
+            fftindex_bfsfcw_ratio = 0x0120;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02b35e69;
+            coeff1_4096Nu = 0x0159af35;
+            coeff1_8191Nu = 0x00acdd01;
+            coeff1_8192Nu = 0x00acd79a;
+            coeff1_8193Nu = 0x00acd234;
+            coeff2_2k = 0x0159af35;
+            coeff2_4k = 0x00acd79a;
+            coeff2_8k = 0x00566bcd;
+            bfsfcw_fftindex_ratio = 0x02f6;
+            fftindex_bfsfcw_ratio = 0x015a;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x032698d0;
+            coeff1_4096Nu = 0x01934c68;
+            coeff1_8191Nu = 0x00c9ac81;
+            coeff1_8192Nu = 0x00c9a634;
+            coeff1_8193Nu = 0x00c99fe7;
+            coeff2_2k = 0x01934c68;
+            coeff2_4k = 0x00c9a634;
+            coeff2_8k = 0x0064d31a;
+            bfsfcw_fftindex_ratio = 0x028a;
+            fftindex_bfsfcw_ratio = 0x0193;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x0399d337;
+            coeff1_4096Nu = 0x01cce99b;
+            coeff1_8191Nu = 0x00e67c02;
+            coeff1_8192Nu = 0x00e674ce;
+            coeff1_8193Nu = 0x00e66d9a;
+            coeff2_2k = 0x01cce99b;
+            coeff2_4k = 0x00e674ce;
+            coeff2_8k = 0x00733a67;
+            bfsfcw_fftindex_ratio = 0x0239;
+            fftindex_bfsfcw_ratio = 0x01cd;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20416667) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x023d337f;
+            coeff1_4096Nu = 0x011e99c0;
+            coeff1_8191Nu = 0x008f515a;
+            coeff1_8192Nu = 0x008f4ce0;
+            coeff1_8193Nu = 0x008f4865;
+            coeff2_2k = 0x011e99c0;
+            coeff2_4k = 0x008f4ce0;
+            coeff2_8k = 0x0047a670;
+            bfsfcw_fftindex_ratio = 0x0393;
+            fftindex_bfsfcw_ratio = 0x011f;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02afd765;
+            coeff1_4096Nu = 0x0157ebb3;
+            coeff1_8191Nu = 0x00abfb39;
+            coeff1_8192Nu = 0x00abf5d9;
+            coeff1_8193Nu = 0x00abf07a;
+            coeff2_2k = 0x0157ebb3;
+            coeff2_4k = 0x00abf5d9;
+            coeff2_8k = 0x0055faed;
+            bfsfcw_fftindex_ratio = 0x02fa;
+            fftindex_bfsfcw_ratio = 0x0158;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x03227b4b;
+            coeff1_4096Nu = 0x01913da6;
+            coeff1_8191Nu = 0x00c8a518;
+            coeff1_8192Nu = 0x00c89ed3;
+            coeff1_8193Nu = 0x00c8988e;
+            coeff2_2k = 0x01913da6;
+            coeff2_4k = 0x00c89ed3;
+            coeff2_8k = 0x00644f69;
+            bfsfcw_fftindex_ratio = 0x028d;
+            fftindex_bfsfcw_ratio = 0x0191;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x03951f32;
+            coeff1_4096Nu = 0x01ca8f99;
+            coeff1_8191Nu = 0x00e54ef7;
+            coeff1_8192Nu = 0x00e547cc;
+            coeff1_8193Nu = 0x00e540a2;
+            coeff2_2k = 0x01ca8f99;
+            coeff2_4k = 0x00e547cc;
+            coeff2_8k = 0x0072a3e6;
+            bfsfcw_fftindex_ratio = 0x023c;
+            fftindex_bfsfcw_ratio = 0x01cb;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20480000) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x023b6db7;
+            coeff1_4096Nu = 0x011db6db;
+            coeff1_8191Nu = 0x008edfe5;
+            coeff1_8192Nu = 0x008edb6e;
+            coeff1_8193Nu = 0x008ed6f7;
+            coeff2_2k = 0x011db6db;
+            coeff2_4k = 0x008edb6e;
+            coeff2_8k = 0x00476db7;
+            bfsfcw_fftindex_ratio = 0x0396;
+            fftindex_bfsfcw_ratio = 0x011e;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02adb6db;
+            coeff1_4096Nu = 0x0156db6e;
+            coeff1_8191Nu = 0x00ab7312;
+            coeff1_8192Nu = 0x00ab6db7;
+            coeff1_8193Nu = 0x00ab685c;
+            coeff2_2k = 0x0156db6e;
+            coeff2_4k = 0x00ab6db7;
+            coeff2_8k = 0x0055b6db;
+            bfsfcw_fftindex_ratio = 0x02fd;
+            fftindex_bfsfcw_ratio = 0x0157;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x03200000;
+            coeff1_4096Nu = 0x01900000;
+            coeff1_8191Nu = 0x00c80640;
+            coeff1_8192Nu = 0x00c80000;
+            coeff1_8193Nu = 0x00c7f9c0;
+            coeff2_2k = 0x01900000;
+            coeff2_4k = 0x00c80000;
+            coeff2_8k = 0x00640000;
+            bfsfcw_fftindex_ratio = 0x028f;
+            fftindex_bfsfcw_ratio = 0x0190;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x03924925;
+            coeff1_4096Nu = 0x01c92492;
+            coeff1_8191Nu = 0x00e4996e;
+            coeff1_8192Nu = 0x00e49249;
+            coeff1_8193Nu = 0x00e48b25;
+            coeff2_2k = 0x01c92492;
+            coeff2_4k = 0x00e49249;
+            coeff2_8k = 0x00724925;
+            bfsfcw_fftindex_ratio = 0x023d;
+            fftindex_bfsfcw_ratio = 0x01c9;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20500000) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x023adeff;
+            coeff1_4096Nu = 0x011d6f80;
+            coeff1_8191Nu = 0x008ebc36;
+            coeff1_8192Nu = 0x008eb7c0;
+            coeff1_8193Nu = 0x008eb34a;
+            coeff2_2k = 0x011d6f80;
+            coeff2_4k = 0x008eb7c0;
+            coeff2_8k = 0x00475be0;
+            bfsfcw_fftindex_ratio = 0x0396;
+            fftindex_bfsfcw_ratio = 0x011d;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02ad0b99;
+            coeff1_4096Nu = 0x015685cc;
+            coeff1_8191Nu = 0x00ab4840;
+            coeff1_8192Nu = 0x00ab42e6;
+            coeff1_8193Nu = 0x00ab3d8c;
+            coeff2_2k = 0x015685cc;
+            coeff2_4k = 0x00ab42e6;
+            coeff2_8k = 0x0055a173;
+            bfsfcw_fftindex_ratio = 0x02fd;
+            fftindex_bfsfcw_ratio = 0x0157;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x031f3832;
+            coeff1_4096Nu = 0x018f9c19;
+            coeff1_8191Nu = 0x00c7d44b;
+            coeff1_8192Nu = 0x00c7ce0c;
+            coeff1_8193Nu = 0x00c7c7ce;
+            coeff2_2k = 0x018f9c19;
+            coeff2_4k = 0x00c7ce0c;
+            coeff2_8k = 0x0063e706;
+            bfsfcw_fftindex_ratio = 0x0290;
+            fftindex_bfsfcw_ratio = 0x0190;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x039164cb;
+            coeff1_4096Nu = 0x01c8b266;
+            coeff1_8191Nu = 0x00e46056;
+            coeff1_8192Nu = 0x00e45933;
+            coeff1_8193Nu = 0x00e45210;
+            coeff2_2k = 0x01c8b266;
+            coeff2_4k = 0x00e45933;
+            coeff2_8k = 0x00722c99;
+            bfsfcw_fftindex_ratio = 0x023e;
+            fftindex_bfsfcw_ratio = 0x01c9;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else if (adcFrequency == 20625000) {
+        if (bandwidth == 5000) {
+            coeff1_2048Nu = 0x02376948;
+            coeff1_4096Nu = 0x011bb4a4;
+            coeff1_8191Nu = 0x008ddec1;
+            coeff1_8192Nu = 0x008dda52;
+            coeff1_8193Nu = 0x008dd5e3;
+            coeff2_2k = 0x011bb4a4;
+            coeff2_4k = 0x008dda52;
+            coeff2_8k = 0x0046ed29;
+            bfsfcw_fftindex_ratio = 0x039c;
+            fftindex_bfsfcw_ratio = 0x011c;
+        } else if (bandwidth == 6000) {
+            coeff1_2048Nu = 0x02a8e4bd;
+            coeff1_4096Nu = 0x0154725e;
+            coeff1_8191Nu = 0x00aa3e81;
+            coeff1_8192Nu = 0x00aa392f;
+            coeff1_8193Nu = 0x00aa33de;
+            coeff2_2k = 0x0154725e;
+            coeff2_4k = 0x00aa392f;
+            coeff2_8k = 0x00551c98;
+            bfsfcw_fftindex_ratio = 0x0302;
+            fftindex_bfsfcw_ratio = 0x0154;
+        } else if (bandwidth == 7000) {
+            coeff1_2048Nu = 0x031a6032;
+            coeff1_4096Nu = 0x018d3019;
+            coeff1_8191Nu = 0x00c69e41;
+            coeff1_8192Nu = 0x00c6980c;
+            coeff1_8193Nu = 0x00c691d8;
+            coeff2_2k = 0x018d3019;
+            coeff2_4k = 0x00c6980c;
+            coeff2_8k = 0x00634c06;
+            bfsfcw_fftindex_ratio = 0x0294;
+            fftindex_bfsfcw_ratio = 0x018d;
+        } else if (bandwidth == 8000) {
+            coeff1_2048Nu = 0x038bdba6;
+            coeff1_4096Nu = 0x01c5edd3;
+            coeff1_8191Nu = 0x00e2fe02;
+            coeff1_8192Nu = 0x00e2f6ea;
+            coeff1_8193Nu = 0x00e2efd2;
+            coeff2_2k = 0x01c5edd3;
+            coeff2_4k = 0x00e2f6ea;
+            coeff2_8k = 0x00717b75;
+            bfsfcw_fftindex_ratio = 0x0242;
+            fftindex_bfsfcw_ratio = 0x01c6;
+        } else {
+            error = Error_INVALID_BW;
+            goto exit;
+        }
+    } else {
+        error = Error_INVALID_XTAL_FREQ;
+        goto exit;
+    }
+
+
+    /** Get ADC multiplier */
+    error = Standard_readRegister (demodulator, 0, Processor_OFDM, adcx2, &adcMultiplier);
+    if (error) goto exit;
+
+    if (adcMultiplier == 1) {
+        coeff1_2048Nu /= 2;
+        coeff1_4096Nu /= 2;
+        coeff1_8191Nu /= 2;
+        coeff1_8192Nu /= 2;
+        coeff1_8193Nu /= 2 ;
+        coeff2_2k /= 2;
+        coeff2_4k /= 2;
+        coeff2_8k /= 2;
+    }
+
+    /** Write coeff1_2048Nu */
+    /** Get Byte0 */
+    temp0 = (Byte) (coeff1_2048Nu & 0x000000FF);
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff1_2048Nu & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff1_2048Nu & 0x00FF0000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff1_2048Nu & 0x03000000) >> 24);
+
+    /** Gig endian to make 8051 happy */
+    buffer[cfoe_NS_2048_coeff1_25_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_2048_coeff1_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_2048_coeff1_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_2048_coeff1_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff2_2k */
+    /** Get Byte0 */
+    temp0 = (Byte) ((coeff2_2k & 0x000000FF));
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff2_2k & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff2_2k & 0x00FF0000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff2_2k & 0x01000000) >> 24);
+
+    /** Gig endian to make 8051 happy */
+    buffer[cfoe_NS_2k_coeff2_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_2k_coeff2_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_2k_coeff2_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_2k_coeff2_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff1_8191Nu */
+    /** Get Byte0 */
+    temp0 = (Byte) ((coeff1_8191Nu & 0x000000FF));
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff1_8191Nu & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff1_8191Nu & 0x00FFC000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff1_8191Nu & 0x03000000) >> 24);
+
+    /** Big endian to make 8051 happy */
+    buffer[cfoe_NS_8191_coeff1_25_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_8191_coeff1_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_8191_coeff1_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_8191_coeff1_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff1_8192Nu */
+    /** Get Byte0 */
+    temp0  = (Byte) (coeff1_8192Nu & 0x000000FF);
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff1_8192Nu & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff1_8192Nu & 0x00FFC000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff1_8192Nu & 0x03000000) >> 24);
+
+    /** Gig endian to make 8051 happy */
+    buffer[cfoe_NS_8192_coeff1_25_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_8192_coeff1_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_8192_coeff1_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_8192_coeff1_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff1_8193Nu */
+    /** Get Byte0 */
+    temp0 = (Byte) ((coeff1_8193Nu & 0x000000FF));
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff1_8193Nu & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff1_8193Nu & 0x00FFC000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff1_8193Nu & 0x03000000) >> 24);
+
+    /** Big endian to make 8051 happy */
+    buffer[cfoe_NS_8193_coeff1_25_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_8193_coeff1_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_8193_coeff1_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_8193_coeff1_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff2_8k */
+    /** Get Byte0 */
+    temp0 = (Byte) ((coeff2_8k & 0x000000FF));
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff2_8k & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff2_8k & 0x00FF0000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff2_8k & 0x01000000) >> 24);
+
+    /** Big endian to make 8051 happy */
+    buffer[cfoe_NS_8k_coeff2_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_8k_coeff2_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_8k_coeff2_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_8k_coeff2_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff1_4096Nu */
+    /** Get Byte0 */
+    temp0 = (Byte) (coeff1_4096Nu & 0x000000FF);
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff1_4096Nu & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff1_4096Nu & 0x00FF0000) >> 16);
+    /** Get Byte3[1:0] */
+    /** Bit[7:2] will be written soon and so don't have to care them */
+    temp3 = (Byte) ((coeff1_4096Nu & 0x03000000) >> 24);
+
+    /** Big endian to make 8051 happy */
+    buffer[cfoe_NS_4096_coeff1_25_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_4096_coeff1_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_4096_coeff1_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_4096_coeff1_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Write coeff2_4k */
+    /** Get Byte0 */
+    temp0 = (Byte) ((coeff2_4k & 0x000000FF));
+    /** Get Byte1 */
+    temp1 = (Byte) ((coeff2_4k & 0x0000FF00) >> 8);
+    /** Get Byte2 */
+    temp2 = (Byte) ((coeff2_4k & 0x00FF0000) >> 16);
+    /** Get Byte3 */
+    temp3 = (Byte) ((coeff2_4k & 0x01000000) >> 24);
+
+    /** Big endian to make 8051 happy */
+    buffer[cfoe_NS_4k_coeff2_24 - cfoe_NS_2048_coeff1_25_24] = temp3;
+    buffer[cfoe_NS_4k_coeff2_23_16 - cfoe_NS_2048_coeff1_25_24] = temp2;
+    buffer[cfoe_NS_4k_coeff2_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[cfoe_NS_4k_coeff2_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Get Byte0 */
+    temp0 = (Byte) (bfsfcw_fftindex_ratio & 0x00FF);
+    /** Get Byte1 */
+    temp1 = (Byte) ((bfsfcw_fftindex_ratio & 0xFF00) >> 8);
+
+    /** Big endian to make 8051 happy */
+    buffer[bfsfcw_fftindex_ratio_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[bfsfcw_fftindex_ratio_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    /** Get Byte0 */
+    temp0 = (Byte) (fftindex_bfsfcw_ratio & 0x00FF);
+    /** Get Byte1 */
+    temp1 = (Byte) ((fftindex_bfsfcw_ratio & 0xFF00) >> 8);
+
+    /** Big endian to make 8051 happy */
+    buffer[fftindex_bfsfcw_ratio_15_8 - cfoe_NS_2048_coeff1_25_24] = temp1;
+    buffer[fftindex_bfsfcw_ratio_7_0 - cfoe_NS_2048_coeff1_25_24] = temp0;
+
+    error = Standard_writeRegisters (demodulator, chip, Processor_OFDM, cfoe_NS_2048_coeff1_25_24, 36, buffer);
+    if (error) goto exit;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_loadFirmware (
+    IN  Demodulator*    demodulator,
+    IN  Byte*           firmwareCodes,
+    IN  Segment*        firmwareSegments,
+    IN  Byte*           firmwarePartitions
+) {
+    Dword error = Error_NO_ERROR;
+    Dword beginPartition;
+    Dword endPartition;
+    Dword version;
+    Dword firmwareLength;
+    Byte* firmwareCodesPointer;
+    Word command;
+    Dword i;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Set I2C master clock speed. */
+    error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_one_cycle_counter_tuner, User_I2C_SPEED);
+    if (error) goto exit;
+
+    firmwareCodesPointer = firmwareCodes;
+    beginPartition = 0;
+    endPartition = firmwarePartitions[0];
+
+    for (i = beginPartition; i < endPartition; i++) {
+        firmwareLength = firmwareSegments[i].segmentLength;
+        if (firmwareSegments[i].segmentType == 0) {
+            /** Dwonload firmware */
+            error = Standard_sendCommand (demodulator, Command_FW_DOWNLOAD_BEGIN, 0, Processor_LINK, 0, NULL, 0, NULL);
+            if (error) goto exit;
+            if (ganymede->cmdDescription->loadFirmware != NULL) {
+                error = ganymede->cmdDescription->loadFirmware (demodulator, firmwareLength, firmwareCodesPointer);
+            }
+            if (error) goto exit;
+            error = Standard_sendCommand (demodulator, Command_FW_DOWNLOAD_END, 0, Processor_LINK, 0, NULL, 0, NULL);
+            if (error) goto exit;
+        } else if (firmwareSegments[i].segmentType == 1) {
+            /** Copy firmware */
+            error = Standard_sendCommand (demodulator, Command_SCATTER_WRITE, 0, Processor_LINK, firmwareLength, firmwareCodesPointer, 0, NULL);
+            if (error) goto exit;
+        } else {
+            /** Direct write firmware */
+            command = (Word) (firmwareCodesPointer[0] << 8) + (Word) firmwareCodesPointer[1];
+            error = Standard_sendCommand (demodulator, command, 0, Processor_LINK, firmwareLength - 2, firmwareCodesPointer + 2, 0, NULL);
+            if (error) goto exit;
+        }
+        firmwareCodesPointer += firmwareLength;
+    }
+
+    /** Boot */
+    error = Standard_sendCommand (demodulator, Command_BOOT, 0, Processor_LINK, 0, NULL, 0, NULL);
+    if (error) goto exit;
+
+    User_delay (demodulator, 10);
+
+    /** Check if firmware is running */
+    version = 0;
+    error = Standard_getFirmwareVersion (demodulator, Processor_LINK, &version);
+    if (error) goto exit;
+    if (version == 0)
+        error = Error_BOOT_FAIL;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_loadScript (
+    IN  Demodulator*    demodulator,
+    IN  StreamType      streamType,
+    IN  Word*           scriptSets,
+    IN  ValueSet*       scripts,
+    IN  Word*           tunerScriptSets,
+    IN  ValueSet*       tunerScripts
+) {
+    Dword error = Error_NO_ERROR;
+    Word beginScript;
+    Word endScript;
+    //Byte adcType = 0;
+    Byte i;
+    Word j;
+	Byte value;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+
+    if ((scriptSets[0] != 0) && (scripts != NULL))
+    {
+        beginScript = 0;
+        endScript = scriptSets[0];
+
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            /** Load OFSM init script */
+            for (j = beginScript; j < endScript; j++) {
+                error = Standard_writeRegister (demodulator, i, Processor_OFDM, scripts[j].address, scripts[j].value);
+                if (error) goto exit;
+            }
+        }
+    }
+
+	/** Detect difference between A and B */
+	error = Standard_readRegister (demodulator, 0, Processor_LINK, 0x384F, &value);
+	if (error) goto exit;
+
+    if ((tunerScriptSets[0] != 0) && (tunerScripts != NULL))
+    {
+        if (tunerScriptSets[1] != 0 && value == 0xFF)
+        {
+            beginScript = tunerScriptSets[0];
+            endScript = tunerScriptSets[0] + tunerScriptSets[1];
+		} else {
+            beginScript = 0;
+            endScript = tunerScriptSets[0];
+        }
+
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            /** Load tuner init script */
+            for (j = beginScript; j < endScript; j++) {
+                error = Standard_writeRegister (demodulator, i, Processor_OFDM, tunerScripts[j].address, tunerScripts[j].value);
+                if (error) goto exit;
+            }
+        }
+    }
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_loadIrTable (
+    IN  Demodulator*    demodulator,
+    IN  Word            tableLength,
+    IN  Byte*           table
+) {
+    Dword error = Error_NO_ERROR;
+    Byte baseHigh;
+    Byte baseLow;
+    Word registerBase;
+    Word i;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_readRegister (demodulator, 0, Processor_LINK, 0x417F, &baseHigh);
+    if (error) goto exit;
+    error = Standard_readRegister (demodulator, 0, Processor_LINK, 0x4180, &baseLow);
+    if (error) goto exit;
+
+    registerBase = (Word) (baseHigh << 8) + (Word) baseLow;
+
+    if (registerBase) {
+        for (i = 0; i < tableLength; i++) {
+            error = Standard_writeRegister (demodulator, 0, Processor_LINK, registerBase + i, table[i]);
+            if (error) goto exit;
+        }
+    }
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_initialize (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chipNumber,
+    IN  Word            sawBandwidth,
+    IN  StreamType      streamType,
+    IN  Architecture    architecture
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    InitializeRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    ganymede->driver = NULL;
+    error = Standard_getDriver (demodulator, &ganymede->driver);
+
+    if (ganymede->driver != NULL) {
+        request.chipNumber = chipNumber;
+        request.sawBandwidth = sawBandwidth;
+        request.streamType = streamType;
+        request.architecture = architecture;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_INITIALIZE,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Dword crystal = 0;
+    Dword adc = 0;
+    Dword fcw = 0;
+    Byte buffer[4];
+	Dword version = 0;
+    Word* tunerScriptSets = NULL;
+    ValueSet* tunerScripts = NULL;
+
+
+    Byte i;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    ganymede->chipNumber = chipNumber;
+    ganymede->options = 0x0000;
+    ganymede->fcw = 0x00000000;
+    ganymede->frequency[0] = 642000;
+	ganymede->frequency[1] = 642000;
+    ganymede->initialized = False;
+
+    if (ganymede->busId == 0xFFFF) {
+        goto exit;
+    }
+
+
+    if (ganymede->tunerDescription->tunerId == 0xFFFF) {
+        goto exit;
+    }
+
+	error = Standard_getFirmwareVersion (demodulator, Processor_LINK, &version);
+	if (error) goto exit;
+	if (version != 0) {
+		ganymede->booted = True;
+	} else {
+		ganymede->booted = False;
+	}
+
+
+
+
+    ganymede->firmwareCodes = Firmware_codes;
+    ganymede->firmwareSegments = Firmware_segments;
+#if 1 //j017,set to 1  //j014+s 
+    ganymede->firmwarePartitions = Firmware_partitions;
+#else
+    ganymede->firmwarePartitions = Firmware_new_partitions;
+#endif //j014+e
+    ganymede->scriptSets = Firmware_scriptSets;
+    ganymede->scripts = Firmware_scripts;
+
+    /** Set up by default tunerDescription */ /** release1remove */
+    tunerScriptSets = ganymede->tunerDescription->tunerScriptSets;
+    tunerScripts = ganymede->tunerDescription->tunerScript;
+
+
+    error = Standard_readRegisterBits (demodulator, 0, Processor_LINK, r_io_mux_pwron_clk_strap, io_mux_pwron_clk_strap_pos, io_mux_pwron_clk_strap_len, &i);
+    if (error) goto exit;
+
+    ganymede->crystalFrequency = Standard_clockTable[i].crystalFrequency;
+    ganymede->adcFrequency = Standard_clockTable[i].adcFrequency;
+
+    ganymede->dataReady = False;
+
+    /** Write secondary I2C address to device */
+    /** it is needed to write i2c address prior to fw-downloading */
+    if (ganymede->chipNumber > 1) {
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, 0x417F, ((PDEVICE_CONTEXT)demodulator->userData)->Map.I2C_SLAVE_ADDR);
+        if (error) goto exit;
+    } else {
+        error = Standard_writeRegister (demodulator, 0, Processor_LINK, 0x417F, 0x00);
+        if (error) goto exit;
+    }
+
+    if (ganymede->firmwareCodes != NULL) {
+        if (ganymede->booted == False) {
+            error = Standard_loadFirmware (demodulator, ganymede->firmwareCodes, ganymede->firmwareSegments, ganymede->firmwarePartitions);
+            if (error) goto exit;
+            ganymede->booted = True;
+        }
+    }
+
+    /** Detect the HostA or HostB */
+    error = Standard_readRegisterBits (demodulator, 0, Processor_LINK, r_io_mux_pwron_hosta, io_mux_pwron_hosta_pos, io_mux_pwron_hosta_len, &ganymede->hostInterface[0]);
+    if (error) goto exit;
+
+
+    /** Tell firmware the type of tuner. */
+    for (i = 0; i < ganymede->chipNumber; i++) {
+		error = Standard_writeRegister (demodulator, i, Processor_LINK, p_reg_link_ofsm_dummy_15_8, (Byte) ganymede->tunerDescription->tunerId);
+        if (error) goto exit;
+
+        /** Set read-update bit to 1 for constellation */
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_feq_read_update, reg_feq_read_update_pos, reg_feq_read_update_len, 1);
+        if (error) goto exit;
+
+        /** Enable FEC Monitor */
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_fec_vtb_rsd_mon_en, fec_vtb_rsd_mon_en_pos, fec_vtb_rsd_mon_en_len, 1);
+        if (error) goto exit;
+    }
+
+    /** Compute ADC and load them to device */
+    error = Standard_computeCrystal (demodulator, (Long) ganymede->crystalFrequency * 1000, &crystal);
+    if (error) goto exit;
+
+    buffer[0] = (Byte) (crystal & 0x000000FF);
+    buffer[1] = (Byte) ((crystal & 0x0000FF00) >> 8);
+    buffer[2] = (Byte) ((crystal & 0x00FF0000) >> 16);
+    buffer[3] = (Byte) ((crystal & 0xFF000000) >> 24);
+    for (i = 0; i < ganymede->chipNumber; i++) {
+        error = Standard_writeRegisters (demodulator, i, Processor_OFDM, crystal_clk_7_0, 4, buffer);
+        if (error) goto exit;
+    }
+
+    /** Compute ADC and load them to device */
+    error = Standard_computeAdc (demodulator, (Long) ganymede->adcFrequency, &adc);
+    if (error) goto exit;
+
+    buffer[0] = (Byte) (adc & 0x000000FF);
+    buffer[1] = (Byte) ((adc & 0x0000FF00) >> 8);
+    buffer[2] = (Byte) ((adc & 0x00FF0000) >> 16);
+    for (i = 0; i < ganymede->chipNumber; i++) {
+        error = Standard_writeRegisters (demodulator, i, Processor_OFDM, p_reg_f_adc_7_0, 3, buffer);
+        if (error) goto exit;
+    }
+
+    /** Compute FCW and load them to device */
+    error = Standard_computeFcw (demodulator, (Long) ganymede->adcFrequency, (Long) ganymede->tunerDescription->ifFrequency, ganymede->tunerDescription->inversion, &fcw);
+    if (error) goto exit;
+    ganymede->fcw = fcw;
+
+    buffer[0] = (Byte) (fcw & 0x000000FF);
+    buffer[1] = (Byte) ((fcw & 0x0000FF00) >> 8);
+    buffer[2] = (Byte) ((fcw & 0x007F0000) >> 16);
+    for (i = 0; i < ganymede->chipNumber; i++) {
+        error = Standard_writeRegisters (demodulator, i, Processor_OFDM, bfs_fcw_7_0, bfs_fcw_22_16 - bfs_fcw_7_0 + 1, buffer);    
+        if (error) goto exit;
+    }
+
+    /** Set the desired stream type */
+    error = Standard_setStreamType (demodulator, streamType);
+    if (error) goto exit;
+
+    /** Set the desired architecture type */
+    error = Standard_setArchitecture (demodulator, architecture);
+    if (error) goto exit;
+
+    if (ganymede->scripts != NULL) {
+        error = Standard_loadScript (demodulator, streamType, ganymede->scriptSets, ganymede->scripts, tunerScriptSets, tunerScripts);
+        if (error) goto exit;
+    }
+
+    if (ganymede->tunerDescription->openTuner != NULL) {
+        if ((ganymede->busId != Bus_I2M) && (ganymede->busId != Bus_I2U)) {
+            for (i = 0; i < ganymede->chipNumber; i++) {
+                error = ganymede->tunerDescription->openTuner (demodulator, i);
+                if (error) goto exit;
+            }
+        }
+    }
+
+#if User_USE_INTERRUPT
+    if (ganymede->busId == Bus_SDIO) {
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_sdioc_external_int_en, reg_sdioc_external_int_en_pos, reg_sdioc_external_int_en_len, 1);
+        if (error) goto exit;
+    }
+#endif
+
+	for (i = 0; i< ganymede->chipNumber; i++) {
+
+		/** Set H/W MPEG2 locked detection **/
+		error = Standard_writeRegister (demodulator, i, Processor_LINK, p_reg_top_lock3_out, 1);
+		if (error) goto exit;
+
+		/** Set registers for driving power 0xD830 **/
+		error = Standard_writeRegister (demodulator, i, Processor_LINK, p_reg_top_padmiscdr2, 1);
+		if (error) goto exit;
+
+		/** Set registers for driving power 0xD831 **/
+		error = Standard_writeRegister (demodulator, i, Processor_LINK, p_reg_top_padmiscdr4, 0);
+		if (error) goto exit;
+
+		/** Set registers for driving power 0xD832 **/
+		error = Standard_writeRegister (demodulator, i, Processor_LINK, p_reg_top_padmiscdr8, 0);
+		if (error) goto exit;
+	}
+
+    ganymede->initialized = True;
+
+#endif
+exit:
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_finalize (
+    IN  Demodulator*    demodulator
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    FinalizeRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_FINALIZE,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte i;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->tunerDescription->closeTuner != NULL) {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            error = ganymede->tunerDescription->closeTuner (demodulator, i);
+        }
+    }
+
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_isAgcLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte temp;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    *locked = False;
+
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, p_agc_lock, agc_lock_pos, agc_lock_len, &temp);
+    if (error) goto exit;
+    if (temp) *locked = True;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_isCfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte temp;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    *locked = False;
+
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, r_reg_cfoe_divg_flag, reg_cfoe_divg_flag_pos, reg_cfoe_divg_flag_len, &temp);
+    if (error) goto exit;
+    if (!temp) *locked = True;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_isSfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte temp;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    *locked = False;
+
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, r_reg_sfoe_divg_flag, reg_sfoe_divg_flag_pos, reg_sfoe_divg_flag_len, &temp);
+    if (error) goto exit;
+    if (!temp) *locked = True;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_isTpsLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte temp;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    *locked = False;
+
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, p_fd_tpsd_lock, fd_tpsd_lock_pos, fd_tpsd_lock_len, &temp);
+    if (error) goto exit;
+    if (temp) *locked = True;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_isMpeg2Locked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte temp;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    *locked = False;
+
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, r_mp2if_sync_byte_locked, mp2if_sync_byte_locked_pos, mp2if_sync_byte_locked_len, &temp);
+    if (error) goto exit;
+    if (temp) *locked = True;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_isLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+) {
+    Dword error = Error_NO_ERROR;
+
+    Word emptyLoop = 0;
+    Word tpsLoop = 0;
+    Word mpeg2Loop = 0;
+    Byte channels[2];
+    Byte begin;
+    Byte end;
+    Byte i;
+    Byte emptyChannel = 1;
+    Byte tpsLocked = 0;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    IsLockedRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.locked = locked;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_ISLOCKED,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    
+    *locked = False;
+
+    if (ganymede->architecture == Architecture_DCA) {
+        begin = 0;
+        end = ganymede->chipNumber;
+    } else {
+        begin = chip;
+        end = begin + 1;
+    }
+
+    for (i = begin; i < end; i++) {
+        ganymede->statistic[i].signalPresented = False;
+        ganymede->statistic[i].signalLocked = False;
+        ganymede->statistic[i].signalQuality = 0;
+        ganymede->statistic[i].signalStrength = 0;
+    }
+
+    channels[0] = 2;
+    channels[1] = 2;
+    while (emptyLoop < 40) {
+        for (i = begin; i < end; i++) {
+            error = Standard_readRegister (demodulator, i, Processor_OFDM, empty_channel_status, &channels[i]);
+            if (error) goto exit;
+        }
+        if ((channels[0] == 1) || (channels[1] == 1)) {
+            emptyChannel = 0;
+            break;
+        }
+        if ((channels[0] == 2) && (channels[1] == 2)) {
+            emptyChannel = 1;
+            goto exit;
+        }
+        User_delay (demodulator, 25);
+        emptyLoop++;
+    }
+
+    if (emptyChannel == 1) goto exit;
+
+    while (tpsLoop < 50) {
+        for (i = begin; i < end; i++) {
+            /** Empty channel */
+            error = Standard_isTpsLocked (demodulator, i, &ganymede->statistic[i].signalPresented);
+            if (error) goto exit;
+            if (ganymede->statistic[i].signalPresented == True) {
+                tpsLocked = 1;
+                break;
+            }
+        }
+
+        if (tpsLocked == 1) break;
+
+        User_delay (demodulator, 25);
+        tpsLoop++;
+    }
+
+    if (tpsLocked == 0) goto exit;
+
+    while (mpeg2Loop < 40) {
+        if (ganymede->architecture == Architecture_DCA) {
+            error = Standard_isMpeg2Locked (demodulator, 0, &ganymede->statistic[0].signalLocked);
+            if (error) goto exit;
+            if (ganymede->statistic[0].signalLocked == True) {
+                for (i = begin; i < end; i++) {
+                    ganymede->statistic[i].signalQuality = 80;
+                    ganymede->statistic[i].signalStrength = 80;
+                }
+                *locked = True;
+                break;
+            }
+        } else {
+            error = Standard_isMpeg2Locked (demodulator, chip, &ganymede->statistic[chip].signalLocked);
+            if (error) goto exit;
+            if (ganymede->statistic[chip].signalLocked == True) {
+                ganymede->statistic[chip].signalQuality = 80;
+                ganymede->statistic[chip].signalStrength = 80;
+                *locked = True;
+                break;
+            }
+        }
+        User_delay (demodulator, 25);
+        mpeg2Loop++;
+    }
+    for (i = begin; i < end; i++) {
+        ganymede->statistic[i].signalQuality = 0;
+        ganymede->statistic[i].signalStrength = 20;
+    }
+
+exit:
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setPriority (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Priority        priority
+)
+{
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte pri;
+    Byte cr;
+    Byte valuew_7_0 = 0;
+    Byte valuew_10_8 = 0;
+    Byte nfvaluew_7_0 = 0;
+    Byte nfvaluew_10_8 = 0;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    if (priority == Priority_HIGH) {
+        pri = 1;
+        /** Get code rate here */
+        error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_hpcr, reg_tpsd_hpcr_pos, reg_tpsd_hpcr_len, &cr);
+        if (error) goto exit;
+    } else {
+        pri = 0;
+        /** Get code rate here */
+        error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_lpcr, reg_tpsd_lpcr_pos, reg_tpsd_lpcr_len, &cr);
+        if (error) goto exit;
+    }
+
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_dec_pri, reg_dec_pri_pos, reg_dec_pri_len, pri);
+    if (error) goto exit;
+
+    /** Set sbx quantizer */
+    switch (cr) {
+        case 0 :
+            valuew_7_0 = 0x20;
+            valuew_10_8 = 0x03;
+            nfvaluew_7_0 = 0x00;
+            nfvaluew_10_8 = 0x01;
+            break;
+        case 1 :
+            valuew_7_0 = 0x5E;
+            valuew_10_8 = 0x01;
+            nfvaluew_7_0 = 0x80;
+            nfvaluew_10_8 = 0x00;
+            break;
+        case 2 :
+            valuew_7_0 = 0x2C;
+            valuew_10_8 = 0x01;
+            nfvaluew_7_0 = 0x55;
+            nfvaluew_10_8 = 0x00;
+            break;
+        case 3 :
+            valuew_7_0 = 0xFA;
+            valuew_10_8 = 0x00;
+            nfvaluew_7_0 = 0x40;
+            nfvaluew_10_8 = 0x00;
+            break;
+        case 4 :
+            valuew_7_0 = 0xC8;
+            valuew_10_8 = 0x00;
+            nfvaluew_7_0 = 0x33;
+            nfvaluew_10_8 = 0x00;
+            break;
+    }
+
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_qnt_valuew_7_0, valuew_7_0);
+    if (error) goto exit;
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_qnt_valuew_10_8, valuew_10_8);
+    if (error) goto exit;
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_qnt_nfvaluew_7_0, nfvaluew_7_0);
+    if (error) goto exit;
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_qnt_nfvaluew_10_8, nfvaluew_10_8);
+    if (error) goto exit;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_reset (
+    IN  Demodulator*    demodulator
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte value;
+    Byte i;
+    Byte j;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    for (i = 0; i < ganymede->chipNumber; i++) {
+
+        /** Enable OFDM reset */
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, I2C_reg_ofdm_rst_en, reg_ofdm_rst_en_pos, reg_ofdm_rst_en_len, 0x01);
+        if (error) goto exit;
+
+        /** Start reset mechanism */
+        value = 0x00;
+        error = Standard_writeRegisters (demodulator, i, Processor_OFDM, RESET_STATE, 1, &value);
+        if (error) goto exit;
+
+        /** Clear ofdm reset */
+        for (j = 0; j < 150; j++) {
+            error = Standard_readRegisterBits (demodulator, i, Processor_OFDM, I2C_reg_ofdm_rst, reg_ofdm_rst_pos, reg_ofdm_rst_len, &value);
+            if (error) goto exit;
+            if (value) break;
+            User_delay (demodulator, 10);
+        }
+
+        if (j == 150) {
+            error = Error_RESET_TIMEOUT;
+            goto exit;
+        }
+
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, I2C_reg_ofdm_rst, reg_ofdm_rst_pos, reg_ofdm_rst_len, 0);
+        if (error) goto exit;
+
+        /** Disable OFDM reset */
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, I2C_reg_ofdm_rst_en, reg_ofdm_rst_en_pos, reg_ofdm_rst_en_len, 0x00);
+        if (error) goto exit;
+    }
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_programFcw (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Long            shift,          /** Hz */
+    IN  Dword           adcFrequency    /** Hz */
+)
+{
+    Dword error = Error_NO_ERROR;
+    Dword fcw;
+    Long fcwShift;
+    Byte temp0;
+    Byte temp1;
+    Byte temp2;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get shift freq */
+    fcwShift = (shift * 8 * 1024 + (Long) adcFrequency / (2 * 1024)) / (Long) adcFrequency * 1024;
+
+    fcw  = (Dword) ((Long) ganymede->fcw + fcwShift);
+
+    temp0 = (Byte) (fcw  & 0x000000FF);
+    temp1 = (Byte) ((fcw & 0x0000FF00) >> 8);
+    temp2 = (Byte) ((fcw & 0x007F0000) >> 16);
+
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_bfs_fcw_7_0, temp0);
+    if (error) goto exit;
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_bfs_fcw_15_8, temp1);
+    if (error) goto exit;
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_reg_bfs_fcw_22_16, temp2);
+    if (error) goto exit;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    OUT ChannelModulation*      channelModulation
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    GetChannelModulationRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.channelModulation = channelModulation;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_GETCHANNELMODULATION,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte temp;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get constellation type */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_const, reg_tpsd_const_pos, reg_tpsd_const_len, &temp);
+    if (error) goto exit;
+    channelModulation->constellation = (Constellation) temp;
+
+    /** Get TPS hierachy and alpha value */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_hier, reg_tpsd_hier_pos, reg_tpsd_hier_len, &temp);
+    if (error) goto exit;
+    channelModulation->hierarchy = (Hierarchy)temp;
+
+    /** Get high/low priority */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_dec_pri, reg_dec_pri_pos, reg_dec_pri_len, &temp);
+    if (error) goto exit;
+    if (temp)
+        channelModulation->priority = Priority_HIGH;
+    else
+        channelModulation->priority = Priority_LOW;
+
+    /** Get high code rate */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_hpcr, reg_tpsd_hpcr_pos, reg_tpsd_hpcr_len, &temp);
+    if (error) goto exit;
+    channelModulation->highCodeRate = (CodeRate) temp;
+
+    /** Get low code rate */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_lpcr, reg_tpsd_lpcr_pos, reg_tpsd_lpcr_len, &temp);
+    if (error) goto exit;
+    channelModulation->lowCodeRate  = (CodeRate) temp;
+
+    /** Get guard interval */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_gi, reg_tpsd_gi_pos, reg_tpsd_gi_len, &temp);
+    if (error) goto exit;
+    channelModulation->interval = (Interval) temp;
+
+    /** Get FFT mode */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_txmod, reg_tpsd_txmod_pos, reg_tpsd_txmod_len, &temp);
+    if (error) goto exit;
+    channelModulation->transmissionMode = (TransmissionModes) temp;
+
+    /** Get bandwidth */
+    error = Standard_readRegisterBits (demodulator, chip, Processor_OFDM, g_reg_bw, reg_bw_pos, reg_bw_len, &temp);
+    if (error) goto exit;
+    channelModulation->bandwidth = (Bandwidth) temp;
+
+    /** Get frequency */
+    channelModulation->frequency = ganymede->frequency[chip];
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    IN  ChannelModulation*      channelModulation
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Byte temp;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Set constellation type */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_const, reg_tpsd_const_pos, reg_tpsd_const_len, (Byte) channelModulation->constellation);
+    if (error) goto exit;
+
+    /** Set TPS hierachy and alpha value */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_hier, reg_tpsd_hier_pos, reg_tpsd_hier_len, (Byte) channelModulation->hierarchy);
+    if (error) goto exit;
+
+    /** Set high/low priority */
+    if (channelModulation->priority == Priority_HIGH)
+        temp = 1;
+    else
+        temp = 0;
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_dec_pri, reg_dec_pri_pos, reg_dec_pri_len, temp);
+    if (error) goto exit;
+
+    /** Set high code rate */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_hpcr, reg_tpsd_hpcr_pos, reg_tpsd_hpcr_len, (Byte) channelModulation->highCodeRate);
+    if (error) goto exit;
+
+    /** Set low code rate */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_lpcr, reg_tpsd_lpcr_pos, reg_tpsd_lpcr_len, (Byte) channelModulation->lowCodeRate);
+    if (error) goto exit;
+
+    /** Set guard interval */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_gi, reg_tpsd_gi_pos, reg_tpsd_gi_len, (Byte) channelModulation->interval);
+    if (error) goto exit;
+
+    /** Set FFT mode */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_tpsd_txmod, reg_tpsd_txmod_pos, reg_tpsd_txmod_len, (Byte) channelModulation->transmissionMode);
+    if (error) goto exit;
+
+    /** Set bandwidth */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, g_reg_bw, reg_bw_pos, reg_bw_len, (Byte) channelModulation->bandwidth);
+    if (error) goto exit;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+Dword Standard_setFrequency (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Dword           frequency
+) {
+    Dword error = Error_NO_ERROR;
+    Byte band;
+    Byte i;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Clear easy mode flag first */
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, Training_Mode, 0x00);
+    if (error) goto exit;
+
+    /** Clear empty_channel_status lock flag */
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, empty_channel_status, 0x00);
+    if (error) goto exit;
+
+    /** Clear MPEG2 lock flag */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, r_mp2if_sync_byte_locked, mp2if_sync_byte_locked_pos, mp2if_sync_byte_locked_len, 0x00);
+    if (error) goto exit;
+
+    /** Determine frequency band */
+    band = 0xFF;
+    for (i = 0; i < Standard_MAX_BAND; i++) {
+        if ((frequency >= Standard_bandTable[i].minimum) && (frequency <= Standard_bandTable[i].maximum)) {
+            band = i;
+            break;
+        }
+    }
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, FreBand, band);
+    if (error) goto exit;
+
+    if (ganymede->tunerDescription->setTuner != NULL) {
+        if ((ganymede->busId != Bus_I2M) && (ganymede->busId != Bus_I2U)) {
+            error = ganymede->tunerDescription->setTuner (demodulator, chip, ganymede->bandwidth[chip], frequency);
+            if (error) goto exit;
+        }
+    }
+
+    /** Trigger ofsm */
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, trigger_ofsm, 0);
+    if (error) goto exit;
+
+    ganymede->frequency[chip] = frequency;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setFrequencyForRetrain (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    IN  Dword                   frequency,
+    IN  Word                    bandwidth,
+    IN  ChannelModulation*      channelModulation
+)
+{
+    Dword error = Error_NO_ERROR;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Clear MPEG2 lock flag first */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, r_mp2if_sync_byte_locked, mp2if_sync_byte_locked_pos, mp2if_sync_byte_locked_len, 0);
+    if (error) goto exit;
+
+    /** Set frequency for all chips */
+    if (ganymede->tunerDescription->setTuner != NULL) {
+        error = ganymede->tunerDescription->setTuner (demodulator, chip, bandwidth, frequency);
+        if (error) goto exit;
+    }
+
+    /** Trigger ofsm */
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, trigger_ofsm, 0);
+    if (error) goto exit;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_maskDcaOutput (
+    IN  Demodulator*    demodulator
+) {
+    Dword error = Error_NO_ERROR;
+    Byte i;
+    Bool dcaValid = False;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if ((ganymede->chipNumber > 1) && (ganymede->architecture == Architecture_DCA))
+        dcaValid = True;
+
+    if (dcaValid == True) {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_dca_upper_out_en, reg_dca_upper_out_en_pos, reg_dca_upper_out_en_len, 0);
+            if (error) goto exit;
+        }
+        User_delay (demodulator, 5);
+    }
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_acquireChannel (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,
+    IN  Dword           frequency
+) {
+    Dword error = Error_NO_ERROR;
+
+    Byte begin;
+    Byte end;
+    Byte i;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    AcquireChannelRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.frequency = frequency;
+        request.bandwidth = bandwidth;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_ACQUIRECHANNEL,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Ganymede* ganymede;
+    deb_info("Enter %s , bw=%d, freq=%d\n", __FUNCTION__, bandwidth, frequency);
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->architecture == Architecture_DCA) {
+        begin = 0;
+        end = ganymede->chipNumber;
+    } else {
+        begin = chip;
+        end = begin + 1;
+    }
+
+    for (i = begin; i < end; i++) {
+        error = Standard_selectBandwidth (demodulator, i, bandwidth, ganymede->adcFrequency);
+        if (error) goto exit;
+		ganymede->bandwidth[i] = bandwidth;
+    }
+
+    error = Standard_maskDcaOutput (demodulator);
+    if (error) goto exit;
+
+    /** Set frequency */
+    for (i = begin; i < end; i++) {
+        error = Standard_setFrequency (demodulator, i, frequency);
+        if (error) goto exit;
+    }
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setStreamType (
+    IN  Demodulator*    demodulator,
+    IN  StreamType      streamType
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    SetStreamTypeRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.streamType = streamType;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_SETSTREAMTYPE,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    //Dword warning = Error_NO_ERROR;
+    Ganymede* ganymede;
+    Byte i;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Enable DVB-T interrupt if next stream type is StreamType_DVBT_DATAGRAM */
+    if (streamType == StreamType_DVBT_DATAGRAM) {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_inten, reg_dvbt_inten_pos, reg_dvbt_inten_len, 1);
+            if (error) goto exit;
+            if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_mpeg_full_speed, reg_mpeg_full_speed_pos, reg_mpeg_full_speed_len, 0);
+                if (error) goto exit;
+            } else {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_mpeg_full_speed, reg_mpeg_full_speed_pos, reg_mpeg_full_speed_len, 1);
+                if (error) goto exit;
+            }
+        }
+    }
+
+    /** Enable DVB-T mode */
+    for (i = 0; i < ganymede->chipNumber; i++) {
+        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_en, reg_dvbt_en_pos, reg_dvbt_en_len, 1);
+        if (error) goto exit;
+    }
+
+    /** Enter sub mode */
+    switch (streamType) {
+
+	case StreamType_NONE : 
+		goto exit;
+		break;
+
+        case StreamType_DVBT_DATAGRAM :
+            if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+                error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 0);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_mp2if_mpeg_par_mode, mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len, 0);
+                if (error) goto exit;
+                /** Fix current leakage */
+                if (ganymede->chipNumber > 1) {
+                    if (ganymede->hostInterface[0]) {
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_par_mode, reg_top_hostb_mpeg_par_mode_pos, reg_top_hostb_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    } else {
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    }
+                } else {
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 1);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 0);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_par_mode, reg_top_hostb_mpeg_par_mode_pos, reg_top_hostb_mpeg_par_mode_len, 1);
+                    if (error) goto exit;
+                }
+            } else {
+                error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 0);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_mp2if_mpeg_par_mode, mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len, 0);
+                if (error) goto exit;
+
+                /** Fix current leakage */
+                if (ganymede->chipNumber > 1) {
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 0);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 0);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_par_mode, reg_top_hostb_mpeg_par_mode_pos, reg_top_hostb_mpeg_par_mode_len, 0);
+                    if (error) goto exit;
+                } else {
+                    if (ganymede->hostInterface[0]) {
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hostb_mpeg_par_mode, reg_top_hostb_mpeg_par_mode_pos, reg_top_hostb_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    } else {
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    }
+                }
+            }
+            break;
+        case StreamType_DVBT_PARALLEL :
+            for (i = 0; i < ganymede->chipNumber; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 0);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_mp2if_mpeg_par_mode, mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len, 1);
+                if (error) goto exit;
+
+                if (i == 0) {
+                    if (ganymede->hostInterface[0]) {
+                        /** HostA interface is enabled */
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    } else {
+                        /** HostB interface is enabled */
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hostb_mpeg_par_mode, reg_top_hostb_mpeg_par_mode_pos, reg_top_hostb_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    }
+                } else {
+                    /** HostA interface is enabled */
+                    error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 1);
+                    if (error) goto exit;
+                }
+            }
+            break;
+        case StreamType_DVBT_SERIAL :
+            for (i = 0; i < ganymede->chipNumber; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 1);
+                if (error) goto exit;
+
+                if (i == 0) {
+                    if (ganymede->hostInterface[0]) {
+                        /** HostA interface is enabled */
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 1);
+                        if (error) goto exit;
+                    } else {
+                        /** HostB interface is enabled */
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 1);
+                        if (error) goto exit;
+                    }
+                } else {
+                    /** HostA interface is enabled */
+                    error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 1);
+                    if (error) goto exit;
+                }
+            }
+            break;
+    }
+    error = User_mpegConfig (demodulator);
+
+    ganymede->streamType = streamType;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setArchitecture (
+    IN  Demodulator*    demodulator,
+    IN  Architecture    architecture
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    SetArchitectureRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.architecture = architecture;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_SETARCHITECTURE,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Word frameSize;
+    Byte packetSize;
+    Byte buffer[2];
+    Byte standAlone[2];
+    Byte upperChip[2];
+    Byte upperHost[2];
+    Byte lowerChip[2];
+    Byte lowerHost[2];
+    Byte dcaEnable[2];
+    Byte phaseLatch[2];
+    Byte fpgaLatch[2];
+    Byte i;
+    Bool pipValid = False;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    if (architecture == Architecture_DCA) {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            standAlone[i] = 0;
+            upperChip[i] = 0;
+            upperHost[i] = 0;
+            lowerChip[i] = 0;
+            lowerHost[i] = 0;
+            dcaEnable[i] = 1;
+            phaseLatch[i] = 0;
+            fpgaLatch[i] = 0;
+        }
+        if (ganymede->chipNumber == 1) {
+            standAlone[0] = 1;
+            dcaEnable[0] = 0;
+        } else {
+            upperChip[ganymede->chipNumber - 1] = 1;
+            upperHost[0] = 1;
+            lowerChip[0] = 1;
+            lowerHost[ganymede->chipNumber - 1] = 1;
+            phaseLatch[0] = 1;
+            phaseLatch[ganymede->chipNumber - 1] = 1;
+            fpgaLatch[0] = 0x66;
+            fpgaLatch[ganymede->chipNumber - 1] = 0x66;
+        }
+    } else {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            standAlone[i] = 1;
+            upperChip[i] = 0;
+            upperHost[i] = 0;
+            lowerChip[i] = 0;
+            lowerHost[i] = 0;
+            dcaEnable[i] = 0;
+            phaseLatch[i] = 0;
+            fpgaLatch[i] = 0;
+        }
+    }
+
+    if (ganymede->initialized == True) {
+        error = Standard_maskDcaOutput (demodulator);
+        if (error) goto exit;
+    }
+
+    /** Set upper chip first in order to avoid I/O conflict */
+    for (i = ganymede->chipNumber; i > 0; i--) {
+        /** Set dca_upper_chip */
+        error = Standard_writeRegisterBits (demodulator, i - 1, Processor_OFDM, p_reg_dca_upper_chip, reg_dca_upper_chip_pos, reg_dca_upper_chip_len, upperChip[i - 1]);
+        if (error) goto exit;
+        if (i == 1) {
+            if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+                if (ganymede->hostInterface[0]) {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_upper, reg_top_hosta_dca_upper_pos, reg_top_hosta_dca_upper_len, upperHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_upper, reg_top_hostb_dca_upper_pos, reg_top_hostb_dca_upper_len, 0);
+                    if (error) goto exit;
+                } else {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_upper, reg_top_hostb_dca_upper_pos, reg_top_hostb_dca_upper_len, upperHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_upper, reg_top_hosta_dca_upper_pos, reg_top_hosta_dca_upper_len, 0);
+                    if (error) goto exit;
+                }
+            } else {
+                if (ganymede->hostInterface[0]) {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_upper, reg_top_hostb_dca_upper_pos, reg_top_hostb_dca_upper_len, upperHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_upper, reg_top_hosta_dca_upper_pos, reg_top_hosta_dca_upper_len, 0);
+                    if (error) goto exit;
+                } else {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_upper, reg_top_hosta_dca_upper_pos, reg_top_hosta_dca_upper_len, upperHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_upper, reg_top_hostb_dca_upper_pos, reg_top_hostb_dca_upper_len, 0);
+                    if (error) goto exit;
+                }
+            }
+        } else {
+            error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_upper, reg_top_hostb_dca_upper_pos, reg_top_hostb_dca_upper_len, upperHost[i - 1]);
+            if (error) goto exit;
+            error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_upper, reg_top_hosta_dca_upper_pos, reg_top_hosta_dca_upper_len, 0);
+            if (error) goto exit;
+        }
+
+        /** Set dca_lower_chip */
+        error = Standard_writeRegisterBits (demodulator, i - 1, Processor_OFDM, p_reg_dca_lower_chip, reg_dca_lower_chip_pos, reg_dca_lower_chip_len, lowerChip[i - 1]);
+        if (error) goto exit;
+        if (i == 1) {
+            if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+                if (ganymede->hostInterface[0]) {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_lower, reg_top_hosta_dca_lower_pos, reg_top_hosta_dca_lower_len, lowerHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_lower, reg_top_hostb_dca_lower_pos, reg_top_hostb_dca_lower_len, 0);
+                    if (error) goto exit;
+                } else {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_lower, reg_top_hostb_dca_lower_pos, reg_top_hostb_dca_lower_len, lowerHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_lower, reg_top_hosta_dca_lower_pos, reg_top_hosta_dca_lower_len, 0);
+                    if (error) goto exit;
+                }
+            } else {
+                if (ganymede->hostInterface[0]) {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_lower, reg_top_hostb_dca_lower_pos, reg_top_hostb_dca_lower_len, lowerHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_lower, reg_top_hosta_dca_lower_pos, reg_top_hosta_dca_lower_len, 0);
+                    if (error) goto exit;
+                } else {
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_lower, reg_top_hosta_dca_lower_pos, reg_top_hosta_dca_lower_len, lowerHost[i - 1]);
+                    if (error) goto exit;
+                    error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_lower, reg_top_hostb_dca_lower_pos, reg_top_hostb_dca_lower_len, 0);
+                    if (error) goto exit;
+                }
+            }
+        } else {
+            error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hostb_dca_lower, reg_top_hostb_dca_lower_pos, reg_top_hostb_dca_lower_len, lowerHost[i - 1]);
+            if (error) goto exit;
+            error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_top_hosta_dca_lower, reg_top_hosta_dca_lower_pos, reg_top_hosta_dca_lower_len, 0);
+            if (error) goto exit;
+        }
+
+        /** Set phase latch */
+        error = Standard_writeRegisterBits (demodulator, i - 1, Processor_OFDM, p_reg_dca_platch, reg_dca_platch_pos, reg_dca_platch_len, phaseLatch[i - 1]);
+        if (error) goto exit;
+
+        /** Set fpga latch */
+        error = Standard_writeRegisterBits (demodulator, i - 1, Processor_OFDM, p_reg_dca_fpga_latch, reg_dca_fpga_latch_pos, reg_dca_fpga_latch_len, fpgaLatch[i - 1]);
+        if (error) goto exit;
+    }
+
+    for (i = 0; i < ganymede->chipNumber; i++) {
+        /** Set stand alone */
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_dca_stand_alone, reg_dca_stand_alone_pos, reg_dca_stand_alone_len, standAlone[i]);
+        if (error) goto exit;
+
+        /** Set DCA enable */
+        error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_dca_en, reg_dca_en_pos, reg_dca_en_len, dcaEnable[i]);
+        if (error) goto exit;
+    }
+
+    if (ganymede->initialized == True) {
+        for (i = 0; i < ganymede->chipNumber; i++) {
+            error = Standard_writeRegister (demodulator, i, Processor_OFDM, trigger_ofsm, 0);
+            if (error) goto exit;
+        }
+    }
+
+
+    if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+        frameSize = User_USB20_FRAME_SIZE_DW;
+        packetSize = (Byte) (User_USB20_MAX_PACKET_SIZE / 4);
+
+        if (ganymede->busId == Bus_USB11) {
+            frameSize   = User_USB11_FRAME_SIZE_DW;
+            packetSize = (Byte) (User_USB11_MAX_PACKET_SIZE / 4);
+        }
+
+        if ((ganymede->chipNumber > 1) && (architecture == Architecture_PIP))
+            pipValid = True;
+#if 0 //j011+s
+        /** Reset EP4 */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2_sw_rst, reg_mp2_sw_rst_pos, reg_mp2_sw_rst_len, 1);
+        if (error) goto exit;
+#endif //j011+e
+
+        /** Reset EP5 */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2if2_sw_rst, reg_mp2if2_sw_rst_pos, reg_mp2if2_sw_rst_len, 1);
+        if (error) goto exit;
+
+        /** Disable EP4 */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_ep4_tx_en, reg_ep4_tx_en_pos, reg_ep4_tx_en_len, 0);
+        if (error) goto exit;
+
+        /** Disable EP5 */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_ep5_tx_en, reg_ep5_tx_en_pos, reg_ep5_tx_en_len, 0);
+        if (error) goto exit;
+
+        /** Disable EP4 NAK */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_ep4_tx_nak, reg_ep4_tx_nak_pos, reg_ep4_tx_nak_len, 0);
+        if (error) goto exit;
+
+        /** Disable EP5 NAK */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_ep5_tx_nak, reg_ep5_tx_nak_pos, reg_ep5_tx_nak_len, 0);
+        if (error) goto exit;
+
+        /** Enable EP4 */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_ep4_tx_en, reg_ep4_tx_en_pos, reg_ep4_tx_en_len, 1);
+        if (error) goto exit;
+
+        /** Set EP4 transfer length */
+        buffer[p_reg_ep4_tx_len_7_0 - p_reg_ep4_tx_len_7_0] = (Byte) frameSize;
+        buffer[p_reg_ep4_tx_len_15_8 - p_reg_ep4_tx_len_7_0] = (Byte) (frameSize >> 8);
+        error = Standard_writeRegisters (demodulator, 0, Processor_LINK, p_reg_ep4_tx_len_7_0, 2, buffer);
+
+        /** Set EP4 packet size */
+        error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_ep4_max_pkt, packetSize);
+        if (error) goto exit;
+
+        if (pipValid == True) {
+            /** Enable EP5 */
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_LINK, p_reg_ep5_tx_en, reg_ep5_tx_en_pos, reg_ep5_tx_en_len, 1);
+            if (error) goto exit;
+
+            /** Set EP5 transfer length */
+            buffer[p_reg_ep5_tx_len_7_0 - p_reg_ep5_tx_len_7_0] = (Byte) frameSize;
+            buffer[p_reg_ep5_tx_len_15_8 - p_reg_ep5_tx_len_7_0] = (Byte) (frameSize >> 8);
+            error = Standard_writeRegisters (demodulator, 0, Processor_LINK, p_reg_ep5_tx_len_7_0, 2, buffer);
+
+            /** Set EP5 packet size */
+            error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_ep5_max_pkt, packetSize);
+            if (error) goto exit;
+        }
+
+
+        /** Disable 15 SER/PAR mode */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 0);
+        if (error) goto exit;
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_mp2if_mpeg_par_mode, mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len, 0);
+        if (error) goto exit;
+
+        if (pipValid == True) {
+            /** Enable mp2if2 */
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2if2_en, reg_mp2if2_en_pos, reg_mp2if2_en_len, 1);
+            if (error) goto exit;
+
+            for (i = 1; i < ganymede->chipNumber; i++) {
+                /** Enable serial mode */
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 1);
+                if (error) goto exit;
+
+                /** Enable HostB serial */
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 1);
+                if (error) goto exit;
+            }
+
+            /** Enable tsis */
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_tsis_en, reg_tsis_en_pos, reg_tsis_en_len, 1);
+            if (error) goto exit;
+        } else {
+            /** Disable mp2if2 */
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2if2_en, reg_mp2if2_en_pos, reg_mp2if2_en_len, 0);
+            if (error) goto exit;
+
+            for (i = 1; i < ganymede->chipNumber; i++) {
+                /** Disable serial mode */
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_mp2if_mpeg_ser_mode, mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, 0);
+                if (error) goto exit;
+
+                /** Disable HostB serial */
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hostb_mpeg_ser_mode, reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 0);
+                if (error) goto exit;
+            }
+
+            /** Disable tsis */
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_tsis_en, reg_tsis_en_pos, reg_tsis_en_len, 0);
+            if (error) goto exit;
+        }
+
+        /** Negate EP4 reset */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2_sw_rst, reg_mp2_sw_rst_pos, reg_mp2_sw_rst_len, 0);
+        if (error) goto exit;
+
+        /** Negate EP5 reset */
+        error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2if2_sw_rst, reg_mp2if2_sw_rst_pos, reg_mp2if2_sw_rst_len, 0);
+        if (error) goto exit;
+
+        if (pipValid == True) {
+            /** Split 15 PSB to 1K + 1K and enable flow control */
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2if2_half_psb, reg_mp2if2_half_psb_pos, reg_mp2if2_half_psb_len, 0);
+            if (error) goto exit;
+            error = Standard_writeRegisterBits (demodulator, 0, Processor_OFDM, p_reg_mp2if_stop_en, reg_mp2if_stop_en_pos, reg_mp2if_stop_en_len, 1);
+            if (error) goto exit;
+
+            for (i = 1; i < ganymede->chipNumber; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_mpeg_full_speed, reg_mpeg_full_speed_pos, reg_mpeg_full_speed_len, 0);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_mp2if_stop_en, reg_mp2if_stop_en_pos, reg_mp2if_stop_en_len, 0);
+                if (error) goto exit;
+            }
+        }
+    }
+
+    ganymede->architecture = architecture;
+
+exit:
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            superFrameCount,
+    IN  Word            packetUnit
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    SetStatisticRangeRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.superFrameCount = superFrameCount;
+        request.packetUnit = packetUnit;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_SETSTATISTICRANGE,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte temp0;
+    Byte temp1;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    /** Set super frame count */
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, qnt_vbc_sframe_num, superFrameCount);
+    if (error) goto exit;
+
+    /** Set packet unit. */
+    temp0 = (Byte) packetUnit;
+    temp1 = (Byte) (packetUnit >> 8);
+    error = Standard_writeRegisters (demodulator, chip, Processor_OFDM, rsd_packet_unit_7_0, 1, &temp0);
+    if (error) goto exit;
+    error = Standard_writeRegisters (demodulator, chip, Processor_OFDM, rsd_packet_unit_15_8, 1, &temp1);
+    if (error) goto exit;
+
+exit:
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte*           frameCount,
+    IN  Word*           packetUnit
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    GetStatisticRangeRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.superFrameCount = superFrameCount;
+        request.packetUnit = packetUnit;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_GETSTATISTICRANGE,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte temp0;
+    Byte temp1;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    /** Get super frame count */
+    error = Standard_readRegister (demodulator, chip, Processor_OFDM, qnt_vbc_sframe_num, frameCount);
+    if (error) goto exit;
+
+    /** Get packet unit. */
+    error = Standard_readRegisters (demodulator, chip, Processor_OFDM, r_rsd_packet_unit_7_0, 1, &temp0);
+    if (error) goto exit;
+    error = Standard_readRegisters (demodulator, chip, Processor_OFDM, r_rsd_packet_unit_15_8, 1, &temp1);
+    if (error) goto exit;
+    *packetUnit = (Word) (temp1 << 8) + (Word) temp0;
+
+exit:
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getStatistic (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Statistic*      statistic
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    GetStatisticRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.statistic = statistic;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_GETSTATISTIC,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Ganymede* ganymede;
+    Byte quality;
+    Byte strength;
+    Byte buffer[2];
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get statistic by stream type */
+    error = Standard_readRegisters (demodulator, chip, Processor_OFDM, tpsd_lock, mpeg_lock - tpsd_lock + 1, buffer);
+    if (error) goto exit;
+
+    if (buffer[tpsd_lock - tpsd_lock])
+        ganymede->statistic[chip].signalPresented = True;
+    else
+        ganymede->statistic[chip].signalPresented = False;
+
+    if (buffer[mpeg_lock - tpsd_lock])
+        ganymede->statistic[chip].signalLocked = True;
+    else
+        ganymede->statistic[chip].signalLocked = False;
+
+    error = Standard_getSignalQuality (demodulator, chip, &quality);
+    if (error) goto exit;
+
+    ganymede->statistic[chip].signalQuality = quality;
+
+    error = Standard_getSignalStrength (demodulator, chip, &strength);
+    if (error) goto exit;
+
+    ganymede->statistic[chip].signalStrength = strength;
+
+    *statistic = ganymede->statistic[chip];
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getInterrupts (
+    IN  Demodulator*    demodulator,
+    OUT Interrupts*     interrupts
+) {
+    Dword error = Error_NO_ERROR;
+    Ganymede* ganymede;
+    Byte value = 0;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get interrupts by stream type */
+
+
+    *interrupts = Interrupt_NONE;
+
+    /** Read the interrupts register to determine the type of interrupts. */
+    error = Standard_readRegister (demodulator, 0, Processor_LINK, r_link_ofsm_dvbt_int, &value);
+    if (error) goto exit;
+
+    if (value & 0x04) {
+        ganymede->dataReady = True;
+        *interrupts |= Interrupt_DVBT;
+    }
+
+exit:
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_clearInterrupt (
+    IN  Demodulator*    demodulator,
+    IN  Interrupt       interrupt
+) {
+    Dword error = Error_NO_ERROR;
+    Ganymede* ganymede;
+    Byte value = 0;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Clear interrupt by stream type */
+
+    //error = ganymede->dvbtStandardDescription.clearInterrupt (demodulator, interrupt);
+    value = (Byte) interrupt;
+
+    /** Clear the specific interrupt. */
+    error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_dvbt_intsts, value);
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getDataLength (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          dataLength,
+    OUT Bool*           valid           /** used in DVBH mode */
+) {
+    Dword error = Error_NO_ERROR;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get data length by stream type */
+    switch (ganymede->burstSize) {
+        case BurstSize_1024 :
+            *dataLength = 1024;
+            break;
+        case BurstSize_2048 :
+            *dataLength = 2048;
+            break;
+        case BurstSize_4096 :
+            *dataLength = 4096;
+            break;
+    }
+    *valid = True;
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get data by stream type */
+
+    //error = ganymede->dvbtStandardDescription.getData (demodulator, bufferLength, buffer);
+
+    if (bufferLength == 0) {
+        error = Error_INVALID_DATA_LENGTH;
+        goto exit;
+    }
+
+
+    /** IP datagram is locate in a special register 0xF00000 */
+    error = ganymede->cmdDescription->receiveData (demodulator, 0xF00000, bufferLength, buffer);
+    if (error) goto exit;
+
+    ganymede->dataReady = False;
+
+exit:
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+/** combine Standard_getLength and Standard_getData */
+Dword Standard_getDatagram (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          bufferLength,
+    OUT Byte*           buffer
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    GetDatagramRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.bufferLength = bufferLength;
+        request.buffer = buffer;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_GETDATAGRAM,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Ganymede* ganymede;
+    Dword length = 0;
+    Byte value;
+    // Bool ready = False;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Get datagram by stream type */
+
+    //error = ganymede->dvbtStandardDescription.getDatagram (demodulator, bufferLength, buffer);
+
+#if User_USE_INTERRUPT
+#else
+
+    error = Standard_readRegisterBits (demodulator, 0, Processor_LINK, r_link_ofsm_ip_valid, link_ofsm_ip_valid_pos, link_ofsm_ip_valid_len, &value);
+    if (error) goto exit;
+
+    if (value) {
+        ganymede->dataReady = True;
+    }
+    if (ganymede->dataReady == False) {
+        *bufferLength = 0;
+        error = Error_NOT_READY;
+        goto exit;
+    }
+#endif
+    switch (ganymede->burstSize) {
+        case BurstSize_1024 :
+            length = 1024;
+            break;
+        case BurstSize_2048 :
+            length = 2048;
+            break;
+        case BurstSize_4096 :
+            length = 4096;
+            break;
+    }
+    if (*bufferLength >= length) {
+        //error = Dvbt_getData (demodulator, length, (Byte*) buffer);
+        //if (error) goto exit;
+
+        if (bufferLength == 0) {
+            error = Error_INVALID_DATA_LENGTH;
+            goto exit;
+        }
+
+
+        /** IP datagram is locate in a special register 0xF00000 */
+        error = ganymede->cmdDescription->receiveData (demodulator, 0xF00000, length, buffer);
+        if (error) goto exit;
+
+        *bufferLength = length;
+
+        ganymede->dataReady = False;
+
+        *bufferLength = length;
+    } else {
+        error = Error_BUFFER_INSUFFICIENT;
+    }
+
+
+exit:
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+/** get ir raw code (4 bytes) */
+Dword Standard_getIrCode (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          code
+)  {
+    Dword error = Error_NO_ERROR;
+    Byte readBuffer[4];
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    error = Standard_sendCommand (demodulator, Command_IR_GET, 0, Processor_LINK, 0, NULL, 4, readBuffer);
+    if (error) goto exit;
+
+    *code = (Dword) ((readBuffer[0] << 24) + (readBuffer[1] << 16) + (readBuffer[2] << 8) + readBuffer[3]);
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_reboot (
+    IN  Demodulator*    demodulator
+)  {
+    Dword error = Error_NO_ERROR;
+    Dword version;
+    Byte i;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    error = Standard_getFirmwareVersion (demodulator, Processor_LINK, &version);
+    if (error) goto exit;
+    if (version == 0xFFFFFFFF) goto exit;       /** I2M and I2U */
+    if (version != 0) {
+        for (i = ganymede->chipNumber; i > 0; i--) {
+            error = ganymede->cmdDescription->reboot (demodulator, i - 1);
+            if (error) goto exit;
+            User_delay (demodulator, 1);
+        }
+
+        User_delay (demodulator, 10);
+
+        version = 1;
+        for (i = 0; i < 30; i++) {
+            error = Standard_getFirmwareVersion (demodulator, Processor_LINK, &version);
+            if (error == Error_NO_ERROR) break;
+            User_delay (demodulator, 10);
+        }
+        if (error) goto exit;
+        if (version != 0)
+            error = Error_REBOOT_FAIL;
+    }
+    for (i = ganymede->chipNumber; i > 0; i--) {
+        error = Standard_writeRegisterBits (demodulator, i - 1, Processor_LINK, p_reg_p_dmb_sw_reset, reg_p_dmb_sw_reset_pos, reg_p_dmb_sw_reset_len, 1);
+        if (error) goto exit;
+    }
+
+    ganymede->booted = False;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_controlPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    ControlPowerSavingRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.control = control;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_CONTROLPOWERSAVING,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte temp;
+    Byte begin;
+    Byte end;
+    Byte i;
+    Byte j;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s control=%d-\n", __FUNCTION__, control);
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->architecture == Architecture_DCA) {
+        begin = 0;
+        end = ganymede->chipNumber;
+    } else {
+        begin = chip;
+        end = begin + 1;
+    }
+
+    if (control) {
+        /** Power up case */
+        if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+            for (i = begin; i < end; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_afe_mem0, 3, 1, 0);
+                if (error) goto exit;
+                error = Standard_writeRegister (demodulator, i, Processor_OFDM, suspend_flag, 0);
+                if (error) goto exit;
+				error = Standard_writeRegister (demodulator, i, Processor_OFDM, trigger_ofsm, 0);
+				if (error) goto exit;
+
+            }
+        } else {  /** TS, SPI, and SDIO case */
+            /** not implemented yet */
+        }
+
+        /** Fixed current leakage */
+        switch (ganymede->busId) {
+            case Bus_SPI :
+            case Bus_SDIO :
+            case Bus_USB :
+            case Bus_USB11 :
+                if (ganymede->chipNumber > 1) {
+                    for (i = 1; i < ganymede->chipNumber; i++) {
+                        /** Disable HostA parallel */
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 0);
+                        if (error) goto exit;
+                    }
+                }
+                break;
+        }
+    } else {
+        /** Power down case */
+        if ((ganymede->busId == Bus_USB) || (ganymede->busId == Bus_USB11)) {
+            for (i = begin; i < end; i++) {
+                error = Standard_writeRegister (demodulator, i, Processor_OFDM, suspend_flag, 1);
+                if (error) goto exit;
+                error = Standard_writeRegister (demodulator, i, Processor_OFDM, trigger_ofsm, 0);
+                if (error) goto exit;
+
+                for (j = 0; j < 150; j++) {
+                    error = Standard_readRegister (demodulator, i, Processor_OFDM, suspend_flag, &temp);
+                    if (error) goto exit;
+                    if (!temp) break;
+                    User_delay (demodulator, 10);
+                }
+                error = Standard_writeRegisterBits (demodulator, i, Processor_OFDM, p_reg_afe_mem0, 3, 1, 1);
+                if (error) goto exit;
+            }
+        } else {  /** TS SPI SDIO */
+            /** not implemented yet */
+        }
+
+        /** Fixed current leakage */
+        switch (ganymede->busId) {
+            case Bus_SPI :
+            case Bus_SDIO :
+            case Bus_USB :
+            case Bus_USB11 :
+                if (ganymede->chipNumber > 1) {
+                    for (i = 1; i < ganymede->chipNumber; i++) {
+                        /** Enable HostA parallel */
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_ser_mode, reg_top_hosta_mpeg_ser_mode_pos, reg_top_hosta_mpeg_ser_mode_len, 0);
+                        if (error) goto exit;
+                        error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_top_hosta_mpeg_par_mode, reg_top_hosta_mpeg_par_mode_pos, reg_top_hosta_mpeg_par_mode_len, 1);
+                        if (error) goto exit;
+                    }
+                }
+                break;
+        }
+    }
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_controlTunerPowerSaving (
+    IN  Demodulator*    demodulator,
+	IN  Byte            control
+) {
+	Dword error = Error_NO_ERROR;
+
+    deb_info("Enter %s control=%d-\n", __FUNCTION__, control);
+	if (control) {
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_top_gpioh7_en, 1);
+		if (error) goto exit;
+
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_top_gpioh7_on, 1);
+		if (error) goto exit;
+
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_top_gpioh7_o, 1);
+		if (error) goto exit;
+	} else {
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_top_gpioh7_en, 1);
+		if (error) goto exit;
+
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_top_gpioh7_on, 1);
+		if (error) goto exit;
+
+		error = Standard_writeRegister (demodulator, 0, Processor_LINK, p_reg_top_gpioh7_o, 0);
+		if (error) goto exit;
+	}
+
+exit:
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+	return (error);
+}
+
+
+Dword Standard_runCode (
+    IN  Demodulator*    demodulator,
+    IN  Word            code
+) {
+    Dword error = Error_NO_ERROR;
+    Byte writeBuffer[2];
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    writeBuffer[0] = (Byte) (code >> 8);
+    writeBuffer[1] = (Byte) code;
+    error = Standard_sendCommand (demodulator, Command_RUN_CODE, 0, Processor_LINK, 2, writeBuffer, 0, NULL);
+    if (error) goto exit;
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_controlPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    ControlPidFilterRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.control = control;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_CONTROLPIDFILTER,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_en, mp2if_pid_en_pos, mp2if_pid_en_len, control);
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_resetPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+#else
+    Ganymede* ganymede;
+    deb_info("Enter %s -\n", __FUNCTION__);
+
+    ganymede = (Ganymede*) demodulator;
+
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_rst, mp2if_pid_rst_pos, mp2if_pid_rst_len, 1);
+    if (error) goto exit;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+Dword Standard_addPidToFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            index,
+    IN  Pid             pid
+) {
+    Dword error = Error_NO_ERROR;
+
+#if User_USE_DRIVER
+    DWORD number;
+    BOOL result;
+    AddPidRequest request;
+    Ganymede* ganymede;
+
+    ganymede = (Ganymede*) demodulator;
+
+    if (ganymede->driver != NULL) {
+        request.chip = chip;
+        request.pid = pid;
+        result = DeviceIoControl (
+                    ganymede->driver,
+                    IOCTL_AFA_DEMOD_ADDPID,
+                    &request,
+                    sizeof (request),
+                    NULL,
+                    0,
+                    &number,
+                    NULL
+        );
+        error = request.error;
+    } else {
+        error = Error_DRIVER_INVALID;
+    }
+#else
+    Byte writeBuffer[2];
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+    /** Enable pid filter */
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_en, mp2if_pid_en_pos, mp2if_pid_en_len, 1);
+    if (error) goto exit;
+
+    writeBuffer[0] = (Byte) pid.value;
+    writeBuffer[1] = (Byte) (pid.value >> 8);
+
+    error = Standard_writeRegisters (demodulator, chip, Processor_OFDM, p_mp2if_pid_dat_l, 2, writeBuffer);
+    if (error) goto exit;
+
+    error = Standard_writeRegisterBits (demodulator, chip, Processor_OFDM, p_mp2if_pid_index_en, mp2if_pid_index_en_pos, mp2if_pid_index_en_len, 1);
+    if (error) goto exit;
+
+    error = Standard_writeRegister (demodulator, chip, Processor_OFDM, p_mp2if_pid_index, index);
+    if (error) goto exit;
+
+exit :
+#endif
+
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_setBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize       burstSize
+) {
+    Dword error = Error_NO_ERROR;
+    Byte i;
+    Ganymede* ganymede;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    ganymede = (Ganymede*) demodulator;
+
+
+    if (burstSize == BurstSize_4096) {
+        error = Error_NOT_SUPPORT;
+        goto exit;
+    }
+
+
+    switch (burstSize) {
+        case BurstSize_1024 :
+            for (i = 0; i < ganymede->chipNumber; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_path, reg_dvbt_path_pos, reg_dvbt_path_len, 1);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_bufsize, reg_dvbt_bufsize_pos, reg_dvbt_bufsize_len, 1);
+                if (error) goto exit;
+            }
+            ganymede->burstSize = BurstSize_1024;
+            break;
+        case BurstSize_2048 :
+            for (i = 0; i < ganymede->chipNumber; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_path, reg_dvbt_path_pos, reg_dvbt_path_len, 1);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_bufsize, reg_dvbt_bufsize_pos, reg_dvbt_bufsize_len, 0);
+                if (error) goto exit;
+            }
+            ganymede->burstSize = BurstSize_2048;
+
+            break;
+        case BurstSize_4096 :
+            for (i = 0; i < ganymede->chipNumber; i++) {
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_path, reg_dvbt_path_pos, reg_dvbt_path_len, 0);
+                if (error) goto exit;
+                error = Standard_writeRegisterBits (demodulator, i, Processor_LINK, p_reg_dvbt_bufsize, reg_dvbt_bufsize_pos, reg_dvbt_bufsize_len, 1);
+                if (error) goto exit;
+            }
+            ganymede->burstSize = BurstSize_4096;
+            break;
+    }
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
+
+
+Dword Standard_getBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize*      burstSize
+) {
+    Dword error = Error_NO_ERROR;
+    Byte path;
+    Byte size;
+
+    deb_info("Enter %s -\n", __FUNCTION__);
+    error = Standard_readRegisterBits (demodulator, 0, Processor_LINK, p_reg_dvbt_path, reg_dvbt_path_pos, reg_dvbt_path_len, &path);
+    if (error) goto exit;
+    error = Standard_readRegisterBits (demodulator, 0, Processor_LINK, p_reg_dvbt_bufsize, reg_dvbt_bufsize_pos, reg_dvbt_bufsize_len, &size);
+    if (error) goto exit;
+
+    if (path) {
+        if (size) {
+            *burstSize = BurstSize_1024;
+        } else {
+            *burstSize = BurstSize_2048;
+        }
+    } else {
+        if (size) {
+            *burstSize = BurstSize_4096;
+        } else {
+            *burstSize = BurstSize_2048;
+        }
+    }
+
+exit :
+    if(error) {
+	deb_info("%s error, ret=0x%x\n", __FUNCTION__, error);
+    }
+    return (error);
+}
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_standard.h	2012-02-27 00:02:36.928915017 +0100
@@ -0,0 +1,1142 @@
+#ifndef __STANDARD_H__
+#define __STANDARD_H__
+
+
+#include "a867_type.h"
+#include "a867_user.h"
+#include "a867_error.h"
+#include "a867_register.h"
+#include "a867_variable.h"
+#include "a867_version.h"
+
+#if User_USE_DRIVER
+#include <tchar.h>
+#include "iocontrol.h"
+#endif
+
+
+/**
+ * Write one byte (8 bits) to a specific register in demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be written.
+ * @param value the value to be written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            value
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the start address of the registers to be written.
+ * @param bufferLength the number of registers to be written.
+ * @param buffer a byte array which is used to store values to be written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Write a collection of values to discontiguous registers in demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param valueSetsLength the number of values to be written.
+ * @param valueSets a ValueSet array which is used to store values to be
+ *        written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in slave device.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the registers to be read.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous registers in slave device
+ * through specified interface (1, 2, 3).
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param interfaceIndex the index of interface. The possible values are
+ *        1~3.
+ * @param slaveAddress the I2c address of slave device.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Write a sequence of bytes to the contiguous cells in the EEPROM.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5 (firmware will detect EEPROM address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the cells to be written.
+ * @param bufferLength the number of cells to be written.
+ * @param buffer a byte array which is used to store values to be written.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Modify bits in the specific register.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be written.
+ * @param position the start position of bits to be modified (0 means the
+ *        LSB of the specifyed register).
+ * @param length the length of bits.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_writeRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+);
+
+
+/**
+ * Read one byte (8 bits) from a specific register in demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be read.
+ * @param value the pointer used to store the value read from demodulator
+ *        register.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readRegister (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    OUT Byte*           value
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous registers in demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be read.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Read a collection of values to discontiguous registers from demodulator.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param valueSetsLength the number of values to be read.
+ * @param valueSets a ValueSet array which is used to store values to be
+ *        read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readScatterRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous registers in tuner.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the registers to be read.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readTunerRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous registers in slave device
+ * through specified interface (1, 2, 3).
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 6 (one more byte to specify tuner address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param interfaceIndex the index of interface. The possible values are
+ *        1~3.
+ * @param slaveAddress the I2c address of slave device.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readGenericRegisters (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            interfaceIndex,
+    IN  Byte            slaveAddress,
+    IN  Byte            bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Read a sequence of bytes from the contiguous cells in the EEPROM.
+ * The maximum burst size is restricted by the capacity of bus. If bus
+ * could transfer N bytes in one cycle, then the maximum value of
+ * bufferLength would be N - 5 (firmware will detect EEPROM address).
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param registerAddress the start address of the cells to be read.
+ * @param registerAddressLength the valid bytes of registerAddress.
+ * @param bufferLength the number of cells to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readEepromValues (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            registerAddress,
+    IN  Byte            bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Read bits of the specified register.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param registerAddress the address of the register to be read.
+ * @param position the start position of bits to be read (0 means the
+ *        LSB of the specifyed register).
+ * @param length the length of bits.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_readRegisterBits (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            position,
+    IN  Byte            length,
+    OUT Byte*           value
+);
+
+
+/**
+ * Send the command to device.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param command the command to be send.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param processor The processor of specified register. Because each chip
+ *        has two processor so user have to specify the processor. The
+ *        possible values are Processor_LINK and Processor_OFDM.
+ * @param writeBufferLength the number of registers to be write.
+ * @param writeBuffer a byte array which is used to store values to be write.
+ * @param readBufferLength the number of registers to be read.
+ * @param readBuffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_sendCommand (
+    IN  Demodulator*    demodulator,
+    OUT Word            command,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ * Get the version of hardware.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param version the version of hardware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getHardwareVersion (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          version
+);
+
+
+/**
+ * Get the version of firmware.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param version the version of firmware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getFirmwareVersion (
+    IN  Demodulator*    demodulator,
+    IN  Processor       processor,
+    OUT Dword*          version
+);
+
+
+/**
+ * Get RF AGC gain.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param rfAgc the value of RF AGC.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getRfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           rfAgc
+);
+
+
+/**
+ * Get IF AGC gain.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param ifAgc the value of IF AGC.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getIfAgcGain (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           ifAgc
+);
+
+
+/**
+ * Load the IR table for USB device.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param tableLength The length of IR table.
+ * @param table The content of IR table.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_loadIrTable (
+    IN  Demodulator*    demodulator,
+    IN  Word            tableLength,
+    IN  Byte*           table
+);
+
+
+/**
+ * Program the bandwidth related parameters to demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param bandwidth DVB channel bandwidth in MHz. The possible values
+ *        are 5, 6, 7, and 8 (MHz).
+ * @param adcFrequency The value of desire internal ADC frequency (Hz).
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_selectBandwidth (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,          /** KHz                 */
+    IN  Dword           adcFrequency        /** Hz, ex: 20480000    */
+);
+
+
+/**
+ * Mask DCA output.
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_maskDcaOutput (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Load firmware to device
+ *
+ * @param demodulator the handle of demodulator.
+ * @streamType current stream type (useless for Ganymede).
+ * @firmwareCodes pointer to fw binary.
+ * @firmwareSegments pointer to fw segments.
+ * @firmwarePartitions pointer to fw partition (useless for Ganymede).
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_loadFirmware (
+    IN  Demodulator*    demodulator,
+    IN  Byte*           firmwareCodes,
+    IN  Segment*        firmwareSegments,
+    IN  Byte*           firmwarePartitions
+);
+
+/**
+ * First, download firmware from host to demodulator. Actually, firmware is
+ * put in firmware.h as a part of source code. Therefore, in order to
+ * update firmware the host have to re-compile the source code.
+ * Second, setting all parameters which will be need at the beginning.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chipNumber The total number of demodulators.
+ * @param sawBandwidth SAW filter bandwidth in MHz. The possible values
+ *        are 6000, 7000, and 8000 (KHz).
+ * @param streamType The format of output stream.
+ * @param architecture the architecture of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_initialize (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chipNumber,
+    IN  Word            sawBandwidth,
+    IN  StreamType      streamType,
+    IN  Architecture    architecture
+);
+
+
+/**
+ * Power off the demodulators.
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_finalize (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_isAgcLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_isCfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_isSfoeLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_isTpsLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_isMpeg2Locked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param locked the result of frequency tuning. True if there is
+ *        demodulator can lock signal, False otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_isLocked (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Bool*           locked
+);
+
+
+/**
+ * Set priorty of modulation.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param priority modulation priority.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_setPriority (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Priority        priority
+);
+
+
+/**
+ * Reset demodulator.
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_reset (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Get channel modulation related information.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param channelModulation The modulation of channel.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ */
+Dword Standard_getChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    OUT ChannelModulation*      channelModulation
+);
+
+
+/**
+ * Set channel modulation related information.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param channelModulation The modulation of channel.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ */
+Dword Standard_setChannelModulation (
+    IN  Demodulator*            demodulator,
+    IN  Byte                    chip,
+    IN  ChannelModulation*      channelModulation
+);
+
+
+/**
+ * Set frequency.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param frequency The desired frequency.
+ * @return Error_NO_ERROR: successful, other non-zero error code otherwise.
+ */
+Dword Standard_setFrequency (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Dword           frequency
+);
+
+
+/**
+ * Specify the bandwidth of channel and tune the channel to the specific
+ * frequency. Afterwards, host could use output parameter dvbH to determine
+ * if there is a DVB-H signal.
+ * In DVB-T mode, after calling this function the output parameter dvbH
+ * should return False and host could use output parameter "locked" to check
+ * if the channel has correct TS output.
+ * In DVB-H mode, after calling this function the output parameter dvbH should
+ * return True and host could start get platform thereafter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param bandwidth The channel bandwidth.
+ *        DVB-T: 5000, 6000, 7000, and 8000 (KHz).
+ *        DVB-H: 5000, 6000, 7000, and 8000 (KHz).
+ *        T-DMB: 5000, 6000, 7000, and 8000 (KHz).
+ *        FM: 100, and 200 (KHz).
+ * @param frequency the channel frequency in KHz.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_acquireChannel (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,
+    IN  Dword           frequency
+);
+
+
+
+/**
+ * Set the output stream type of chip. Because the device could output in
+ * many stream type, therefore host have to choose one type before receive
+ * data.
+ *
+ * Note: Please refer to the example of Standard_acquireChannel when host want
+ *       to detect the available channels.
+ * Note: After host know all the available channels, and want to change to
+ *       specific channel, host have to choose output mode before receive
+ *       data. Please refer the example of Standard_setStreamType.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param streamType the possible values are
+ *        DVB-H:    StreamType_DVBH_DATAGRAM
+ *                  StreamType_DVBH_DATABURST
+ *        DVB-T:    StreamType_DVBT_DATAGRAM
+ *                  StreamType_DVBT_PARALLEL
+ *                  StreamType_DVBT_SERIAL
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_setStreamType (
+    IN  Demodulator*    demodulator,
+    IN  StreamType      streamType
+);
+
+
+/**
+ * Set the architecture of chip. When two of our device are using, they could
+ * be operated in Diversity Combine Architecture (DCA) or (PIP). Therefore,
+ * host could decide which mode to be operated.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param architecture the possible values are
+ *        Architecture_DCA
+ *        Architecture_PIP
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_setArchitecture (
+    IN  Demodulator*    demodulator,
+    IN  Architecture    architecture
+);
+
+
+/**
+ * Set the counting range for Post-Viterbi and Post-Viterbi.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param postErrorCount the number of super frame for Pre-Viterbi.
+ * @param postBitCount the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getPostVitBer (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Dword*          postErrorCount, /** 24 bits */
+    OUT Dword*          postBitCount,   /** 16 bits */
+    OUT Word*           abortCount
+);
+
+
+/**
+ * Get siganl quality.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param quality The value of signal quality.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getSignalQuality (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           quality
+);
+
+
+/**
+ * Get siganl strength.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param strength The value of signal strength.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getSignalStrength (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Byte*           strength
+);
+
+
+/**
+ * Get signal strength in dbm
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param rfpullUpVolt_X10 the pullup voltag of RF multiply 10.
+ * @param ifpullUpVolt_X10 the pullup voltag of IF multiply 10.
+ * @param strengthDbm The value of signal strength in DBm.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getSignalStrengthDbm (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Long            rfpullUpVolt_X10,     /** RF pull up voltage multiplied by 10   */
+    IN  Long            ifpullUpVolt_X10,     /** IF pull up voltage multiplied by 10   */
+    OUT Long*           strengthDbm           /** DBm                                   */
+);
+
+
+/**
+ * Set the counting range for Pre-Viterbi and Post-Viterbi.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7. NOTE: When the architecture is set to Architecture_DCA
+ *        this parameter is regard as don't care.
+ * @param frameCount the number of super frame for Pre-Viterbi.
+ * @param packetUnit the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_setStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            superFrameCount,
+    IN  Word            packetUnit
+);
+
+
+/**
+ * Get the counting range for Pre-Viterbi and Post-Viterbi.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param frameCount the number of super frame for Pre-Viterbi.
+ * @param packetUnit the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getStatisticRange (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte*           frameCount,
+    IN  Word*           packetUnit
+);
+
+
+/**
+ * Get the statistic values of demodulator, it includes Pre-Viterbi BER,
+ * Post-Viterbi BER, Abort Count, Signal Presented Flag, Signal Locked Flag,
+ * Signal Quality, Signal Strength, Delta-T for DVB-H time slicing.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param statistic the structure that store all statistic values.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getStatistic (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    OUT Statistic*      statistic
+);
+
+
+/**
+ * Get interrupt status.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param interrupts the type of interrupts.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getInterrupts (
+    IN  Demodulator*    demodulator,
+    OUT Interrupts*     interrupts
+);
+
+
+/**
+ * Clear interrupt status.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param interrupt interrupt name.
+ * @param packetUnit the number of packet unit for Post-Viterbi.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_clearInterrupt (
+    IN  Demodulator*    demodulator,
+    IN  Interrupt       interrupt
+);
+
+
+/**
+ * Get data length.
+ * In DVB-T mode, data length should always equals 2K,
+ * In DVB-H mode, data length would be the length of IP datagram.
+ * NOTE: data can't be transfer via I2C bus, in order to transfer data
+ * host must provide SPI bus.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param dataLength the length of data.
+ * @param valid True if the data length is valid.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getDataLength (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          dataLength,
+    OUT Bool*           valid
+);
+
+
+/**
+ * Get DVB-T data.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param bufferLength the length of buffer.
+ * @param buffer buffer used to get Data.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_getData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Get datagram from device.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param bufferLength the number of registers to be read.
+ * @param buffer a byte array which is used to store values to be read.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @return Error_BUFFER_INSUFFICIENT: if buffer is too small.
+ */
+Dword Standard_getDatagram (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param code the value of IR raw code, the size should be 4 or 6,
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_getIrCode (
+    IN  Demodulator*    demodulator,
+    OUT Dword*          code
+);
+
+
+/**
+ * Return to boot code
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_reboot (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param contorl 1: Power up, 0: Power down;
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_controlPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param contorl 1: Power up, 0: Power down;
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_controlTunerPowerSaving (
+    IN  Demodulator*    demodulator,
+    IN  Byte            control
+);
+
+
+/**
+ *
+ * @param demodulator the handle of demodulator.
+ * @param code the address of function pointer in firmware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_runCode (
+    IN  Demodulator*    demodulator,
+    IN  Word            code
+);
+
+
+/**
+ * Control PID fileter
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param contorl 0: Disable, 1: Enable.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @example <pre>
+ * </pre>
+ */
+Dword Standard_controlPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            control
+);
+
+
+/**
+ * Reset PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_resetPidFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+);
+
+
+/**
+ * Add PID to PID filter.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param chip The index of demodulator. The possible values are
+ *        0~7.
+ * @param pid the PID that will be add to PID filter.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+Dword Standard_addPidToFilter (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            index,
+    IN  Pid             pid
+);
+
+
+/**
+ * Set datagram burst size.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param burstSize the burst size.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @return Error_NOT_SUPPORT: if the burst size is not support.
+ */
+Dword Standard_setBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize       burstSize
+);
+
+
+/**
+ * Get datagram burst size.
+ *
+ * @param demodulator the handle of demodulator.
+ * @param burstSize the burst size.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ * @return Error_NOT_SUPPORT: if the burst size is not support.
+ */
+Dword Standard_getBurstSize (
+    IN  Demodulator*    demodulator,
+    IN  BurstSize*      burstSize
+);
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_type.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_type.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_type.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_type.h	2012-02-27 00:02:36.078915017 +0100
@@ -0,0 +1,968 @@
+#ifndef __TYPE_H__
+#define __TYPE_H__
+
+#include <linux/module.h>
+#include "a867_userdef.h"// for Linux
+
+
+//#define IN
+//#define OUT
+//#define INOUT
+
+//j010+s
+#define TS_PACKET_COUNT 44
+//j010+e
+
+
+/**
+ * The type of handle.
+ */
+typedef void* Handle;
+
+
+/**
+ * The type defination of 8-bits unsigned type.
+ */
+typedef unsigned char Byte;
+
+
+/**
+ * The type defination of 16-bits unsigned type.
+ */
+typedef unsigned short Word;
+
+
+/**
+ * The type defination of 32-bits unsigned type.
+ */
+typedef unsigned int Dword;
+
+
+/**
+ * The type defination of 16-bits signed type.
+ */
+typedef short Short;
+
+
+/**
+ * The type defination of 32-bits signed type.
+ */
+typedef int Long;
+
+
+
+#include "a867_inttype.h"        /** release1remove */
+
+/**
+ * The type defination of Bool
+ */
+typedef enum {
+    False = 0,
+    True = 1
+} Bool;
+
+
+/**
+ * The type defination of Segment
+ */
+typedef struct {
+    Byte segmentType;           /** 0:Firmware download 1:Rom copy 2:Direct command */
+    Dword segmentLength;
+} Segment;
+
+
+/**
+ * The type defination of Bandwidth.
+ */
+typedef enum {
+    Bandwidth_6M = 0,           /** Signal bandwidth is 6MHz */
+    Bandwidth_7M,               /** Signal bandwidth is 7MHz */
+    Bandwidth_8M,               /** Signal bandwidth is 8MHz */
+    Bandwidth_5M                /** Signal bandwidth is 5MHz */
+} Bandwidth;
+
+
+/**
+ * The type defination of TransmissionMode.
+ */
+typedef enum {
+    TransmissionMode_2K = 0,    /** OFDM frame consists of 2048 different carriers (2K FFT mode) */
+    TransmissionMode_8K = 1,    /** OFDM frame consists of 8192 different carriers (8K FFT mode) */
+    TransmissionMode_4K = 2     /** OFDM frame consists of 4096 different carriers (4K FFT mode) */
+} TransmissionModes;
+
+
+/**
+ * The type defination of Constellation.
+ */
+typedef enum {
+    Constellation_QPSK = 0,     /** Signal uses QPSK constellation  */
+    Constellation_16QAM,        /** Signal uses 16QAM constellation */
+    Constellation_64QAM         /** Signal uses 64QAM constellation */
+} Constellation;
+
+
+/**
+ * The type defination of Interval.
+ */
+typedef enum {
+    Interval_1_OVER_32 = 0,     /** Guard interval is 1/32 of symbol length */
+    Interval_1_OVER_16,         /** Guard interval is 1/16 of symbol length */
+    Interval_1_OVER_8,          /** Guard interval is 1/8 of symbol length  */
+    Interval_1_OVER_4           /** Guard interval is 1/4 of symbol length  */
+} Interval;
+
+
+/**
+ * The type defination of Priority.
+ */
+typedef enum {
+    Priority_HIGH = 0,          /** DVB-T and DVB-H - identifies high-priority stream */
+    Priority_LOW                /** DVB-T and DVB-H - identifies low-priority stream  */
+} Priority;
+
+
+/**
+ * The type defination of CodeRate.
+ */
+typedef enum {
+    CodeRate_1_OVER_2 = 0,      /** Signal uses FEC coding ratio of 1/2 */
+    CodeRate_2_OVER_3,          /** Signal uses FEC coding ratio of 2/3 */
+    CodeRate_3_OVER_4,          /** Signal uses FEC coding ratio of 3/4 */
+    CodeRate_5_OVER_6,          /** Signal uses FEC coding ratio of 5/6 */
+    CodeRate_7_OVER_8,          /** Signal uses FEC coding ratio of 7/8 */
+    CodeRate_NONE               /** None, NXT doesn't have this one     */
+} CodeRate;
+
+
+/**
+ * TPS Hierarchy and Alpha value.
+ */
+typedef enum {
+    Hierarchy_NONE = 0,         /** Signal is non-hierarchical        */
+    Hierarchy_ALPHA_1,          /** Signalling format uses alpha of 1 */
+    Hierarchy_ALPHA_2,          /** Signalling format uses alpha of 2 */
+    Hierarchy_ALPHA_4           /** Signalling format uses alpha of 4 */
+} Hierarchy;
+
+
+/**
+ * The defination of SubchannelType.
+ */
+typedef enum {
+    SubchannelType_AUDIO = 0,           /** Signal in subchannel is audio format          */
+    SubchannelType_VIDEO = 1,           /** Signal in subchannel is video format          */
+    SubchannelType_PACKET = 3,          /** Signal in subchannel is packet format         */
+    SubchannelType_ENHANCEPACKET = 4    /** Signal in subchannel is enhance packet format */
+} SubchannelType;
+
+
+/**
+ * The defination of ProtectionLevel.
+ */
+typedef enum {
+    ProtectionLevel_NONE = 0x00,    /** The protection level of subchannel is none     */
+    ProtectionLevel_PL1 = 0x01,     /** The protection level of subchannel is level 1  */
+    ProtectionLevel_PL2 = 0x02,     /** The protection level of subchannel is level 2  */
+    ProtectionLevel_PL3 = 0x03,     /** The protection level of subchannel is level 3  */
+    ProtectionLevel_PL4 = 0x04,     /** The protection level of subchannel is level 4  */
+    ProtectionLevel_PL5 = 0x05,     /** The protection level of subchannel is level 5  */
+    ProtectionLevel_PL1A = 0x1A,    /** The protection level of subchannel is level 1A */
+    ProtectionLevel_PL2A = 0x2A,    /** The protection level of subchannel is level 2A */
+    ProtectionLevel_PL3A = 0x3A,    /** The protection level of subchannel is level 3A */
+    ProtectionLevel_PL4A = 0x4A,    /** The protection level of subchannel is level 4A */
+    ProtectionLevel_PL1B = 0x1B,    /** The protection level of subchannel is level 1B */
+    ProtectionLevel_PL2B = 0x2B,    /** The protection level of subchannel is level 2B */
+    ProtectionLevel_PL3B = 0x3B,    /** The protection level of subchannel is level 3B */
+    ProtectionLevel_PL4B = 0x4B     /** The protection level of subchannel is level 4B */
+} ProtectionLevel;
+
+
+/**
+ * The defination of ChannelInformation.
+ */
+typedef struct {
+    Dword frequency;                    /** Channel frequency in KHz.                                */
+    TransmissionModes transmissionMode; /** Number of carriers used for OFDM signal                  */
+    Constellation constellation;        /** Constellation scheme (FFT mode) in use                   */
+    Interval interval;                  /** Fraction of symbol length used as guard (Guard Interval) */
+    Priority priority;                  /** The priority of stream                                   */
+    CodeRate highCodeRate;              /** FEC coding ratio of high-priority stream                 */
+    CodeRate lowCodeRate;               /** FEC coding ratio of low-priority stream                  */
+    Hierarchy hierarchy;                /** Hierarchy levels of OFDM signal                          */
+    Bandwidth bandwidth;
+} ChannelModulation;
+
+
+/**
+ * The defination of SubchannelModulation. This structure is used to
+ * represent subchannel modulation when device is operate in T-DMB/DAB mode.
+ *
+ */
+typedef struct {
+    Byte subchannelId;                  /** The ID of subchannel.                                                 */
+    Word subchannelSize;                /** The size of subchannel.                                               */
+    Word bitRate;                       /** The bit rate of subchannel.                                           */
+    Byte transmissionMode;              /** The transmission mode of subchannel, possible values are: 1, 2, 3, 4. */
+    ProtectionLevel protectionLevel;    /** The protection level of subchannel.                                   */
+    SubchannelType subchannelType;      /** The type of subchannel                                                */
+    Byte conditionalAccess;             /** If a conditional access exist                                         */
+    Byte tiiPrimary;                    /** TII primary                                                           */
+    Byte tiiCombination;                /** TII combination                                                       */
+} SubchannelModulation;
+
+
+/**
+ * The type defination of IpVersion.
+ */
+typedef enum {
+    IpVersion_IPV4 = 0,         /** The IP version if IPv4 */
+    IpVersion_IPV6 = 1          /** The IP version if IPv6 */
+} IpVersion;
+
+
+/**
+ * The type defination of Ip.
+ */
+typedef struct {
+    IpVersion version;          /** The version of IP. See the defination of IpVersion.                                               */
+    Priority priority;          /** The priority of IP. See the defination of Priority.                                               */
+    Bool cache;                 /** True: IP datagram will be cached in device's buffer. Fasle: IP datagram will be transfer to host. */
+    Byte address[16];           /** The byte array to store IP address.                                                               */
+} Ip;
+
+
+/**
+ * The type defination of Platform.
+ * Mostly used is in DVB-H standard
+ */
+typedef struct {
+    Dword platformId;           /** The ID of platform.                                    */
+    char iso639LanguageCode[3]; /** The ISO 639 language code for platform name.           */
+    Byte platformNameLength;    /** The length of platform name.                           */
+    char platformName[32];      /** The char array to store platform name.                 */
+    Word bandwidth;             /** The operating channel bandwith of this platform.       */
+    Dword frequency;            /** The operating channel frequency of this platform.      */
+    Byte* information;          /** The extra information about this platform.             */
+    Word informationLength;     /** The length of information.                             */
+    Bool hasInformation;        /** The flag to indicate if there exist extra information. */
+    IpVersion ipVersion;        /** The IP version of this platform.                       */
+} Platform;
+
+
+/**
+ * The type defination of Label.
+ */
+typedef struct {
+    Byte charSet;
+    Word charFlag;
+    Byte string[16];
+} Label;
+
+
+/**
+ * The type defination of Ensemble.
+ */
+typedef struct {
+    Word ensembleId;
+    Label ensembleLabel;
+    Byte totalServices;
+} Ensemble;
+
+
+/**
+ * The type defination of Service.
+ * Mostly used is in T-DMB standard
+ */
+typedef struct {
+    Byte serviceType;       /** Service Type(P/D): 0x00: Program, 0x80: Data */
+    Dword serviceId;
+    Dword frequency;
+    Label serviceLabel;
+    Byte totalComponents;
+} Service;
+
+
+/**
+ * The type defination of Service Component.
+ */
+typedef struct {
+    Byte serviceType;           /** Service Type(P/D): 0x00: Program, 0x80: Data         */
+    Dword serviceId;            /** Service ID                                           */
+    Word componentId;           /** Stream audio/data is subchid, packet mode is SCId    */
+    Byte componentIdService;    /** Component ID within Service                          */
+    Label componentLabel;       /** The label of component. See the defination of Label. */
+    Byte language;              /** Language code                                        */
+    Byte primary;               /** Primary/Secondary                                    */
+    Byte conditionalAccess;     /** Conditional Access flag                              */
+    Byte componentType;         /** Component Type (A/D)                                 */
+    Byte transmissionId;        /** Transmission Mechanism ID                            */
+} Component;
+
+
+/**
+ * The type defination of Target.
+ */
+typedef enum {
+    SectionType_MPE = 0,        /** Stands for MPE data.                                         */
+    SectionType_SIPSI,          /** Stands for SI/PSI table, but don't have to specify table ID. */
+    SectionType_TABLE           /** Stands for SI/PSI table.                                     */
+} SectionType;
+
+
+/**
+ * The type defination of FrameRow.
+ */
+typedef enum {
+    FrameRow_256 = 0,           /** There should be 256 rows for each column in MPE-FEC frame.  */
+    FrameRow_512,               /** There should be 512 rows for each column in MPE-FEC frame.  */
+    FrameRow_768,               /** There should be 768 rows for each column in MPE-FEC frame.  */
+    FrameRow_1024               /** There should be 1024 rows for each column in MPE-FEC frame. */
+} FrameRow;
+
+
+/**
+ * The type defination of Pid.
+ *
+ * In DVB-T mode, only value is valid. In DVB-H mode,
+ * as sectionType = SectionType_SIPSI: only value is valid.
+ * as sectionType = SectionType_TABLE: both value and table is valid.
+ * as sectionType = SectionType_MPE: except table all other fields is valid.
+ */
+typedef struct {
+    Byte table;                 /** The table ID. Which is used to filter specific SI/PSI table.                                  */
+    Byte duration;              /** The maximum burst duration. It can be specify to 0xFF if user don't know the exact value.     */
+    FrameRow frameRow;          /** The frame row of MPE-FEC. It means the exact number of rows for each column in MPE-FEC frame. */
+    SectionType sectionType;    /** The section type of pid. See the defination of SectionType.                                   */
+    Priority priority;          /** The priority of MPE data. Only valid when sectionType is set to SectionType_MPE.              */
+    IpVersion version;          /** The IP version of MPE data. Only valid when sectionType is set to SectionType_MPE.            */
+    Bool cache;                 /** True: MPE data will be cached in device's buffer. Fasle: MPE will be transfer to host.        */
+    Word value;                 /** The 13 bits Packet ID.                                                                        */
+} Pid;
+
+
+/**
+ * The type defination of ValueSet.
+ */
+typedef struct {
+    Dword address;      /** The address of target register */
+    Byte value;         /** The value of target register   */
+} ValueSet;
+
+
+/**
+ * The type defination of Datetime.
+ */
+typedef struct {
+    Dword mjd;              /** The mjd of datetime           */
+    Byte configuration;     /** The configuration of datetime */
+    Byte hours;             /** The hours of datetime         */
+    Byte minutes;           /** The minutes of datetime       */
+    Byte seconds;           /** The seconds of datetime       */
+    Word milliseconds;      /** The milli seconds of datetime */
+} Datetime;
+
+
+/**
+ * The type defination of Interrupts.
+ */
+typedef Word Interrupts;
+
+
+/**
+ * The type defination of Interrupt.
+ */
+typedef enum {
+    Interrupt_NONE      = 0x0000,   /** No interrupt. */
+    Interrupt_SIPSI     = 0x0001,
+    Interrupt_DVBH      = 0x0002,
+    Interrupt_DVBT      = 0x0004,
+    Interrupt_PLATFORM  = 0x0008,
+    Interrupt_VERSION   = 0x0010,
+    Interrupt_FREQUENCY = 0x0020,
+    Interrupt_SOFTWARE1 = 0x0040,
+    Interrupt_SOFTWARE2 = 0x0080,
+    Interrupt_FIC       = 0x0100,
+    Interrupt_MSC       = 0x0200,
+    Interrupt_MCISI     = 0x0400
+} Interrupt;
+
+
+/**
+ * The type defination of Multiplier.
+ */
+typedef enum {
+    Multiplier_1X = 0,
+    Multiplier_2X
+} Multiplier;
+
+
+/**
+ * The type defination of StreamType.
+ */
+typedef enum {
+    StreamType_NONE = 0,        /** Invalid (Null) StreamType                */
+    StreamType_DVBT_DATAGRAM,   /** DVB-T mode, store data in device buffer  */
+    StreamType_DVBT_PARALLEL,   /** DVB-T mode, output via paralle interface */
+    StreamType_DVBT_SERIAL,     /** DVB-T mode, output via serial interface  */
+} StreamType;
+
+
+/**
+ * The type defination of StreamType.
+ */
+typedef enum {
+    Architecture_NONE = 0,      /** Inavalid (Null) Architecture.                                    */
+    Architecture_DCA,           /** Diversity combine architecture. Only valid when chip number > 1. */
+    Architecture_PIP            /** Picture in picture. Only valid when chip number > 1.             */
+} Architecture;
+
+
+/**
+ * The type defination of ClockTable.
+ */
+typedef struct {
+    Dword crystalFrequency;     /** The frequency of crystal. */
+    Dword adcFrequency;         /** The frequency of ADC.     */
+} ClockTable;
+
+
+/**
+ * The type defination of BandTable.
+ */
+typedef struct {
+    Dword minimum;          /** The minimum frequency of this band */
+    Dword maximum;          /** The maximum frequency of this band */
+} BandTable;
+
+
+/**
+ * The type defination of MeanTable.
+ */
+typedef struct {
+    Dword mean;
+    Dword errorCount;
+} MeanTable;
+
+
+/**
+ * The type defination of Polarity.
+ */
+typedef enum {
+    Polarity_NORMAL = 0,
+    Polarity_INVERSE
+} Polarity;
+
+
+/**
+ * The type defination of Processor.
+ */
+typedef enum {
+    Processor_LINK = 0,
+    Processor_OFDM = 8
+} Processor;
+
+
+/**
+ * The type defination of BurstSize.
+ */
+typedef enum {
+    BurstSize_1024 = 0,
+    BurstSize_2048,
+    BurstSize_4096
+} BurstSize;
+
+
+/**
+ * The type defination of Demodulator.
+ */
+typedef struct {
+    Handle userData;
+    Handle driver;
+} Demodulator;
+
+
+#include "a867_user.h"
+
+
+/**
+ * The type defination of Statistic.
+ */
+typedef struct {
+    Bool signalPresented;       /** Signal is presented.                                                                         */
+    Bool signalLocked;          /** Signal is locked.                                                                            */
+    Byte signalQuality;         /** Signal quality, from 0 (poor) to 100 (good).                                                 */
+    Byte signalStrength;        /** Signal strength from 0 (weak) to 100 (strong).                                               */
+    Byte frameErrorRatio;       /** Frame Error Ratio (error ratio before MPE-FEC), from 0 (no error) to 100 (all error).        */
+    Byte mpefecFrameErrorRatio; /** MPE-FEC Frame Error Ratio (error ratio after MPE-FEC). from 0 (no error) to 100 (all error). */
+} Statistic;
+
+
+/**
+ * General demodulator register-write function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be written.
+ * @param bufferLength number, 1-8, of registers to be written.
+ * @param buffer buffer used to store values to be written to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*WriteRegisters) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer
+);
+
+
+/**
+ * General demodulator register-read function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*WriteScatterRegisters) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsAddressLength,
+    IN  Byte            valueSetsLength,
+    IN  ValueSet*       valueSets
+);
+
+
+/**
+ * General tuner register-write function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be written.
+ * @param bufferLength number, 1-8, of registers to be written.
+ * @param buffer buffer used to store values to be written to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*WriteTunerRegisters) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            tunerAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            writeBufferLength,
+    IN  Byte*           writeBuffer
+);
+
+
+/**
+ * General write EEPROM function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be written.
+ * @param buffer buffer used to store values to be written to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*WriteEepromValues) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            eepromAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            writeBufferLength,
+    IN  Byte*           writeBuffer
+);
+
+
+/**
+ * General demodulator register-read function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*ReadRegisters) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ * General demodulator register-read function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*ReadScatterRegisters) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Byte            valueSetsAddressLength,
+    IN  Byte            valueSetsLength,
+    OUT ValueSet*       valueSets
+);
+
+
+/**
+ * General tuner register-read function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*ReadTunerRegisters) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            tunerAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            readBufferLength,
+    IN  Byte*           readBuffer
+);
+
+
+/**
+ * General read EEPROM function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*ReadEepromValues) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Byte            eepromAddress,
+    IN  Word            registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ * General demodulator register-read function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*ModifyRegister) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           registerAddress,
+    IN  Byte            registerAddressLength,
+    IN  Byte            position,
+    IN  Byte            length,
+    IN  Byte            value
+);
+
+
+/**
+ * General load firmware function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param length The length of firmware.
+ * @param firmware The byte array of firmware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*LoadFirmware) (
+    IN  Demodulator*    demodulator,
+    IN  Dword           firmwareLength,
+    IN  Byte*           firmware
+);
+
+
+/**
+ * General reboot function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param length The length of firmware.
+ * @param firmware The byte array of firmware.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*Reboot) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+);
+
+
+/**
+ * Find and Get bus handle used to control bus
+ *
+ * @param demodulator the handle of demodulator.
+ * @param handle The bus handle.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*GetBus) (
+    IN  Demodulator*    demodulator,
+    OUT Handle*         handle
+);
+
+
+/**
+ * Find and Get bus handle used to control bus
+ *
+ * @param demodulator the handle of demodulator.
+ * @param bufferLength The length to transmit.
+ * @param buffer The buffer which we store the data to send.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*BusTx) (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Find and Get bus handle used to control bus
+ *
+ * @param demodulator the handle of demodulator.
+ * @param bufferLength The length to transmit.
+ * @param buffer The buffer which we store the data to send.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*BusRx) (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Find and Get bus handle used to control bus
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress The starting address of memory to get.
+ * @param readBufferLength The length of buffer to receive data.
+ * @param readBuffer The buffer use to store received data
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*BusRxData) (
+    IN  Demodulator*    demodulator,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+/**
+ * General send command function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param command The command which you wan.
+ * @param valueLength value length.
+ * @param valueBuffer value buffer.
+ * @param referenceLength reference length.
+ * @param referenceBuffer reference buffer.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*SendCommand) (
+    IN  Demodulator*    demodulator,
+    IN  Word            command,
+    IN  Byte            chip,
+    IN  Processor       processor,
+    IN  Dword           writeBufferLength,
+    IN  Byte*           writeBuffer,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ * General read EEPROM function
+ *
+ * @param demodulator the handle of demodulator.
+ * @param registerAddress address of register to be read.
+ * @param bufferLength number, 1-8, of registers to be read.
+ * @param buffer buffer used to store values to be read to specified
+ *        registers.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*ReceiveData) (
+    IN  Demodulator*    demodulator,
+    IN  Dword           registerAddress,
+    IN  Dword           readBufferLength,
+    OUT Byte*           readBuffer
+);
+
+
+/**
+ * The type defination of BusDescription
+ */
+typedef struct {
+    GetBus              getBus;
+    BusTx               busTx;
+    BusRx               busRx;
+    BusRxData           busRxData;
+} BusDescription;
+
+
+/**
+ * The type defination of BusDescription
+ */
+typedef struct {
+    Dword                   mailBoxSize;
+    BusDescription*         busDescription;
+    WriteRegisters          writeRegisters;
+    WriteScatterRegisters   writeScatterRegisters;
+    WriteTunerRegisters     writeTunerRegisters;
+    WriteEepromValues       writeEepromValues;
+    ReadRegisters           readRegisters;
+    ReadScatterRegisters    readScatterRegisters;
+    ReadTunerRegisters      readTunerRegisters;
+    ReadEepromValues        readEepromValues;
+    ModifyRegister          modifyRegister;
+    LoadFirmware            loadFirmware;
+    Reboot                  reboot;
+    SendCommand             sendCommand;
+    ReceiveData             receiveData;
+} CmdDescription;
+
+
+/**
+ * General tuner opening function
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*OpenTuner) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+);
+
+
+/**
+ * General tuner closing function
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*CloseTuner) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip
+);
+
+
+/**
+ * General tuner setting function
+ *
+ * @param demodulator the handle of demodulator.
+ * @return Error_NO_ERROR: successful, non-zero error code otherwise.
+ */
+typedef Dword (*SetTuner) (
+    IN  Demodulator*    demodulator,
+    IN  Byte            chip,
+    IN  Word            bandwidth,
+    IN  Dword           frequency
+);
+
+
+/**
+ * The type defination of TunerDescription
+ */
+typedef struct {
+    OpenTuner       openTuner;
+    CloseTuner      closeTuner;
+    SetTuner        setTuner;
+    ValueSet*       tunerScript;
+    Word*           tunerScriptSets;
+    Byte            tunerAddress;
+    Byte            registerAddressLength;
+    Dword           ifFrequency;
+    Bool            inversion;
+    Word			tunerId;
+} TunerDescription;
+
+
+/**
+ * The data structure of DefaultDemodulator
+ */
+typedef struct {
+    /** Basic structure */
+    Handle userData;
+    Handle driver;
+    Dword options;
+    Word busId;
+    CmdDescription* cmdDescription;
+    Word tunerId;
+    TunerDescription *tunerDescription;
+} DefaultDemodulator;
+
+
+/**
+ * The data structure of Ganymede
+ */
+typedef struct {
+    /** Basic structure */
+    Handle userData;
+    Handle driver;
+    Dword options;
+    Word busId;
+    CmdDescription* cmdDescription;
+    TunerDescription *tunerDescription;
+    Byte* firmwareCodes;
+    Segment* firmwareSegments;
+    Byte* firmwarePartitions;
+    Word* scriptSets;
+    ValueSet* scripts;
+    Word* tunerScriptSets;
+    ValueSet* tunerScripts;
+    Byte chipNumber;
+    Dword crystalFrequency;
+    Dword adcFrequency;
+    StreamType streamType;
+    Architecture architecture;
+    Word bandwidth[2];
+    Dword frequency[2];
+    Dword fcw;
+    Statistic statistic[2];
+    ChannelStatistic channelStatistic[2];   /** release1remove */
+    Byte hostInterface[2];
+    Bool booted;
+    Bool initialized;
+
+    /** DVB-T structure */
+    Bool dataReady;
+    BurstSize burstSize;
+
+    Byte GPIO8Value[2];
+} Ganymede;
+
+
+extern const Byte Standard_bitMask[8];
+#define REG_MASK(pos, len)                (Standard_bitMask[len-1] << pos)
+#define REG_CLEAR(temp, pos, len)         (temp & (~REG_MASK(pos, len)))
+#define REG_CREATE(val, temp, pos, len)   ((val << pos) | (REG_CLEAR(temp, pos, len)))
+#define REG_GET(value, pos, len)          ((value & REG_MASK(pos, len)) >> pos)
+#define LOWBYTE(w)      ((Byte)((w) & 0xff))
+#define HIGHBYTE(w)     ((Byte)((w >> 8) & 0xff))
+
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.c	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,171 @@
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)  
+#include <linux/autoconf.h>
+#else
+#include <generated/autoconf.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/usb.h>
+#include <asm/uaccess.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/vmalloc.h>
+
+#include "a867_usb2impl.h"
+#include "a867_af903x.h"
+
+#ifdef UNDER_CE
+
+Handle Usb2_handle = NULL;
+
+
+Dword Usb2_getDriver (
+	IN  Demodulator*	demodulator,
+	OUT Handle*			handle
+) {
+	return (Error_NO_ERROR);
+}
+
+
+Dword Usb2_writeControlBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	IN  Byte*			buffer
+) {
+	return (Error_NO_ERROR);
+}
+
+
+Dword Usb2_readControlBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	OUT Byte*			buffer
+) {
+	return (Error_NO_ERROR);
+}
+
+
+Dword Usb2_readDataBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	OUT Byte*			buffer
+) {
+	return (Error_NO_ERROR);
+}
+
+#else
+
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0500
+#endif
+
+Handle Usb2_handle = 0;
+/*
+bool (__cdecl *Usb2_initialize) (
+);
+void (__cdecl *Usb2_finalize) (
+);
+bool (__cdecl *Usb2_writeControl) (
+	Byte*		poutBuf,
+	unsigned long		WriteLen,
+	unsigned long*		pnBytesWrite
+); 
+bool (__cdecl *Usb2_readControl) (
+	Byte*		pinBuf,
+	unsigned long		ReadLen,
+	unsigned long*		pnBytesRead
+);
+bool (__cdecl *Usb2_readData) (
+	BYTE*		pinBuf,
+	ULONG		ReadLen
+);
+*/
+
+Dword Usb2_getDriver (
+	IN  Demodulator*	demodulator,
+	OUT Handle*			handle
+) {
+	Dword error = Error_NO_ERROR;
+/*
+	HINSTANCE instance = NULL;
+
+    instance = LoadLibrary ("AF15BDAEX.dll");
+    Usb2_initialize = (bool (__cdecl *) (
+			)) GetProcAddress (instance, "af15_init");
+    Usb2_finalize = (void (__cdecl *) (
+			)) GetProcAddress (instance, "af15_exit");
+	Usb2_writeControl = (bool (__cdecl *) (
+					BYTE*		poutBuf,
+					ULONG		WriteLen,
+					ULONG*		pnBytesWrite
+			)) GetProcAddress (instance, "af15_WriteBulkData");
+    Usb2_readControl = (bool (__cdecl *) (
+					BYTE*		pinBuf,
+					ULONG		ReadLen,
+					ULONG*		pnBytesRead
+			)) GetProcAddress (instance, "af15_ReadBulkData");
+    Usb2_readData = (bool (__cdecl *) (
+					BYTE*		pinBuf,
+					ULONG		ReadLen
+			)) GetProcAddress (instance, "af15_GetTsData");
+
+	if (!Usb2_initialize ())
+		error = Error_DRIVER_INVALID;
+			
+	*handle = (Handle) instance;
+*/
+	return (error);
+}
+
+
+Dword Usb2_writeControlBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	IN  Byte*			buffer
+) {
+//    Ganymede *pGanymede = (Ganymede *)demodulator;
+    Dword     ret,act_len;
+	    		ret = usb_bulk_msg(usb_get_dev(udevs),
+			usb_sndbulkpipe(usb_get_dev(udevs), 0x02),
+			buffer,
+			bufferLength,
+			&act_len,
+			1000);
+    
+	return (Error_NO_ERROR);
+}
+
+
+Dword Usb2_readControlBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	OUT Byte*			buffer
+) {
+//    Ganymede *pGanymede = (Ganymede *)demodulator;
+	Dword     ret, nBytesRead;
+   ret = usb_bulk_msg(usb_get_dev(udevs),
+				usb_rcvbulkpipe(usb_get_dev(udevs),129),
+				buffer,
+				255,
+				&nBytesRead,
+				1000);
+    
+	return (Error_NO_ERROR);
+}
+
+
+Dword Usb2_readDataBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	OUT Byte*			buffer
+) {
+	return (Error_NO_ERROR);
+}
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb2impl.h	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,38 @@
+#ifndef __USB2IMPL_H__
+#define __USB2IMPL_H__
+
+
+#include "a867_type.h"
+#include "a867_error.h"
+#include "a867_user.h"
+#include "a867_cmd.h"
+
+
+Dword Usb2_getDriver (
+	IN  Demodulator*	demodulator,
+	OUT Handle*			handle
+);
+
+
+Dword Usb2_writeControlBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	IN  Byte*			buffer
+);
+
+
+Dword Usb2_readControlBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	OUT Byte*			buffer
+);
+
+
+Dword Usb2_readDataBus (
+	IN  Demodulator*	demodulator,
+	IN  Dword			bufferLength,
+	OUT Byte*			buffer
+);
+
+#endif
+
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb-urb.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb-urb.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb-urb.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_usb-urb.c	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,247 @@
+/* usb-urb.c is part of the DVB USB library.
+ *
+ * Copyright (C) 2004-6 Patrick Boettcher (patrick.boettcher@desy.de)
+ * see dvb-usb-init.c for copyright information.
+ *
+ * This file keeps functions for initializing and handling the
+ * BULK and ISOC USB data transfers in a generic way.
+ * Can be used for DVB-only and also, that's the plan, for
+ * Hybrid USB devices (analog and DVB).
+ */
+#include "dvb-usb-common.h"
+
+/* URB stuff for streaming */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static void usb_urb_complete(struct urb *urb, struct pt_regs *ptregs)
+#else
+static void usb_urb_complete(struct urb *urb)
+#endif
+{
+	struct usb_data_stream *stream = urb->context;
+	int ptype = usb_pipetype(urb->pipe);
+	int i;
+	u8 *b;
+
+	deb_uxfer("'%s' urb completed. status: %d, length: %d/%d, pack_num: %d, errors: %d\n",
+		ptype == PIPE_ISOCHRONOUS ? "isoc" : "bulk",
+		urb->status,urb->actual_length,urb->transfer_buffer_length,
+		urb->number_of_packets,urb->error_count);
+
+	switch (urb->status) {
+		case 0:         /* success */
+		case -ETIMEDOUT:    /* NAK */
+			break;
+		case -ECONNRESET:   /* kill */
+		case -ENOENT:
+		case -ESHUTDOWN:
+			return;
+		default:        /* error */
+			deb_ts("urb completition error %d.\n", urb->status);
+			break;
+	}
+
+	b = (u8 *) urb->transfer_buffer;
+	switch (ptype) {
+		case PIPE_ISOCHRONOUS:
+			for (i = 0; i < urb->number_of_packets; i++) {
+
+				if (urb->iso_frame_desc[i].status != 0)
+					deb_ts("iso frame descriptor has an error: %d\n",urb->iso_frame_desc[i].status);
+				else if (urb->iso_frame_desc[i].actual_length > 0)
+					stream->complete(stream, b + urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].actual_length);
+
+				urb->iso_frame_desc[i].status = 0;
+				urb->iso_frame_desc[i].actual_length = 0;
+			}
+			debug_dump(b,20,deb_uxfer);
+			break;
+		case PIPE_BULK:
+			if (urb->actual_length > 0)
+				stream->complete(stream, b, urb->actual_length);
+			break;
+		default:
+			err("unkown endpoint type in completition handler.");
+			return;
+	}
+	usb_submit_urb(urb,GFP_ATOMIC);
+}
+
+int usb_urb_kill(struct usb_data_stream *stream)
+{
+	int i;
+	for (i = 0; i < stream->urbs_submitted; i++) {
+		deb_ts("killing URB no. %d.\n",i);
+
+		/* stop the URB */
+		usb_kill_urb(stream->urb_list[i]);
+	}
+	stream->urbs_submitted = 0;
+	return 0;
+}
+
+int usb_urb_submit(struct usb_data_stream *stream)
+{
+	int i,ret;
+	for (i = 0; i < stream->urbs_initialized; i++) {
+		deb_ts("submitting URB no. %d\n",i);
+		if ((ret = usb_submit_urb(stream->urb_list[i],GFP_ATOMIC))) {
+			err("could not submit URB no. %d - get them all back",i);
+			usb_urb_kill(stream);
+			return ret;
+		}
+		stream->urbs_submitted++;
+	}
+	return 0;
+}
+
+static int usb_free_stream_buffers(struct usb_data_stream *stream)
+{
+	if (stream->state & USB_STATE_URB_BUF) {
+		while (stream->buf_num) {
+			stream->buf_num--;
+			deb_mem("freeing buffer %d\n",stream->buf_num);
+			usb_buffer_free(stream->udev, stream->buf_size,
+					stream->buf_list[stream->buf_num], stream->dma_addr[stream->buf_num]);
+		}
+	}
+
+	stream->state &= ~USB_STATE_URB_BUF;
+
+	return 0;
+}
+
+static int usb_allocate_stream_buffers(struct usb_data_stream *stream, int num, unsigned long size)
+{
+	stream->buf_num = 0;
+	stream->buf_size = size;
+
+	deb_mem("all in all I will use %lu bytes for streaming\n",num*size);
+
+	for (stream->buf_num = 0; stream->buf_num < num; stream->buf_num++) {
+		deb_mem("allocating buffer %d\n",stream->buf_num);
+		if (( stream->buf_list[stream->buf_num] =
+					usb_buffer_alloc(stream->udev, size, GFP_ATOMIC,
+					&stream->dma_addr[stream->buf_num]) ) == NULL) {
+			deb_mem("not enough memory for urb-buffer allocation.\n");
+			usb_free_stream_buffers(stream);
+			return -ENOMEM;
+		}
+		deb_mem("buffer %d: %p (dma: %Lu)\n",
+			stream->buf_num,
+stream->buf_list[stream->buf_num], (long long)stream->dma_addr[stream->buf_num]);
+		memset(stream->buf_list[stream->buf_num],0,size);
+		stream->state |= USB_STATE_URB_BUF;
+	}
+	deb_mem("allocation successful\n");
+
+	return 0;
+}
+
+static int usb_bulk_urb_init(struct usb_data_stream *stream)
+{
+	int i;
+
+	if ((i = usb_allocate_stream_buffers(stream,stream->props.count,
+					stream->props.u.bulk.buffersize)) < 0)
+		return i;
+
+	/* allocate the URBs */
+	for (i = 0; i < stream->props.count; i++) {
+		if ((stream->urb_list[i] = usb_alloc_urb(0,GFP_ATOMIC)) == NULL)
+			return -ENOMEM;
+
+		usb_fill_bulk_urb( stream->urb_list[i], stream->udev,
+				usb_rcvbulkpipe(stream->udev,stream->props.endpoint),
+				stream->buf_list[i],
+				stream->props.u.bulk.buffersize,
+				usb_urb_complete, stream);
+
+		stream->urb_list[i]->transfer_flags = 0;
+		stream->urbs_initialized++;
+	}
+	return 0;
+}
+
+static int usb_isoc_urb_init(struct usb_data_stream *stream)
+{
+	int i,j;
+
+	if ((i = usb_allocate_stream_buffers(stream,stream->props.count,
+					stream->props.u.isoc.framesize*stream->props.u.isoc.framesperurb)) < 0)
+		return i;
+
+	/* allocate the URBs */
+	for (i = 0; i < stream->props.count; i++) {
+		struct urb *urb;
+		int frame_offset = 0;
+		if ((stream->urb_list[i] =
+					usb_alloc_urb(stream->props.u.isoc.framesperurb,GFP_ATOMIC)) == NULL)
+			return -ENOMEM;
+
+		urb = stream->urb_list[i];
+
+		urb->dev = stream->udev;
+		urb->context = stream;
+		urb->complete = usb_urb_complete;
+		urb->pipe = usb_rcvisocpipe(stream->udev,stream->props.endpoint);
+		urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
+		urb->interval = stream->props.u.isoc.interval;
+		urb->number_of_packets = stream->props.u.isoc.framesperurb;
+		urb->transfer_buffer_length = stream->buf_size;
+		urb->transfer_buffer = stream->buf_list[i];
+		urb->transfer_dma = stream->dma_addr[i];
+
+		for (j = 0; j < stream->props.u.isoc.framesperurb; j++) {
+			urb->iso_frame_desc[j].offset = frame_offset;
+			urb->iso_frame_desc[j].length = stream->props.u.isoc.framesize;
+			frame_offset += stream->props.u.isoc.framesize;
+		}
+
+		stream->urbs_initialized++;
+	}
+	return 0;
+}
+
+int usb_urb_init(struct usb_data_stream *stream, struct usb_data_stream_properties *props)
+{
+	if (stream == NULL || props == NULL)
+		return -EINVAL;
+
+	memcpy(&stream->props, props, sizeof(*props));
+
+	usb_clear_halt(stream->udev,usb_rcvbulkpipe(stream->udev,stream->props.endpoint));
+
+	if (stream->complete == NULL) {
+		err("there is no data callback - this doesn't make sense.");
+		return -EINVAL;
+	}
+
+	switch (stream->props.type) {
+		case USB_BULK:
+			return usb_bulk_urb_init(stream);
+		case USB_ISOC:
+			return usb_isoc_urb_init(stream);
+		default:
+			err("unkown URB-type for data transfer.");
+			return -EINVAL;
+	}
+}
+
+int usb_urb_exit(struct usb_data_stream *stream)
+{
+	int i;
+
+	usb_urb_kill(stream);
+
+	for (i = 0; i < stream->urbs_initialized; i++) {
+		if (stream->urb_list[i] != NULL) {
+			deb_mem("freeing URB no. %d.\n",i);
+			/* free the URBs */
+			usb_free_urb(stream->urb_list[i]);
+		}
+	}
+	stream->urbs_initialized = 0;
+
+	usb_free_stream_buffers(stream);
+	return 0;
+}
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.c	2012-02-27 00:02:35.848915017 +0100
@@ -0,0 +1,236 @@
+#include "a867_user.h"
+#include "a867_af903x.h"
+
+
+/**
+ * Handle for specific bus driver
+ */
+Handle User_handle = NULL;
+
+
+/**
+ * Totoal number of chip
+ */
+Byte User_chipNumber;
+
+
+/**
+ * Current index of chip
+ */
+Byte User_chipIndex;
+
+
+/**
+ * Variable of critical section
+ */
+
+Dword User_memoryCopy (
+    IN  Demodulator*    demodulator,
+    IN  void*           dest,
+    IN  void*           src,
+    IN  Dword           count
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  memcpy(dest, src, (size_t)count);
+	 *  return (0);
+     */
+	//memcpy (dest, src, (size_t)count);
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_memoryFree (
+	IN  Demodulator*	demodulator,
+	IN  void*			mem
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  free(pMem);
+	 *  return (0);
+     */
+	//free (mem);
+	//ExFreePool(mem);
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_printf (
+	IN  Demodulator*	demodulator,
+	IN  const char*		format, 
+	IN  ...
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  va_list arg;
+     *
+     *  va_start(arg, format);
+     *  vprintf(format, arg);
+     *  va_end(arg);
+     *  return (0);
+     */
+	return (Error_NO_ERROR);
+}
+
+
+Dword User_delay (
+    IN  Demodulator*    demodulator,
+	IN  Dword			dwMs
+) {	
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  delay(dwMs);
+     *  return (0);
+     */
+    //Sleep (dwMs);
+	unsigned long j = (HZ*dwMs)/1000;
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(j);
+
+	return (Error_NO_ERROR);
+}
+
+
+Dword User_createCriticalSection (
+	IN  Demodulator*	demodulator
+) {
+    /*
+     *  ToDo:  Add code here 
+     *
+     *  //Pseudo code
+     *  return (0);
+     */
+	return (Error_NO_ERROR);
+}
+
+
+Dword User_deleteCriticalSection (
+	IN  Demodulator*	demodulator
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  return (0);
+     */
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_enterCriticalSection (
+    IN  Demodulator*    demodulator
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  return (0);
+     */
+    PDEVICE_CONTEXT PDC = (PDEVICE_CONTEXT)demodulator->userData;
+    if( PDC ) {
+	    down(&PDC->regLock); 
+    }
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_leaveCriticalSection (
+    IN  Demodulator*    demodulator
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  return (0);
+     */
+
+    PDEVICE_CONTEXT PDC = (PDEVICE_CONTEXT)demodulator->userData;
+    if( PDC ) {
+	    up(&PDC->regLock); 
+    }
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_mpegConfig (
+    IN  Demodulator*    demodulator
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     */
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_busTx (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    IN  Byte*           buffer
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  short i;
+     *
+     *  start();
+     *  write_i2c(uc2WireAddr);
+     *  ack();
+     *  for (i = 0; i < bufferLength; i++) {
+     *      write_i2c(*(ucpBuffer + i));
+     *      ack();
+     *  }
+     *  stop();
+     *
+     *  // If no error happened return 0, else return error code.
+     *  return (0);
+     */
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_busRx (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+) {
+    /*
+     *  ToDo:  Add code here
+     *
+     *  //Pseudo code
+     *  short i;
+     *
+     *  start();
+     *  write_i2c(uc2WireAddr | 0x01);
+     *  ack();
+     *  for (i = 0; i < bufferLength - 1; i++) {
+     *      read_i2c(*(ucpBuffer + i));
+     *      ack();
+     *  }
+     *  read_i2c(*(ucpBuffer + bufferLength - 1));
+     *  nack();
+     *  stop();
+     *
+     *  // If no error happened return 0, else return error code.
+     *  return (0);
+     */
+    return (Error_NO_ERROR);
+}
+
+
+Dword User_busRxData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+) {
+    return (Error_NO_ERROR);
+}
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_userdef.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_userdef.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_userdef.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_userdef.h	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,25 @@
+#ifndef _USERDEF_H_
+#define _USERDEF_H_
+
+
+//typedef     unsigned char   BYTE;      // 1 byte
+//typedef     unsigned short  WORD;      // 2 bytes
+//typedef     unsigned long   DWORD;     // 4 bytes
+typedef     int             INT;       // 4 bytes
+//typedef     void *          HANDLE;
+
+//#define NULL    0
+
+#ifdef IN
+#undef IN
+#endif
+
+#ifdef OUT
+#undef OUT
+#endif
+
+#define IN  
+#define OUT
+#define INOUT
+
+#endif // _USERDEF_H_
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_user.h	2012-02-27 00:02:36.908915017 +0100
@@ -0,0 +1,155 @@
+#ifndef __USER_H__
+#define __USER_H__
+
+
+//#include <stdio.h>
+#include "a867_type.h"
+#include "a867_error.h"
+//#include <linux/smp_lock.h> //for Linux mdelay
+#include <linux/delay.h> //for Linux mdelay
+
+
+
+#define User_USE_INTERRUPT              0
+#define User_USE_DRIVER                 0
+
+/** Define timeout count for acquirePlatform and setPlatform, the default value 300 means 30 seconds. */
+#define User_TIMEOUT_COUNT			300
+
+/** Define I2C master speed, the default value 0x0D means 197KHz (1000000000 / (24.4 * 16 * User_I2C_SPEED)). */
+#define User_I2C_SPEED              0x0D
+
+/** Define I2C address of secondary chip when Diversity mode or PIP mode is active. */
+#define User_I2C_ADDRESS			0x3A//0x38
+
+/** Define USB frame size */
+#define User_USB20_MAX_PACKET_SIZE      512
+//j010+s
+//#define User_USB20_FRAME_SIZE           (188 * 348)
+#define User_USB20_FRAME_SIZE           (188 * TS_PACKET_COUNT)
+//j010+e
+#define User_USB20_FRAME_SIZE_DW        (User_USB20_FRAME_SIZE / 4)
+#define User_USB11_MAX_PACKET_SIZE      64
+#define User_USB11_FRAME_SIZE           (188 * 21)
+#define User_USB11_FRAME_SIZE_DW        (User_USB11_FRAME_SIZE / 4)
+
+typedef     unsigned char   tBYTE;      // 1 byte
+typedef     unsigned short  tWORD;      // 2 bytes
+typedef     unsigned int	tDWORD;     // 4 bytes
+typedef     int             tINT;       // 4 bytes
+typedef     void *          tHANDLE;
+
+/**
+ * Memory copy Function
+ */
+Dword User_memoryCopy (
+    IN  Demodulator*    demodulator,
+    IN  void*           dest,
+    IN  void*           src,
+    IN  Dword           count
+);
+
+
+/**
+ * Memory free Function
+ */
+Dword User_memoryFree (
+	IN  Demodulator*	demodulator,
+	IN  void*			mem
+);
+
+
+/**
+ * Print Function
+ */
+Dword User_printf (
+	IN  Demodulator*	demodulator,
+	IN  const char*		format, 
+	IN  ...
+);
+
+
+/**
+ * Delay Function
+ */
+Dword User_delay (
+    IN  Demodulator*    demodulator,
+	IN  Dword			dwMs
+);
+
+
+/**
+ * Creat and initialize critical section
+ */
+Dword User_createCriticalSection (
+	IN  Demodulator*	demodulator
+);
+
+
+/**
+ * Delete critical section
+ */
+Dword User_deleteCriticalSection (
+	IN  Demodulator*	demodulator
+);
+
+
+/**
+ * Enter critical section
+ */
+Dword User_enterCriticalSection (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Leave critical section
+ */
+Dword User_leaveCriticalSection (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Config MPEG2 interface
+ */
+Dword User_mpegConfig (
+    IN  Demodulator*    demodulator
+);
+
+
+/**
+ * Write data via "Control Bus"
+ * I2C mode : uc2WireAddr mean demodulator chip address, the default value is 0x38
+ * USB mode : uc2WireAddr is useless, don't have to send this data
+ */
+Dword User_busTx (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    IN  Byte*           buffer
+);
+
+
+/**
+ * Read data via "Control Bus"
+ * I2C mode : uc2WireAddr mean demodulator chip address, the default value is 0x38
+ * USB mode : uc2WireAddr is useless, don't have to send this data
+ */
+Dword User_busRx (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+);
+
+
+/**
+ * Read data via "Data Bus"
+ * I2C mode : uc2WireAddr mean demodulator chip address, the default value is 0x38
+ * USB mode : uc2WireAddr is useless, don't have to send this data
+ */
+Dword User_busRxData (
+    IN  Demodulator*    demodulator,
+    IN  Dword           bufferLength,
+    OUT Byte*           buffer
+);
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_variable.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_variable.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_variable.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_variable.h	2012-02-27 00:02:36.938915017 +0100
@@ -0,0 +1,260 @@
+#ifndef __VARIABLE_H__
+#define __VARIABLE_H__
+//this file define variable which initialized by AP
+//CFOE------------------------------------------
+
+//These variables are initialized by API.
+//Don't change the order of the definition of these variables.
+
+
+//2k
+//BASE Address 0x418B
+#define var_addr_base                       0x418b
+#define log_addr_base                       0x418d
+#define log_data_base                       0x418f
+// Do NOT touch the following line: used by script
+// --- @xx++ Start variable block
+//Initialization..
+//API relative
+//BASE Address 0x0000
+#define trigger_ofsm                        0x0000
+#define cfoe_NS_2048_coeff1_25_24           0x0001
+#define cfoe_NS_2048_coeff1_23_16           0x0002
+#define cfoe_NS_2048_coeff1_15_8            0x0003
+#define cfoe_NS_2048_coeff1_7_0             0x0004
+#define cfoe_NS_2k_coeff2_24                0x0005
+#define cfoe_NS_2k_coeff2_23_16             0x0006
+#define cfoe_NS_2k_coeff2_15_8              0x0007
+#define cfoe_NS_2k_coeff2_7_0               0x0008
+
+//8k..
+
+#define cfoe_NS_8191_coeff1_25_24           0x0009
+#define cfoe_NS_8191_coeff1_23_16           0x000a
+#define cfoe_NS_8191_coeff1_15_8            0x000b
+#define cfoe_NS_8191_coeff1_7_0             0x000c
+#define cfoe_NS_8192_coeff1_25_24           0x000d
+#define cfoe_NS_8192_coeff1_23_16           0x000e
+#define cfoe_NS_8192_coeff1_15_8            0x000f
+#define cfoe_NS_8192_coeff1_7_0             0x0010
+#define cfoe_NS_8193_coeff1_25_24           0x0011
+#define cfoe_NS_8193_coeff1_23_16           0x0012
+#define cfoe_NS_8193_coeff1_15_8            0x0013
+#define cfoe_NS_8193_coeff1_7_0             0x0014
+
+#define cfoe_NS_8k_coeff2_24                0x0015
+#define cfoe_NS_8k_coeff2_23_16             0x0016
+#define cfoe_NS_8k_coeff2_15_8              0x0017
+#define cfoe_NS_8k_coeff2_7_0               0x0018
+
+//4k
+#define cfoe_NS_4096_coeff1_25_24           0x0019
+#define cfoe_NS_4096_coeff1_23_16           0x001a
+#define cfoe_NS_4096_coeff1_15_8            0x001b
+#define cfoe_NS_4096_coeff1_7_0             0x001c
+#define cfoe_NS_4k_coeff2_24                0x001d
+#define cfoe_NS_4k_coeff2_23_16             0x001e
+#define cfoe_NS_4k_coeff2_15_8              0x001f
+#define cfoe_NS_4k_coeff2_7_0               0x0020
+
+#define bfsfcw_fftindex_ratio_7_0           0x0021
+#define bfsfcw_fftindex_ratio_15_8          0x0022
+#define fftindex_bfsfcw_ratio_7_0           0x0023
+#define fftindex_bfsfcw_ratio_15_8          0x0024
+
+
+
+#define crystal_clk_7_0                     0x0025
+#define crystal_clk_15_8                    0x0026
+#define crystal_clk_23_16                   0x0027
+#define crystal_clk_31_24                   0x0028
+
+
+#define bfs_fcw_7_0                         0x0029
+#define bfs_fcw_15_8                        0x002a
+#define bfs_fcw_22_16                       0x002b
+
+//----------------------------------------------
+//statistic performance..
+
+#define qnt_vbc_err_7_0                     0x002c  //snr
+#define qnt_vbc_err_15_8                    0x002d  //snr
+#define qnt_vbc_err_23_16                   0x002e  //snr
+#define r_qnt_vbc_sframe_num                0x002f
+#define tpsd_const                          0x0030
+#define tpsd_txmod                          0x0031
+ 
+#define rsd_abort_packet_cnt_7_0            0x0032
+#define rsd_abort_packet_cnt_15_8           0x0033
+#define rsd_bit_err_cnt_7_0                 0x0034
+#define rsd_bit_err_cnt_15_8                0x0035
+#define rsd_bit_err_cnt_23_16               0x0036
+#define r_rsd_packet_unit_7_0               0x0037
+#define r_rsd_packet_unit_15_8              0x0038
+
+#define qnt_vbc_sframe_num                  0x0039
+#define rsd_packet_unit_7_0                 0x003a
+#define rsd_packet_unit_15_8                0x003b
+
+#define tpsd_lock                           0x003c
+#define mpeg_lock                           0x003d
+#define RsdSequence                         0x003e
+#define VtbSequence                         0x003f
+
+#define Training_Mode                       0x0040
+#define RESET_STATE                         0x0041
+#define unplug_flg                          0x0042
+#define aci_0                               0x0043
+#define aci_1                               0x0044
+
+#define adcx2                               0x0045
+#define tuner_ID                            0x0046
+#define empty_channel_status                0x0047
+#define signal_strength                     0x0048
+#define signal_quality                      0x0049
+#define est_rf_level_dbm                    0x004a
+#define FreBand                             0x004b
+#define suspend_flag                        0x004c
+//GUI relative
+//Initial OFSM
+#define API_Reserved                        0x004d
+#define var_ofsm_state                      0x004e
+#define OfdmGuiRCN_H                        0x004f
+#define OfdmGuiRCN_L                        0x0050
+#define antenna_unplugged                   0x0051
+#define strong_signal_detected              0x0052
+#define channelFlatnessInd                  0x0053
+#define Flatness_Ind_nonCmb                 0x0054
+#define AutoDetectedSpectrumInv             0x0055
+#define IsSpectrumInv                       0x0056
+#define strong_detect_bypass                0x0057
+#define ss_dtop_bypass                      0x0058
+#define retrain_dtop_bypass                 0x0059
+#define EnableTimeSlice                     0x005a
+#define SynchronizationType                 0x005b
+#define ApplyFastSynchronizationToEchoChannel 0x005c
+#define ApplyPwmToRfIf                      0x005d
+#define ChannelNo                           0x005e
+
+//release to AAGC document..
+#define csi_bypass                          0x005f
+#define mobile_bypass                       0x0060
+#define EnableSpeedLog                      0x0061
+
+//regression used only..
+#define r_rsd_abort_total_packet_7_0        0x0062
+#define r_rsd_abort_total_packet_15_8       0x0063
+#define r_rsd_abort_total_packet_23_16      0x0064
+#define MaxRsdSequence                      0x0065
+#define RsdFrameNo                          0x0066
+#define MPESuperFrameNo                     0x0067
+
+#define AgcDesiredLevel                     0x0068
+#define MinRfGain                           0x0069
+#define MaxIfGain                           0x006a
+#define RssiOffset                          0x006b
+#define RssiResidual                        0x006c
+//Dtop
+
+#define strong_weak_signal_default          0x006d
+#define unplug_th                           0x006e
+#define afe_mem4_rssi_comp                  0x006f
+
+#define aagc_speed_detect_count             0x0070
+#define aagc_mobile_thr                     0x0071
+#define aagc_nonmobile_thr                  0x0072
+#define agc_counter                         0x0073
+#define DisableAagcTop                      0x0074
+#define AgcReset                            0x0075
+#define AgcUp                               0x0076
+#define AgcDown                             0x0077
+#define AgcHold                             0x0078
+#define PwmCtrlHw                           0x0079
+#define MaxAgcGain                          0x007a
+#define IniAgcGain                          0x007b
+#define mccid_bypass                        0x007c
+#define CdpfEnDefaultEchoRange              0x007d
+#define CdpfIniTestNo                       0x007e
+#define timing_err_level                    0x007f
+#define timing_retrain_cnt                  0x0080
+#define ChannelDiffThr                      0x0081
+
+#define adjacent_on                         0x0082
+#define near_adjacent_on                    0x0083
+#define adjacent_off                        0x0084
+#define near_adjacent_off                   0x0085
+#define max_rf_agc_7_0                      0x0086
+#define max_rf_agc_9_8                      0x0087
+#define rf_top_numerator_s_7_0              0x0088
+#define rf_top_numerator_s_9_8              0x0089
+
+#define gui_tdi_lms_en                      0x008a
+#define fccid_strobe_scale                  0x008b
+#define fccid_strobe_numerator              0x008c
+#define fccid_strobe_base                   0x008d
+#define use_fccid                           0x008e
+#define fft_ave_symbol_num                  0x008f
+#define large_tone_num_th_7_0               0x0090
+#define large_tone_num_th_15_8              0x0091
+#define use_3m_lpf_th                       0x0092
+#define ce_var_min_8k                       0x0093
+#define ce_var_min_4k                       0x0094
+#define ce_var_min_2k                       0x0095
+#define ce_var_min_8k_non_flat              0x0096
+#define flatness_thr                        0x0097
+#define non_mobile_signal_level_offset      0x0098
+#define gui_ar_csi_en                       0x0099
+#define h2_echo_detected                    0x009a
+#define signal_strength_rf_high             0x009b
+#define signal_strength_rf_low              0x009c
+#define signal_strength_if_high             0x009d
+#define signal_strength_if_low              0x009e
+//flatness
+#define flatness_thr_high                   0x009f
+#define flatness_thr_low                    0x00a0
+
+//softbit quality
+#define sbq1                                0x00a1
+#define sbq2                                0x00a2
+
+//DCA
+#define dyna_dca_offset_en                  0x00a3
+#define dca_sbq_bad_th                      0x00a4
+#define detect_timing_err_en                0x00a5
+#define flatness_from_h2_echo               0x00a6
+
+#define timging_error_detection             0x00a7
+#define ce_forced_by_rotate                 0x00a8
+#define fccid_fft_mask_en                   0x00a9
+#define second_fctrl_unforce_en             0x00aa
+#define force_fdi0_at_high_mobile_en        0x00ab
+#define high_mobile_detected                0x00ac
+#define flatness_detection_en               0x00ad
+#define ChooseFsteCostFunctionFromCdpf      0x00ae
+#define signal_level                        0x00af
+#define TryConf2En                          0x00b0
+#define Lower_tpsd_lock                     0x00b1
+#define Upper_tpsd_lock                     0x00b2
+
+#define AgcCtrlType                         0x00b3
+#define opt_LNA_Rssi_scale                  0x00b4
+#define StopByTcl                           0x00b5
+#define RssiCalibration                     0x00b6
+#define AciDesiredSignalLevel_h             0x00b7
+#define AciDesiredSignalLevel_l             0x00b8
+#define ECO_ASIC                            0x00b9
+#define NXP_USE_I2C                         0x00ba
+#define rf_freqency_23_16                   0x00bb
+#define rf_freqency_15_8                    0x00bc
+#define rf_freqency_7_0                     0x00bd
+#define iqik_en                             0x00be
+#define dcc_en                              0x00bf
+#define VHFPinEnTh                          0x00c0
+#define ACIdetection                        0x00c1
+#define PinDiode                            0x00c2
+#define LNA_Gain                            0x00c3
+#define RSSI_LNA_ON                         0x00c4
+#define var_end                             0x00c5
+
+//BASE Address 0xFFFF
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_version.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_version.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_version.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/a867_version.h	2012-02-27 00:02:36.928915017 +0100
@@ -0,0 +1,3 @@
+#define Version_NUMBER		0x0200
+#define Version_DATE		0x20080314
+#define Version_BUILD		0x01
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.c media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.c
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.c	2012-02-27 00:02:36.878915017 +0100
@@ -0,0 +1,1268 @@
+/*
+ * Afatech AF9035 DVB USB driver
+ *
+ * Copyright (C) 2008 Afatech
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Thanks to TerraTec for a support received.
+ */
+
+#include "af9035.h"
+#include "af9033.h"
+#include "tua9001.h"
+#include "mxl5007t.h"
+#include "tda18218.h"
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)) || ((defined V4L2_VERSION) && (V4L2_VERSION >= 196608))
+#define V4L2_REFACTORED_MFE_CODE
+#endif
+
+static int dvb_usb_af9035_debug;
+module_param_named(debug, dvb_usb_af9035_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level" DVB_USB_DEBUG_STATUS);
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static DEFINE_MUTEX(af9035_usb_mutex);
+
+static struct af9035_config af9035_config;
+static struct dvb_usb_device_properties af9035_properties[1];
+static int af9035_properties_count = ARRAY_SIZE(af9035_properties);
+
+static struct af9033_config af9035_af9033_config[] = {
+	{
+		.demod_address = 0,
+		.tuner_address = 0,
+		.output_mode = AF9033_TS_MODE_USB,
+	}, {
+		.demod_address = 0,
+		.tuner_address = 0,
+		.output_mode = AF9033_TS_MODE_SERIAL,
+	}
+};
+
+static u8 regmask[8] = {0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
+
+static int af9035_rw_udev(struct usb_device *udev, struct af9035_req *req)
+{
+#define BUF_SIZE 63
+	int act_len, ret;
+	u8 buf[BUF_SIZE];
+	u32 msg_len;
+	static u8 seq; /* packet sequence number */
+	u16 checksum = 0;
+	u8 i;
+
+	/* buffer overflow check */
+	if (req->wlen > (BUF_SIZE - 6) || req->rlen > (BUF_SIZE - 5)) {
+		err("too much data wlen:%d rlen:%d", req->wlen, req->rlen);
+		return -EINVAL;
+	}
+
+	if (mutex_lock_interruptible(&af9035_usb_mutex) < 0)
+		return -EAGAIN;
+
+	buf[0] = req->wlen + 3 + 2; /* 3 header + 2 checksum */
+	buf[1] = req->mbox;
+	buf[2] = req->cmd;
+	buf[3] = seq++;
+	if (req->wlen)
+		memcpy(&buf[4], req->wbuf, req->wlen);
+
+	/* calc and add checksum */
+	for (i = 1; i < buf[0]-1; i++) {
+		if (i % 2)
+			checksum += buf[i] << 8;
+		else
+			checksum += buf[i];
+	}
+	checksum = ~checksum;
+
+	buf[buf[0]-1] = (checksum >> 8);
+	buf[buf[0]-0] = (checksum & 0xff);
+
+	msg_len = buf[0]+1;
+
+	deb_xfer(">>> ");
+	debug_dump(buf, msg_len, deb_xfer);
+
+	/* send req */
+	ret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 0x02), buf, msg_len,
+	&act_len, AF9035_USB_TIMEOUT);
+	if (ret)
+		err("bulk message failed:%d (%d/%d)", ret, msg_len, act_len);
+	else
+		if (act_len != msg_len)
+			ret = -EIO; /* all data is not send */
+	if (ret)
+		goto error_unlock;
+
+	/* no ack for those packets */
+	if (req->cmd == CMD_FW_DOWNLOAD)
+		goto exit_unlock;
+
+	/* receive ack and data if read req */
+	msg_len = 3 + req->rlen + 2;  /* data len + status + seq + checksum */
+	ret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, 0x81), buf, msg_len,
+			   &act_len, AF9035_USB_TIMEOUT);
+	if (ret) {
+		err("recv bulk message failed:%d", ret);
+		ret = -EIO;
+		goto error_unlock;
+	}
+
+	deb_xfer("<<< ");
+	debug_dump(buf, act_len, deb_xfer);
+
+	/* check status */
+	if (buf[2]) {
+		err("command:%02x failed:%d", req->cmd, buf[2]);
+		ret = -EIO;
+		goto error_unlock;
+	}
+
+	/* read request, copy returned data to return buf */
+	if (req->rlen)
+		memcpy(req->rbuf, &buf[3], req->rlen);
+error_unlock:
+exit_unlock:
+	mutex_unlock(&af9035_usb_mutex);
+
+	return ret;
+}
+
+static int af9035_write_regs_bis(struct usb_device *d, u8 mbox, u16 reg,
+u8 *val, u8 len)
+{
+	u8 wbuf[6+len];
+	struct af9035_req req = {CMD_REG_DEMOD_WRITE, mbox, sizeof(wbuf), wbuf,
+		0, NULL};
+	wbuf[0] = len;
+	wbuf[1] = 2;
+	wbuf[2] = 0;
+	wbuf[3] = 0;
+	wbuf[4] = reg >> 8;
+	wbuf[5] = reg & 0xff;
+	memcpy(&wbuf[6], val, len);
+	return af9035_rw_udev(d, &req);
+}
+
+static int af9035_write_regs(struct dvb_usb_device *d, u8 mbox, u16 reg,
+u8 *val, u8 len)
+{
+	return af9035_write_regs_bis(d->udev, mbox, reg, val, len);
+}
+
+static int af9035_read_regs_bis(struct usb_device *d, u8 mbox, u16 reg, u8 *val,
+	u8 len)
+{
+	u8 wbuf[] = {len, 2, 0, 0, reg >> 8, reg & 0xff};
+	struct af9035_req req = {CMD_REG_DEMOD_READ, mbox, sizeof(wbuf), wbuf,
+		len, val};
+	return af9035_rw_udev(d, &req);
+}
+
+static int af9035_read_regs(struct dvb_usb_device *d, u8 mbox, u16 reg, u8 *val,
+	u8 len)
+{
+	return af9035_read_regs_bis(d->udev, mbox, reg, val, len);
+}
+
+static int af9035_write_reg_bis(struct usb_device *d, u8 mbox, u16 reg, u8 val)
+{
+	return af9035_write_regs_bis(d, mbox, reg, &val, 1);
+}
+
+static int af9035_write_reg(struct dvb_usb_device *d, u8 mbox, u16 reg, u8 val)
+{
+	return af9035_write_regs_bis(d->udev, mbox, reg, &val, 1);
+}
+
+static int af9035_read_reg_bis(struct usb_device *d, u8 mbox, u16 reg, u8 *val)
+{
+	return af9035_read_regs_bis(d, mbox, reg, val, 1);
+}
+
+static int af9035_write_reg_bits_bis(struct usb_device *d, u8 mbox, u16 reg,
+	u8 pos, u8 len, u8 val)
+{
+	int ret;
+	u8 tmp, mask;
+
+	ret = af9035_read_reg_bis(d, mbox, reg, &tmp);
+	if (ret)
+		return ret;
+
+	mask = regmask[len - 1] << pos;
+	tmp = (tmp & ~mask) | ((val << pos) & mask);
+
+	return af9035_write_reg_bis(d, mbox, reg, tmp);
+}
+
+static int af9035_write_reg_bits(struct dvb_usb_device *d, u8 mbox, u16 reg,
+	u8 pos, u8 len, u8 val)
+{
+	return af9035_write_reg_bits_bis(d->udev, mbox, reg, pos, len, val);
+}
+
+static int af9035_read_reg_bits_bis(struct usb_device *d, u8 mbox, u16 reg,
+	u8 pos, u8 len, u8 *val)
+{
+	int ret;
+	u8 tmp;
+
+	ret = af9035_read_reg_bis(d, mbox, reg, &tmp);
+	if (ret)
+		return ret;
+	*val = (tmp >> pos) & regmask[len - 1];
+	return 0;
+}
+
+static int af9035_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+	int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int ret = 0, i = 0;
+	u16 reg;
+	u8 mbox;
+
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	while (i < num) {
+		mbox = msg[i].buf[0];
+		reg = msg[i].buf[1] << 8;
+		reg += msg[i].buf[2];
+		if (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {
+			if (msg[i].addr ==
+				af9035_af9033_config[0].demod_address ||
+			    msg[i].addr ==
+				af9035_af9033_config[1].demod_address) {
+				if (af9035_af9033_config[1].demod_address && (msg[i].addr == af9035_af9033_config[1].demod_address))
+					mbox += 0x10;
+				ret = af9035_read_regs(d, mbox, reg,
+					&msg[i+1].buf[0], msg[i+1].len);
+			} else {
+				/* FIXME */
+				u8 wbuf[5];
+				u8 rbuf[BUF_SIZE];
+				struct af9035_req req = {CMD_REG_TUNER_READ,
+					LINK, sizeof(wbuf), wbuf, msg[i + 1].len,
+					rbuf};
+				if (af9035_af9033_config[1].tuner_address &&
+					(msg[i].addr == af9035_af9033_config[1].tuner_address)) {
+					msg[i].addr = af9035_af9033_config[0].tuner_address;
+					req.mbox += 0x10;
+				}
+				wbuf[0] = msg[i + 1].len; /* read len */
+				wbuf[1] = msg[i].addr; /* tuner i2c addr */
+				wbuf[2] = 0x01; /* reg width */
+				wbuf[3] = 0x00; /* reg MSB */
+				wbuf[4] = msg[i].buf[0]; /* reg LSB */
+				ret = af9035_rw_udev(d->udev, &req);
+				memcpy (msg[i + 1].buf, rbuf, msg[i + 1].len);
+			}
+			i += 2;
+		} else {
+			if (msg[i].addr ==
+				af9035_af9033_config[0].demod_address ||
+			    msg[i].addr ==
+				af9035_af9033_config[1].demod_address) {
+				if (af9035_af9033_config[1].demod_address && (msg[i].addr == af9035_af9033_config[1].demod_address))
+					mbox += 0x10;
+				ret = af9035_write_regs(d, mbox, reg,
+					&msg[i].buf[3], msg[i].len-3);
+			} else {
+				u8 wbuf[BUF_SIZE];
+				struct af9035_req req = {CMD_REG_TUNER_WRITE,
+					LINK, 4 + msg[i].len, wbuf, 0, NULL};
+				if (af9035_af9033_config[1].tuner_address &&
+					(msg[i].addr == af9035_af9033_config[1].tuner_address)) {
+					msg[i].addr = af9035_af9033_config[0].tuner_address;
+					req.mbox += 0x10;
+				}
+				wbuf[0] = msg[i].len - 1; /* write len */
+				wbuf[1] = msg[i].addr; /* tuner i2c addr */
+				wbuf[2] = 0x01; /* reg width */
+				wbuf[3] = 0x00; /* reg MSB */
+				memcpy (&wbuf[4], msg[i].buf, msg[i].len);
+				ret = af9035_rw_udev(d->udev, &req);
+			}
+			i += 1;
+		}
+		if (ret)
+			goto error;
+
+	}
+	ret = i;
+error:
+	mutex_unlock(&d->i2c_mutex);
+
+	return ret;
+}
+
+static u32 af9035_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm af9035_i2c_algo = {
+	.master_xfer = af9035_i2c_xfer,
+	.functionality = af9035_i2c_func,
+#ifdef NEED_ALGO_CONTROL
+	.algo_control = dummy_algo_control,
+#endif
+};
+
+static int af9035_init_endpoint(struct dvb_usb_device *d)
+{
+	int ret;
+	u16 frame_size;
+	u8  packet_size;
+
+	if (d->udev->speed == USB_SPEED_FULL) {
+		frame_size = TS_USB11_FRAME_SIZE/4;
+		packet_size = TS_USB11_MAX_PACKET_SIZE/4;
+	} else {
+		frame_size = TS_USB20_FRAME_SIZE/4;
+		packet_size = TS_USB20_MAX_PACKET_SIZE/4;
+	}
+
+	deb_info("%s: USB speed:%d frame_size:%04x packet_size:%02x\n",
+		__func__, d->udev->speed, frame_size, packet_size);
+
+	/* enable EP4 reset */
+	ret = af9035_write_reg_bits(d, OFDM, p_reg_mp2_sw_rst,
+		reg_mp2_sw_rst_pos, reg_mp2_sw_rst_len, 1);
+	if (ret)
+		goto error;
+
+	/* enable EP5 reset */
+	ret = af9035_write_reg_bits(d, OFDM, p_reg_mp2if2_sw_rst,
+		reg_mp2if2_sw_rst_pos, reg_mp2if2_sw_rst_len, 1);
+	if (ret)
+		goto error;
+
+	/* disable EP4 */
+	ret = af9035_write_reg_bits(d, LINK, p_reg_ep4_tx_en,
+		reg_ep4_tx_en_pos, reg_ep4_tx_en_len, 0);
+	if (ret)
+		goto error;
+
+	/* disable EP5 */
+	ret = af9035_write_reg_bits(d, LINK, p_reg_ep5_tx_en,
+		reg_ep5_tx_en_pos, reg_ep5_tx_en_len, 0);
+	if (ret)
+		goto error;
+
+	/* disable EP4 NAK */
+	ret = af9035_write_reg_bits(d, LINK, p_reg_ep4_tx_nak,
+		reg_ep4_tx_nak_pos, reg_ep4_tx_nak_len, 0);
+	if (ret)
+		goto error;
+
+	/* disable EP5 NAK */
+	ret = af9035_write_reg_bits(d, LINK, p_reg_ep5_tx_nak,
+		reg_ep5_tx_nak_pos, reg_ep5_tx_nak_len, 0);
+	if (ret)
+		goto error;
+
+	/* enable EP4 */
+	ret = af9035_write_reg_bits(d, LINK, p_reg_ep4_tx_en,
+		reg_ep4_tx_en_pos, reg_ep4_tx_en_len, 1);
+	if (ret)
+		goto error;
+
+	/* EP4 xfer length */
+	ret = af9035_write_regs(d, LINK, p_reg_ep4_tx_len_7_0,
+		(u8 *) &frame_size, sizeof(frame_size));
+	if (ret)
+		goto error;
+
+	/* EP4 packet size */
+	ret = af9035_write_reg(d, LINK, p_reg_ep4_max_pkt, packet_size);
+	if (ret)
+		goto error;
+
+	/* configure EP5 for dual mode */
+	if (af9035_config.dual_mode) {
+		/* enable EP5 */
+		ret = af9035_write_reg_bits(d, LINK, p_reg_ep5_tx_en,
+			reg_ep5_tx_en_pos, reg_ep5_tx_en_len, 1);
+		if (ret)
+			goto error;
+
+		/* EP5 xfer length */
+		ret = af9035_write_regs(d, LINK, p_reg_ep5_tx_len_7_0,
+			(u8 *) &frame_size, sizeof(frame_size));
+		if (ret)
+			goto error;
+
+		/* EP5 packet size */
+		ret = af9035_write_reg(d, LINK, p_reg_ep5_max_pkt, packet_size);
+		if (ret)
+			goto error;
+	}
+
+	/* enable / disable mp2if2 */
+	ret = af9035_write_reg_bits(d, OFDM, p_reg_mp2if2_en,
+		reg_mp2if2_en_pos, reg_mp2if2_en_len, af9035_config.dual_mode);
+	if (ret)
+		goto error;
+
+	/* enable / disable tsis */
+	ret = af9035_write_reg_bits(d, OFDM, p_reg_tsis_en, reg_tsis_en_pos,
+		reg_tsis_en_len, af9035_config.dual_mode);
+	if (ret)
+		goto error;
+
+	/* negate EP4 reset */
+	ret = af9035_write_reg_bits(d, OFDM, p_reg_mp2_sw_rst,
+		reg_mp2_sw_rst_pos, reg_mp2_sw_rst_len, 0);
+	if (ret)
+		goto error;
+
+	/* negate EP5 reset */
+	ret = af9035_write_reg_bits(d, OFDM, p_reg_mp2if2_sw_rst,
+		reg_mp2if2_sw_rst_pos, reg_mp2if2_sw_rst_len, 0);
+	if (ret)
+		goto error;
+
+error:
+	if (ret)
+		err("endpoint init failed:%d", ret);
+	return ret;
+}
+
+static int af9035_init(struct dvb_usb_device *d)
+{
+	int ret;
+	deb_info("%s:\n", __func__);
+
+	ret = af9035_init_endpoint(d);
+	if (ret)
+		goto error;
+error:
+	return ret;
+}
+
+static int af9035_download_firmware(struct usb_device *udev,
+	const struct firmware *fw)
+{
+	u8 *fw_data_ptr = (u8 *) fw->data;
+	int i, j, len, packets, remainder, ret;
+	u8 wbuf[1];
+	u8 rbuf[4];
+	struct af9035_firmware_header fw_hdr;
+	struct af9035_req req = {0, LINK, 0, NULL, 1, rbuf};
+	struct af9035_req req_fw_dl = {CMD_FW_DOWNLOAD, LINK, 0, NULL, 0, NULL};
+	struct af9035_req req_rom = {CMD_SCATTER_WRITE, LINK, 0, NULL, 1, rbuf};
+	struct af9035_req req_fw_ver = {CMD_QUERYINFO, LINK, 1, wbuf, 4, rbuf};
+
+	/* read firmware segment info from beginning of the firmware file */
+	fw_hdr.segment_count = *fw_data_ptr++;
+	deb_info("%s: fw segment count:%d\n", __func__, fw_hdr.segment_count);
+	if (fw_hdr.segment_count > SEGMENT_MAX_COUNT) {
+		warn("too big firmware segmen count:%d", fw_hdr.segment_count);
+		fw_hdr.segment_count = SEGMENT_MAX_COUNT;
+	}
+	for (i = 0; i < fw_hdr.segment_count; i++) {
+		fw_hdr.segment[i].type = (*fw_data_ptr++);
+		fw_hdr.segment[i].len  = (*fw_data_ptr++) << 24;
+		fw_hdr.segment[i].len += (*fw_data_ptr++) << 16;
+		fw_hdr.segment[i].len += (*fw_data_ptr++) <<  8;
+		fw_hdr.segment[i].len += (*fw_data_ptr++) <<  0;
+		deb_info("%s: fw segment type:%d len:%d\n", __func__,
+			fw_hdr.segment[i].type, fw_hdr.segment[i].len);
+	}
+
+	#define FW_PACKET_MAX_DATA 57 /* 63-4-2, packet_size-header-checksum */
+
+	/* download all segments */
+	for (i = 0; i < fw_hdr.segment_count; i++) {
+		deb_info("%s: segment type:%d\n", __func__,
+			fw_hdr.segment[i].type);
+		if (fw_hdr.segment[i].type == SEGMENT_FW_DOWNLOAD) {
+			/* download begin packet */
+			req.cmd = CMD_FW_DOWNLOAD_BEGIN;
+			ret = af9035_rw_udev(udev, &req);
+			if (ret) {
+				err("firmware download failed:%d", ret);
+				goto error;
+			}
+
+			packets = fw_hdr.segment[i].len / FW_PACKET_MAX_DATA;
+			remainder = fw_hdr.segment[i].len % FW_PACKET_MAX_DATA;
+			len = FW_PACKET_MAX_DATA;
+			for (j = 0; j <= packets; j++) {
+				if (j == packets)  /* size of the last packet */
+					len = remainder;
+
+				req_fw_dl.wlen = len;
+				req_fw_dl.wbuf = fw_data_ptr;
+				ret = af9035_rw_udev(udev, &req_fw_dl);
+				if (ret) {
+					err("firmware download failed at " \
+						"segment:%d packet:%d err:%d", \
+						i, j, ret);
+					goto error;
+				}
+				fw_data_ptr += len;
+			}
+			/* download end packet */
+			req.cmd = CMD_FW_DOWNLOAD_END;
+			ret = af9035_rw_udev(udev, &req);
+			if (ret) {
+				err("firmware download failed:%d", ret);
+				goto error;
+			}
+		} else if (fw_hdr.segment[i].type == SEGMENT_ROM_COPY){
+			packets = fw_hdr.segment[i].len / FW_PACKET_MAX_DATA;
+			remainder = fw_hdr.segment[i].len % FW_PACKET_MAX_DATA;
+			len = FW_PACKET_MAX_DATA;
+			for (j = 0; j <= packets; j++) {
+				if (j == packets)  /* size of the last packet */
+					len = remainder;
+
+				req_rom.wlen = len;
+				req_rom.wbuf = fw_data_ptr;
+				ret = af9035_rw_udev(udev, &req_rom);
+				if (ret) {
+					err("firmware download failed at " \
+						"segment:%d packet:%d err:%d", \
+						i, j, ret);
+					goto error;
+				}
+				fw_data_ptr += len;
+			}
+		} else {
+			deb_info("%s: segment type:%d not implemented\n",
+				__func__, fw_hdr.segment[i].type);
+		}
+	}
+
+	/* firmware loaded, request boot */
+	req.cmd = CMD_BOOT;
+	ret = af9035_rw_udev(udev, &req);
+	if (ret)
+		goto error;
+
+	/* ensure firmware starts */
+	wbuf[0] = 1;
+	ret = af9035_rw_udev(udev, &req_fw_ver);
+	if (ret)
+		goto error;
+
+	deb_info("%s: reply:%02x %02x %02x %02x\n", __func__,
+		rbuf[0], rbuf[1], rbuf[2], rbuf[3]);
+
+	if (!(rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])) {
+		err("firmware did not run");
+		ret = -EIO;
+	}
+
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int af9035_read_eeprom_reg(struct usb_device *udev, u16 reg, u8 *val)
+{
+	u8 wbuf[] = {1, 2, 0, 0, reg >> 8, reg & 0xff};
+	struct af9035_req req = {CMD_REG_DEMOD_READ, LINK, sizeof(wbuf), wbuf,
+		1, val};
+	return af9035_rw_udev(udev, &req);
+}
+
+static int af9035_read_config(struct usb_device *udev)
+{
+	int ret;
+	u8 val, i, offset = 0;
+
+	/* IR remote controller */
+	ret = af9035_read_eeprom_reg(udev, EEPROM_IR_MODE, &val);
+	if (ret)
+		goto error;
+	deb_info("%s: IR mode:%d\n", __func__, val);
+
+	/* TS mode - one or two receivers */
+	ret = af9035_read_eeprom_reg(udev, EEPROM_TS_MODE, &val);
+	if (ret)
+		goto error;
+	af9035_config.dual_mode = val;
+	deb_info("%s: TS mode:%d\n", __func__, af9035_config.dual_mode);
+
+	/* Set adapter0 buffer size according to USB port speed, adapter1 buffer
+	   size can be static because it is enabled only USB2.0 */
+	for (i = 0; i < af9035_properties_count; i++) {
+		/* USB1.1 set smaller buffersize and disable 2nd adapter */
+		if (udev->speed == USB_SPEED_FULL) {
+#ifdef V4L2_REFACTORED_MFE_CODE
+			af9035_properties[i].adapter[0].fe[0].stream.u.bulk.buffersize
+#else
+			af9035_properties[i].adapter[0].stream.u.bulk.buffersize
+#endif
+				= TS_USB11_MAX_PACKET_SIZE;
+			/* disable 2nd adapter because we don't have
+			   PID-filters */
+			af9035_config.dual_mode = 0;
+		} else {
+#ifdef V4L2_REFACTORED_MFE_CODE
+			af9035_properties[i].adapter[0].fe[0].stream.u.bulk.buffersize
+#else
+			af9035_properties[i].adapter[0].stream.u.bulk.buffersize
+#endif
+				= TS_USB20_FRAME_SIZE;
+		}
+	}
+
+	if (af9035_config.dual_mode) {
+		/* read 2nd demodulator I2C address */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_2WIREADDR, &val);
+		if (ret)
+			goto error;
+		deb_info("%s: 2nd demod I2C addr:%02x\n", __func__, val);
+		af9035_af9033_config[1].demod_address = val;
+		/* enable 2nd adapter */
+		for (i = 0; i < af9035_properties_count; i++)
+			af9035_properties[i].num_adapters = 2;
+	} else {
+		 /* disable 2nd adapter */
+		for (i = 0; i < af9035_properties_count; i++)
+			af9035_properties[i].num_adapters = 1;
+	}
+
+	for (i = 0; i < af9035_properties[0].num_adapters; i++) {
+		if (i == 1)
+			offset =  EEPROM_SHIFT;
+
+		/* saw BW */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_SAW_BW1 + offset,
+			&val);
+		if (ret)
+			goto error;
+		deb_info("%s: [%d] saw BW:%d\n", __func__, i, val);
+
+		/* xtal */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_XTAL1 + offset, &val);
+		if (ret)
+			goto error;
+		deb_info("%s: [%d] xtal:%d\n", __func__, i, val);
+
+		/* RF spectrum inversion */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_SPECINV1 + offset,
+			&val);
+		if (ret)
+			goto error;
+		deb_info("%s: [%d] RF spectrum inv:%d\n", __func__, i, val);
+
+		/* IF */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_IFFREQH1 + offset,
+			&val);
+		if (ret)
+			goto error;
+		af9035_af9033_config[i].if_freq = val << 8;
+		ret = af9035_read_eeprom_reg(udev, EEPROM_IFFREQL1 + offset,
+			&val);
+		if (ret)
+			goto error;
+		af9035_af9033_config[i].if_freq += val;
+		deb_info("%s: [%d] IF:%d\n", __func__, i,
+			af9035_af9033_config[0].if_freq);
+
+		/* MT2060 IF1 */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_IF1H1 + offset, &val);
+		if (ret)
+			goto error;
+		af9035_config.mt2060_if1[i] = val << 8;
+		ret = af9035_read_eeprom_reg(udev, EEPROM_IF1L1 + offset, &val);
+		if (ret)
+			goto error;
+		af9035_config.mt2060_if1[i] += val;
+		deb_info("%s: [%d] MT2060 IF1:%d\n", __func__, i,
+			af9035_config.mt2060_if1[i]);
+
+		/* tuner */
+		ret = af9035_read_eeprom_reg(udev, EEPROM_TUNER_ID1 + offset,
+			&val);
+		if (ret)
+			goto error;
+		switch (val) {
+		case AF9033_TUNER_TUA9001:
+			af9035_af9033_config[i].rf_spec_inv = 1;
+			break;
+		case AF9033_TUNER_MXL5007t:
+			af9035_af9033_config[i].rf_spec_inv = 1;
+			break;
+                case AF9033_TUNER_TDA18218:
+			af9035_af9033_config[i].rf_spec_inv = 1;
+			break;
+		default:
+			warn("tuner ID:%d not supported, please report!", val);
+			return -ENODEV;
+		};
+
+		af9035_af9033_config[i].tuner = val;
+		deb_info("%s: [%d] tuner ID:%d\n", __func__, i, val);
+	}
+
+error:
+	if (ret)
+		err("eeprom read failed:%d", ret);
+
+	if (le16_to_cpu(udev->descriptor.idVendor) == USB_VID_AVERMEDIA) {
+		switch (le16_to_cpu(udev->descriptor.idProduct)) {
+		case USB_PID_AVERMEDIA_A825:
+		case USB_PID_AVERMEDIA_A835:
+		case USB_PID_AVERMEDIA_B835:
+		case USB_PID_AVERMEDIA_A333:
+		case USB_PID_AVERMEDIA_B867:
+		case USB_PID_AVERMEDIA_1867:
+		case USB_PID_AVERMEDIA_0337:
+		case USB_PID_AVERMEDIA_A867:
+		case USB_PID_AVERMEDIA_0867:
+		case USB_PID_AVERMEDIA_F337:
+		case USB_PID_AVERMEDIA_3867:
+			deb_info("%s: AverMedia A825/A835/B835/A333/A867: overriding config\n", __func__);
+			/* set correct IF */
+			for (i = 0; i < af9035_properties[0].num_adapters; i++) {
+				af9035_af9033_config[i].if_freq = 4570000;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int af9035_aux_init(struct usb_device *d)
+{
+	int ret;
+	u8 tmp, i;
+
+	/* get demod crystal and ADC freqs */
+	ret = af9035_read_reg_bits_bis(d, LINK,
+		r_io_mux_pwron_clk_strap, io_mux_pwron_clk_strap_pos,
+		io_mux_pwron_clk_strap_len, &tmp);
+	if (ret)
+		goto error;
+
+	for (i = 0; i < af9035_properties[0].num_adapters; i++) {
+		af9035_af9033_config[i].crystal_clock =
+			clock_table[tmp].crystal;
+		af9035_af9033_config[i].adc_clock =
+			clock_table[tmp].adc;
+	}
+
+	/* write 2nd demod I2C address to device */
+	ret = af9035_write_reg_bis(d, LINK, 0x417f,
+		af9035_af9033_config[1].demod_address);
+	if (ret)
+		goto error;
+
+	/* enable / disable clock out for 2nd demod for power saving */
+	ret = af9035_write_reg_bis(d, LINK, p_reg_top_clkoen,
+		af9035_config.dual_mode);
+
+error:
+	return ret;
+}
+
+static int af9035_identify_state(struct usb_device *udev,
+				 struct dvb_usb_device_properties *props,
+				 struct dvb_usb_device_description **desc,
+				 int *cold)
+{
+	int ret;
+	u8 wbuf[1] = {1};
+	u8 rbuf[4];
+	struct af9035_req req = {CMD_QUERYINFO, 0, sizeof(wbuf), wbuf,
+		sizeof(rbuf), rbuf};
+
+	ret = af9035_rw_udev(udev, &req);
+	if (ret)
+		return ret;
+
+	deb_info("%s: reply:%02x %02x %02x %02x\n", __func__,
+		rbuf[0], rbuf[1], rbuf[2], rbuf[3]);
+	if (rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])
+		*cold = 0;
+	else
+		*cold = 1;
+
+	return ret;
+}
+
+static int af9035_af9033_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	/* attach demodulator */
+#ifdef V4L2_REFACTORED_MFE_CODE
+	adap->fe_adap[0].fe = dvb_attach(af9033_attach, &af9035_af9033_config[adap->id],
+		&adap->dev->i2c_adap);
+
+	return adap->fe_adap[0].fe == NULL ? -ENODEV : 0;
+#else
+	adap->fe = dvb_attach(af9033_attach, &af9035_af9033_config[adap->id],
+		&adap->dev->i2c_adap);
+
+	return adap->fe == NULL ? -ENODEV : 0;
+#endif
+}
+
+static struct tua9001_config af9035_tua9001_config[] = {
+	{
+		.i2c_address = 0xc0,
+	} , {
+		.i2c_address = 0xc1,
+	}
+};
+
+static struct mxl5007t_config af9035_mxl5007t_config[] = {
+	{
+		.xtal_freq_hz = MxL_XTAL_24_MHZ,
+		.if_freq_hz = MxL_IF_4_57_MHZ,
+		.invert_if = 0,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 0,
+		.clk_out_amp = MxL_CLKOUT_AMP_0_94V,
+	} , {
+		.xtal_freq_hz = MxL_XTAL_24_MHZ,
+		.if_freq_hz = MxL_IF_4_57_MHZ,
+		.invert_if = 0,
+		.loop_thru_enable = 3,
+		.clk_out_enable = 1,
+		.clk_out_amp = MxL_CLKOUT_AMP_0_94V,
+	}
+};
+
+static struct tda18218_config af9035_tda18218_config = {
+        .i2c_address = 0xc0,
+        .i2c_wr_max = 17,
+};
+
+static int af9035_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	int ret;
+	deb_info("%s: \n", __func__);
+
+	switch (af9035_af9033_config[adap->id].tuner) {
+	case AF9033_TUNER_TUA9001:
+		af9035_af9033_config[adap->id].tuner_address = af9035_tua9001_config[adap->id].i2c_address;
+		af9035_af9033_config[adap->id].tuner_address += adap->id;
+		if (adap->id == 0) {
+			/* gpiot3 TUA9001 RESETN
+			   gpiot2 TUA9001 RXEN */
+			ret = af9035_write_reg_bits(adap->dev, LINK,
+				p_reg_top_gpiot2_en, reg_top_gpiot2_en_pos,
+				reg_top_gpiot2_en_len, 1);
+			ret = af9035_write_reg_bits(adap->dev, LINK,
+				p_reg_top_gpiot2_on, reg_top_gpiot2_on_pos,
+				reg_top_gpiot2_on_len, 1);
+			ret = af9035_write_reg_bits(adap->dev, LINK,
+				p_reg_top_gpiot3_en, reg_top_gpiot3_en_pos,
+				reg_top_gpiot3_en_len, 1);
+			ret = af9035_write_reg_bits(adap->dev, LINK,
+				p_reg_top_gpiot3_on, reg_top_gpiot3_on_pos,
+				reg_top_gpiot3_on_len, 1);
+
+			/* reset tuner */
+			ret = af9035_write_reg_bits(adap->dev, LINK, p_reg_top_gpiot3_o,
+				 reg_top_gpiot3_o_pos, reg_top_gpiot3_o_len, 0);
+			msleep(1);
+			ret = af9035_write_reg_bits(adap->dev, LINK, p_reg_top_gpiot3_o,
+				 reg_top_gpiot3_o_pos, reg_top_gpiot3_o_len, 1);
+
+			/* activate tuner - TODO: do that like I2C gate control */
+			ret = af9035_write_reg_bits(adap->dev, LINK, p_reg_top_gpiot2_o,
+				 reg_top_gpiot2_o_pos, reg_top_gpiot2_o_len, 1);
+		}
+
+#ifdef V4L2_REFACTORED_MFE_CODE
+		ret = dvb_attach(tua9001_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap,
+#else
+		ret = dvb_attach(tua9001_attach, adap->fe, &adap->dev->i2c_adap,
+#endif
+			&af9035_tua9001_config[adap->id]) == NULL ? -ENODEV : 0;
+
+		break;
+	case AF9033_TUNER_MXL5007t:
+		af9035_af9033_config[adap->id].tuner_address = 0xc0;
+		af9035_af9033_config[adap->id].tuner_address += adap->id;
+		if (adap->id == 0) {
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh12_en,
+				1);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh12_on,
+				1);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh12_o,
+				0);
+
+			msleep(30);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh12_o,
+				1);
+
+			msleep(300);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh4_en,
+				1);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh4_on,
+				1);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh4_o,
+				0);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh3_en,
+				1);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh3_on,
+				1);
+
+			ret = af9035_write_reg(adap->dev, LINK,
+				p_reg_top_gpioh3_o,
+				1);
+		}
+
+#ifdef V4L2_REFACTORED_MFE_CODE
+		ret = dvb_attach(mxl5007t_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap,
+#else
+		ret = dvb_attach(mxl5007t_attach, adap->fe, &adap->dev->i2c_adap,
+#endif
+			af9035_af9033_config[adap->id].tuner_address,
+			&af9035_mxl5007t_config[adap->id]) == NULL ? -ENODEV : 0;
+
+		break;
+          case AF9033_TUNER_TDA18218:
+                  af9035_af9033_config[adap->id].tuner_address = af9035_tua9001_config[adap->id].i2c_address;
+                  af9035_af9033_config[adap->id].tuner_address += adap->id;
+                  if (adap->id == 0) {
+                  /* gpiot3 TUA9001 RESETN
+                  gpiot2 TUA9001 RXEN */
+                  ret = af9035_write_reg_bits(adap->dev, LINK,
+                          p_reg_top_gpiot2_en, reg_top_gpiot2_en_pos,
+                          reg_top_gpiot2_en_len, 1);
+                  ret = af9035_write_reg_bits(adap->dev, LINK,
+                          p_reg_top_gpiot2_on, reg_top_gpiot2_on_pos,
+                          reg_top_gpiot2_on_len, 1);
+                  ret = af9035_write_reg_bits(adap->dev, LINK,
+                          p_reg_top_gpiot3_en, reg_top_gpiot3_en_pos,
+                          reg_top_gpiot3_en_len, 1);
+                  ret = af9035_write_reg_bits(adap->dev, LINK,
+                          p_reg_top_gpiot3_on, reg_top_gpiot3_on_pos,
+                          reg_top_gpiot3_on_len, 1);
+
+                  /* reset tuner */
+                  ret = af9035_write_reg_bits(adap->dev, LINK, p_reg_top_gpiot3_o,
+                          reg_top_gpiot3_o_pos, reg_top_gpiot3_o_len, 0);
+                  msleep(1);
+                  ret = af9035_write_reg_bits(adap->dev, LINK, p_reg_top_gpiot3_o,
+                          reg_top_gpiot3_o_pos, reg_top_gpiot3_o_len, 1);
+
+                   /* activate tuner - TODO: do that like I2C gate control */
+                   ret = af9035_write_reg_bits(adap->dev, LINK, p_reg_top_gpiot2_o,
+                           reg_top_gpiot2_o_pos, reg_top_gpiot2_o_len, 1);
+                   }
+
+#ifdef V4L2_REFACTORED_MFE_CODE
+                   ret = dvb_attach(tda18218_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap,
+#else
+                   ret = dvb_attach(tda18218_attach, adap->fe, &adap->dev->i2c_adap,
+#endif
+                           &af9035_tda18218_config) == NULL ? -ENODEV : 0;
+                   break;
+	default:
+		ret = -ENODEV;
+		err("unknown tuner ID:%d",
+			af9035_af9033_config[adap->id].tuner);
+	}
+
+	return ret;
+}
+
+/*
+ * enable devices supported by the Avemedia A867 proprietary driver;
+ * some device use an unsupported tuner type (AF9007), so it will not work;
+ * probably those devices belong to the A333 family;
+ */
+#define ENABLE_A867_DEVICES
+
+enum af9035_usb_table_entry {
+	AFATECH_AF9035_1000,
+	AFATECH_AF9035_1001,
+	AFATECH_AF9035_1002,
+	AFATECH_AF9035_1003,
+	AFATECH_AF9035_9035,
+	TERRATEC_CINERGY_T_STICK,
+	TERRATEC_CINERGY_T_STICK_2,
+	AVERMEDIA_TWINSTAR,
+	AVERMEDIA_VOLAR_HD,
+	AVERMEDIA_VOLAR_HD_PRO,
+#ifdef ENABLE_A867_DEVICES
+	AVERMEDIA_A333,
+	AVERMEDIA_B867,
+	AVERMEDIA_1867,
+	AVERMEDIA_0337,
+	AVERMEDIA_A867,
+	AVERMEDIA_0867,
+	AVERMEDIA_F337,
+	AVERMEDIA_3867,
+#endif
+};
+
+static struct usb_device_id af9035_usb_table[] = {
+	[AFATECH_AF9035_1000] = {USB_DEVICE(USB_VID_AFATECH,
+				USB_PID_AFATECH_AF9035_1000)},
+	[AFATECH_AF9035_1001] = {USB_DEVICE(USB_VID_AFATECH,
+				USB_PID_AFATECH_AF9035_1001)},
+	[AFATECH_AF9035_1002] = {USB_DEVICE(USB_VID_AFATECH,
+				USB_PID_AFATECH_AF9035_1002)},
+	[AFATECH_AF9035_1003] = {USB_DEVICE(USB_VID_AFATECH,
+				USB_PID_AFATECH_AF9035_1003)},
+	[AFATECH_AF9035_9035] = {USB_DEVICE(USB_VID_AFATECH,
+				USB_PID_AFATECH_AF9035_9035)},
+	[TERRATEC_CINERGY_T_STICK] = {USB_DEVICE(USB_VID_TERRATEC,
+				USB_PID_TERRATEC_CINERGY_T_STICK)},
+	[TERRATEC_CINERGY_T_STICK_2] = {USB_DEVICE(USB_VID_TERRATEC,
+				USB_PID_TERRATEC_CINERGY_T_STICK_2)},
+	[AVERMEDIA_TWINSTAR] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_A825)},
+	[AVERMEDIA_VOLAR_HD] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_A835)},
+	[AVERMEDIA_VOLAR_HD_PRO] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_B835)},
+#ifdef ENABLE_A867_DEVICES
+	[AVERMEDIA_A333] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_A333)},
+	[AVERMEDIA_B867] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_B867)},
+	[AVERMEDIA_1867] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_1867)},
+	[AVERMEDIA_0337] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_0337)},
+	[AVERMEDIA_A867] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_A867)},
+	[AVERMEDIA_0867] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_0867)},
+	[AVERMEDIA_F337] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_F337)},
+	[AVERMEDIA_3867] = {USB_DEVICE(USB_VID_AVERMEDIA,
+				USB_PID_AVERMEDIA_3867)},
+#endif
+	{ },
+};
+
+MODULE_DEVICE_TABLE(usb, af9035_usb_table);
+
+static struct dvb_usb_device_properties af9035_properties[] = {
+	{
+		.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+
+		.usb_ctrl = DEVICE_SPECIFIC,
+		.download_firmware = af9035_download_firmware,
+		.firmware = "dvb-usb-af9035-01.fw",
+		.no_reconnect = 1,
+
+		.size_of_priv = 0,
+
+		.adapter = {
+			{
+#ifdef V4L2_REFACTORED_MFE_CODE
+			.num_frontends = 1,
+			.fe = {{
+#endif
+				.frontend_attach =
+					af9035_af9033_frontend_attach,
+				.tuner_attach = af9035_tuner_attach,
+				.stream = {
+					.type = USB_BULK,
+					.count = 4,
+					.endpoint = 0x84,
+				},
+#ifdef V4L2_REFACTORED_MFE_CODE
+			}},
+#endif
+			},
+			{
+#ifdef V4L2_REFACTORED_MFE_CODE
+			.num_frontends = 1,
+			.fe = {{
+#endif
+				.frontend_attach =
+					af9035_af9033_frontend_attach,
+				.tuner_attach = af9035_tuner_attach,
+				.stream = {
+					.type = USB_BULK,
+					.count = 4,
+					.endpoint = 0x85,
+					.u = {
+						.bulk = {
+							.buffersize =
+						TS_USB20_FRAME_SIZE,
+						}
+					}
+				},
+#ifdef V4L2_REFACTORED_MFE_CODE
+			}},
+#endif
+			}
+		},
+
+		.identify_state = af9035_identify_state,
+
+		.i2c_algo = &af9035_i2c_algo,
+
+#ifdef ENABLE_A867_DEVICES
+		.num_device_descs = 6,
+#else
+		.num_device_descs = 4,
+#endif
+		.devices = {
+			{
+				.name = "Afatech AF9035 DVB-T USB2.0 stick",
+				.cold_ids = {&af9035_usb_table[AFATECH_AF9035_1000],
+					     &af9035_usb_table[AFATECH_AF9035_1001],
+					     &af9035_usb_table[AFATECH_AF9035_1002],
+					     &af9035_usb_table[AFATECH_AF9035_1003],
+					     &af9035_usb_table[AFATECH_AF9035_9035], NULL},
+				.warm_ids = {NULL},
+			},
+			{
+				.name = "TerraTec Cinergy T Stick",
+				.cold_ids = {&af9035_usb_table[TERRATEC_CINERGY_T_STICK],
+					     &af9035_usb_table[TERRATEC_CINERGY_T_STICK_2], NULL},
+				.warm_ids = {NULL},
+			},
+			{
+				.name = "Avermedia TwinStar",
+				.cold_ids = {&af9035_usb_table[AVERMEDIA_TWINSTAR], NULL},
+				.warm_ids = {NULL},
+			},
+			{
+				.name = "Avermedia AverTV Volar HD & HD PRO (A835)",
+				.cold_ids = {&af9035_usb_table[AVERMEDIA_VOLAR_HD],
+					     &af9035_usb_table[AVERMEDIA_VOLAR_HD_PRO], NULL},
+				.warm_ids = {NULL},
+			},
+#ifdef ENABLE_A867_DEVICES
+			{
+				.name = "Avermedia A333",
+				.cold_ids = {&af9035_usb_table[AVERMEDIA_A333],
+					     &af9035_usb_table[AVERMEDIA_B867], NULL},
+				.warm_ids = {NULL},
+			},
+			{
+				.name = "Avermedia A867",
+				.cold_ids = {&af9035_usb_table[AVERMEDIA_1867],
+					     &af9035_usb_table[AVERMEDIA_0337],
+					     &af9035_usb_table[AVERMEDIA_A867],
+					     &af9035_usb_table[AVERMEDIA_0867],
+					     &af9035_usb_table[AVERMEDIA_F337],
+					     &af9035_usb_table[AVERMEDIA_3867], NULL},
+				.warm_ids = {NULL},
+			},
+#endif
+		}
+	},
+};
+
+static int af9035_usb_probe(struct usb_interface *intf,
+			    const struct usb_device_id *id)
+{
+	int ret = 0;
+	struct dvb_usb_device *d = NULL;
+	struct usb_device *udev = interface_to_usbdev(intf);
+	u8 i;
+
+	deb_info("%s: interface:%d\n", __func__,
+		intf->cur_altsetting->desc.bInterfaceNumber);
+
+	/* interface 0 is used by DVB-T receiver and
+	   interface 1 is for remote controller (HID) */
+	if (intf->cur_altsetting->desc.bInterfaceNumber == 0) {
+		ret = af9035_read_config(udev);
+		if (ret)
+			return ret;
+
+		ret = af9035_aux_init(udev);
+		if (ret)
+			return ret;
+
+		for (i = 0; i < af9035_properties_count; i++) {
+			ret = dvb_usb_device_init(intf, &af9035_properties[i],
+				THIS_MODULE, &d, adapter_nr);
+			if (!ret)
+				break;
+			if (ret != -ENODEV)
+				return ret;
+		}
+		if (ret)
+			return ret;
+
+		if (d)
+			ret = af9035_init(d);
+	}
+
+	return ret;
+}
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver af9035_usb_driver = {
+	.name = "dvb_usb_af9035",
+	.probe = af9035_usb_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table = af9035_usb_table,
+};
+
+/* module stuff */
+static int __init af9035_usb_module_init(void)
+{
+	int ret;
+	ret = usb_register(&af9035_usb_driver);
+	if (ret)
+		err("module init failed:%d", ret);
+
+	return ret;
+}
+
+static void __exit af9035_usb_module_exit(void)
+{
+	/* deregister this driver from the USB subsystem */
+	usb_deregister(&af9035_usb_driver);
+}
+
+module_init(af9035_usb_module_init);
+module_exit(af9035_usb_module_exit);
+
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_DESCRIPTION("Afatech AF9035 driver");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.h media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.h
--- media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/dvb-usb/af9035.h	2012-02-27 00:02:36.128915017 +0100
@@ -0,0 +1,187 @@
+/*
+ * Afatech AF9035 DVB USB driver
+ *
+ * Copyright (C) 2008 Afatech
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Thanks to TerraTec for a support received.
+ */
+
+#ifndef AF9035_H
+#define AF9035_H
+#include "af9033_reg.h"
+
+#define DVB_USB_LOG_PREFIX "af9035"
+#include "dvb-usb.h"
+
+#define deb_info(args...) dprintk(dvb_usb_af9035_debug, 0x01, args)
+#define deb_rc(args...)   dprintk(dvb_usb_af9035_debug, 0x02, args)
+#define deb_xfer(args...) dprintk(dvb_usb_af9035_debug, 0x04, args)
+#define deb_reg(args...)  dprintk(dvb_usb_af9035_debug, 0x08, args)
+#define deb_i2c(args...)  dprintk(dvb_usb_af9035_debug, 0x10, args)
+#define deb_fw(args...)   dprintk(dvb_usb_af9035_debug, 0x20, args)
+
+#define AF9035_USB_TIMEOUT 2000
+
+#define LINK 0x00
+#define OFDM 0x80
+
+#define TS_MODE_SINGLE   0
+#define TS_MODE_DCA_PIP  1
+#define TS_MODE_DCA      2 /* any other value than 0, 1, 3 (?) */
+#define TS_MODE_PIP      3
+
+#define TS_PACKET_SIZE            188
+#define TS_USB20_PACKET_COUNT     348
+#define TS_USB20_FRAME_SIZE       (TS_PACKET_SIZE*TS_USB20_PACKET_COUNT)
+#define TS_USB11_PACKET_COUNT      21
+#define TS_USB11_FRAME_SIZE       (TS_PACKET_SIZE*TS_USB11_PACKET_COUNT)
+#define TS_USB20_MAX_PACKET_SIZE  512
+#define TS_USB11_MAX_PACKET_SIZE   64
+
+/* EEPROM locations */
+#define GANY_ONLY 0x42f5
+#define EEPROM_FLB_OFS  8
+#define EEPROM_BASE_ADDR  (GANY_ONLY + EEPROM_FLB_OFS)
+#define EEPROM_SHIFT      (0x10)
+
+#define EEPROM_IR_MODE    (EEPROM_BASE_ADDR+0x10)   /* 00:disabled, 01:HID */
+#define EEPROM_SELSUSPEND (EEPROM_BASE_ADDR+0x28)   /* selective suspend mode */
+#define EEPROM_TS_MODE    (EEPROM_BASE_ADDR+0x28+1) /* 0:one ts, 1:dual ts */
+#define EEPROM_2WIREADDR  (EEPROM_BASE_ADDR+0x28+2) /* 2nd demod I2C addr */
+#define EEPROM_SUSPEND    (EEPROM_BASE_ADDR+0x28+3) /* suspend mode */
+#define EEPROM_IR_TYPE    (EEPROM_BASE_ADDR+0x28+4) /* 0:NEC, 1:RC6 */
+
+#define EEPROM_SAW_BW1    (EEPROM_BASE_ADDR+0x28+5)
+#define EEPROM_XTAL1      (EEPROM_BASE_ADDR+0x28+6)
+#define EEPROM_SPECINV1   (EEPROM_BASE_ADDR+0x28+7)
+#define EEPROM_TUNER_ID1  (EEPROM_BASE_ADDR+0x30+4)
+#define EEPROM_IFFREQL1   (EEPROM_BASE_ADDR+0x30)
+#define EEPROM_IFFREQH1   (EEPROM_BASE_ADDR+0x30+1)
+#define EEPROM_IF1L1      (EEPROM_BASE_ADDR+0x30+2)
+#define EEPROM_IF1H1      (EEPROM_BASE_ADDR+0x30+3)
+
+#define EEPROM_SAW_BW2    (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x28+5)
+#define EEPROM_XTAL2      (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x28+6)
+#define EEPROM_SPECINV2   (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x28+7)
+#define EEPROM_TUNER_ID2  (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x30+4)
+#define EEPROM_IFFREQL2   (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x30)
+#define EEPROM_IFFREQH2   (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x30+1)
+#define EEPROM_IF1L2      (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x30+2)
+#define EEPROM_IF1H2      (EEPROM_BASE_ADDR+EEPROM_SHIFT+0x30+3)
+
+struct af9035_clock {
+	u32 crystal;
+	u32 adc;
+};
+
+static struct af9035_clock clock_table[] = {
+	{20480000, 20480000},  /*     FPGA */
+	{16384000, 20480000},  /* 16.38MHz */
+	{20480000, 20480000},  /* 20.48MHz */
+	{36000000, 20250000},  /* 36.00MHz */
+	{30000000, 20156250},  /* 30.00MHz */
+	{26000000, 20583333},  /* 26.00MHz */
+	{28000000, 20416667},  /* 28.00MHz */
+	{32000000, 20500000},  /* 32.00MHz */
+	{34000000, 20187500},  /* 34.00MHz */
+	{24000000, 20500000},  /* 24.00MHz */
+	{22000000, 20625000},  /* 22.00MHz */
+	{12000000, 20250000},  /* 12.00MHz */
+};
+
+struct af9035_req {
+	u8  cmd;
+	u8  mbox;
+	u8  wlen;
+	u8  *wbuf;
+	u8  rlen;
+	u8  *rbuf;
+};
+
+/* USB commands */
+#define CMD_REG_DEMOD_READ          0x00
+#define CMD_REG_DEMOD_WRITE         0x01
+#define CMD_REG_TUNER_READ          0x02
+#define CMD_REG_TUNER_WRITE         0x03
+#define CMD_REG_EEPROM_READ         0x04
+#define CMD_REG_EEPROM_WRITE        0x05
+#define CMD_VAR_READ                0x08
+#define CMD_VAR_WRITE               0x09
+
+#define CMD_DATA_READ               0x06
+
+#define CMD_PLATFORM_GET            0x0A
+#define CMD_PLATFORM_SET            0x0B
+#define CMD_IP_CACHE                0x0D
+#define CMD_IP_ADD                  0x0E
+#define CMD_IP_REMOVE               0x0F
+#define CMD_PID_ADD                 0x10
+#define CMD_PID_REMOVE              0x11
+/* get SI/PSI table for specific PID "once" */
+#define CMD_SIPSI_GET               0x12
+#define CMD_SIPSI_MPE_RESET         0x13
+#define CMD_H_PID_ADD               0x15
+#define CMD_H_PID_REMOVE            0x16
+#define CMD_ABORT                   0x17
+#define CMD_IR_GET                  0x18
+#define CMD_IR_SET                  0x19
+#define CMD_FW_DOWNLOAD_BEGIN       0x24
+#define CMD_FW_DOWNLOAD             0x21
+#define CMD_FW_DOWNLOAD_END         0x25
+#define CMD_QUERYINFO               0x22
+#define CMD_BOOT                    0x23
+#define CMD_REBOOT                  0x23
+#define CMD_RUN_CODE                0x26
+#define CMD_SCATTER_READ            0x28
+#define CMD_SCATTER_WRITE           0x29
+#define CMD_GENERIC_READ            0x2A
+#define CMD_GENERIC_WRITE           0x2B
+
+#define CMD_SERVICES_GET            0x83
+#define CMD_COMPONENT_ADD           0x86
+#define CMD_COMPONENT_REMOVE        0x87
+#define CMD_FIG_ADD                 0x88
+#define CMD_FIG_REMOVE              0x89
+
+/* this Linux driver does not implement usage of "short command" at all */
+#define CMD_SHORT_REG_DEMOD_READ    0x02
+#define CMD_SHORT_REG_DEMOD_WRITE   0X03
+#define CMD_SHORT_REG_TUNER_READ    0x04
+#define CMD_SHORT_REG_TUNER_WRITE   0X05
+
+struct af9035_config {
+	u8 dual_mode:1;
+	u16 mt2060_if1[2];
+};
+
+struct af9035_segment {
+#define SEGMENT_FW_DOWNLOAD 0
+#define SEGMENT_ROM_COPY    1
+#define SEGMENT_DIRECT_CMD  2
+	u8 type;
+	u32 len;
+};
+
+struct af9035_firmware_header {
+#define SEGMENT_MAX_COUNT 50
+	u8 segment_count;
+	struct af9035_segment segment[SEGMENT_MAX_COUNT];
+};
+
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/af9033.c media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033.c
--- media_build_experimental//linux/drivers/media/dvb/frontends/af9033.c	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033.c	2012-02-27 00:02:38.328915017 +0100
@@ -0,0 +1,1957 @@
+/*
+ * Afatech AF9033 demodulator driver
+ *
+ * Copyright (C) 2008 Afatech
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Thanks to TerraTec for a support received.
+ */
+
+#include "dvb_frontend.h"
+#include <linux/slab.h>         /* for kzalloc/kfree */
+#include <linux/version.h>
+#include "af9033_priv.h"
+#include "af9033.h"
+#include "af9033_reg.h"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)) || ((defined V4L2_VERSION) && (V4L2_VERSION >= 197120))
+/* all DVB frontend drivers now work directly with the DVBv5
+ * structure. This warrants that all drivers will be
+ * getting/setting frontend parameters on a consistent way, in
+ * order to avoid copying data from/to the DVBv3 structs
+ * without need.
+ */
+#define V4L2_ONLY_DVB_V5
+#endif
+
+static int af9033_debug;
+module_param_named(debug, af9033_debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+static int af9033_snrdb;
+module_param_named(snrdb, af9033_snrdb, int, 0644);
+MODULE_PARM_DESC(snrdb, "Turn on/off SNR output as dBx10 (default:off).");
+
+struct af9033_state {
+	struct i2c_adapter *i2c;
+	struct dvb_frontend frontend;
+	struct af9033_config config;
+
+	u16 signal_strength;
+	u32 ber;
+	u32 ucblocks;
+	u16 snr;
+	u32 frequency;
+	unsigned long next_statistics_check;
+};
+
+static u8 regmask[8] = {0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
+
+/* write multiple registers */
+static int af9033_write_regs(struct af9033_state *state, u8 mbox, u16 reg,
+	u8 *val, u8 len)
+{
+	u8 buf[3+len];
+	struct i2c_msg msg = {
+		.addr = state->config.demod_address,
+		.flags = 0,
+		.len = sizeof(buf),
+		.buf = buf };
+
+	buf[0] = mbox;
+	buf[1] = reg >> 8;
+	buf[2] = reg & 0xff;
+	memcpy(&buf[3], val, len);
+
+	if (i2c_transfer(state->i2c, &msg, 1) != 1) {
+		warn("I2C write failed reg:%04x len:%d", reg, len);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+/* read multiple registers */
+static int af9033_read_regs(struct af9033_state *state, u8 mbox, u16 reg,
+	u8 *val, u8 len)
+{
+	u8 obuf[3] = {mbox, reg >> 8, reg & 0xff};
+	struct i2c_msg msg[2] = {
+		{
+			.addr = state->config.demod_address,
+			.flags = 0,
+			.len = sizeof(obuf),
+			.buf = obuf
+		}, {
+			.addr = state->config.demod_address,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val
+		}
+	};
+
+	if (i2c_transfer(state->i2c, msg, 2) != 2) {
+		warn("I2C read failed reg:%04x", reg);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+/* write single register */
+static int af9033_write_reg(struct af9033_state *state, u8 mbox, u16 reg,
+	u8 val)
+{
+	return af9033_write_regs(state, mbox, reg, &val, 1);
+}
+
+/* read single register */
+static int af9033_read_reg(struct af9033_state *state, u8 mbox, u16 reg,
+	u8 *val)
+{
+	return af9033_read_regs(state, mbox, reg, val, 1);
+}
+
+/* write single register bits */
+static int af9033_write_reg_bits(struct af9033_state *state, u8 mbox, u16 reg,
+	u8 pos, u8 len, u8 val)
+{
+	int ret;
+	u8 tmp, mask;
+
+	ret = af9033_read_reg(state, mbox, reg, &tmp);
+	if (ret)
+		return ret;
+
+	mask = regmask[len - 1] << pos;
+	tmp = (tmp & ~mask) | ((val << pos) & mask);
+
+	return af9033_write_reg(state, mbox, reg, tmp);
+}
+
+/* read single register bits */
+static int af9033_read_reg_bits(struct af9033_state *state, u8 mbox, u16 reg,
+	u8 pos, u8 len, u8 *val)
+{
+	int ret;
+	u8 tmp;
+
+	ret = af9033_read_reg(state, mbox, reg, &tmp);
+	if (ret)
+		return ret;
+
+	*val = (tmp >> pos) & regmask[len - 1];
+	return 0;
+}
+
+static u32 af913_div(u32 a, u32 b, u32 x)
+{
+	u32 r = 0, c = 0, i;
+	deb_info("%s: a:%d b:%d x:%d\n", __func__, a, b, x);
+
+	if (a > b) {
+		c = a / b;
+		a = a - c * b;
+	}
+
+	for (i = 0; i < x; i++) {
+		if (a >= b) {
+			r += 1;
+			a -= b;
+		}
+		a <<= 1;
+		r <<= 1;
+	}
+	r = (c << (u32)x) + r;
+
+	deb_info("%s: a:%d b:%d x:%d r:%d r:%x\n", __func__, a, b, x, r, r);
+	return r;
+}
+
+#ifdef V4L2_ONLY_DVB_V5
+static int af9033_set_coeff(struct af9033_state *state, u32 bw)
+#else
+static int af9033_set_coeff(struct af9033_state *state, fe_bandwidth_t bw)
+#endif
+{
+	int ret = 0;
+	u8 tmp, i = 0;
+	u8 buf[36];
+	u32 uninitialized_var(coeff1_2048nu);
+	u32 uninitialized_var(coeff1_4096nu);
+	u32 uninitialized_var(coeff1_8191nu);
+	u32 uninitialized_var(coeff1_8192nu);
+	u32 uninitialized_var(coeff1_8193nu);
+	u32 uninitialized_var(coeff2_2k);
+	u32 uninitialized_var(coeff2_4k);
+	u32 uninitialized_var(coeff2_8k);
+	u16 uninitialized_var(bfsfcw_fftindex_ratio);
+	u16 uninitialized_var(fftindex_bfsfcw_ratio);
+	deb_info("%s: adc_clock:%d bw:%d\n", __func__,
+		state->config.adc_clock, bw);
+
+#ifdef V4L2_ONLY_DVB_V5
+#define BANDWIDTH_5_MHZ 5000000
+#define BANDWIDTH_6_MHZ 6000000
+#define BANDWIDTH_7_MHZ 7000000
+#define BANDWIDTH_8_MHZ 8000000
+#endif
+
+	switch (state->config.adc_clock) {
+	case 20156250:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x02449b5c;
+			coeff1_4096nu = 0x01224dae;
+			coeff1_8191nu = 0x00912b60;
+			coeff1_8192nu = 0x009126d7;
+			coeff1_8193nu = 0x0091224e;
+			coeff2_2k = 0x01224dae;
+			coeff2_4k = 0x009126d7;
+			coeff2_8k = 0x0048936b;
+			bfsfcw_fftindex_ratio = 0x0387;
+			fftindex_bfsfcw_ratio = 0x0122;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02b8ba6e;
+			coeff1_4096nu = 0x015c5d37;
+			coeff1_8191nu = 0x00ae340d;
+			coeff1_8192nu = 0x00ae2e9b;
+			coeff1_8193nu = 0x00ae292a;
+			coeff2_2k = 0x015c5d37;
+			coeff2_4k = 0x00ae2e9b;
+			coeff2_8k = 0x0057174e;
+			bfsfcw_fftindex_ratio = 0x02f1;
+			fftindex_bfsfcw_ratio = 0x015c;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x032cd980;
+			coeff1_4096nu = 0x01966cc0;
+			coeff1_8191nu = 0x00cb3cba;
+			coeff1_8192nu = 0x00cb3660;
+			coeff1_8193nu = 0x00cb3007;
+			coeff2_2k = 0x01966cc0;
+			coeff2_4k = 0x00cb3660;
+			coeff2_8k = 0x00659b30;
+			bfsfcw_fftindex_ratio = 0x0285;
+			fftindex_bfsfcw_ratio = 0x0196;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x03a0f893;
+			coeff1_4096nu = 0x01d07c49;
+			coeff1_8191nu = 0x00e84567;
+			coeff1_8192nu = 0x00e83e25;
+			coeff1_8193nu = 0x00e836e3;
+			coeff2_2k = 0x01d07c49;
+			coeff2_4k = 0x00e83e25;
+			coeff2_8k = 0x00741f12;
+			bfsfcw_fftindex_ratio = 0x0234;
+			fftindex_bfsfcw_ratio = 0x01d0;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20187500:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x0243b546;
+			coeff1_4096nu = 0x0121daa3;
+			coeff1_8191nu = 0x0090f1d9;
+			coeff1_8192nu = 0x0090ed51;
+			coeff1_8193nu = 0x0090e8ca;
+			coeff2_2k = 0x0121daa3;
+			coeff2_4k = 0x0090ed51;
+			coeff2_8k = 0x004876a9;
+			bfsfcw_fftindex_ratio = 0x0388;
+			fftindex_bfsfcw_ratio = 0x0122;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02b7a654;
+			coeff1_4096nu = 0x015bd32a;
+			coeff1_8191nu = 0x00adef04;
+			coeff1_8192nu = 0x00ade995;
+			coeff1_8193nu = 0x00ade426;
+			coeff2_2k = 0x015bd32a;
+			coeff2_4k = 0x00ade995;
+			coeff2_8k = 0x0056f4ca;
+			bfsfcw_fftindex_ratio = 0x02f2;
+			fftindex_bfsfcw_ratio = 0x015c;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x032b9761;
+			coeff1_4096nu = 0x0195cbb1;
+			coeff1_8191nu = 0x00caec30;
+			coeff1_8192nu = 0x00cae5d8;
+			coeff1_8193nu = 0x00cadf81;
+			coeff2_2k = 0x0195cbb1;
+			coeff2_4k = 0x00cae5d8;
+			coeff2_8k = 0x006572ec;
+			bfsfcw_fftindex_ratio = 0x0286;
+			fftindex_bfsfcw_ratio = 0x0196;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x039f886f;
+			coeff1_4096nu = 0x01cfc438;
+			coeff1_8191nu = 0x00e7e95b;
+			coeff1_8192nu = 0x00e7e21c;
+			coeff1_8193nu = 0x00e7dadd;
+			coeff2_2k = 0x01cfc438;
+			coeff2_4k = 0x00e7e21c;
+			coeff2_8k = 0x0073f10e;
+			bfsfcw_fftindex_ratio = 0x0235;
+			fftindex_bfsfcw_ratio = 0x01d0;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20250000:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x0241eb3b;
+			coeff1_4096nu = 0x0120f59e;
+			coeff1_8191nu = 0x00907f53;
+			coeff1_8192nu = 0x00907acf;
+			coeff1_8193nu = 0x0090764b;
+			coeff2_2k = 0x0120f59e;
+			coeff2_4k = 0x00907acf;
+			coeff2_8k = 0x00483d67;
+			bfsfcw_fftindex_ratio = 0x038b;
+			fftindex_bfsfcw_ratio = 0x0121;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02b580ad;
+			coeff1_4096nu = 0x015ac057;
+			coeff1_8191nu = 0x00ad6597;
+			coeff1_8192nu = 0x00ad602b;
+			coeff1_8193nu = 0x00ad5ac1;
+			coeff2_2k = 0x015ac057;
+			coeff2_4k = 0x00ad602b;
+			coeff2_8k = 0x0056b016;
+			bfsfcw_fftindex_ratio = 0x02f4;
+			fftindex_bfsfcw_ratio = 0x015b;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x03291620;
+			coeff1_4096nu = 0x01948b10;
+			coeff1_8191nu = 0x00ca4bda;
+			coeff1_8192nu = 0x00ca4588;
+			coeff1_8193nu = 0x00ca3f36;
+			coeff2_2k = 0x01948b10;
+			coeff2_4k = 0x00ca4588;
+			coeff2_8k = 0x006522c4;
+			bfsfcw_fftindex_ratio = 0x0288;
+			fftindex_bfsfcw_ratio = 0x0195;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x039cab92;
+			coeff1_4096nu = 0x01ce55c9;
+			coeff1_8191nu = 0x00e7321e;
+			coeff1_8192nu = 0x00e72ae4;
+			coeff1_8193nu = 0x00e723ab;
+			coeff2_2k = 0x01ce55c9;
+			coeff2_4k = 0x00e72ae4;
+			coeff2_8k = 0x00739572;
+			bfsfcw_fftindex_ratio = 0x0237;
+			fftindex_bfsfcw_ratio = 0x01ce;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20583333:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x02388f54;
+			coeff1_4096nu = 0x011c47aa;
+			coeff1_8191nu = 0x008e2846;
+			coeff1_8192nu = 0x008e23d5;
+			coeff1_8193nu = 0x008e1f64;
+			coeff2_2k = 0x011c47aa;
+			coeff2_4k = 0x008e23d5;
+			coeff2_8k = 0x004711ea;
+			bfsfcw_fftindex_ratio = 0x039a;
+			fftindex_bfsfcw_ratio = 0x011c;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02aa4598;
+			coeff1_4096nu = 0x015522cc;
+			coeff1_8191nu = 0x00aa96bb;
+			coeff1_8192nu = 0x00aa9166;
+			coeff1_8193nu = 0x00aa8c12;
+			coeff2_2k = 0x015522cc;
+			coeff2_4k = 0x00aa9166;
+			coeff2_8k = 0x005548b3;
+			bfsfcw_fftindex_ratio = 0x0300;
+			fftindex_bfsfcw_ratio = 0x0155;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x031bfbdc;
+			coeff1_4096nu = 0x018dfdee;
+			coeff1_8191nu = 0x00c7052f;
+			coeff1_8192nu = 0x00c6fef7;
+			coeff1_8193nu = 0x00c6f8bf;
+			coeff2_2k = 0x018dfdee;
+			coeff2_4k = 0x00c6fef7;
+			coeff2_8k = 0x00637f7b;
+			bfsfcw_fftindex_ratio = 0x0293;
+			fftindex_bfsfcw_ratio = 0x018e;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x038db21f;
+			coeff1_4096nu = 0x01c6d910;
+			coeff1_8191nu = 0x00e373a3;
+			coeff1_8192nu = 0x00e36c88;
+			coeff1_8193nu = 0x00e3656d;
+			coeff2_2k = 0x01c6d910;
+			coeff2_4k = 0x00e36c88;
+			coeff2_8k = 0x0071b644;
+			bfsfcw_fftindex_ratio = 0x0240;
+			fftindex_bfsfcw_ratio = 0x01c7;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20416667:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x023d337f;
+			coeff1_4096nu = 0x011e99c0;
+			coeff1_8191nu = 0x008f515a;
+			coeff1_8192nu = 0x008f4ce0;
+			coeff1_8193nu = 0x008f4865;
+			coeff2_2k = 0x011e99c0;
+			coeff2_4k = 0x008f4ce0;
+			coeff2_8k = 0x0047a670;
+			bfsfcw_fftindex_ratio = 0x0393;
+			fftindex_bfsfcw_ratio = 0x011f;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02afd765;
+			coeff1_4096nu = 0x0157ebb3;
+			coeff1_8191nu = 0x00abfb39;
+			coeff1_8192nu = 0x00abf5d9;
+			coeff1_8193nu = 0x00abf07a;
+			coeff2_2k = 0x0157ebb3;
+			coeff2_4k = 0x00abf5d9;
+			coeff2_8k = 0x0055faed;
+			bfsfcw_fftindex_ratio = 0x02fa;
+			fftindex_bfsfcw_ratio = 0x0158;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x03227b4b;
+			coeff1_4096nu = 0x01913da6;
+			coeff1_8191nu = 0x00c8a518;
+			coeff1_8192nu = 0x00c89ed3;
+			coeff1_8193nu = 0x00c8988e;
+			coeff2_2k = 0x01913da6;
+			coeff2_4k = 0x00c89ed3;
+			coeff2_8k = 0x00644f69;
+			bfsfcw_fftindex_ratio = 0x028d;
+			fftindex_bfsfcw_ratio = 0x0191;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x03951f32;
+			coeff1_4096nu = 0x01ca8f99;
+			coeff1_8191nu = 0x00e54ef7;
+			coeff1_8192nu = 0x00e547cc;
+			coeff1_8193nu = 0x00e540a2;
+			coeff2_2k = 0x01ca8f99;
+			coeff2_4k = 0x00e547cc;
+			coeff2_8k = 0x0072a3e6;
+			bfsfcw_fftindex_ratio = 0x023c;
+			fftindex_bfsfcw_ratio = 0x01cb;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20480000:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x023b6db7;
+			coeff1_4096nu = 0x011db6db;
+			coeff1_8191nu = 0x008edfe5;
+			coeff1_8192nu = 0x008edb6e;
+			coeff1_8193nu = 0x008ed6f7;
+			coeff2_2k = 0x011db6db;
+			coeff2_4k = 0x008edb6e;
+			coeff2_8k = 0x00476db7;
+			bfsfcw_fftindex_ratio = 0x0396;
+			fftindex_bfsfcw_ratio = 0x011e;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02adb6db;
+			coeff1_4096nu = 0x0156db6e;
+			coeff1_8191nu = 0x00ab7312;
+			coeff1_8192nu = 0x00ab6db7;
+			coeff1_8193nu = 0x00ab685c;
+			coeff2_2k = 0x0156db6e;
+			coeff2_4k = 0x00ab6db7;
+			coeff2_8k = 0x0055b6db;
+			bfsfcw_fftindex_ratio = 0x02fd;
+			fftindex_bfsfcw_ratio = 0x0157;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x03200000;
+			coeff1_4096nu = 0x01900000;
+			coeff1_8191nu = 0x00c80640;
+			coeff1_8192nu = 0x00c80000;
+			coeff1_8193nu = 0x00c7f9c0;
+			coeff2_2k = 0x01900000;
+			coeff2_4k = 0x00c80000;
+			coeff2_8k = 0x00640000;
+			bfsfcw_fftindex_ratio = 0x028f;
+			fftindex_bfsfcw_ratio = 0x0190;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x03924925;
+			coeff1_4096nu = 0x01c92492;
+			coeff1_8191nu = 0x00e4996e;
+			coeff1_8192nu = 0x00e49249;
+			coeff1_8193nu = 0x00e48b25;
+			coeff2_2k = 0x01c92492;
+			coeff2_4k = 0x00e49249;
+			coeff2_8k = 0x00724925;
+			bfsfcw_fftindex_ratio = 0x023d;
+			fftindex_bfsfcw_ratio = 0x01c9;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20500000:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x023adeff;
+			coeff1_4096nu = 0x011d6f80;
+			coeff1_8191nu = 0x008ebc36;
+			coeff1_8192nu = 0x008eb7c0;
+			coeff1_8193nu = 0x008eb34a;
+			coeff2_2k = 0x011d6f80;
+			coeff2_4k = 0x008eb7c0;
+			coeff2_8k = 0x00475be0;
+			bfsfcw_fftindex_ratio = 0x0396;
+			fftindex_bfsfcw_ratio = 0x011d;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02ad0b99;
+			coeff1_4096nu = 0x015685cc;
+			coeff1_8191nu = 0x00ab4840;
+			coeff1_8192nu = 0x00ab42e6;
+			coeff1_8193nu = 0x00ab3d8c;
+			coeff2_2k = 0x015685cc;
+			coeff2_4k = 0x00ab42e6;
+			coeff2_8k = 0x0055a173;
+			bfsfcw_fftindex_ratio = 0x02fd;
+			fftindex_bfsfcw_ratio = 0x0157;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x031f3832;
+			coeff1_4096nu = 0x018f9c19;
+			coeff1_8191nu = 0x00c7d44b;
+			coeff1_8192nu = 0x00c7ce0c;
+			coeff1_8193nu = 0x00c7c7ce;
+			coeff2_2k = 0x018f9c19;
+			coeff2_4k = 0x00c7ce0c;
+			coeff2_8k = 0x0063e706;
+			bfsfcw_fftindex_ratio = 0x0290;
+			fftindex_bfsfcw_ratio = 0x0190;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x039164cb;
+			coeff1_4096nu = 0x01c8b266;
+			coeff1_8191nu = 0x00e46056;
+			coeff1_8192nu = 0x00e45933;
+			coeff1_8193nu = 0x00e45210;
+			coeff2_2k = 0x01c8b266;
+			coeff2_4k = 0x00e45933;
+			coeff2_8k = 0x00722c99;
+			bfsfcw_fftindex_ratio = 0x023e;
+			fftindex_bfsfcw_ratio = 0x01c9;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	case 20625000:
+		switch (bw) {
+#if 0 /* keep */
+		case BANDWIDTH_5_MHZ:
+			coeff1_2048nu = 0x02376948;
+			coeff1_4096nu = 0x011bb4a4;
+			coeff1_8191nu = 0x008ddec1;
+			coeff1_8192nu = 0x008dda52;
+			coeff1_8193nu = 0x008dd5e3;
+			coeff2_2k = 0x011bb4a4;
+			coeff2_4k = 0x008dda52;
+			coeff2_8k = 0x0046ed29;
+			bfsfcw_fftindex_ratio = 0x039c;
+			fftindex_bfsfcw_ratio = 0x011c;
+			break;
+#endif
+		case BANDWIDTH_6_MHZ:
+			coeff1_2048nu = 0x02a8e4bd;
+			coeff1_4096nu = 0x0154725e;
+			coeff1_8191nu = 0x00aa3e81;
+			coeff1_8192nu = 0x00aa392f;
+			coeff1_8193nu = 0x00aa33de;
+			coeff2_2k = 0x0154725e;
+			coeff2_4k = 0x00aa392f;
+			coeff2_8k = 0x00551c98;
+			bfsfcw_fftindex_ratio = 0x0302;
+			fftindex_bfsfcw_ratio = 0x0154;
+			break;
+		case BANDWIDTH_7_MHZ:
+			coeff1_2048nu = 0x031a6032;
+			coeff1_4096nu = 0x018d3019;
+			coeff1_8191nu = 0x00c69e41;
+			coeff1_8192nu = 0x00c6980c;
+			coeff1_8193nu = 0x00c691d8;
+			coeff2_2k = 0x018d3019;
+			coeff2_4k = 0x00c6980c;
+			coeff2_8k = 0x00634c06;
+			bfsfcw_fftindex_ratio = 0x0294;
+			fftindex_bfsfcw_ratio = 0x018d;
+			break;
+		case BANDWIDTH_8_MHZ:
+			coeff1_2048nu = 0x038bdba6;
+			coeff1_4096nu = 0x01c5edd3;
+			coeff1_8191nu = 0x00e2fe02;
+			coeff1_8192nu = 0x00e2f6ea;
+			coeff1_8193nu = 0x00e2efd2;
+			coeff2_2k = 0x01c5edd3;
+			coeff2_4k = 0x00e2f6ea;
+			coeff2_8k = 0x00717b75;
+			bfsfcw_fftindex_ratio = 0x0242;
+			fftindex_bfsfcw_ratio = 0x01c6;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		err("invalid xtal freq");
+		return -EINVAL;
+	}
+	if (ret) {
+		err("invalid bandwidth");
+		return ret;
+	}
+
+#ifdef V4L2_ONLY_DVB_V5
+#undef BANDWIDTH_5_MHZ
+#undef BANDWIDTH_6_MHZ
+#undef BANDWIDTH_7_MHZ
+#undef BANDWIDTH_8_MHZ
+#endif
+
+	/* adc multiplier */
+	ret = af9033_read_reg(state, OFDM, api_adcx2, &tmp);
+	if (ret)
+		return ret;
+
+	if (tmp == 1) {
+		coeff1_2048nu /= 2;
+		coeff1_4096nu /= 2;
+		coeff1_8191nu /= 2;
+		coeff1_8192nu /= 2;
+		coeff1_8193nu /= 2 ;
+		coeff2_2k /= 2;
+		coeff2_4k /= 2;
+		coeff2_8k /= 2;
+	}
+
+	buf[i++] = (u8) ((coeff1_2048nu         & 0x03000000) >> 24);
+	buf[i++] = (u8) ((coeff1_2048nu         & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff1_2048nu         & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff1_2048nu         & 0x000000ff));
+	buf[i++] = (u8) ((coeff1_4096nu         & 0x03000000) >> 24);
+	buf[i++] = (u8) ((coeff1_4096nu         & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff1_4096nu         & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff1_4096nu         & 0x000000ff));
+	buf[i++] = (u8) ((coeff1_8191nu         & 0x03000000) >> 24);
+	buf[i++] = (u8) ((coeff1_8191nu         & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff1_8191nu         & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff1_8191nu         & 0x000000ff));
+	buf[i++] = (u8) ((coeff1_8192nu         & 0x03000000) >> 24);
+	buf[i++] = (u8) ((coeff1_8192nu         & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff1_8192nu         & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff1_8192nu         & 0x000000ff));
+	buf[i++] = (u8) ((coeff1_8193nu         & 0x03000000) >> 24);
+	buf[i++] = (u8) ((coeff1_8193nu         & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff1_8193nu         & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff1_8193nu         & 0x000000ff));
+	buf[i++] = (u8) ((coeff2_8k             & 0x01000000) >> 24);
+	buf[i++] = (u8) ((coeff2_8k             & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff2_8k             & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff2_8k             & 0x000000ff));
+	buf[i++] = (u8) ((coeff2_2k             & 0x01000000) >> 24);
+	buf[i++] = (u8) ((coeff2_2k             & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff2_2k             & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff2_2k             & 0x000000ff));
+	buf[i++] = (u8) ((coeff2_4k             & 0x01000000) >> 24);
+	buf[i++] = (u8) ((coeff2_4k             & 0x00ff0000) >> 16);
+	buf[i++] = (u8) ((coeff2_4k             & 0x0000ff00) >> 8);
+	buf[i++] = (u8) ((coeff2_4k             & 0x000000ff));
+	buf[i++] = (u8) ((bfsfcw_fftindex_ratio &     0x00ff));
+	buf[i++] = (u8) ((bfsfcw_fftindex_ratio &     0xff00) >> 8);
+	buf[i++] = (u8) ((fftindex_bfsfcw_ratio &     0x00ff));
+	buf[i++] = (u8) ((fftindex_bfsfcw_ratio &     0xff00) >> 8);
+
+	deb_info("%s: coeff:", __func__);
+	debug_dump(buf, sizeof(buf), deb_info);
+
+	/* program */
+	return af9033_write_regs(state, OFDM, api_cfoe_NS_2048_coeff1_25_24,
+		buf, sizeof(buf));
+}
+
+static int af9033_set_crystal_ctrl(struct af9033_state *state)
+{
+	u8 buf[4];
+	u32 crystal_cw;
+	deb_info("%s: crystal_clock:%d\n", __func__,
+		state->config.crystal_clock);
+
+	crystal_cw = af913_div(state->config.crystal_clock, 1000000ul, 19ul);
+
+	buf[0] = (u8) ((crystal_cw & 0x000000ff));
+	buf[1] = (u8) ((crystal_cw & 0x0000ff00) >> 8);
+	buf[2] = (u8) ((crystal_cw & 0x00ff0000) >> 16);
+	buf[3] = (u8) ((crystal_cw & 0xff000000) >> 24);
+
+	deb_info("%s: crystal_cw:", __func__);
+	debug_dump(buf, sizeof(buf), deb_info);
+
+	/* program */
+	return af9033_write_regs(state, OFDM, api_crystal_clk_7_0, buf,
+		sizeof(buf));
+}
+
+static int af9033_set_adc_ctrl(struct af9033_state *state)
+{
+	u8 buf[3];
+	u32 adc_cw;
+	deb_info("%s: adc_clock:%d\n", __func__, state->config.adc_clock);
+
+	adc_cw = af913_div(state->config.adc_clock, 1000000ul, 19ul);
+
+	buf[0] = (u8) ((adc_cw & 0x000000ff));
+	buf[1] = (u8) ((adc_cw & 0x0000ff00) >> 8);
+	buf[2] = (u8) ((adc_cw & 0x00ff0000) >> 16);
+
+	deb_info("%s: adc_cw:", __func__);
+	debug_dump(buf, sizeof(buf), deb_info);
+
+	/* program */
+	return af9033_write_regs(state, OFDM, p_reg_f_adc_7_0, buf,
+		sizeof(buf));
+}
+
+static int af9033_set_freq_ctrl(struct af9033_state *state)
+{
+	int ret;
+	u8 buf[3], tmp;
+	u32 adc_freq, freq_cw;
+	s8 bfs_spec_inv;
+	int if_sample_freq;
+
+	bfs_spec_inv = state->config.rf_spec_inv ? -1 : 1;
+
+	adc_freq       = state->config.adc_clock;
+	if_sample_freq = state->config.if_freq;
+
+	while (if_sample_freq > (adc_freq / 2))
+		if_sample_freq = if_sample_freq - adc_freq;
+
+	if (if_sample_freq >= 0)
+		bfs_spec_inv = bfs_spec_inv * (-1);
+	else
+		if_sample_freq = if_sample_freq * (-1);
+
+	freq_cw = af913_div(if_sample_freq, adc_freq, 23ul);
+
+	if (bfs_spec_inv == -1)
+		freq_cw *= -1;
+
+	/* adc multiplier */
+	ret = af9033_read_reg(state, OFDM, api_adcx2, &tmp);
+	if (ret)
+		return ret;
+
+	if (tmp == 1)
+		freq_cw /= 2;
+
+	buf[0] = (u8) ((freq_cw & 0x000000ff));
+	buf[1] = (u8) ((freq_cw & 0x0000ff00) >> 8);
+	buf[2] = (u8) ((freq_cw & 0x007f0000) >> 16);
+
+	deb_info("%s: freq_cw:", __func__);
+	debug_dump(buf, sizeof(buf), deb_info);
+
+	/* program */
+	return af9033_write_regs(state, OFDM, api_bfs_fcw_7_0, buf,
+		sizeof(buf));
+}
+static void af9033_release(struct dvb_frontend *fe)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static int af9033_init(struct dvb_frontend *fe)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret, i, len;
+	u8 tmp0, tmp1;
+	struct regdesc *init;
+	deb_info("%s\n", __func__);
+
+	/* power on */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_afe_mem0, 3, 1, 0);
+	if (ret)
+		goto error;
+
+	ret = af9033_write_reg(state, OFDM, api_suspend_flag, 0);
+	if (ret)
+		goto error;
+
+	/* tell to the firmware type of the tuner */
+	ret = af9033_write_reg(state, LINK, p_reg_link_ofsm_dummy_15_8,
+		state->config.tuner);
+	if (ret)
+		goto error;
+
+	/* set read-update bit for constellation */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_feq_read_update,
+		reg_feq_read_update_pos, reg_feq_read_update_len, 1);
+	if (ret)
+		goto error;
+
+	/* enable FEC monitor */
+	ret = af9033_write_reg_bits(state, OFDM, p_fec_vtb_rsd_mon_en,
+		fec_vtb_rsd_mon_en_pos, fec_vtb_rsd_mon_en_len, 1);
+	if (ret)
+		goto error;
+
+	/* program crystal control */
+	ret = af9033_set_crystal_ctrl(state);
+	if (ret)
+		goto error;
+
+	/* program ADC control */
+	ret = af9033_set_adc_ctrl(state);
+	if (ret)
+		goto error;
+
+	/* enable DVB-T interrupt */
+	ret = af9033_write_reg_bits(state, LINK, p_reg_dvbt_inten,
+		reg_dvbt_inten_pos, reg_dvbt_inten_len, 1);
+	if (ret)
+		goto error;
+
+	/* enable DVB-T mode */
+	ret = af9033_write_reg_bits(state, LINK, p_reg_dvbt_en,
+		reg_dvbt_en_pos, reg_dvbt_en_len, 1);
+	if (ret)
+		goto error;
+
+	/* set dca_upper_chip */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_dca_upper_chip,
+		reg_dca_upper_chip_pos, reg_dca_upper_chip_len, 0);
+	if (ret)
+		goto error;
+
+	ret = af9033_write_reg_bits(state, LINK, p_reg_top_hostb_dca_upper,
+		reg_top_hostb_dca_upper_pos, reg_top_hostb_dca_upper_len, 0);
+	if (ret)
+		goto error;
+
+	ret = af9033_write_reg_bits(state, LINK, p_reg_top_hosta_dca_upper,
+		reg_top_hosta_dca_upper_pos, reg_top_hosta_dca_upper_len, 0);
+	if (ret)
+		goto error;
+
+	/* set dca_lower_chip */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_dca_lower_chip,
+		reg_dca_lower_chip_pos, reg_dca_lower_chip_len, 0);
+	if (ret)
+		goto error;
+
+	ret = af9033_write_reg_bits(state, LINK, p_reg_top_hostb_dca_lower,
+		reg_top_hostb_dca_lower_pos, reg_top_hostb_dca_lower_len, 0);
+	if (ret)
+		goto error;
+
+	ret = af9033_write_reg_bits(state, LINK, p_reg_top_hosta_dca_lower,
+		reg_top_hosta_dca_lower_pos, reg_top_hosta_dca_lower_len, 0);
+	if (ret)
+		goto error;
+
+	/* set phase latch */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_dca_platch,
+		reg_dca_platch_pos, reg_dca_platch_len, 0);
+	if (ret)
+		goto error;
+
+	/* set fpga latch */
+	ret = af9033_write_reg(state, OFDM, p_reg_dca_fpga_latch, 0);
+	if (ret)
+		goto error;
+
+	/* set stand alone */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_dca_stand_alone,
+		reg_dca_stand_alone_pos, reg_dca_stand_alone_len, 1);
+	if (ret)
+		goto error;
+
+	/* set DCA enable */
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_dca_en, reg_dca_en_pos,
+		reg_dca_en_len, 0);
+	if (ret)
+		goto error;
+
+	/* load OFSM settings */
+	deb_info("%s: load ofsm settings\n", __func__);
+	len = ARRAY_SIZE(ofsm_init);
+	init = ofsm_init;
+	for (i = 0; i < len; i++) {
+		ret = af9033_write_reg(state, OFDM, init[i].addr, init[i].val);
+		if (ret)
+			goto error;
+	}
+
+	/* load tuner specific settings */
+	deb_info("%s: load tuner specific settings\n", __func__);
+	switch (state->config.tuner) {
+	case AF9033_TUNER_TUA9001:
+		len = ARRAY_SIZE(tuner_init_tua9001);
+		init = tuner_init_tua9001;
+		break;
+	case AF9033_TUNER_MXL5007t:
+		len = ARRAY_SIZE(tuner_init_mxl5007t);
+		init = tuner_init_mxl5007t;
+		break;
+        case AF9033_TUNER_TDA18218:
+                len = ARRAY_SIZE(tuner_init_tda18218);
+                init = tuner_init_tda18218;
+                break;
+	default:
+		len = 0;
+		init = NULL;
+		break;
+	}
+	for (i = 0; i < len; i++) {
+		ret = af9033_write_reg(state, OFDM, init[i].addr, init[i].val);
+		if (ret)
+			goto error;
+	}
+
+	/* set H/W MPEG2 locked detection **/
+	ret = af9033_write_reg(state, LINK, p_reg_top_lock3_out, 1);
+	if (ret)
+		goto error;
+
+	/* set registers for driving power */
+	ret = af9033_write_reg(state, LINK, p_reg_top_padmiscdr2, 1);
+	if (ret)
+		goto error;
+
+	/* et registers for driving power */
+	ret = af9033_write_reg(state, LINK, p_reg_top_padmiscdr4, 0);
+	if (ret)
+		goto error;
+
+	/* set registers for driving power */
+	ret = af9033_write_reg(state, LINK, p_reg_top_padmiscdr8, 0);
+	if (ret)
+		goto error;
+
+	/* set TS mode */
+	deb_info("%s: setting ts mode\n", __func__);
+	tmp0 = 0; /* parallel mode */
+	tmp1 = 0; /* serial mode */
+	switch (state->config.output_mode) {
+	case AF9033_TS_MODE_PARALLEL:
+		tmp0 = 1;
+		break;
+	case AF9033_TS_MODE_SERIAL:
+		tmp1 = 1;
+		break;
+	case AF9033_TS_MODE_USB:
+		/* usb mode for AF9035 */
+	default:
+		break;
+	}
+	ret = af9033_write_reg_bits(state, OFDM, p_mp2if_mpeg_par_mode,
+		mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len, tmp0);
+	if (ret)
+		goto error;
+	ret = af9033_write_reg_bits(state, OFDM, p_mp2if_mpeg_ser_mode,
+		mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len, tmp1);
+	if (ret)
+		goto error;
+
+	if (state->config.output_mode == AF9033_TS_MODE_SERIAL) {
+		ret = af9033_write_reg_bits(state, LINK, p_reg_top_hostb_mpeg_ser_mode,
+			reg_top_hostb_mpeg_ser_mode_pos, reg_top_hostb_mpeg_ser_mode_len, 1);
+		if (ret)
+			goto error;
+	}
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int af9033_sleep(struct dvb_frontend *fe)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 tmp, i;
+	deb_info("%s\n", __func__);
+
+	ret = af9033_write_reg(state, OFDM, api_suspend_flag, 1);
+	if (ret)
+		goto error;
+
+	ret = af9033_write_reg(state, OFDM, api_trigger_ofsm, 0);
+	if (ret)
+		goto error;
+
+	for (i = 0; i < 150; i++) {
+		ret = af9033_read_reg(state, OFDM, api_suspend_flag, &tmp);
+		if (ret)
+			goto error;
+		if (!tmp)
+			break;
+		msleep(10);
+	}
+	if (tmp) {
+		deb_info("%s: power off time outs\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	ret = af9033_write_reg_bits(state, OFDM, p_reg_afe_mem0, 3, 1, 1);
+	if (ret)
+		goto error;
+
+	/* fixed current leakage (?) */
+	if (state->config.output_mode != AF9033_TS_MODE_USB) {
+		/* enable parallel TS */
+		ret = af9033_write_reg_bits(state, LINK,
+			p_reg_top_hosta_mpeg_ser_mode,
+			reg_top_hosta_mpeg_ser_mode_pos,
+			reg_top_hosta_mpeg_ser_mode_len, 0);
+		if (ret)
+			goto error;
+
+		ret = af9033_write_reg_bits(state, LINK,
+			p_reg_top_hosta_mpeg_par_mode,
+			reg_top_hosta_mpeg_par_mode_pos,
+			reg_top_hosta_mpeg_par_mode_len, 1);
+	}
+
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+#ifdef V4L2_ONLY_DVB_V5
+static int af9033_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *params = &fe->dtv_property_cache;
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 tmp;
+	deb_info("%s: freq:%d bw:%d\n", __func__, params->frequency,
+		params->bandwidth_hz);
+
+	state->frequency = params->frequency;
+
+	/* program tuner */
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+
+	/* program CFOE coefficients */
+	ret = af9033_set_coeff(state, params->bandwidth_hz);
+	if (ret)
+		goto error;
+
+	/* program frequency control */
+	ret = af9033_set_freq_ctrl(state);
+	if (ret)
+		goto error;
+
+	/* program bandwidth */
+	switch (params->bandwidth_hz) {
+	case 6000000:
+		tmp = 0;
+		break;
+	case 7000000:
+		tmp = 1;
+		break;
+	case 8000000:
+		tmp = 2;
+		break;
+#if 0 /* keep */
+	case 5000000:
+		tmp = 3;
+		break;
+#endif
+	default:
+		deb_info("%s: invalid bandwidth\n", __func__);
+		return -EINVAL;
+	}
+	ret = af9033_write_reg_bits(state, OFDM, g_reg_bw, reg_bw_pos,
+		reg_bw_len, tmp);
+	if (ret)
+		goto error;
+
+	/* clear easy mode flag */
+	ret = af9033_write_reg(state, OFDM, api_Training_Mode, 0x00);
+	if (ret)
+		goto error;
+
+	/* clear empty channel flag */
+	ret = af9033_write_reg(state, OFDM, api_empty_channel_status, 0x00);
+	if (ret)
+		goto error;
+
+	/* clear MPEG2 lock flag */
+	ret = af9033_write_reg_bits(state, OFDM, r_mp2if_sync_byte_locked,
+		mp2if_sync_byte_locked_pos, mp2if_sync_byte_locked_len, 0x00);
+	if (ret)
+		goto error;
+
+	/* set frequency band
+	    174 -  230 MHz VHF     band = 0x00
+	    350 -  900 MHz UHF     band = 0x01
+	   1670 - 1680 MHz L-BAND  band = 0x02
+	   otherwise               band = 0xff */
+	/* TODO: are both min/max ranges really required... */
+	if ((state->frequency >= 174000000) && (state->frequency <= 230000000))
+		tmp = 0x00; /* VHF */
+	else if ((state->frequency >= 350000000) && (state->frequency <= 900000000))
+		tmp = 0x01; /* UHF */
+	else if ((state->frequency >= 1670000000) && (state->frequency <= 1680000000))
+		tmp = 0x02; /* L-BAND */
+	else
+		tmp = 0xff;
+
+	ret = af9033_write_reg(state, OFDM, api_FreBand, tmp);
+	if (ret)
+		goto error;
+
+	/* trigger ofsm */
+	ret = af9033_write_reg(state, OFDM, api_trigger_ofsm, 0);
+	if (ret)
+		goto error;
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+#else
+static int af9033_set_frontend(struct dvb_frontend *fe,
+	struct dvb_frontend_parameters *params)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 tmp;
+	deb_info("%s: freq:%d bw:%d\n", __func__, params->frequency,
+		params->u.ofdm.bandwidth);
+
+	state->frequency = params->frequency;
+
+	/* program tuner */
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe, params);
+
+	/* program CFOE coefficients */
+	ret = af9033_set_coeff(state, params->u.ofdm.bandwidth);
+	if (ret)
+		goto error;
+
+	/* program frequency control */
+	ret = af9033_set_freq_ctrl(state);
+	if (ret)
+		goto error;
+
+	/* program bandwidth */
+	switch (params->u.ofdm.bandwidth) {
+	case BANDWIDTH_6_MHZ:
+		tmp = 0;
+		break;
+	case BANDWIDTH_7_MHZ:
+		tmp = 1;
+		break;
+	case BANDWIDTH_8_MHZ:
+		tmp = 2;
+		break;
+#if 0 /* keep */
+	case BANDWIDTH_5_MHZ:
+		tmp = 3;
+		break;
+#endif
+	default:
+		deb_info("%s: invalid bandwidth\n", __func__);
+		return -EINVAL;
+	}
+	ret = af9033_write_reg_bits(state, OFDM, g_reg_bw, reg_bw_pos,
+		reg_bw_len, tmp);
+	if (ret)
+		goto error;
+
+	/* clear easy mode flag */
+	ret = af9033_write_reg(state, OFDM, api_Training_Mode, 0x00);
+	if (ret)
+		goto error;
+
+	/* clear empty channel flag */
+	ret = af9033_write_reg(state, OFDM, api_empty_channel_status, 0x00);
+	if (ret)
+		goto error;
+
+	/* clear MPEG2 lock flag */
+	ret = af9033_write_reg_bits(state, OFDM, r_mp2if_sync_byte_locked,
+		mp2if_sync_byte_locked_pos, mp2if_sync_byte_locked_len, 0x00);
+	if (ret)
+		goto error;
+
+	/* set frequency band
+	    174 -  230 MHz VHF     band = 0x00
+	    350 -  900 MHz UHF     band = 0x01
+	   1670 - 1680 MHz L-BAND  band = 0x02
+	   otherwise               band = 0xff */
+	/* TODO: are both min/max ranges really required... */
+	if ((state->frequency >= 174000000) && (state->frequency <= 230000000))
+		tmp = 0x00; /* VHF */
+	else if ((state->frequency >= 350000000) && (state->frequency <= 900000000))
+		tmp = 0x01; /* UHF */
+	else if ((state->frequency >= 1670000000) && (state->frequency <= 1680000000))
+		tmp = 0x02; /* L-BAND */
+	else
+		tmp = 0xff;
+
+	ret = af9033_write_reg(state, OFDM, api_FreBand, tmp);
+	if (ret)
+		goto error;
+
+	/* trigger ofsm */
+	ret = af9033_write_reg(state, OFDM, api_trigger_ofsm, 0);
+	if (ret)
+		goto error;
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+#endif
+
+static int af9033_get_tune_settings(struct dvb_frontend *fe,
+	struct dvb_frontend_tune_settings *fesettings)
+{
+	fesettings->min_delay_ms = 800;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+
+	return 0;
+}
+
+#ifdef V4L2_ONLY_DVB_V5
+static int af9033_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf[8];
+	deb_info("%s\n", __func__);
+#define TRANSMISSION_MODE  (g_reg_tpsd_txmod - g_reg_tpsd_txmod)
+#define GUARD_INTERVAL     (g_reg_tpsd_gi    - g_reg_tpsd_txmod)
+#define HIERARCHY          (g_reg_tpsd_hier  - g_reg_tpsd_txmod)
+#define CONSTELLATION      (g_reg_tpsd_const - g_reg_tpsd_txmod)
+#define BANDWIDTH          (g_reg_bw         - g_reg_tpsd_txmod)
+#define PRIORITY           (g_reg_dec_pri    - g_reg_tpsd_txmod)
+#define CODE_RATE_HP       (g_reg_tpsd_hpcr  - g_reg_tpsd_txmod)
+#define CODE_RATE_LP       (g_reg_tpsd_lpcr  - g_reg_tpsd_txmod)
+
+	/* read all needed registers */
+	ret = af9033_read_regs(state, OFDM, g_reg_tpsd_txmod, buf, sizeof(buf));
+	if (ret)
+		goto error;
+
+	deb_info("%s: ", __func__);
+	debug_dump(buf, sizeof(buf), deb_info);
+
+	switch ((buf[CONSTELLATION] >> 0) & 3) {
+	case 0:
+		p->modulation = QPSK;
+		break;
+	case 1:
+		p->modulation = QAM_16;
+		break;
+	case 2:
+		p->modulation = QAM_64;
+		break;
+	}
+
+	switch ((buf[TRANSMISSION_MODE] >> 0) & 3) {
+	case 0:
+		p->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+#if 0 /* keep */
+	case 2:
+		p->transmission_mode = TRANSMISSION_MODE_4K;
+		break;
+#endif
+	}
+
+	switch ((buf[GUARD_INTERVAL] >> 0) & 3) {
+	case 0:
+		p->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+
+	switch ((buf[HIERARCHY] >> 0) & 7) {
+	case 0:
+		p->hierarchy = HIERARCHY_NONE;
+		break;
+	case 1:
+		p->hierarchy = HIERARCHY_1;
+		break;
+	case 2:
+		p->hierarchy = HIERARCHY_2;
+		break;
+	case 3:
+		p->hierarchy = HIERARCHY_4;
+		break;
+	}
+
+	switch ((buf[CODE_RATE_HP] >> 0) & 7) {
+	case 0:
+		p->code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_HP = FEC_7_8;
+		break;
+	case 5:
+		p->code_rate_HP = FEC_NONE;
+		break;
+	}
+
+	switch ((buf[CODE_RATE_LP] >> 0) & 7) {
+	case 0:
+		p->code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_LP = FEC_7_8;
+		break;
+	case 5:
+		p->code_rate_LP = FEC_NONE;
+		break;
+	}
+
+	switch ((buf[BANDWIDTH] >> 0) & 3) {
+	case 0:
+		p->bandwidth_hz = 6000000;
+		break;
+	case 1:
+		p->bandwidth_hz = 7000000;
+		break;
+	case 2:
+		p->bandwidth_hz = 8000000;
+		break;
+#if 0 /* keep */
+	case 3:
+		p->bandwidth_hz = 5000000;
+		break;
+#endif
+	}
+
+	p->inversion = INVERSION_AUTO;
+	p->frequency = state->frequency;
+
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+#else
+static int af9033_get_frontend(struct dvb_frontend *fe,
+	struct dvb_frontend_parameters *p)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf[8];
+	deb_info("%s\n", __func__);
+#define TRANSMISSION_MODE  (g_reg_tpsd_txmod - g_reg_tpsd_txmod)
+#define GUARD_INTERVAL     (g_reg_tpsd_gi    - g_reg_tpsd_txmod)
+#define HIERARCHY          (g_reg_tpsd_hier  - g_reg_tpsd_txmod)
+#define CONSTELLATION      (g_reg_tpsd_const - g_reg_tpsd_txmod)
+#define BANDWIDTH          (g_reg_bw         - g_reg_tpsd_txmod)
+#define PRIORITY           (g_reg_dec_pri    - g_reg_tpsd_txmod)
+#define CODE_RATE_HP       (g_reg_tpsd_hpcr  - g_reg_tpsd_txmod)
+#define CODE_RATE_LP       (g_reg_tpsd_lpcr  - g_reg_tpsd_txmod)
+
+	/* read all needed registers */
+	ret = af9033_read_regs(state, OFDM, g_reg_tpsd_txmod, buf, sizeof(buf));
+	if (ret)
+		goto error;
+
+	deb_info("%s: ", __func__);
+	debug_dump(buf, sizeof(buf), deb_info);
+
+	switch ((buf[CONSTELLATION] >> 0) & 3) {
+	case 0:
+		p->u.ofdm.constellation = QPSK;
+		break;
+	case 1:
+		p->u.ofdm.constellation = QAM_16;
+		break;
+	case 2:
+		p->u.ofdm.constellation = QAM_64;
+		break;
+	}
+
+	switch ((buf[TRANSMISSION_MODE] >> 0) & 3) {
+	case 0:
+		p->u.ofdm.transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->u.ofdm.transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+#if 0 /* keep */
+	case 2:
+		p->u.ofdm.transmission_mode = TRANSMISSION_MODE_4K;
+		break;
+#endif
+	}
+
+	switch ((buf[GUARD_INTERVAL] >> 0) & 3) {
+	case 0:
+		p->u.ofdm.guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->u.ofdm.guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->u.ofdm.guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->u.ofdm.guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+
+	switch ((buf[HIERARCHY] >> 0) & 7) {
+	case 0:
+		p->u.ofdm.hierarchy_information = HIERARCHY_NONE;
+		break;
+	case 1:
+		p->u.ofdm.hierarchy_information = HIERARCHY_1;
+		break;
+	case 2:
+		p->u.ofdm.hierarchy_information = HIERARCHY_2;
+		break;
+	case 3:
+		p->u.ofdm.hierarchy_information = HIERARCHY_4;
+		break;
+	}
+
+	switch ((buf[CODE_RATE_HP] >> 0) & 7) {
+	case 0:
+		p->u.ofdm.code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		p->u.ofdm.code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		p->u.ofdm.code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		p->u.ofdm.code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		p->u.ofdm.code_rate_HP = FEC_7_8;
+		break;
+	case 5:
+		p->u.ofdm.code_rate_HP = FEC_NONE;
+		break;
+	}
+
+	switch ((buf[CODE_RATE_LP] >> 0) & 7) {
+	case 0:
+		p->u.ofdm.code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		p->u.ofdm.code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		p->u.ofdm.code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		p->u.ofdm.code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		p->u.ofdm.code_rate_LP = FEC_7_8;
+		break;
+	case 5:
+		p->u.ofdm.code_rate_HP = FEC_NONE;
+		break;
+	}
+
+	switch ((buf[BANDWIDTH] >> 0) & 3) {
+	case 0:
+		p->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
+		break;
+	case 1:
+		p->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
+		break;
+	case 2:
+		p->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
+		break;
+#if 0 /* keep */
+	case 3:
+		p->u.ofdm.bandwidth = BANDWIDTH_5_MHZ;
+		break;
+#endif
+	}
+
+	p->inversion = INVERSION_AUTO;
+	p->frequency = state->frequency;
+
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+#endif
+
+static int af9033_update_ber_ucblocks(struct dvb_frontend *fe)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf[3];
+	u32 error_bit_count = 0;
+	u32 total_bit_count = 0;
+	u16 abort_packet_count = 0;
+
+	/* don't update ber / ucblocks unnecessary often */
+	if (time_before(jiffies, state->next_statistics_check))
+		return 0;
+
+	/* set minimum ber / ucblocks update interval */
+	state->next_statistics_check = jiffies + msecs_to_jiffies(500);
+
+	state->ber = 0;
+
+	/* no need to check ber / ucblocks in case of no lock */
+	ret = af9033_read_reg_bits(state, OFDM,
+		r_mp2if_sync_byte_locked, mp2if_sync_byte_locked_pos,
+		mp2if_sync_byte_locked_len, buf);
+	if (ret)
+		goto error;
+	if (!buf[0])
+		goto exit;
+
+	/* get abort packet count */
+	ret = af9033_read_regs(state, OFDM, api_rsd_abort_packet_cnt_7_0, buf,
+		sizeof(buf) - 1);
+	if (ret)
+		goto error;
+
+	abort_packet_count = (buf[1] << 8) + buf[0];
+
+	/* get error bit count */
+	ret = af9033_read_regs(state, OFDM, api_rsd_bit_err_cnt_7_0, buf,
+		sizeof(buf));
+	if (ret)
+		goto error;
+
+	error_bit_count = (buf[2] << 16) + (buf[1] << 8) + buf[0];
+	error_bit_count = error_bit_count - abort_packet_count * 8 * 8;
+
+	/* get used RSD counting period (it is 10000 by defaut) */
+	ret = af9033_read_regs(state, OFDM, api_r_rsd_packet_unit_7_0, buf,
+		sizeof(buf) - 1);
+	if (ret)
+		goto error;
+
+	total_bit_count = (buf[1] << 8) + buf[0];
+	total_bit_count = total_bit_count - abort_packet_count;
+	total_bit_count = total_bit_count * 204 * 8;
+
+	if (total_bit_count)
+		state->ber = error_bit_count * 1000000000 / total_bit_count;
+
+	state->ucblocks += abort_packet_count;
+
+	deb_info("%s: err bits:%d total bits:%d abort count:%d\n", __func__,
+		error_bit_count, total_bit_count, abort_packet_count);
+
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+exit:
+	return ret;
+}
+
+static int af9033_update_snr(struct dvb_frontend *fe)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf[3], i, len;
+	u32 snr_val;
+	struct snr_table *uninitialized_var(snr_table);
+
+	/* read snr registers */
+	ret = af9033_read_regs(state, OFDM, api_qnt_vbc_err_7_0, buf,
+		sizeof(buf));
+	if (ret)
+		goto error;
+	snr_val = (buf[2] << 16) + (buf[1] << 8) + buf[0];
+
+	/* read current constellation */
+	ret = af9033_read_reg_bits(state, OFDM, g_reg_tpsd_const,
+		reg_tpsd_const_pos, reg_tpsd_const_len, &buf[0]);
+	if (ret)
+		goto error;
+
+	switch (buf[0]) {
+	case 0:
+		len = ARRAY_SIZE(qpsk_snr_table);
+		snr_table = qpsk_snr_table;
+		break;
+	case 1:
+		len = ARRAY_SIZE(qam16_snr_table);
+		snr_table = qam16_snr_table;
+		break;
+	case 2:
+		len = ARRAY_SIZE(qam64_snr_table);
+		snr_table = qam64_snr_table;
+		break;
+	default:
+		len = 0;
+	}
+
+	/* get snr from lookup table */
+	for (i = 0; i < len; i++) {
+		if (snr_val < snr_table[i].val) {
+			state->snr = snr_table[i].snr * 10;
+			break;
+		}
+	}
+	deb_info("%s: snr_val:%x snr:%x\n", __func__, snr_val, state->snr);
+
+	if (len && !af9033_snrdb)
+		state->snr = (0xffff / (snr_table[len - 1].snr * 10)) * state->snr;
+
+error:
+	return ret;
+}
+
+static int af9033_update_signal_strength(struct dvb_frontend *fe)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	u8 strength;
+
+	/* read signal strength from 0-100 scale */
+	ret = af9033_read_reg(state, OFDM, api_signal_strength, &strength);
+	if (ret)
+		goto error;
+
+	/* scale value to 0x0000-0xffff */
+	state->signal_strength = strength * 0xffff / 100;
+
+error:
+	return ret;
+}
+
+static int af9033_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u8 tmp;
+	*status = 0;
+
+	/* empty channel; 0:no result, 1:signal, 2:empty */
+	ret = af9033_read_reg(state, OFDM, api_empty_channel_status, &tmp);
+	if (ret)
+		goto error;
+	if (tmp == 0x01) /* have signal */
+		*status |= FE_HAS_SIGNAL;
+
+	if (tmp != 0x02) {
+		/* TPS lock */
+		ret = af9033_read_reg_bits(state, OFDM, p_fd_tpsd_lock,
+			fd_tpsd_lock_pos, fd_tpsd_lock_len, &tmp);
+		if (ret)
+			goto error;
+		if (tmp)
+			*status |= FE_HAS_VITERBI | FE_HAS_CARRIER;
+
+		/* MPEG2 lock */
+		ret = af9033_read_reg_bits(state, OFDM,
+			r_mp2if_sync_byte_locked, mp2if_sync_byte_locked_pos,
+			mp2if_sync_byte_locked_len, &tmp);
+		if (ret)
+			goto error;
+		if (tmp)
+			*status |= FE_HAS_SYNC | FE_HAS_LOCK;
+	}
+
+	/* update ber / ucblocks */
+	ret = af9033_update_ber_ucblocks(fe);
+
+error:
+	if (ret)
+		deb_info("%s: failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int af9033_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	deb_info("%s\n", __func__);
+	ret = af9033_update_ber_ucblocks(fe);
+	*ber = state->ber;
+	return ret;
+}
+
+static int af9033_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	deb_info("%s\n", __func__);
+	ret = af9033_update_signal_strength(fe);
+	if (ret)
+		goto error;
+	ret = af9033_update_ber_ucblocks(fe);
+	*strength = state->signal_strength;
+error:
+	return ret;
+}
+
+static int af9033_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	deb_info("%s\n", __func__);
+	ret = af9033_update_snr(fe);
+	if (ret)
+		goto error;
+	ret = af9033_update_ber_ucblocks(fe);
+	*snr = state->snr;
+error:
+	return ret;
+}
+
+static int af9033_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	int ret;
+	deb_info("%s\n", __func__);
+	ret = af9033_update_ber_ucblocks(fe);
+	*ucblocks = state->ucblocks;
+	return ret;
+}
+
+static int af9033_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct af9033_state *state = fe->demodulator_priv;
+	deb_info("%s: enable:%d\n", __func__, enable);
+
+	return af9033_write_reg_bits(state, LINK, p_reg_bypass_host2tuner,
+		reg_bypass_host2tuner_pos, reg_bypass_host2tuner_len, enable);
+}
+
+static struct dvb_frontend_ops af9033_ops;
+
+struct dvb_frontend *af9033_attach(const struct af9033_config *config,
+	struct i2c_adapter *i2c)
+{
+	int ret;
+	struct af9033_state *state = NULL;
+	u8 buf[8];
+	deb_info("%s:\n", __func__);
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct af9033_state), GFP_KERNEL);
+	if (state == NULL)
+		goto error;
+
+	/* setup the state */
+	state->i2c = i2c;
+	memcpy(&state->config, config, sizeof(struct af9033_config));
+
+	/* firmware version */
+	ret = af9033_read_regs(state, LINK, 0x83e9, &buf[0], sizeof(buf) / 2);
+	if (ret)
+		goto error;
+
+	ret = af9033_read_regs(state, OFDM, 0x4191, &buf[4], sizeof(buf) / 2);
+	if (ret)
+		goto error;
+
+	info("firmware version: LINK:%d.%d.%d.%d OFDM:%d.%d.%d.%d",
+		buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+
+	/* settings for mp2if */
+	if (state->config.output_mode == AF9033_TS_MODE_USB) {
+		/* split 15 PSB to 1K + 1K and enable flow control */
+		ret = af9033_write_reg_bits(state, OFDM, p_reg_mp2if2_half_psb,
+			reg_mp2if2_half_psb_pos, reg_mp2if2_half_psb_len, 0);
+		if (ret)
+			goto error;
+		ret = af9033_write_reg_bits(state, OFDM, p_reg_mp2if_stop_en,
+			reg_mp2if_stop_en_pos, reg_mp2if_stop_en_len, 1);
+	} else {
+		/* AF9033 set mpeg to full speed */
+		ret = af9033_write_reg_bits(state, OFDM, p_reg_mpeg_full_speed,
+			reg_mpeg_full_speed_pos, reg_mpeg_full_speed_len, 0);
+		if (ret)
+			goto error;
+		ret = af9033_write_reg_bits(state, OFDM, p_reg_mp2if_stop_en,
+			reg_mp2if_stop_en_pos, reg_mp2if_stop_en_len, 0);
+	}
+	if (ret)
+		goto error;
+
+	/* set to 0 as open drain for tuner i2c */
+	ret = af9033_write_reg(state, LINK, p_reg_top_padodpu, 0);
+	if (ret)
+		goto error;
+
+	/* set to 0 as push pull for tuner AGC */
+	ret = af9033_write_reg(state, LINK, p_reg_top_agc_od, 0);
+	if (ret)
+		goto error;
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops, &af9033_ops,
+		sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	return &state->frontend;
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(af9033_attach);
+
+static struct dvb_frontend_ops af9033_ops = {
+#ifdef V4L2_ONLY_DVB_V5
+	.delsys = { SYS_DVBT },
+#endif
+	.info = {
+		.name = "Afatech AF9033 DVB-T",
+#ifndef V4L2_ONLY_DVB_V5
+		.type = FE_OFDM,
+#endif
+		.frequency_min =  44250000,
+		.frequency_max = 867250000,
+		.frequency_stepsize = 62500,
+		.frequency_tolerance = 0,
+		.caps =
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS
+	},
+
+	.release = af9033_release,
+
+	.init = af9033_init,
+	.sleep = af9033_sleep,
+
+	.set_frontend = af9033_set_frontend,
+	.get_tune_settings = af9033_get_tune_settings,
+
+	.get_frontend = af9033_get_frontend,
+
+	.read_status = af9033_read_status,
+	.read_ber = af9033_read_ber,
+	.read_signal_strength = af9033_read_signal_strength,
+	.read_snr = af9033_read_snr,
+	.read_ucblocks = af9033_read_ucblocks,
+
+	.i2c_gate_ctrl = af9033_i2c_gate_ctrl,
+};
+
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_DESCRIPTION("Afatech AF9033 DVB-T demodulator driver");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/af9033.h media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033.h
--- media_build_experimental//linux/drivers/media/dvb/frontends/af9033.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033.h	2012-02-27 00:02:38.168915017 +0100
@@ -0,0 +1,100 @@
+/*
+ * Afatech AF9033 demodulator driver
+ *
+ * Copyright (C) 2008 Afatech
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Thanks to TerraTec for a support received.
+ */
+
+#ifndef AF9033_H
+#define AF9033_H
+
+#include <linux/dvb/frontend.h>
+
+enum af9033_ts_mode {
+	AF9033_TS_MODE_PARALLEL,
+	AF9033_TS_MODE_SERIAL,
+	AF9033_TS_MODE_USB, /* only for AF9035 */
+};
+
+enum af9033_tuner {
+	AF9033_TUNER_TUA9001    = 0x27, /* Infineon TUA 9001 */
+	AF9033_TUNER_FC0011     = 0x28, /* Fitipower FC0011 */
+	AF9033_TUNER_MXL5007t   = 0xa0, /* Maxlinear MXL5007t */
+        AF9033_TUNER_TDA18218   = 0xa1, /* NXP TDA 18218HN */
+};
+
+/* clock setting table:
+ =================================
+ adc_clock  crystal_clock  Xtal
+ =================================
+ 20480000   20480000      FPGA
+ 16384000   20480000      16.38MHz
+ 20480000   20480000      20.48MHz
+ 36000000   20250000      36.00MHz
+ 30000000   20156250      30.00MHz
+ 26000000   20583333      26.00MHz
+ 28000000   20416667      28.00MHz
+ 32000000   20500000      32.00MHz
+ 34000000   20187500      34.00MHz
+ 24000000   20500000      24.00MHz
+ 22000000   20625000      22.00MHz
+ 12000000   20250000      12.00MHz
+*/
+
+struct af9033_config {
+	/* demodulator's I2C address */
+	u8 demod_address;
+
+	u8 tuner_address;
+
+	/* xtal clock Hz */
+	u32 crystal_clock;
+
+	/* ADC clock Hz */
+	u32 adc_clock;
+
+	/* tuner ID */
+	u8 tuner;
+
+	/* intermediate frequency Hz */
+	u32 if_freq;
+
+	/* TS data output mode */
+	u8 output_mode:2;
+
+	/* RF spectrum inversion */
+	u8 rf_spec_inv:1;
+};
+
+
+#if defined(CONFIG_DVB_AF9033) || \
+	(defined(CONFIG_DVB_AF9033_MODULE) && defined(MODULE))
+extern struct dvb_frontend *af9033_attach(const struct af9033_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *af9033_attach(
+const struct af9033_config *config, struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_AF9033 */
+
+#endif /* AF9033_H */
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/af9033_priv.h media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033_priv.h
--- media_build_experimental//linux/drivers/media/dvb/frontends/af9033_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033_priv.h	2012-02-27 00:02:38.018915017 +0100
@@ -0,0 +1,383 @@
+/*
+ * Afatech AF9033 demodulator driver
+ *
+ * Copyright (C) 2008 Afatech
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Thanks to TerraTec for a support received.
+ */
+
+#ifndef AF9033_PRIV_H
+#define AF9033_PRIV_H
+
+#define LOG_PREFIX "af9033"
+
+#define dprintk(var, level, args...) \
+	    do { if ((var & level)) printk(args); } while (0)
+
+#define debug_dump(b, l, func) {\
+	int loop_; \
+	for (loop_ = 0; loop_ < l; loop_++) \
+		func("%02x ", b[loop_]); \
+	func("\n");\
+}
+
+#define deb_info(args...) dprintk(af9033_debug, 0x01, args)
+
+#undef err
+#define err(f, arg...)  printk(KERN_ERR     LOG_PREFIX": " f "\n" , ## arg)
+#undef info
+#define info(f, arg...) printk(KERN_INFO    LOG_PREFIX": " f "\n" , ## arg)
+#undef warn
+#define warn(f, arg...) printk(KERN_WARNING LOG_PREFIX": " f "\n" , ## arg)
+
+#define LINK 0x00
+#define OFDM 0x80
+
+struct regdesc {
+	u16 addr;
+	u8  val;
+};
+
+struct snr_table {
+	u32 val;
+	u8 snr;
+};
+
+/* QPSK SNR lookup table */
+static struct snr_table qpsk_snr_table[] = {
+	{0x000b4771,  0},
+	{0x000c1aed,  1},
+	{0x000d0d27,  2},
+	{0x000e4d19,  3},
+	{0x000e5da8,  4},
+	{0x00107097,  5},
+	{0x00116975,  6},
+	{0x001252d9,  7},
+	{0x00131fa4,  8},
+	{0x0013d5e1,  9},
+	{0x00148e53, 10},
+	{0x0015358b, 11},
+	{0x0015dd29, 12},
+	{0x00168112, 13},
+	{0x00170b61, 14},
+	{0x0017a532, 15},
+	{0x00180f94, 16},
+	{0x00186ed2, 17},
+	{0x0018b271, 18},
+	{0x0018e118, 19},
+	{0x0018ff4b, 20},
+	{0x00190af1, 21},
+	{0x00191451, 22},
+	{0xffffffff, 23},
+};
+
+/* QAM16 SNR lookup table */
+static struct snr_table qam16_snr_table[] = {
+	{0x0004f0d5,  0},
+	{0x0005387a,  1},
+	{0x000573a4,  2},
+	{0x0005a99e,  3},
+	{0x0005cc80,  4},
+	{0x0005eb62,  5},
+	{0x0005fecf,  6},
+	{0x00060b80,  7},
+	{0x00062501,  8},
+	{0x00064865,  9},
+	{0x00069604, 10},
+	{0x0006f356, 11},
+	{0x0007706a, 12},
+	{0x000804d3, 13},
+	{0x00089d1a, 14},
+	{0x00093e3d, 15},
+	{0x0009e35d, 16},
+	{0x000a7c3c, 17},
+	{0x000afaf8, 18},
+	{0x000b719d, 19},
+	{0x000bda6a, 20},
+	{0x000c0c75, 21},
+	{0x000c3f7d, 22},
+	{0x000c5e62, 23},
+	{0x000c6c31, 24},
+	{0x000c7925, 25},
+	{0xffffffff, 26},
+};
+
+/* QAM64 SNR lookup table */
+static struct snr_table qam64_snr_table[] = {
+	{0x000256d0,  0},
+	{0x00027a65,  1},
+	{0x00029873,  2},
+	{0x0002b7fe,  3},
+	{0x0002cf1e,  4},
+	{0x0002e234,  5},
+	{0x0002f409,  6},
+	{0x00030046,  7},
+	{0x00030844,  8},
+	{0x00030a02,  9},
+	{0x00030cde, 10},
+	{0x00031031, 11},
+	{0x0003144c, 12},
+	{0x000315dd, 13},
+	{0x00031920, 14},
+	{0x000322d0, 15},
+	{0x000339fc, 16},
+	{0x000364a1, 17},
+	{0x00038bcc, 18},
+	{0x0003c7d3, 19},
+	{0x000408cc, 20},
+	{0x00043bed, 21},
+	{0x00048061, 22},
+	{0x0004be95, 23},
+	{0x0004fa7d, 24},
+	{0x00052405, 25},
+	{0x0005570d, 26},
+	{0x00059feb, 27},
+	{0x0005bf38, 28},
+	{0xffffffff, 29},
+};
+
+static struct regdesc ofsm_init[] = {
+	{0x0051, 0x01},
+	{0x0070, 0x0A},
+	{0x007E, 0x04},
+	{0x0081, 0x0A},
+	{0x008A, 0x01},
+	{0x008E, 0x01},
+	{0x0092, 0x06},
+	{0x0099, 0x01},
+	{0x009F, 0xE1},
+	{0x00A0, 0xCF},
+	{0x00A3, 0x01},
+	{0x00A5, 0x01},
+	{0x00A6, 0x01},
+	{0x00A9, 0x00},
+	{0x00AA, 0x01},
+	{0x00AB, 0x01},
+	{0x00B0, 0x01},
+	{0x00C0, 0x05},
+	{0x00C4, 0x19},
+	{0xF000, 0x0F},
+	{0xF016, 0x10},
+	{0xF017, 0x04},
+	{0xF018, 0x05},
+	{0xF019, 0x04},
+	{0xF01A, 0x05},
+	{0xF021, 0x03},
+	{0xF022, 0x0A},
+	{0xF023, 0x0A},
+	{0xF02B, 0x00},
+	{0xF02C, 0x01},
+	{0xF064, 0x03},
+	{0xF065, 0xF9},
+	{0xF066, 0x03},
+	{0xF067, 0x01},
+	{0xF06F, 0xE0},
+	{0xF070, 0x03},
+	{0xF072, 0x0F},
+	{0xF073, 0x03},
+	{0xF078, 0x00},
+	{0xF087, 0x00},
+	{0xF09B, 0x3F},
+	{0xF09C, 0x00},
+	{0xF09D, 0x20},
+	{0xF09E, 0x00},
+	{0xF09F, 0x0C},
+	{0xF0A0, 0x00},
+	{0xF130, 0x04},
+	{0xF132, 0x04},
+	{0xF144, 0x1A},
+	{0xF146, 0x00},
+	{0xF14A, 0x01},
+	{0xF14C, 0x00},
+	{0xF14D, 0x00},
+	{0xF14F, 0x04},
+	{0xF158, 0x7F},
+	{0xF15A, 0x00},
+	{0xF15B, 0x08},
+	{0xF15D, 0x03},
+	{0xF15E, 0x05},
+	{0xF163, 0x05},
+	{0xF166, 0x01},
+	{0xF167, 0x40},
+	{0xF168, 0x0F},
+	{0xF17A, 0x00},
+	{0xF17B, 0x00},
+	{0xF183, 0x01},
+	{0xF19D, 0x40},
+	{0xF1BC, 0x36},
+	{0xF1BD, 0x00},
+	{0xF1CB, 0xA0},
+	{0xF1CC, 0x01},
+	{0xF204, 0x10},
+	{0xF214, 0x00},
+	{0xF40E, 0x0A},
+	{0xF40F, 0x40},
+	{0xF410, 0x08},
+	{0xF55F, 0x0A},
+	{0xF561, 0x15},
+	{0xF562, 0x20},
+	{0xF5DF, 0xFB},
+	{0xF5E0, 0x00},
+	{0xF5E3, 0x09},
+	{0xF5E4, 0x01},
+	{0xF5E5, 0x01},
+	{0xF5F8, 0x01},
+	{0xF5FD, 0x01},
+	{0xF600, 0x05},
+	{0xF601, 0x08},
+	{0xF602, 0x0B},
+	{0xF603, 0x0E},
+	{0xF604, 0x11},
+	{0xF605, 0x14},
+	{0xF606, 0x17},
+	{0xF607, 0x1F},
+	{0xF60E, 0x00},
+	{0xF60F, 0x04},
+	{0xF610, 0x32},
+	{0xF611, 0x10},
+	{0xF707, 0xFC},
+	{0xF708, 0x00},
+	{0xF709, 0x37},
+	{0xF70A, 0x00},
+	{0xF78B, 0x01},
+	{0xF80F, 0x40},
+	{0xF810, 0x54},
+	{0xF811, 0x5A},
+	{0xF905, 0x01},
+	{0xFB06, 0x03},
+	{0xFD8B, 0x00}
+};
+
+/* Infineon TUA 9001 tuner init
+   AF9033_TUNER_TUA9001    = 0x27 */
+static struct regdesc tuner_init_tua9001[] = {
+	{0x0046, 0x27},
+	{0x0057, 0x00},
+	{0x0058, 0x01},
+	{0x005f, 0x00},
+	{0x0060, 0x00},
+	{0x006d, 0x00},
+	{0x0071, 0x05},
+	{0x0072, 0x02},
+	{0x0074, 0x01},
+	{0x0075, 0x03},
+	{0x0076, 0x02},
+	{0x0077, 0x00},
+	{0x0078, 0x01},
+	{0x0079, 0x00},
+	{0x007a, 0x7E},
+	{0x007b, 0x3E},
+	{0x0093, 0x00},
+	{0x0094, 0x01},
+	{0x0095, 0x02},
+	{0x0096, 0x01},
+	{0x0098, 0x0A},
+	{0x009b, 0x05},
+	{0x009c, 0x80},
+	{0x00b3, 0x00},
+	{0x00c1, 0x01},
+	{0x00c2, 0x00},
+	{0xF007, 0x00},
+	{0xF01F, 0x82},
+	{0xF020, 0x00},
+	{0xF029, 0x82},
+	{0xF02A, 0x00},
+	{0xF047, 0x00},
+	{0xF054, 0x00},
+	{0xF055, 0x00},
+	{0xF077, 0x01},
+	{0xF1E6, 0x00},
+};
+
+/* NXP TDA18218 tuner init
+   AF9033_TUNER_TDA18218   = 161 */
+static struct regdesc tuner_init_tda18218[] = {
+        {0x0046, 0x27},
+        {0x0071, 0x05},
+        {0x0072, 0x02},
+        {0x0074, 0x01},
+        {0x0075, 0x03},
+        {0x0076, 0x02},
+        {0x0077, 0x00},
+        {0x0078, 0x01},
+        {0x007a, 0x7e},
+        {0x007b, 0x3e},
+        {0x0098, 0x0a},
+        {0x00b3, 0x00},
+        {0xf007, 0x00},
+        {0xf01f, 0x82},
+        {0xf020, 0x00},
+        {0xf047, 0x00},
+        {0xf077, 0x01},
+        {0xf1e6, 0x00},
+        {0x0057, 0x00},
+        {0x0058, 0x01},
+        {0x005f, 0x00},
+        {0x0060, 0x00},
+        {0x006d, 0x00},
+        {0x0079, 0x00},
+        {0x0093, 0x00},
+        {0x0094, 0x01},
+        {0x0095, 0x02},
+        {0x0096, 0x01},
+        {0x009b, 0x05},
+        {0x009c, 0x80},
+        {0x00c1, 0x01},
+        {0x00c2, 0x00},
+        {0xf029, 0x82},
+        {0xf02a, 0x00},
+        {0xf054, 0x00},
+        {0xf055, 0x00},
+};
+
+static struct regdesc tuner_init_mxl5007t[] = {
+	{0x0046, 0x1b},
+	{0x0057, 0x01},
+	{0x0058, 0x01},
+	{0x005f, 0x00},
+	{0x0060, 0x00},
+	{0x0068, 0x96},
+	{0x0071, 0x05},
+	{0x0072, 0x02},
+	{0x0074, 0x01},
+	{0x0079, 0x01},
+	{0x0093, 0x00},
+	{0x0094, 0x00},
+	{0x0095, 0x00},
+	{0x0096, 0x00},
+	{0x00b3, 0x01},
+	{0x00c1, 0x01},
+	{0x00c2, 0x00},
+	{0xF007, 0x00},
+	{0xF00C, 0x19},
+	{0xF00D, 0x1a},
+	{0xF012, 0xda},
+	{0xF013, 0x00},
+	{0xF014, 0x00},
+	{0xF015, 0x02},
+	{0xF01F, 0x82},
+	{0xF020, 0x00},
+	{0xF029, 0x82},
+	{0xF02A, 0x00},
+	{0xF077, 0x02},
+	{0xF1E6, 0x00},
+};
+
+#endif /* AF9033_PRIV_H */
+
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/af9033_reg.h media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033_reg.h
--- media_build_experimental//linux/drivers/media/dvb/frontends/af9033_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/af9033_reg.h	2012-02-27 00:02:38.328915017 +0100
@@ -0,0 +1,11006 @@
+/*
+ * Afatech AF9033 demodulator driver
+ *
+ * Copyright (C) 2008 Afatech
+ * Copyright (C) 2009 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Thanks to TerraTec for a support received.
+ */
+
+#ifndef AF9033_REG_H
+#define AF9033_REG_H
+
+/* these variables are initialized by API */
+#define api_var_addr_base                       0x418b
+#define api_log_addr_base                       0x418d
+#define api_log_data_base                       0x418f
+#define api_LowerLocalRetrain                   0x43bb
+
+#define api_trigger_ofsm                        0x0000
+#define api_cfoe_NS_2048_coeff1_25_24           0x0001
+#define api_cfoe_NS_2048_coeff1_23_16           0x0002
+#define api_cfoe_NS_2048_coeff1_15_8            0x0003
+#define api_cfoe_NS_2048_coeff1_7_0             0x0004
+#define api_cfoe_NS_2k_coeff2_24                0x0005
+#define api_cfoe_NS_2k_coeff2_23_16             0x0006
+#define api_cfoe_NS_2k_coeff2_15_8              0x0007
+#define api_cfoe_NS_2k_coeff2_7_0               0x0008
+#define api_cfoe_NS_8191_coeff1_25_24           0x0009
+#define api_cfoe_NS_8191_coeff1_23_16           0x000a
+#define api_cfoe_NS_8191_coeff1_15_8            0x000b
+#define api_cfoe_NS_8191_coeff1_7_0             0x000c
+#define api_cfoe_NS_8192_coeff1_25_24           0x000d
+#define api_cfoe_NS_8192_coeff1_23_16           0x000e
+#define api_cfoe_NS_8192_coeff1_15_8            0x000f
+#define api_cfoe_NS_8192_coeff1_7_0             0x0010
+#define api_cfoe_NS_8193_coeff1_25_24           0x0011
+#define api_cfoe_NS_8193_coeff1_23_16           0x0012
+#define api_cfoe_NS_8193_coeff1_15_8            0x0013
+#define api_cfoe_NS_8193_coeff1_7_0             0x0014
+#define api_cfoe_NS_8k_coeff2_24                0x0015
+#define api_cfoe_NS_8k_coeff2_23_16             0x0016
+#define api_cfoe_NS_8k_coeff2_15_8              0x0017
+#define api_cfoe_NS_8k_coeff2_7_0               0x0018
+#define api_cfoe_NS_4096_coeff1_25_24           0x0019
+#define api_cfoe_NS_4096_coeff1_23_16           0x001a
+#define api_cfoe_NS_4096_coeff1_15_8            0x001b
+#define api_cfoe_NS_4096_coeff1_7_0             0x001c
+#define api_cfoe_NS_4k_coeff2_24                0x001d
+#define api_cfoe_NS_4k_coeff2_23_16             0x001e
+#define api_cfoe_NS_4k_coeff2_15_8              0x001f
+#define api_cfoe_NS_4k_coeff2_7_0               0x0020
+
+#define api_bfsfcw_fftindex_ratio_7_0           0x0021
+#define api_bfsfcw_fftindex_ratio_15_8          0x0022
+#define api_fftindex_bfsfcw_ratio_7_0           0x0023
+#define api_fftindex_bfsfcw_ratio_15_8          0x0024
+
+#define api_crystal_clk_7_0                     0x0025
+#define api_crystal_clk_15_8                    0x0026
+#define api_crystal_clk_23_16                   0x0027
+#define api_crystal_clk_31_24                   0x0028
+
+#define api_bfs_fcw_7_0                         0x0029
+#define api_bfs_fcw_15_8                        0x002a
+#define api_bfs_fcw_22_16                       0x002b
+
+#define api_qnt_vbc_err_7_0                     0x002c
+#define api_qnt_vbc_err_15_8                    0x002d
+#define api_qnt_vbc_err_23_16                   0x002e
+#define api_r_qnt_vbc_sframe_num                0x002f
+#define api_tpsd_const                          0x0030
+#define api_tpsd_txmod                          0x0031
+ 
+#define api_rsd_abort_packet_cnt_7_0            0x0032
+#define api_rsd_abort_packet_cnt_15_8           0x0033
+#define api_rsd_bit_err_cnt_7_0                 0x0034
+#define api_rsd_bit_err_cnt_15_8                0x0035
+#define api_rsd_bit_err_cnt_23_16               0x0036
+#define api_r_rsd_packet_unit_7_0               0x0037
+#define api_r_rsd_packet_unit_15_8              0x0038
+
+#define api_qnt_vbc_sframe_num                  0x0039
+#define api_rsd_packet_unit_7_0                 0x003a
+#define api_rsd_packet_unit_15_8                0x003b
+
+#define api_tpsd_lock                           0x003c
+#define api_mpeg_lock                           0x003d
+#define api_RsdSequence                         0x003e
+#define api_VtbSequence                         0x003f
+
+#define api_Training_Mode                       0x0040
+#define api_RESET_STATE                         0x0041
+#define api_EXT_LNA_OFF                         0x0042
+#define api_aci_0                               0x0043
+#define api_aci_1                               0x0044
+
+#define api_adcx2                               0x0045
+#define api_tuner_ID                            0x0046
+#define api_empty_channel_status                0x0047
+#define api_signal_strength                     0x0048
+#define api_signal_quality                      0x0049
+#define api_est_rf_level_dbm                    0x004a
+#define api_FreBand                             0x004b
+#define api_suspend_flag                        0x004c
+#define api_SupportRelayCommandWrite            0x004d
+#define api_RelayCommandWrite                   0x004e
+
+#define api_OfdmGuiRCN_H                        0x004f
+#define api_OfdmGuiRCN_L                        0x0050
+#define api_antenna_unplugged                   0x0051
+#define api_strong_signal_detected              0x0052
+#define api_channelFlatnessInd                  0x0053
+#define api_Flatness_Ind_nonCmb                 0x0054
+#define api_AutoDetectedSpectrumInv             0x0055
+#define api_IsSpectrumInv                       0x0056
+#define api_strong_detect_bypass                0x0057
+#define api_ss_dtop_bypass                      0x0058
+#define api_retrain_dtop_bypass                 0x0059
+#define api_EnableTimeSlice                     0x005a
+#define api_SynchronizationType                 0x005b
+#define api_ApplyFastSynchronizationToEchoChannel 0x005c
+#define api_ApplyPwmToRfIf                      0x005d
+#define api_ChannelNo                           0x005e
+
+#define api_csi_bypass                          0x005f
+#define api_mobile_bypass                       0x0060
+#define api_EnableSpeedLog                      0x0061
+
+#define api_r_rsd_abort_total_packet_7_0        0x0062
+#define api_r_rsd_abort_total_packet_15_8       0x0063
+#define api_r_rsd_abort_total_packet_23_16      0x0064
+#define api_MaxRsdSequence                      0x0065
+#define api_RsdFrameNo                          0x0066
+#define api_MPESuperFrameNo                     0x0067
+
+#define api_AgcDesiredLevel                     0x0068
+#define api_MinRfGain                           0x0069
+#define api_MaxIfGain                           0x006a
+#define api_RssiOffset                          0x006b
+#define api_RssiResidual                        0x006c
+
+#define api_strong_weak_signal_default          0x006d
+#define api_PionDiodeDefaultResetInVHF          0x006e
+#define api_afe_mem4_rssi_comp                  0x006f
+
+#define api_aagc_speed_detect_count             0x0070
+#define api_aagc_mobile_thr                     0x0071
+#define api_aagc_nonmobile_thr                  0x0072
+#define api_agc_counter                         0x0073
+#define api_DisableAagcTop                      0x0074
+#define api_AgcReset                            0x0075
+#define api_AgcUp                               0x0076
+#define api_AgcDown                             0x0077
+#define api_AgcHold                             0x0078
+#define api_PwmCtrlHw                           0x0079
+#define api_MaxAgcGain                          0x007a
+#define api_IniAgcGain                          0x007b
+#define api_mccid_bypass                        0x007c
+#define api_CdpfEnDefaultEchoRange              0x007d
+#define api_CdpfIniTestNoSteady                 0x007e
+#define api_timing_err_level                    0x007f
+#define api_timing_retrain_cnt                  0x0080
+#define api_ChannelDiffThrSteady                0x0081
+
+#define api_adjacent_on                         0x0082
+#define api_near_adjacent_on                    0x0083
+#define api_adjacent_off                        0x0084
+#define api_near_adjacent_off                   0x0085
+#define api_max_rf_agc_7_0                      0x0086
+#define api_max_rf_agc_9_8                      0x0087
+#define api_rf_top_numerator_s_7_0              0x0088
+#define api_rf_top_numerator_s_9_8              0x0089
+
+#define api_gui_tdi_lms_en                      0x008a
+#define api_fccid_strobe_scale                  0x008b
+#define api_fccid_strobe_numerator              0x008c
+#define api_fccid_strobe_base                   0x008d
+#define api_use_fccid                           0x008e
+#define api_fft_ave_symbol_num                  0x008f
+#define api_large_tone_num_th_7_0               0x0090
+#define api_large_tone_num_th_15_8              0x0091
+#define api_use_3m_lpf_th                       0x0092
+#define api_ce_var_min_8k                       0x0093
+#define api_ce_var_min_4k                       0x0094
+#define api_ce_var_min_2k                       0x0095
+#define api_ce_var_min_8k_non_flat              0x0096
+#define api_flatness_thr                        0x0097
+#define api_non_mobile_signal_level_offset      0x0098
+#define api_gui_ar_csi_en                       0x0099
+#define api_h2_echo_detected                    0x009a
+#define api_gain_offset_O                       0x009b
+#define api_gain_slope_O                        0x009c
+#define api_pin_diode_gain_loss                 0x009d
+#define api_signal_strength_if_low              0x009e
+
+#define api_flatness_thr_high                   0x009f
+#define api_flatness_thr_low                    0x00a0
+
+#define api_sbq1                                0x00a1
+#define api_sbq2                                0x00a2
+
+#define api_dyna_dca_offset_en                  0x00a3
+#define api_dca_sbq_bad_th                      0x00a4
+#define api_detect_timing_err_en                0x00a5
+#define api_flatness_from_h2_echo               0x00a6
+
+#define api_timging_error_detection             0x00a7
+#define api_ce_forced_by_rotate                 0x00a8
+#define api_fccid_fft_mask_en                   0x00a9
+#define api_second_fctrl_unforce_en             0x00aa
+#define api_force_fdi0_at_high_mobile_en        0x00ab
+#define api_high_mobile_detected                0x00ac
+#define api_flatness_detection_en               0x00ad
+#define api_ChooseFsteCostFunctionFromCdpf      0x00ae
+#define api_signal_level                        0x00af
+#define api_TryConf2En                          0x00b0
+#define api_Lower_tpsd_lock                     0x00b1
+#define api_Upper_tpsd_lock                     0x00b2
+
+#define api_AgcCtrlType                         0x00b3
+#define api_opt_LNA_Rssi_scale                  0x00b4
+#define api_StopByTcl                           0x00b5
+#define api_RssiCalibration                     0x00b6
+#define api_AciDesiredSignalLevel_h             0x00b7
+#define api_AciDesiredSignalLevel_l             0x00b8
+#define api_ECO_ASIC                            0x00b9
+#define api_NXP_USE_I2C                         0x00ba
+#define api_rf_freqency_23_16                   0x00bb
+#define api_rf_freqency_15_8                    0x00bc
+#define api_rf_freqency_7_0                     0x00bd
+#define api_iqik_en                             0x00be
+#define api_dcc_en                              0x00bf
+#define api_CdpfIniTestNoMobile                 0x00c0
+#define api_ACIdetection                        0x00c1
+#define api_PinDiode                            0x00c2
+#define api_LNA_Gain                            0x00c3
+#define api_ChannelDiffThrMobile                0x00c4
+#define api_var_end                             0x00c5
+
+/* registers */
+#define    p_reg_p_aagc_log_2_acc   0xF000
+#define reg_p_aagc_log_2_acc_pos 0
+#define reg_p_aagc_log_2_acc_len 4
+#define reg_p_aagc_log_2_acc_lsb 0
+#define    p_reg_p_aagc_signal_level_rdy    0xF001
+#define reg_p_aagc_signal_level_rdy_pos 0
+#define reg_p_aagc_signal_level_rdy_len 1
+#define reg_p_aagc_signal_level_rdy_lsb 0
+#define    r_reg_r_aagc_signal_level_7_0    0xF002
+#define reg_r_aagc_signal_level_7_0_pos 0
+#define reg_r_aagc_signal_level_7_0_len 8
+#define reg_r_aagc_signal_level_7_0_lsb 0
+#define    r_reg_r_aagc_signal_level_9_8    0xF003
+#define reg_r_aagc_signal_level_9_8_pos 0
+#define reg_r_aagc_signal_level_9_8_len 2
+#define reg_r_aagc_signal_level_9_8_lsb 8
+#define    p_reg_p_aagc_rf_if_swap  0xF004
+#define reg_p_aagc_rf_if_swap_pos 0
+#define reg_p_aagc_rf_if_swap_len 1
+#define reg_p_aagc_rf_if_swap_lsb 0
+#define    p_reg_p_pwm_rf_if_from_hw    0xF006
+#define reg_p_pwm_rf_if_from_hw_pos 0
+#define reg_p_pwm_rf_if_from_hw_len 1
+#define reg_p_pwm_rf_if_from_hw_lsb 0
+#define    p_reg_aagc_out_if_inv    0xF007
+#define reg_aagc_out_if_inv_pos 0
+#define reg_aagc_out_if_inv_len 1
+#define reg_aagc_out_if_inv_lsb 0
+#define    p_reg_aagc_int_en    0xF008
+#define reg_aagc_int_en_pos 0
+#define reg_aagc_int_en_len 1
+#define reg_aagc_int_en_lsb 0
+#define    p_reg_aagc_lock_change_flag  0xF009
+#define reg_aagc_lock_change_flag_pos 0
+#define reg_aagc_lock_change_flag_len 1
+#define reg_aagc_lock_change_flag_lsb 0
+#define    p_reg_aagc_rf_loop_bw_scale_acquire  0xF00A
+#define reg_aagc_rf_loop_bw_scale_acquire_pos 0
+#define reg_aagc_rf_loop_bw_scale_acquire_len 5
+#define reg_aagc_rf_loop_bw_scale_acquire_lsb 0
+#define    p_reg_aagc_rf_loop_bw_scale_track    0xF00B
+#define reg_aagc_rf_loop_bw_scale_track_pos 0
+#define reg_aagc_rf_loop_bw_scale_track_len 5
+#define reg_aagc_rf_loop_bw_scale_track_lsb 0
+#define    p_reg_aagc_if_loop_bw_scale_acquire  0xF00C
+#define reg_aagc_if_loop_bw_scale_acquire_pos 0
+#define reg_aagc_if_loop_bw_scale_acquire_len 5
+#define reg_aagc_if_loop_bw_scale_acquire_lsb 0
+#define    p_reg_aagc_if_loop_bw_scale_track    0xF00D
+#define reg_aagc_if_loop_bw_scale_track_pos 0
+#define reg_aagc_if_loop_bw_scale_track_len 5
+#define reg_aagc_if_loop_bw_scale_track_lsb 0
+#define    p_reg_aagc_max_rf_agc_7_0    0xF00E
+#define reg_aagc_max_rf_agc_7_0_pos 0
+#define reg_aagc_max_rf_agc_7_0_len 8
+#define reg_aagc_max_rf_agc_7_0_lsb 0
+#define    p_reg_aagc_max_rf_agc_9_8    0xF00F
+#define reg_aagc_max_rf_agc_9_8_pos 0
+#define reg_aagc_max_rf_agc_9_8_len 2
+#define reg_aagc_max_rf_agc_9_8_lsb 8
+#define    p_reg_aagc_min_rf_agc_7_0    0xF010
+#define reg_aagc_min_rf_agc_7_0_pos 0
+#define reg_aagc_min_rf_agc_7_0_len 8
+#define reg_aagc_min_rf_agc_7_0_lsb 0
+#define    p_reg_aagc_min_rf_agc_9_8    0xF011
+#define reg_aagc_min_rf_agc_9_8_pos 0
+#define reg_aagc_min_rf_agc_9_8_len 2
+#define reg_aagc_min_rf_agc_9_8_lsb 8
+#define    p_reg_aagc_max_if_agc_7_0    0xF012
+#define reg_aagc_max_if_agc_7_0_pos 0
+#define reg_aagc_max_if_agc_7_0_len 8
+#define reg_aagc_max_if_agc_7_0_lsb 0
+#define    p_reg_aagc_max_if_agc_9_8    0xF013
+#define reg_aagc_max_if_agc_9_8_pos 0
+#define reg_aagc_max_if_agc_9_8_len 2
+#define reg_aagc_max_if_agc_9_8_lsb 8
+#define    p_reg_aagc_min_if_agc_7_0    0xF014
+#define reg_aagc_min_if_agc_7_0_pos 0
+#define reg_aagc_min_if_agc_7_0_len 8
+#define reg_aagc_min_if_agc_7_0_lsb 0
+#define    p_reg_aagc_min_if_agc_9_8    0xF015
+#define reg_aagc_min_if_agc_9_8_pos 0
+#define reg_aagc_min_if_agc_9_8_len 2
+#define reg_aagc_min_if_agc_9_8_lsb 8
+#define    p_reg_aagc_lock_sample_scale 0xF016
+#define reg_aagc_lock_sample_scale_pos 0
+#define reg_aagc_lock_sample_scale_len 5
+#define reg_aagc_lock_sample_scale_lsb 0
+#define    p_reg_aagc_rf_agc_lock_scale_acquire 0xF017
+#define reg_aagc_rf_agc_lock_scale_acquire_pos 0
+#define reg_aagc_rf_agc_lock_scale_acquire_len 3
+#define reg_aagc_rf_agc_lock_scale_acquire_lsb 0
+#define    p_reg_aagc_rf_agc_lock_scale_track   0xF018
+#define reg_aagc_rf_agc_lock_scale_track_pos 0
+#define reg_aagc_rf_agc_lock_scale_track_len 3
+#define reg_aagc_rf_agc_lock_scale_track_lsb 0
+#define    p_reg_aagc_if_agc_lock_scale_acquire 0xF019
+#define reg_aagc_if_agc_lock_scale_acquire_pos 0
+#define reg_aagc_if_agc_lock_scale_acquire_len 3
+#define reg_aagc_if_agc_lock_scale_acquire_lsb 0
+#define    p_reg_aagc_if_agc_lock_scale_track   0xF01A
+#define reg_aagc_if_agc_lock_scale_track_pos 0
+#define reg_aagc_if_agc_lock_scale_track_len 3
+#define reg_aagc_if_agc_lock_scale_track_lsb 0
+#define    p_reg_aagc_rf_top_numerator_s_7_0    0xF01B
+#define reg_aagc_rf_top_numerator_s_7_0_pos 0
+#define reg_aagc_rf_top_numerator_s_7_0_len 8
+#define reg_aagc_rf_top_numerator_s_7_0_lsb 0
+#define    p_reg_aagc_rf_top_numerator_s_9_8    0xF01C
+#define reg_aagc_rf_top_numerator_s_9_8_pos 0
+#define reg_aagc_rf_top_numerator_s_9_8_len 2
+#define reg_aagc_rf_top_numerator_s_9_8_lsb 8
+#define    p_reg_aagc_if_top_numerator_s_7_0    0xF01D
+#define reg_aagc_if_top_numerator_s_7_0_pos 0
+#define reg_aagc_if_top_numerator_s_7_0_len 8
+#define reg_aagc_if_top_numerator_s_7_0_lsb 0
+#define    p_reg_aagc_if_top_numerator_s_9_8    0xF01E
+#define reg_aagc_if_top_numerator_s_9_8_pos 0
+#define reg_aagc_if_top_numerator_s_9_8_len 2
+#define reg_aagc_if_top_numerator_s_9_8_lsb 8
+#define    p_reg_aagc_adc_out_desired_s_7_0 0xF01F
+#define reg_aagc_adc_out_desired_s_7_0_pos 0
+#define reg_aagc_adc_out_desired_s_7_0_len 8
+#define reg_aagc_adc_out_desired_s_7_0_lsb 0
+#define    p_reg_aagc_adc_out_desired_s_8   0xF020
+#define reg_aagc_adc_out_desired_s_8_pos 0
+#define reg_aagc_adc_out_desired_s_8_len 1
+#define reg_aagc_adc_out_desired_s_8_lsb 8
+#define    p_reg_aagc_lock_count_th 0xF021
+#define reg_aagc_lock_count_th_pos 0
+#define reg_aagc_lock_count_th_len 4
+#define reg_aagc_lock_count_th_lsb 0
+#define    p_reg_aagc_rf_agc_unlock_numerator   0xF022
+#define reg_aagc_rf_agc_unlock_numerator_pos 0
+#define reg_aagc_rf_agc_unlock_numerator_len 6
+#define reg_aagc_rf_agc_unlock_numerator_lsb 0
+#define    p_reg_aagc_if_agc_unlock_numerator   0xF023
+#define reg_aagc_if_agc_unlock_numerator_pos 0
+#define reg_aagc_if_agc_unlock_numerator_len 6
+#define reg_aagc_if_agc_unlock_numerator_lsb 0
+#define    p_reg_aagc_rf_top_numerator_m_7_0    0xF025
+#define reg_aagc_rf_top_numerator_m_7_0_pos 0
+#define reg_aagc_rf_top_numerator_m_7_0_len 8
+#define reg_aagc_rf_top_numerator_m_7_0_lsb 0
+#define    p_reg_aagc_rf_top_numerator_m_9_8    0xF026
+#define reg_aagc_rf_top_numerator_m_9_8_pos 0
+#define reg_aagc_rf_top_numerator_m_9_8_len 2
+#define reg_aagc_rf_top_numerator_m_9_8_lsb 8
+#define    p_reg_aagc_if_top_numerator_m_7_0    0xF027
+#define reg_aagc_if_top_numerator_m_7_0_pos 0
+#define reg_aagc_if_top_numerator_m_7_0_len 8
+#define reg_aagc_if_top_numerator_m_7_0_lsb 0
+#define    p_reg_aagc_if_top_numerator_m_9_8    0xF028
+#define reg_aagc_if_top_numerator_m_9_8_pos 0
+#define reg_aagc_if_top_numerator_m_9_8_len 2
+#define reg_aagc_if_top_numerator_m_9_8_lsb 8
+#define    p_reg_aagc_adc_out_desired_m_7_0 0xF029
+#define reg_aagc_adc_out_desired_m_7_0_pos 0
+#define reg_aagc_adc_out_desired_m_7_0_len 8
+#define reg_aagc_adc_out_desired_m_7_0_lsb 0
+#define    p_reg_aagc_adc_out_desired_m_8   0xF02A
+#define reg_aagc_adc_out_desired_m_8_pos 0
+#define reg_aagc_adc_out_desired_m_8_len 1
+#define reg_aagc_adc_out_desired_m_8_lsb 8
+#define    p_reg_aagc_mobile_sel    0xF02B
+#define reg_aagc_mobile_sel_pos 0
+#define reg_aagc_mobile_sel_len 1
+#define reg_aagc_mobile_sel_lsb 0
+#define    p_reg_aagc_top_reload    0xF02C
+#define reg_aagc_top_reload_pos 0
+#define reg_aagc_top_reload_len 1
+#define reg_aagc_top_reload_lsb 0
+#define    p_reg_aagc_rf_delta_voltage_en   0xF02D
+#define reg_aagc_rf_delta_voltage_en_pos 0
+#define reg_aagc_rf_delta_voltage_en_len 1
+#define reg_aagc_rf_delta_voltage_en_lsb 0
+#define    p_reg_aagc_rf_voltage_inc    0xF02E
+#define reg_aagc_rf_voltage_inc_pos 0
+#define reg_aagc_rf_voltage_inc_len 1
+#define reg_aagc_rf_voltage_inc_lsb 0
+#define    p_reg_aagc_if_delta_voltage_en   0xF02F
+#define reg_aagc_if_delta_voltage_en_pos 0
+#define reg_aagc_if_delta_voltage_en_len 1
+#define reg_aagc_if_delta_voltage_en_lsb 0
+#define    p_reg_aagc_if_voltage_inc    0xF030
+#define reg_aagc_if_voltage_inc_pos 0
+#define reg_aagc_if_voltage_inc_len 1
+#define reg_aagc_if_voltage_inc_lsb 0
+#define    p_reg_aagc_rf_delta_voltage_7_0  0xF032
+#define reg_aagc_rf_delta_voltage_7_0_pos 0
+#define reg_aagc_rf_delta_voltage_7_0_len 8
+#define reg_aagc_rf_delta_voltage_7_0_lsb 0
+#define    p_reg_aagc_rf_delta_voltage_15_8 0xF033
+#define reg_aagc_rf_delta_voltage_15_8_pos 0
+#define reg_aagc_rf_delta_voltage_15_8_len 8
+#define reg_aagc_rf_delta_voltage_15_8_lsb 8
+#define    p_reg_aagc_rf_delta_voltage_23_16    0xF034
+#define reg_aagc_rf_delta_voltage_23_16_pos 0
+#define reg_aagc_rf_delta_voltage_23_16_len 8
+#define reg_aagc_rf_delta_voltage_23_16_lsb 16
+#define    p_reg_aagc_rf_delta_voltage_29_24    0xF035
+#define reg_aagc_rf_delta_voltage_29_24_pos 0
+#define reg_aagc_rf_delta_voltage_29_24_len 6
+#define reg_aagc_rf_delta_voltage_29_24_lsb 24
+#define    p_reg_aagc_if_delta_voltage_7_0  0xF036
+#define reg_aagc_if_delta_voltage_7_0_pos 0
+#define reg_aagc_if_delta_voltage_7_0_len 8
+#define reg_aagc_if_delta_voltage_7_0_lsb 0
+#define    p_reg_aagc_if_delta_voltage_15_8 0xF037
+#define reg_aagc_if_delta_voltage_15_8_pos 0
+#define reg_aagc_if_delta_voltage_15_8_len 8
+#define reg_aagc_if_delta_voltage_15_8_lsb 8
+#define    p_reg_aagc_if_delta_voltage_23_16    0xF038
+#define reg_aagc_if_delta_voltage_23_16_pos 0
+#define reg_aagc_if_delta_voltage_23_16_len 8
+#define reg_aagc_if_delta_voltage_23_16_lsb 16
+#define    p_reg_aagc_if_delta_voltage_29_24    0xF039
+#define reg_aagc_if_delta_voltage_29_24_pos 0
+#define reg_aagc_if_delta_voltage_29_24_len 6
+#define reg_aagc_if_delta_voltage_29_24_lsb 24
+#define    p_reg_aagc_delta_voltage_hold_time   0xF03A
+#define reg_aagc_delta_voltage_hold_time_pos 0
+#define reg_aagc_delta_voltage_hold_time_len 8
+#define reg_aagc_delta_voltage_hold_time_lsb 0
+#define    p_reg_aagc_top_th_dis    0xF041
+#define reg_aagc_top_th_dis_pos 0
+#define reg_aagc_top_th_dis_len 1
+#define reg_aagc_top_th_dis_lsb 0
+#define    p_reg_p_aagc_rf_floor_dca    0xF042
+#define reg_p_aagc_rf_floor_dca_pos 0
+#define reg_p_aagc_rf_floor_dca_len 8
+#define reg_p_aagc_rf_floor_dca_lsb 0
+#define    p_reg_p_aagc_if_floor_dca    0xF043
+#define reg_p_aagc_if_floor_dca_pos 0
+#define reg_p_aagc_if_floor_dca_len 8
+#define reg_p_aagc_if_floor_dca_lsb 0
+#define    p_reg_p_aagc_rf_gain_scale_dca   0xF044
+#define reg_p_aagc_rf_gain_scale_dca_pos 0
+#define reg_p_aagc_rf_gain_scale_dca_len 3
+#define reg_p_aagc_rf_gain_scale_dca_lsb 0
+#define    p_reg_p_aagc_if_gain_scale_dca   0xF045
+#define reg_p_aagc_if_gain_scale_dca_pos 0
+#define reg_p_aagc_if_gain_scale_dca_len 3
+#define reg_p_aagc_if_gain_scale_dca_lsb 0
+#define    r_reg_r_aagc_ufl_gain    0xF046
+#define reg_r_aagc_ufl_gain_pos 0
+#define reg_r_aagc_ufl_gain_len 8
+#define reg_r_aagc_ufl_gain_lsb 0
+#define    p_reg_aagc_out_rf_inv    0xF047
+#define reg_aagc_out_rf_inv_pos 0
+#define reg_aagc_out_rf_inv_len 1
+#define reg_aagc_out_rf_inv_lsb 0
+#define    p_reg_p_aagc_save_agc_control    0xF048
+#define reg_p_aagc_save_agc_control_pos 0
+#define reg_p_aagc_save_agc_control_len 1
+#define reg_p_aagc_save_agc_control_lsb 0
+#define    p_reg_aagc_fw_sel    0xF049
+#define reg_aagc_fw_sel_pos 0
+#define reg_aagc_fw_sel_len 1
+#define reg_aagc_fw_sel_lsb 0
+#define    r_reg_r_aagc_rf_control_7_0  0xF04A
+#define reg_r_aagc_rf_control_7_0_pos 0
+#define reg_r_aagc_rf_control_7_0_len 8
+#define reg_r_aagc_rf_control_7_0_lsb 0
+#define    r_reg_r_aagc_rf_control_9_8  0xF04B
+#define reg_r_aagc_rf_control_9_8_pos 0
+#define reg_r_aagc_rf_control_9_8_len 2
+#define reg_r_aagc_rf_control_9_8_lsb 8
+#define    r_reg_r_aagc_if_control_7_0  0xF04C
+#define reg_r_aagc_if_control_7_0_pos 0
+#define reg_r_aagc_if_control_7_0_len 8
+#define reg_r_aagc_if_control_7_0_lsb 0
+#define    r_reg_r_aagc_if_control_9_8  0xF04D
+#define reg_r_aagc_if_control_9_8_pos 0
+#define reg_r_aagc_if_control_9_8_len 2
+#define reg_r_aagc_if_control_9_8_lsb 8
+#define    p_reg_aagc_adc_out_desired_from_fw_7_0   0xF04E
+#define reg_aagc_adc_out_desired_from_fw_7_0_pos 0
+#define reg_aagc_adc_out_desired_from_fw_7_0_len 8
+#define reg_aagc_adc_out_desired_from_fw_7_0_lsb 0
+#define    p_reg_aagc_adc_out_desired_from_fw_8 0xF04F
+#define reg_aagc_adc_out_desired_from_fw_8_pos 0
+#define reg_aagc_adc_out_desired_from_fw_8_len 1
+#define reg_aagc_adc_out_desired_from_fw_8_lsb 8
+#define    p_reg_aagc_init_rf_agc_7_0   0xF050
+#define reg_aagc_init_rf_agc_7_0_pos 0
+#define reg_aagc_init_rf_agc_7_0_len 8
+#define reg_aagc_init_rf_agc_7_0_lsb 0
+#define    p_reg_aagc_init_rf_agc_9_8   0xF051
+#define reg_aagc_init_rf_agc_9_8_pos 0
+#define reg_aagc_init_rf_agc_9_8_len 2
+#define reg_aagc_init_rf_agc_9_8_lsb 8
+#define    p_reg_aagc_init_if_agc_7_0   0xF052
+#define reg_aagc_init_if_agc_7_0_pos 0
+#define reg_aagc_init_if_agc_7_0_len 8
+#define reg_aagc_init_if_agc_7_0_lsb 0
+#define    p_reg_aagc_init_if_agc_9_8   0xF053
+#define reg_aagc_init_if_agc_9_8_pos 0
+#define reg_aagc_init_if_agc_9_8_len 2
+#define reg_aagc_init_if_agc_9_8_lsb 8
+#define    p_reg_p_pwm_if_high_unit_num 0xF054
+#define reg_p_pwm_if_high_unit_num_pos 0
+#define reg_p_pwm_if_high_unit_num_len 8
+#define reg_p_pwm_if_high_unit_num_lsb 0
+#define    p_reg_p_pwm_rf_high_unit_num 0xF055
+#define reg_p_pwm_rf_high_unit_num_pos 0
+#define reg_p_pwm_rf_high_unit_num_len 8
+#define reg_p_pwm_rf_high_unit_num_lsb 0
+#define    p_reg_p_pwm_rf_gpio  0xF058
+#define reg_p_pwm_rf_gpio_pos 0
+#define reg_p_pwm_rf_gpio_len 1
+#define reg_p_pwm_rf_gpio_lsb 0
+#define    p_reg_p_pwm_if_gpio  0xF058
+#define reg_p_pwm_if_gpio_pos 1
+#define reg_p_pwm_if_gpio_len 1
+#define reg_p_pwm_if_gpio_lsb 0
+#define    p_reg_aagc_in_sat_cnt_7_0    0xF05A
+#define reg_aagc_in_sat_cnt_7_0_pos 0
+#define reg_aagc_in_sat_cnt_7_0_len 8
+#define reg_aagc_in_sat_cnt_7_0_lsb 0
+#define    p_reg_aagc_in_sat_cnt_15_8   0xF05B
+#define reg_aagc_in_sat_cnt_15_8_pos 0
+#define reg_aagc_in_sat_cnt_15_8_len 8
+#define reg_aagc_in_sat_cnt_15_8_lsb 8
+#define    p_reg_aagc_in_sat_cnt_23_16  0xF05C
+#define reg_aagc_in_sat_cnt_23_16_pos 0
+#define reg_aagc_in_sat_cnt_23_16_len 8
+#define reg_aagc_in_sat_cnt_23_16_lsb 16
+#define    p_reg_aagc_in_sat_cnt_31_24  0xF05D
+#define reg_aagc_in_sat_cnt_31_24_pos 0
+#define reg_aagc_in_sat_cnt_31_24_len 8
+#define reg_aagc_in_sat_cnt_31_24_lsb 24
+#define    p_reg_p_pwm_cycle_unit   0xF05E
+#define reg_p_pwm_cycle_unit_pos 0
+#define reg_p_pwm_cycle_unit_len 4
+#define reg_p_pwm_cycle_unit_lsb 0
+#define    p_reg_p_pwm_en   0xF05F
+#define reg_p_pwm_en_pos 0
+#define reg_p_pwm_en_len 1
+#define reg_p_pwm_en_lsb 0
+#define    r_reg_aagc_rf_gain   0xF060
+#define reg_aagc_rf_gain_pos 0
+#define reg_aagc_rf_gain_len 8
+#define reg_aagc_rf_gain_lsb 0
+#define    r_reg_aagc_if_gain   0xF061
+#define reg_aagc_if_gain_pos 0
+#define reg_aagc_if_gain_len 8
+#define reg_aagc_if_gain_lsb 0
+#define    r_reg_aagc_current_desired_level_7_0 0xF062
+#define reg_aagc_current_desired_level_7_0_pos 0
+#define reg_aagc_current_desired_level_7_0_len 8
+#define reg_aagc_current_desired_level_7_0_lsb 0
+#define    r_reg_aagc_current_desired_level_8   0xF063
+#define reg_aagc_current_desired_level_8_pos 0
+#define reg_aagc_current_desired_level_8_len 1
+#define reg_aagc_current_desired_level_8_lsb 8
+#define    p_reg_tinr_fifo_size 0xF064
+#define reg_tinr_fifo_size_pos 0
+#define reg_tinr_fifo_size_len 5
+#define reg_tinr_fifo_size_lsb 0
+#define    p_reg_tinr_saturation_th_7_0 0xF065
+#define reg_tinr_saturation_th_7_0_pos 0
+#define reg_tinr_saturation_th_7_0_len 8
+#define reg_tinr_saturation_th_7_0_lsb 0
+#define    p_reg_tinr_saturation_th_9_8 0xF066
+#define reg_tinr_saturation_th_9_8_pos 0
+#define reg_tinr_saturation_th_9_8_len 2
+#define reg_tinr_saturation_th_9_8_lsb 8
+#define    p_reg_tinr_saturation_cnt_th 0xF067
+#define reg_tinr_saturation_cnt_th_pos 0
+#define reg_tinr_saturation_cnt_th_len 4
+#define reg_tinr_saturation_cnt_th_lsb 0
+#define    r_reg_tinr_counter_7_0   0xF068
+#define reg_tinr_counter_7_0_pos 0
+#define reg_tinr_counter_7_0_len 8
+#define reg_tinr_counter_7_0_lsb 0
+#define    r_reg_tinr_counter_15_8  0xF069
+#define reg_tinr_counter_15_8_pos 0
+#define reg_tinr_counter_15_8_len 8
+#define reg_tinr_counter_15_8_lsb 8
+#define    p_reg_tinr_counter_rst   0xF06C
+#define reg_tinr_counter_rst_pos 0
+#define reg_tinr_counter_rst_len 1
+#define reg_tinr_counter_rst_lsb 0
+#define    p_reg_tinr_ins_th_7_0    0xF06F
+#define reg_tinr_ins_th_7_0_pos 0
+#define reg_tinr_ins_th_7_0_len 8
+#define reg_tinr_ins_th_7_0_lsb 0
+#define    p_reg_tinr_ins_th_9_8    0xF070
+#define reg_tinr_ins_th_9_8_pos 0
+#define reg_tinr_ins_th_9_8_len 2
+#define reg_tinr_ins_th_9_8_lsb 8
+#define    p_reg_tinr_ins_en    0xF071
+#define reg_tinr_ins_en_pos 0
+#define reg_tinr_ins_en_len 1
+#define reg_tinr_ins_en_lsb 0
+#define    p_reg_tinr_ins_size  0xF072
+#define reg_tinr_ins_size_pos 0
+#define reg_tinr_ins_size_len 4
+#define reg_tinr_ins_size_lsb 0
+#define    p_reg_tinr_ins_hnum  0xF073
+#define reg_tinr_ins_hnum_pos 0
+#define reg_tinr_ins_hnum_len 4
+#define reg_tinr_ins_hnum_lsb 0
+#define    r_reg_tinr_ins_hcnt_7_0  0xF074
+#define reg_tinr_ins_hcnt_7_0_pos 0
+#define reg_tinr_ins_hcnt_7_0_len 8
+#define reg_tinr_ins_hcnt_7_0_lsb 0
+#define    r_reg_tinr_ins_hcnt_15_8 0xF075
+#define reg_tinr_ins_hcnt_15_8_pos 0
+#define reg_tinr_ins_hcnt_15_8_len 8
+#define reg_tinr_ins_hcnt_15_8_lsb 8
+#define    p_reg_tinr_in_conj   0xF076
+#define reg_tinr_in_conj_pos 0
+#define reg_tinr_in_conj_len 1
+#define reg_tinr_in_conj_lsb 0
+#define    p_reg_tinr_in_zero_if    0xF077
+#define reg_tinr_in_zero_if_pos 0
+#define reg_tinr_in_zero_if_len 2
+#define reg_tinr_in_zero_if_lsb 0
+#define    p_reg_tinr_in_shift  0xF078
+#define reg_tinr_in_shift_pos 0
+#define reg_tinr_in_shift_len 1
+#define reg_tinr_in_shift_lsb 0
+#define    p_reg_tinr_in_conj_sat_counter_rst   0xF079
+#define reg_tinr_in_conj_sat_counter_rst_pos 0
+#define reg_tinr_in_conj_sat_counter_rst_len 1
+#define reg_tinr_in_conj_sat_counter_rst_lsb 0
+#define    r_reg_tinr_in_conj_sat_counter_7_0   0xF07A
+#define reg_tinr_in_conj_sat_counter_7_0_pos 0
+#define reg_tinr_in_conj_sat_counter_7_0_len 8
+#define reg_tinr_in_conj_sat_counter_7_0_lsb 0
+#define    r_reg_tinr_in_conj_sat_counter_14_8  0xF07B
+#define reg_tinr_in_conj_sat_counter_14_8_pos 0
+#define reg_tinr_in_conj_sat_counter_14_8_len 7
+#define reg_tinr_in_conj_sat_counter_14_8_lsb 8
+#define    p_reg_p_antif_en 0xF07C
+#define reg_p_antif_en_pos 0
+#define reg_p_antif_en_len 1
+#define reg_p_antif_en_lsb 0
+#define    p_reg_p_antif_rst    0xF07D
+#define reg_p_antif_rst_pos 0
+#define reg_p_antif_rst_len 1
+#define reg_p_antif_rst_lsb 0
+#define    p_reg_p_antif_byp    0xF07E
+#define reg_p_antif_byp_pos 0
+#define reg_p_antif_byp_len 1
+#define reg_p_antif_byp_lsb 0
+#define    p_reg_p_antif_mode   0xF07F
+#define reg_p_antif_mode_pos 0
+#define reg_p_antif_mode_len 1
+#define reg_p_antif_mode_lsb 0
+#define    p_reg_p_ds_byp   0xF080
+#define reg_p_ds_byp_pos 0
+#define reg_p_ds_byp_len 1
+#define reg_p_ds_byp_lsb 0
+#define    p_reg_p_antif_dagc5_mode 0xF081
+#define reg_p_antif_dagc5_mode_pos 0
+#define reg_p_antif_dagc5_mode_len 2
+#define reg_p_antif_dagc5_mode_lsb 0
+#define    p_reg_p_antif_dagc5_desired_level_7_0    0xF082
+#define reg_p_antif_dagc5_desired_level_7_0_pos 0
+#define reg_p_antif_dagc5_desired_level_7_0_len 8
+#define reg_p_antif_dagc5_desired_level_7_0_lsb 0
+#define    p_reg_p_antif_dagc5_desired_level_8  0xF083
+#define reg_p_antif_dagc5_desired_level_8_pos 0
+#define reg_p_antif_dagc5_desired_level_8_len 1
+#define reg_p_antif_dagc5_desired_level_8_lsb 8
+#define    p_reg_p_antif_dagc5_apply_delay  0xF084
+#define reg_p_antif_dagc5_apply_delay_pos 0
+#define reg_p_antif_dagc5_apply_delay_len 7
+#define reg_p_antif_dagc5_apply_delay_lsb 0
+#define    p_reg_p_antif_dagc5_fixed_gain_7_0   0xF085
+#define reg_p_antif_dagc5_fixed_gain_7_0_pos 0
+#define reg_p_antif_dagc5_fixed_gain_7_0_len 8
+#define reg_p_antif_dagc5_fixed_gain_7_0_lsb 0
+#define    p_reg_p_antif_dagc5_fixed_gain_11_8  0xF086
+#define reg_p_antif_dagc5_fixed_gain_11_8_pos 0
+#define reg_p_antif_dagc5_fixed_gain_11_8_len 4
+#define reg_p_antif_dagc5_fixed_gain_11_8_lsb 8
+#define    p_reg_p_antif_dagc5_use_despow   0xF087
+#define reg_p_antif_dagc5_use_despow_pos 0
+#define reg_p_antif_dagc5_use_despow_len 1
+#define reg_p_antif_dagc5_use_despow_lsb 0
+#define    p_reg_p_antif_dagc5_log_2_accumulate_num 0xF088
+#define reg_p_antif_dagc5_log_2_accumulate_num_pos 0
+#define reg_p_antif_dagc5_log_2_accumulate_num_len 5
+#define reg_p_antif_dagc5_log_2_accumulate_num_lsb 0
+#define    p_reg_p_antif_dagc5_in_sat_cnt_7_0   0xF089
+#define reg_p_antif_dagc5_in_sat_cnt_7_0_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_7_0_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_7_0_lsb 0
+#define    p_reg_p_antif_dagc5_in_sat_cnt_15_8  0xF08A
+#define reg_p_antif_dagc5_in_sat_cnt_15_8_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_15_8_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_15_8_lsb 8
+#define    p_reg_p_antif_dagc5_in_sat_cnt_23_16 0xF08B
+#define reg_p_antif_dagc5_in_sat_cnt_23_16_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_23_16_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_23_16_lsb 16
+#define    p_reg_p_antif_dagc5_in_sat_cnt_31_24 0xF08C
+#define reg_p_antif_dagc5_in_sat_cnt_31_24_pos 0
+#define reg_p_antif_dagc5_in_sat_cnt_31_24_len 8
+#define reg_p_antif_dagc5_in_sat_cnt_31_24_lsb 24
+#define    p_reg_p_antif_dagc5_out_sat_cnt_7_0  0xF08D
+#define reg_p_antif_dagc5_out_sat_cnt_7_0_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_7_0_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_7_0_lsb 0
+#define    p_reg_p_antif_dagc5_out_sat_cnt_15_8 0xF08E
+#define reg_p_antif_dagc5_out_sat_cnt_15_8_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_15_8_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_15_8_lsb 8
+#define    p_reg_p_antif_dagc5_out_sat_cnt_23_16    0xF08F
+#define reg_p_antif_dagc5_out_sat_cnt_23_16_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_23_16_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_23_16_lsb 16
+#define    p_reg_p_antif_dagc5_out_sat_cnt_31_24    0xF090
+#define reg_p_antif_dagc5_out_sat_cnt_31_24_pos 0
+#define reg_p_antif_dagc5_out_sat_cnt_31_24_len 8
+#define reg_p_antif_dagc5_out_sat_cnt_31_24_lsb 24
+#define    p_reg_p_antif_dagc5_rst  0xF091
+#define reg_p_antif_dagc5_rst_pos 0
+#define reg_p_antif_dagc5_rst_len 1
+#define reg_p_antif_dagc5_rst_lsb 0
+#define    p_reg_p_antif_dagc5_en   0xF092
+#define reg_p_antif_dagc5_en_pos 0
+#define reg_p_antif_dagc5_en_len 1
+#define reg_p_antif_dagc5_en_lsb 0
+#define    p_reg_p_antif_sc_mode    0xF093
+#define reg_p_antif_sc_mode_pos 0
+#define reg_p_antif_sc_mode_len 4
+#define reg_p_antif_sc_mode_lsb 0
+#define    p_reg_p_antif_dagc5_done 0xF094
+#define reg_p_antif_dagc5_done_pos 0
+#define reg_p_antif_dagc5_done_len 1
+#define reg_p_antif_dagc5_done_lsb 0
+#define    r_reg_r_antif_sc_7_0 0xF095
+#define reg_r_antif_sc_7_0_pos 0
+#define reg_r_antif_sc_7_0_len 8
+#define reg_r_antif_sc_7_0_lsb 0
+#define    r_reg_r_antif_sc_15_8    0xF096
+#define reg_r_antif_sc_15_8_pos 0
+#define reg_r_antif_sc_15_8_len 8
+#define reg_r_antif_sc_15_8_lsb 8
+#define    r_reg_r_antif_dagc5_multiplier_7_0   0xF097
+#define reg_r_antif_dagc5_multiplier_7_0_pos 0
+#define reg_r_antif_dagc5_multiplier_7_0_len 8
+#define reg_r_antif_dagc5_multiplier_7_0_lsb 0
+#define    r_reg_r_antif_dagc5_multiplier_15_8  0xF098
+#define reg_r_antif_dagc5_multiplier_15_8_pos 0
+#define reg_r_antif_dagc5_multiplier_15_8_len 8
+#define reg_r_antif_dagc5_multiplier_15_8_lsb 8
+#define    r_reg_r_antif_dagc5_right_shift_bits 0xF099
+#define reg_r_antif_dagc5_right_shift_bits_pos 0
+#define reg_r_antif_dagc5_right_shift_bits_len 4
+#define reg_r_antif_dagc5_right_shift_bits_lsb 0
+#define    p_reg_p_antif_dagc5_bypass_scale_ctl 0xF09A
+#define reg_p_antif_dagc5_bypass_scale_ctl_pos 0
+#define reg_p_antif_dagc5_bypass_scale_ctl_len 3
+#define reg_p_antif_dagc5_bypass_scale_ctl_lsb 0
+#define    p_reg_mccid_ccirunno_7_0 0xF09B
+#define reg_mccid_ccirunno_7_0_pos 0
+#define reg_mccid_ccirunno_7_0_len 8
+#define reg_mccid_ccirunno_7_0_lsb 0
+#define    p_reg_mccid_ccirunno_8   0xF09C
+#define reg_mccid_ccirunno_8_pos 0
+#define reg_mccid_ccirunno_8_len 1
+#define reg_mccid_ccirunno_8_lsb 8
+#define    p_reg_mccid_acirunno_7_0 0xF09D
+#define reg_mccid_acirunno_7_0_pos 0
+#define reg_mccid_acirunno_7_0_len 8
+#define reg_mccid_acirunno_7_0_lsb 0
+#define    p_reg_mccid_acirunno_8   0xF09E
+#define reg_mccid_acirunno_8_pos 0
+#define reg_mccid_acirunno_8_len 1
+#define reg_mccid_acirunno_8_lsb 8
+#define    p_reg_mccid_maxtonenearrange_7_0 0xF09F
+#define reg_mccid_maxtonenearrange_7_0_pos 0
+#define reg_mccid_maxtonenearrange_7_0_len 8
+#define reg_mccid_maxtonenearrange_7_0_lsb 0
+#define    p_reg_mccid_maxtonenearrange_8   0xF0A0
+#define reg_mccid_maxtonenearrange_8_pos 0
+#define reg_mccid_maxtonenearrange_8_len 1
+#define reg_mccid_maxtonenearrange_8_lsb 8
+#define    r_reg_mccid_maxacipower_7_0  0xF0A1
+#define reg_mccid_maxacipower_7_0_pos 0
+#define reg_mccid_maxacipower_7_0_len 8
+#define reg_mccid_maxacipower_7_0_lsb 0
+#define    r_reg_mccid_maxacipower_15_8 0xF0A2
+#define reg_mccid_maxacipower_15_8_pos 0
+#define reg_mccid_maxacipower_15_8_len 8
+#define reg_mccid_maxacipower_15_8_lsb 8
+#define    r_reg_mccid_maxacipower_19_16    0xF0A3
+#define reg_mccid_maxacipower_19_16_pos 0
+#define reg_mccid_maxacipower_19_16_len 4
+#define reg_mccid_maxacipower_19_16_lsb 16
+#define    p_reg_p_dcoe_en  0xF0D5
+#define reg_p_dcoe_en_pos 0
+#define reg_p_dcoe_en_len 1
+#define reg_p_dcoe_en_lsb 0
+#define    p_reg_p_dcoe_rst 0xF0D6
+#define reg_p_dcoe_rst_pos 0
+#define reg_p_dcoe_rst_len 1
+#define reg_p_dcoe_rst_lsb 0
+#define    p_reg_p_dcoe_clear   0xF0D7
+#define reg_p_dcoe_clear_pos 0
+#define reg_p_dcoe_clear_len 1
+#define reg_p_dcoe_clear_lsb 0
+#define    p_reg_p_dcoe_applyloc_7_0    0xF0D8
+#define reg_p_dcoe_applyloc_7_0_pos 0
+#define reg_p_dcoe_applyloc_7_0_len 8
+#define reg_p_dcoe_applyloc_7_0_lsb 0
+#define    p_reg_p_dcoe_applyloc_12_8   0xF0D9
+#define reg_p_dcoe_applyloc_12_8_pos 0
+#define reg_p_dcoe_applyloc_12_8_len 5
+#define reg_p_dcoe_applyloc_12_8_lsb 8
+#define    p_reg_p_dcoe_accnums 0xF0DA
+#define reg_p_dcoe_accnums_pos 0
+#define reg_p_dcoe_accnums_len 3
+#define reg_p_dcoe_accnums_lsb 0
+#define    p_reg_p_dcoe_accweightsum_sh 0xF0DB
+#define reg_p_dcoe_accweightsum_sh_pos 0
+#define reg_p_dcoe_accweightsum_sh_len 3
+#define reg_p_dcoe_accweightsum_sh_lsb 0
+#define    p_reg_p_dcoe_accweightcurr   0xF0DC
+#define reg_p_dcoe_accweightcurr_pos 0
+#define reg_p_dcoe_accweightcurr_len 8
+#define reg_p_dcoe_accweightcurr_lsb 0
+#define    p_reg_dcoe_apply_rd  0xF0DF
+#define reg_dcoe_apply_rd_pos 0
+#define reg_dcoe_apply_rd_len 1
+#define reg_dcoe_apply_rd_lsb 0
+#define    r_reg_dcoe_apply_i   0xF0E0
+#define reg_dcoe_apply_i_pos 0
+#define reg_dcoe_apply_i_len 8
+#define reg_dcoe_apply_i_lsb 0
+#define    r_reg_dcoe_apply_q   0xF0E1
+#define reg_dcoe_apply_q_pos 0
+#define reg_dcoe_apply_q_len 8
+#define reg_dcoe_apply_q_lsb 0
+#define    p_reg_p_dcrm_en  0xF0E2
+#define reg_p_dcrm_en_pos 0
+#define reg_p_dcrm_en_len 1
+#define reg_p_dcrm_en_lsb 0
+#define    p_reg_p_dcrm_fir 0xF0E3
+#define reg_p_dcrm_fir_pos 0
+#define reg_p_dcrm_fir_len 1
+#define reg_p_dcrm_fir_lsb 0
+#define    p_reg_p_dcrm_log2_firlen 0xF0E4
+#define reg_p_dcrm_log2_firlen_pos 0
+#define reg_p_dcrm_log2_firlen_len 3
+#define reg_p_dcrm_log2_firlen_lsb 0
+#define    r_reg_dcoe_apply_fir_i   0xF0E5
+#define reg_dcoe_apply_fir_i_pos 0
+#define reg_dcoe_apply_fir_i_len 8
+#define reg_dcoe_apply_fir_i_lsb 0
+#define    r_reg_dcoe_apply_fir_q   0xF0E6
+#define reg_dcoe_apply_fir_q_pos 0
+#define reg_dcoe_apply_fir_q_len 8
+#define reg_dcoe_apply_fir_q_lsb 0
+#define    p_reg_p_dcrm_force_en    0xF0E7
+#define reg_p_dcrm_force_en_pos 0
+#define reg_p_dcrm_force_en_len 1
+#define reg_p_dcrm_force_en_lsb 0
+#define    p_reg_p_dcrm_force_value_i   0xF0E8
+#define reg_p_dcrm_force_value_i_pos 0
+#define reg_p_dcrm_force_value_i_len 8
+#define reg_p_dcrm_force_value_i_lsb 0
+#define    p_reg_p_dcrm_force_value_q   0xF0E9
+#define reg_p_dcrm_force_value_q_pos 0
+#define reg_p_dcrm_force_value_q_len 8
+#define reg_p_dcrm_force_value_q_lsb 0
+#define    p_reg_p_iqip_en  0xF0EA
+#define reg_p_iqip_en_pos 0
+#define reg_p_iqip_en_len 1
+#define reg_p_iqip_en_lsb 0
+#define    p_reg_p_iqip_rst 0xF0EB
+#define reg_p_iqip_rst_pos 0
+#define reg_p_iqip_rst_len 1
+#define reg_p_iqip_rst_lsb 0
+#define    p_reg_iqip_mu_ld 0xF0EC
+#define reg_iqip_mu_ld_pos 0
+#define reg_iqip_mu_ld_len 1
+#define reg_iqip_mu_ld_lsb 0
+#define    p_reg_p_iqip_mu_7_0  0xF0ED
+#define reg_p_iqip_mu_7_0_pos 0
+#define reg_p_iqip_mu_7_0_len 8
+#define reg_p_iqip_mu_7_0_lsb 0
+#define    p_reg_p_iqip_mu_11_8 0xF0EE
+#define reg_p_iqip_mu_11_8_pos 0
+#define reg_p_iqip_mu_11_8_len 4
+#define reg_p_iqip_mu_11_8_lsb 8
+#define    p_reg_iqip_gs_ld 0xF0EF
+#define reg_iqip_gs_ld_pos 0
+#define reg_iqip_gs_ld_len 1
+#define reg_iqip_gs_ld_lsb 0
+#define    p_reg_p_iqip_gsnums  0xF0F0
+#define reg_p_iqip_gsnums_pos 0
+#define reg_p_iqip_gsnums_len 4
+#define reg_p_iqip_gsnums_lsb 0
+#define    p_reg_p_iqip_gsites_7_0  0xF0F1
+#define reg_p_iqip_gsites_7_0_pos 0
+#define reg_p_iqip_gsites_7_0_len 8
+#define reg_p_iqip_gsites_7_0_lsb 0
+#define    p_reg_p_iqip_gsites_15_8 0xF0F2
+#define reg_p_iqip_gsites_15_8_pos 0
+#define reg_p_iqip_gsites_15_8_len 8
+#define reg_p_iqip_gsites_15_8_lsb 8
+#define    p_reg_iqip_w_ld  0xF0F3
+#define reg_iqip_w_ld_pos 0
+#define reg_iqip_w_ld_len 1
+#define reg_iqip_w_ld_lsb 0
+#define    p_reg_p_iqip_w_re_7_0    0xF0F4
+#define reg_p_iqip_w_re_7_0_pos 0
+#define reg_p_iqip_w_re_7_0_len 8
+#define reg_p_iqip_w_re_7_0_lsb 0
+#define    p_reg_p_iqip_w_re_15_8   0xF0F5
+#define reg_p_iqip_w_re_15_8_pos 0
+#define reg_p_iqip_w_re_15_8_len 8
+#define reg_p_iqip_w_re_15_8_lsb 8
+#define    p_reg_p_iqip_w_re_16 0xF0F6
+#define reg_p_iqip_w_re_16_pos 0
+#define reg_p_iqip_w_re_16_len 1
+#define reg_p_iqip_w_re_16_lsb 16
+#define    p_reg_p_iqip_w_im_7_0    0xF0F7
+#define reg_p_iqip_w_im_7_0_pos 0
+#define reg_p_iqip_w_im_7_0_len 8
+#define reg_p_iqip_w_im_7_0_lsb 0
+#define    p_reg_p_iqip_w_im_15_8   0xF0F8
+#define reg_p_iqip_w_im_15_8_pos 0
+#define reg_p_iqip_w_im_15_8_len 8
+#define reg_p_iqip_w_im_15_8_lsb 8
+#define    p_reg_p_iqip_w_im_16 0xF0F9
+#define reg_p_iqip_w_im_16_pos 0
+#define reg_p_iqip_w_im_16_len 1
+#define reg_p_iqip_w_im_16_lsb 16
+#define    p_reg_iqip_accnums_rd    0xF0FA
+#define reg_iqip_accnums_rd_pos 0
+#define reg_iqip_accnums_rd_len 1
+#define reg_iqip_accnums_rd_lsb 0
+#define    p_reg_p_iqip_accnums 0xF0FB
+#define reg_p_iqip_accnums_pos 0
+#define reg_p_iqip_accnums_len 2
+#define reg_p_iqip_accnums_lsb 0
+#define    p_reg_iqip_accnums_rdy   0xF0FC
+#define reg_iqip_accnums_rdy_pos 0
+#define reg_iqip_accnums_rdy_len 1
+#define reg_iqip_accnums_rdy_lsb 0
+#define    r_reg_r_iqip_wacc_re_7_0 0xF0FD
+#define reg_r_iqip_wacc_re_7_0_pos 0
+#define reg_r_iqip_wacc_re_7_0_len 8
+#define reg_r_iqip_wacc_re_7_0_lsb 0
+#define    r_reg_r_iqip_wacc_re_15_8    0xF0FE
+#define reg_r_iqip_wacc_re_15_8_pos 0
+#define reg_r_iqip_wacc_re_15_8_len 8
+#define reg_r_iqip_wacc_re_15_8_lsb 8
+#define    r_reg_r_iqip_wacc_re_16  0xF0FF
+#define reg_r_iqip_wacc_re_16_pos 0
+#define reg_r_iqip_wacc_re_16_len 1
+#define reg_r_iqip_wacc_re_16_lsb 16
+#define    r_reg_r_iqip_wacc_im_7_0 0xF100
+#define reg_r_iqip_wacc_im_7_0_pos 0
+#define reg_r_iqip_wacc_im_7_0_len 8
+#define reg_r_iqip_wacc_im_7_0_lsb 0
+#define    r_reg_r_iqip_wacc_im_15_8    0xF101
+#define reg_r_iqip_wacc_im_15_8_pos 0
+#define reg_r_iqip_wacc_im_15_8_len 8
+#define reg_r_iqip_wacc_im_15_8_lsb 8
+#define    r_reg_r_iqip_wacc_im_16  0xF102
+#define reg_r_iqip_wacc_im_16_pos 0
+#define reg_r_iqip_wacc_im_16_len 1
+#define reg_r_iqip_wacc_im_16_lsb 16
+#define    r_reg_r_iqip_out2cacc_re_7_0 0xF103
+#define reg_r_iqip_out2cacc_re_7_0_pos 0
+#define reg_r_iqip_out2cacc_re_7_0_len 8
+#define reg_r_iqip_out2cacc_re_7_0_lsb 0
+#define    r_reg_r_iqip_out2cacc_re_15_8    0xF104
+#define reg_r_iqip_out2cacc_re_15_8_pos 0
+#define reg_r_iqip_out2cacc_re_15_8_len 8
+#define reg_r_iqip_out2cacc_re_15_8_lsb 8
+#define    r_reg_r_iqip_out2cacc_re_21_16   0xF105
+#define reg_r_iqip_out2cacc_re_21_16_pos 0
+#define reg_r_iqip_out2cacc_re_21_16_len 6
+#define reg_r_iqip_out2cacc_re_21_16_lsb 16
+#define    r_reg_r_iqip_out2cacc_im_7_0 0xF106
+#define reg_r_iqip_out2cacc_im_7_0_pos 0
+#define reg_r_iqip_out2cacc_im_7_0_len 8
+#define reg_r_iqip_out2cacc_im_7_0_lsb 0
+#define    r_reg_r_iqip_out2cacc_im_15_8    0xF107
+#define reg_r_iqip_out2cacc_im_15_8_pos 0
+#define reg_r_iqip_out2cacc_im_15_8_len 8
+#define reg_r_iqip_out2cacc_im_15_8_lsb 8
+#define    r_reg_r_iqip_out2cacc_im_21_16   0xF108
+#define reg_r_iqip_out2cacc_im_21_16_pos 0
+#define reg_r_iqip_out2cacc_im_21_16_len 6
+#define reg_r_iqip_out2cacc_im_21_16_lsb 16
+#define    p_reg_mccid_ccif0_scstrobe   0xF109
+#define reg_mccid_ccif0_scstrobe_pos 0
+#define reg_mccid_ccif0_scstrobe_len 7
+#define reg_mccid_ccif0_scstrobe_lsb 0
+#define    p_reg_mccid_cciftrigger  0xF10A
+#define reg_mccid_cciftrigger_pos 0
+#define reg_mccid_cciftrigger_len 1
+#define reg_mccid_cciftrigger_lsb 0
+#define    p_reg_mccid_ccif1_scstrobe   0xF10B
+#define reg_mccid_ccif1_scstrobe_pos 0
+#define reg_mccid_ccif1_scstrobe_len 7
+#define reg_mccid_ccif1_scstrobe_lsb 0
+#define    p_reg_mccid_ccif0_fcwccif_7_0    0xF10E
+#define reg_mccid_ccif0_fcwccif_7_0_pos 0
+#define reg_mccid_ccif0_fcwccif_7_0_len 8
+#define reg_mccid_ccif0_fcwccif_7_0_lsb 0
+#define    p_reg_mccid_ccif0_fcwccif_13_8   0xF10F
+#define reg_mccid_ccif0_fcwccif_13_8_pos 0
+#define reg_mccid_ccif0_fcwccif_13_8_len 6
+#define reg_mccid_ccif0_fcwccif_13_8_lsb 8
+#define    p_reg_mccid_ccif0_state  0xF110
+#define reg_mccid_ccif0_state_pos 0
+#define reg_mccid_ccif0_state_len 1
+#define reg_mccid_ccif0_state_lsb 0
+#define    p_reg_mccid_ccif0_acistate   0xF111
+#define reg_mccid_ccif0_acistate_pos 0
+#define reg_mccid_ccif0_acistate_len 1
+#define reg_mccid_ccif0_acistate_lsb 0
+#define    p_reg_mccid_ccif1_fcwccif_7_0    0xF112
+#define reg_mccid_ccif1_fcwccif_7_0_pos 0
+#define reg_mccid_ccif1_fcwccif_7_0_len 8
+#define reg_mccid_ccif1_fcwccif_7_0_lsb 0
+#define    p_reg_mccid_ccif1_fcwccif_13_8   0xF113
+#define reg_mccid_ccif1_fcwccif_13_8_pos 0
+#define reg_mccid_ccif1_fcwccif_13_8_len 6
+#define reg_mccid_ccif1_fcwccif_13_8_lsb 8
+#define    p_reg_mccid_ccif1_state  0xF114
+#define reg_mccid_ccif1_state_pos 0
+#define reg_mccid_ccif1_state_len 1
+#define reg_mccid_ccif1_state_lsb 0
+#define    p_reg_mccid_ccif1_acistate   0xF115
+#define reg_mccid_ccif1_acistate_pos 0
+#define reg_mccid_ccif1_acistate_len 1
+#define reg_mccid_ccif1_acistate_lsb 0
+#define    r_reg_r_acif_saturate    0xF117
+#define reg_r_acif_saturate_pos 0
+#define reg_r_acif_saturate_len 8
+#define reg_r_acif_saturate_lsb 0
+#define    p_reg_tmr_timer0_threshold_7_0   0xF118
+#define reg_tmr_timer0_threshold_7_0_pos 0
+#define reg_tmr_timer0_threshold_7_0_len 8
+#define reg_tmr_timer0_threshold_7_0_lsb 0
+#define    p_reg_tmr_timer0_threshold_15_8  0xF119
+#define reg_tmr_timer0_threshold_15_8_pos 0
+#define reg_tmr_timer0_threshold_15_8_len 8
+#define reg_tmr_timer0_threshold_15_8_lsb 8
+#define    p_reg_tmr_timer0_enable  0xF11A
+#define reg_tmr_timer0_enable_pos 0
+#define reg_tmr_timer0_enable_len 1
+#define reg_tmr_timer0_enable_lsb 0
+#define    p_reg_tmr_timer0_clk_sel 0xF11B
+#define reg_tmr_timer0_clk_sel_pos 0
+#define reg_tmr_timer0_clk_sel_len 1
+#define reg_tmr_timer0_clk_sel_lsb 0
+#define    p_reg_tmr_timer0_int 0xF11C
+#define reg_tmr_timer0_int_pos 0
+#define reg_tmr_timer0_int_len 1
+#define reg_tmr_timer0_int_lsb 0
+#define    p_reg_tmr_timer0_rst 0xF11D
+#define reg_tmr_timer0_rst_pos 0
+#define reg_tmr_timer0_rst_len 1
+#define reg_tmr_timer0_rst_lsb 0
+#define    r_reg_tmr_timer0_count_7_0   0xF11E
+#define reg_tmr_timer0_count_7_0_pos 0
+#define reg_tmr_timer0_count_7_0_len 8
+#define reg_tmr_timer0_count_7_0_lsb 0
+#define    r_reg_tmr_timer0_count_15_8  0xF11F
+#define reg_tmr_timer0_count_15_8_pos 0
+#define reg_tmr_timer0_count_15_8_len 8
+#define reg_tmr_timer0_count_15_8_lsb 8
+#define    p_reg_suspend    0xF120
+#define reg_suspend_pos 0
+#define reg_suspend_len 1
+#define reg_suspend_lsb 0
+#define    p_reg_suspend_rdy    0xF121
+#define reg_suspend_rdy_pos 0
+#define reg_suspend_rdy_len 1
+#define reg_suspend_rdy_lsb 0
+#define    p_reg_resume 0xF122
+#define reg_resume_pos 0
+#define reg_resume_len 1
+#define reg_resume_lsb 0
+#define    p_reg_resume_rdy 0xF123
+#define reg_resume_rdy_pos 0
+#define reg_resume_rdy_len 1
+#define reg_resume_rdy_lsb 0
+#define    p_reg_gp_trigger 0xF124
+#define reg_gp_trigger_pos 0
+#define reg_gp_trigger_len 1
+#define reg_gp_trigger_lsb 0
+#define    p_reg_trigger_sel    0xF125
+#define reg_trigger_sel_pos 0
+#define reg_trigger_sel_len 2
+#define reg_trigger_sel_lsb 0
+#define    p_reg_debug_ofdm 0xF126
+#define reg_debug_ofdm_pos 0
+#define reg_debug_ofdm_len 2
+#define reg_debug_ofdm_lsb 0
+#define    p_reg_trigger_module_sel 0xF127
+#define reg_trigger_module_sel_pos 0
+#define reg_trigger_module_sel_len 6
+#define reg_trigger_module_sel_lsb 0
+#define    p_reg_trigger_set_sel    0xF128
+#define reg_trigger_set_sel_pos 0
+#define reg_trigger_set_sel_len 6
+#define reg_trigger_set_sel_lsb 0
+#define    p_reg_fw_int_mask_n  0xF129
+#define reg_fw_int_mask_n_pos 0
+#define reg_fw_int_mask_n_len 1
+#define reg_fw_int_mask_n_lsb 0
+#define    p_reg_dioif_rst  0xF12A
+#define reg_dioif_rst_pos 0
+#define reg_dioif_rst_len 1
+#define reg_dioif_rst_lsb 0
+#define    p_reg_debug_group    0xF12B
+#define reg_debug_group_pos 0
+#define reg_debug_group_len 4
+#define reg_debug_group_lsb 0
+#define    p_reg_odbg_clk_sel   0xF12C
+#define reg_odbg_clk_sel_pos 0
+#define reg_odbg_clk_sel_len 3
+#define reg_odbg_clk_sel_lsb 0
+#define    p_reg_p_ccif_shift_fre   0xF12F
+#define reg_p_ccif_shift_fre_pos 0
+#define reg_p_ccif_shift_fre_len 1
+#define reg_p_ccif_shift_fre_lsb 0
+#define    p_reg_p_ccif_bandwidth_factor    0xF130
+#define reg_p_ccif_bandwidth_factor_pos 0
+#define reg_p_ccif_bandwidth_factor_len 3
+#define reg_p_ccif_bandwidth_factor_lsb 0
+#define    p_reg_ccif_rst   0xF131
+#define reg_ccif_rst_pos 0
+#define reg_ccif_rst_len 1
+#define reg_ccif_rst_lsb 0
+#define    p_reg_p_ccif_min_bandwidth   0xF132
+#define reg_p_ccif_min_bandwidth_pos 0
+#define reg_p_ccif_min_bandwidth_len 7
+#define reg_p_ccif_min_bandwidth_lsb 0
+#define    p_reg_ccif_bq0_state 0xF133
+#define reg_ccif_bq0_state_pos 0
+#define reg_ccif_bq0_state_len 1
+#define reg_ccif_bq0_state_lsb 0
+#define    p_reg_ccif_bq0_outputscaling 0xF134
+#define reg_ccif_bq0_outputscaling_pos 0
+#define reg_ccif_bq0_outputscaling_len 5
+#define reg_ccif_bq0_outputscaling_lsb 0
+#define    p_reg_ccif_bq1_state 0xF135
+#define reg_ccif_bq1_state_pos 0
+#define reg_ccif_bq1_state_len 1
+#define reg_ccif_bq1_state_lsb 0
+#define    p_reg_ccif_bq1_outputscaling 0xF136
+#define reg_ccif_bq1_outputscaling_pos 0
+#define reg_ccif_bq1_outputscaling_len 5
+#define reg_ccif_bq1_outputscaling_lsb 0
+#define    p_reg_ccif_bq0_a1_7_0    0xF137
+#define reg_ccif_bq0_a1_7_0_pos 0
+#define reg_ccif_bq0_a1_7_0_len 8
+#define reg_ccif_bq0_a1_7_0_lsb 0
+#define    p_reg_ccif_bq0_a1_13_8   0xF138
+#define reg_ccif_bq0_a1_13_8_pos 0
+#define reg_ccif_bq0_a1_13_8_len 6
+#define reg_ccif_bq0_a1_13_8_lsb 8
+#define    p_reg_ccif_bq1_a1_7_0    0xF139
+#define reg_ccif_bq1_a1_7_0_pos 0
+#define reg_ccif_bq1_a1_7_0_len 8
+#define reg_ccif_bq1_a1_7_0_lsb 0
+#define    p_reg_ccif_bq1_a1_13_8   0xF13A
+#define reg_ccif_bq1_a1_13_8_pos 0
+#define reg_ccif_bq1_a1_13_8_len 6
+#define reg_ccif_bq1_a1_13_8_lsb 8
+#define    p_reg_ccif_bq0_b1_7_0    0xF13B
+#define reg_ccif_bq0_b1_7_0_pos 0
+#define reg_ccif_bq0_b1_7_0_len 8
+#define reg_ccif_bq0_b1_7_0_lsb 0
+#define    p_reg_ccif_bq0_b1_13_8   0xF13C
+#define reg_ccif_bq0_b1_13_8_pos 0
+#define reg_ccif_bq0_b1_13_8_len 6
+#define reg_ccif_bq0_b1_13_8_lsb 8
+#define    p_reg_ccif_bq1_b1_7_0    0xF13D
+#define reg_ccif_bq1_b1_7_0_pos 0
+#define reg_ccif_bq1_b1_7_0_len 8
+#define reg_ccif_bq1_b1_7_0_lsb 0
+#define    p_reg_ccif_bq1_b1_13_8   0xF13E
+#define reg_ccif_bq1_b1_13_8_pos 0
+#define reg_ccif_bq1_b1_13_8_len 6
+#define reg_ccif_bq1_b1_13_8_lsb 8
+#define    p_reg_ccif_bq0_b2_7_0    0xF13F
+#define reg_ccif_bq0_b2_7_0_pos 0
+#define reg_ccif_bq0_b2_7_0_len 8
+#define reg_ccif_bq0_b2_7_0_lsb 0
+#define    p_reg_ccif_bq0_b2_13_8   0xF140
+#define reg_ccif_bq0_b2_13_8_pos 0
+#define reg_ccif_bq0_b2_13_8_len 6
+#define reg_ccif_bq0_b2_13_8_lsb 8
+#define    p_reg_ccif_bq1_b2_7_0    0xF141
+#define reg_ccif_bq1_b2_7_0_pos 0
+#define reg_ccif_bq1_b2_7_0_len 8
+#define reg_ccif_bq1_b2_7_0_lsb 0
+#define    p_reg_ccif_bq1_b2_13_8   0xF142
+#define reg_ccif_bq1_b2_13_8_pos 0
+#define reg_ccif_bq1_b2_13_8_len 6
+#define reg_ccif_bq1_b2_13_8_lsb 8
+#define    p_reg_ccif_debug_rst 0xF143
+#define reg_ccif_debug_rst_pos 0
+#define reg_ccif_debug_rst_len 1
+#define reg_ccif_debug_rst_lsb 0
+#define    p_reg_mccid_defaultccifscstrobe  0xF144
+#define reg_mccid_defaultccifscstrobe_pos 0
+#define reg_mccid_defaultccifscstrobe_len 7
+#define reg_mccid_defaultccifscstrobe_lsb 0
+#define    p_reg_mccid_monitoringaci    0xF145
+#define reg_mccid_monitoringaci_pos 0
+#define reg_mccid_monitoringaci_len 1
+#define reg_mccid_monitoringaci_lsb 0
+#define    p_reg_mccid_ispassmode   0xF146
+#define reg_mccid_ispassmode_pos 0
+#define reg_mccid_ispassmode_len 1
+#define reg_mccid_ispassmode_lsb 0
+#define    p_reg_mccid_issteadystatemode    0xF147
+#define reg_mccid_issteadystatemode_pos 0
+#define reg_mccid_issteadystatemode_len 1
+#define reg_mccid_issteadystatemode_lsb 0
+#define    p_reg_mccid_fixedgaincmp 0xF148
+#define reg_mccid_fixedgaincmp_pos 0
+#define reg_mccid_fixedgaincmp_len 1
+#define reg_mccid_fixedgaincmp_lsb 0
+#define    p_reg_mccid_misscounter_reset    0xF149
+#define reg_mccid_misscounter_reset_pos 0
+#define reg_mccid_misscounter_reset_len 1
+#define reg_mccid_misscounter_reset_lsb 0
+#define    p_reg_mccid_acwgcheckcciexist    0xF14A
+#define reg_mccid_acwgcheckcciexist_pos 0
+#define reg_mccid_acwgcheckcciexist_len 1
+#define reg_mccid_acwgcheckcciexist_lsb 0
+#define    p_reg_mccid_acidone  0xF14B
+#define reg_mccid_acidone_pos 0
+#define reg_mccid_acidone_len 1
+#define reg_mccid_acidone_lsb 0
+#define    p_reg_mccid_sxdesiredpower_7_0   0xF14C
+#define reg_mccid_sxdesiredpower_7_0_pos 0
+#define reg_mccid_sxdesiredpower_7_0_len 8
+#define reg_mccid_sxdesiredpower_7_0_lsb 0
+#define    p_reg_mccid_sxdesiredpower_9_8   0xF14D
+#define reg_mccid_sxdesiredpower_9_8_pos 0
+#define reg_mccid_sxdesiredpower_9_8_len 2
+#define reg_mccid_sxdesiredpower_9_8_lsb 8
+#define    p_reg_mccid_defaultccitimertriggerno 0xF14E
+#define reg_mccid_defaultccitimertriggerno_pos 0
+#define reg_mccid_defaultccitimertriggerno_len 8
+#define reg_mccid_defaultccitimertriggerno_lsb 0
+#define    p_reg_mccid_detectedmaxtonecountshift    0xF14F
+#define reg_mccid_detectedmaxtonecountshift_pos 0
+#define reg_mccid_detectedmaxtonecountshift_len 3
+#define reg_mccid_detectedmaxtonecountshift_lsb 0
+#define    p_reg_mccid_moveffttoccif_en 0xF151
+#define reg_mccid_moveffttoccif_en_pos 0
+#define reg_mccid_moveffttoccif_en_len 1
+#define reg_mccid_moveffttoccif_en_lsb 0
+#define    p_reg_mccid_fftindextobfsfcwfactor_7_0   0xF152
+#define reg_mccid_fftindextobfsfcwfactor_7_0_pos 0
+#define reg_mccid_fftindextobfsfcwfactor_7_0_len 8
+#define reg_mccid_fftindextobfsfcwfactor_7_0_lsb 0
+#define    p_reg_mccid_fftindextobfsfcwfactor_9_8   0xF153
+#define reg_mccid_fftindextobfsfcwfactor_9_8_pos 0
+#define reg_mccid_fftindextobfsfcwfactor_9_8_len 2
+#define reg_mccid_fftindextobfsfcwfactor_9_8_lsb 8
+#define    p_reg_mccid_bfsfcwffttoindexfactor_7_0   0xF154
+#define reg_mccid_bfsfcwffttoindexfactor_7_0_pos 0
+#define reg_mccid_bfsfcwffttoindexfactor_7_0_len 8
+#define reg_mccid_bfsfcwffttoindexfactor_7_0_lsb 0
+#define    p_reg_mccid_bfsfcwffttoindexfactor_10_8  0xF155
+#define reg_mccid_bfsfcwffttoindexfactor_10_8_pos 0
+#define reg_mccid_bfsfcwffttoindexfactor_10_8_len 3
+#define reg_mccid_bfsfcwffttoindexfactor_10_8_lsb 8
+#define    p_reg_mccid_detectedaci  0xF156
+#define reg_mccid_detectedaci_pos 0
+#define reg_mccid_detectedaci_len 1
+#define reg_mccid_detectedaci_lsb 0
+#define    r_reg_mccid_filter_enable    0xF157
+#define reg_mccid_filter_enable_pos 0
+#define reg_mccid_filter_enable_len 1
+#define reg_mccid_filter_enable_lsb 0
+#define    p_reg_mccid_aciscstrobe  0xF158
+#define reg_mccid_aciscstrobe_pos 0
+#define reg_mccid_aciscstrobe_len 7
+#define reg_mccid_aciscstrobe_lsb 0
+#define    p_reg_mccid_scanningaci  0xF159
+#define reg_mccid_scanningaci_pos 0
+#define reg_mccid_scanningaci_len 1
+#define reg_mccid_scanningaci_lsb 0
+#define    p_reg_mccid_windowsizeacciwdcount_7_0    0xF15A
+#define reg_mccid_windowsizeacciwdcount_7_0_pos 0
+#define reg_mccid_windowsizeacciwdcount_7_0_len 8
+#define reg_mccid_windowsizeacciwdcount_7_0_lsb 0
+#define    p_reg_mccid_windowsizeacciwdcount_12_8   0xF15B
+#define reg_mccid_windowsizeacciwdcount_12_8_pos 0
+#define reg_mccid_windowsizeacciwdcount_12_8_len 5
+#define reg_mccid_windowsizeacciwdcount_12_8_lsb 8
+#define    p_reg_mccid_scannedacionly   0xF15C
+#define reg_mccid_scannedacionly_pos 0
+#define reg_mccid_scannedacionly_len 1
+#define reg_mccid_scannedacionly_lsb 0
+#define    p_reg_mccid_scfactor 0xF15D
+#define reg_mccid_scfactor_pos 0
+#define reg_mccid_scfactor_len 5
+#define reg_mccid_scfactor_lsb 0
+#define    p_reg_mccid_defaultevaluatingbandwidthfactor 0xF15E
+#define reg_mccid_defaultevaluatingbandwidthfactor_pos 0
+#define reg_mccid_defaultevaluatingbandwidthfactor_len 3
+#define reg_mccid_defaultevaluatingbandwidthfactor_lsb 0
+#define    p_reg_mccid_defaultacipowerlevel 0xF15F
+#define reg_mccid_defaultacipowerlevel_pos 0
+#define reg_mccid_defaultacipowerlevel_len 3
+#define reg_mccid_defaultacipowerlevel_lsb 0
+#define    r_reg_mccid_outputdagc1gain_7_0  0xF160
+#define reg_mccid_outputdagc1gain_7_0_pos 0
+#define reg_mccid_outputdagc1gain_7_0_len 8
+#define reg_mccid_outputdagc1gain_7_0_lsb 0
+#define    r_reg_mccid_outputdagc1gain_9_8  0xF161
+#define reg_mccid_outputdagc1gain_9_8_pos 0
+#define reg_mccid_outputdagc1gain_9_8_len 2
+#define reg_mccid_outputdagc1gain_9_8_lsb 8
+#define    r_reg_mccid_outputdagc1gainshift 0xF162
+#define reg_mccid_outputdagc1gainshift_pos 0
+#define reg_mccid_outputdagc1gainshift_len 4
+#define reg_mccid_outputdagc1gainshift_lsb 0
+#define    p_reg_mccid_defaultacwgcheckccipowerlevel    0xF163
+#define reg_mccid_defaultacwgcheckccipowerlevel_pos 0
+#define reg_mccid_defaultacwgcheckccipowerlevel_len 3
+#define reg_mccid_defaultacwgcheckccipowerlevel_lsb 0
+#define    p_reg_mccid_ccipowerlevelfactor  0xF166
+#define reg_mccid_ccipowerlevelfactor_pos 0
+#define reg_mccid_ccipowerlevelfactor_len 3
+#define reg_mccid_ccipowerlevelfactor_lsb 0
+#define    p_reg_mccid_scstrobesearchingrange   0xF167
+#define reg_mccid_scstrobesearchingrange_pos 0
+#define reg_mccid_scstrobesearchingrange_len 8
+#define reg_mccid_scstrobesearchingrange_lsb 0
+#define    p_reg_mccid_searchingno  0xF168
+#define reg_mccid_searchingno_pos 0
+#define reg_mccid_searchingno_len 6
+#define reg_mccid_searchingno_lsb 0
+#define    p_reg_mccid_scannedacifrequencyresolution    0xF169
+#define reg_mccid_scannedacifrequencyresolution_pos 0
+#define reg_mccid_scannedacifrequencyresolution_len 4
+#define reg_mccid_scannedacifrequencyresolution_lsb 0
+#define    p_reg_mccid_fft0_maskmaxtoneindex_7_0    0xF16A
+#define reg_mccid_fft0_maskmaxtoneindex_7_0_pos 0
+#define reg_mccid_fft0_maskmaxtoneindex_7_0_len 8
+#define reg_mccid_fft0_maskmaxtoneindex_7_0_lsb 0
+#define    p_reg_mccid_fft0_maskmaxtoneindex_12_8   0xF16B
+#define reg_mccid_fft0_maskmaxtoneindex_12_8_pos 0
+#define reg_mccid_fft0_maskmaxtoneindex_12_8_len 5
+#define reg_mccid_fft0_maskmaxtoneindex_12_8_lsb 8
+#define    p_reg_mccid_fft0_state   0xF16C
+#define reg_mccid_fft0_state_pos 0
+#define reg_mccid_fft0_state_len 1
+#define reg_mccid_fft0_state_lsb 0
+#define    p_reg_mccid_fft1_state   0xF16D
+#define reg_mccid_fft1_state_pos 0
+#define reg_mccid_fft1_state_len 1
+#define reg_mccid_fft1_state_lsb 0
+#define    p_reg_mccid_fft0_maskmintoneindex_7_0    0xF16E
+#define reg_mccid_fft0_maskmintoneindex_7_0_pos 0
+#define reg_mccid_fft0_maskmintoneindex_7_0_len 8
+#define reg_mccid_fft0_maskmintoneindex_7_0_lsb 0
+#define    p_reg_mccid_fft0_maskmintoneindex_12_8   0xF16F
+#define reg_mccid_fft0_maskmintoneindex_12_8_pos 0
+#define reg_mccid_fft0_maskmintoneindex_12_8_len 5
+#define reg_mccid_fft0_maskmintoneindex_12_8_lsb 8
+#define    p_reg_mccid_acipowerlevelfactor  0xF170
+#define reg_mccid_acipowerlevelfactor_pos 0
+#define reg_mccid_acipowerlevelfactor_len 3
+#define reg_mccid_acipowerlevelfactor_lsb 0
+#define    p_reg_mccid_fft1_maskmaxtoneindex_7_0    0xF171
+#define reg_mccid_fft1_maskmaxtoneindex_7_0_pos 0
+#define reg_mccid_fft1_maskmaxtoneindex_7_0_len 8
+#define reg_mccid_fft1_maskmaxtoneindex_7_0_lsb 0
+#define    p_reg_mccid_fft1_maskmaxtoneindex_12_8   0xF172
+#define reg_mccid_fft1_maskmaxtoneindex_12_8_pos 0
+#define reg_mccid_fft1_maskmaxtoneindex_12_8_len 5
+#define reg_mccid_fft1_maskmaxtoneindex_12_8_lsb 8
+#define    p_reg_mccid_fft1_maskmintoneindex_7_0    0xF173
+#define reg_mccid_fft1_maskmintoneindex_7_0_pos 0
+#define reg_mccid_fft1_maskmintoneindex_7_0_len 8
+#define reg_mccid_fft1_maskmintoneindex_7_0_lsb 0
+#define    p_reg_mccid_fft1_maskmintoneindex_12_8   0xF174
+#define reg_mccid_fft1_maskmintoneindex_12_8_pos 0
+#define reg_mccid_fft1_maskmintoneindex_12_8_len 5
+#define reg_mccid_fft1_maskmintoneindex_12_8_lsb 8
+#define    p_reg_mccid_reset    0xF175
+#define reg_mccid_reset_pos 0
+#define reg_mccid_reset_len 1
+#define reg_mccid_reset_lsb 0
+#define    p_reg_mccid_gaincmpreset 0xF176
+#define reg_mccid_gaincmpreset_pos 0
+#define reg_mccid_gaincmpreset_len 1
+#define reg_mccid_gaincmpreset_lsb 0
+#define    p_reg_mccid_acwgreset    0xF177
+#define reg_mccid_acwgreset_pos 0
+#define reg_mccid_acwgreset_len 1
+#define reg_mccid_acwgreset_lsb 0
+#define    p_reg_mccid_ccif0_ofsmstateenable    0xF178
+#define reg_mccid_ccif0_ofsmstateenable_pos 0
+#define reg_mccid_ccif0_ofsmstateenable_len 1
+#define reg_mccid_ccif0_ofsmstateenable_lsb 0
+#define    p_reg_mccid_ccif1_ofsmstateenable    0xF179
+#define reg_mccid_ccif1_ofsmstateenable_pos 0
+#define reg_mccid_ccif1_ofsmstateenable_len 1
+#define reg_mccid_ccif1_ofsmstateenable_lsb 0
+#define    p_reg_mccid_fft0_ofsmstateenable 0xF17A
+#define reg_mccid_fft0_ofsmstateenable_pos 0
+#define reg_mccid_fft0_ofsmstateenable_len 1
+#define reg_mccid_fft0_ofsmstateenable_lsb 0
+#define    p_reg_mccid_fft1_ofsmstateenable 0xF17B
+#define reg_mccid_fft1_ofsmstateenable_pos 0
+#define reg_mccid_fft1_ofsmstateenable_len 1
+#define reg_mccid_fft1_ofsmstateenable_lsb 0
+#define    p_reg_mccid_fftfiltermaskchange  0xF17C
+#define reg_mccid_fftfiltermaskchange_pos 0
+#define reg_mccid_fftfiltermaskchange_len 1
+#define reg_mccid_fftfiltermaskchange_lsb 0
+#define    r_reg_mccid_maxacipowertone_7_0  0xF17D
+#define reg_mccid_maxacipowertone_7_0_pos 0
+#define reg_mccid_maxacipowertone_7_0_len 8
+#define reg_mccid_maxacipowertone_7_0_lsb 0
+#define    r_reg_mccid_maxacipowertone_12_8 0xF17E
+#define reg_mccid_maxacipowertone_12_8_pos 0
+#define reg_mccid_maxacipowertone_12_8_len 5
+#define reg_mccid_maxacipowertone_12_8_lsb 8
+#define    r_reg_mccid_ccidisappear 0xF17F
+#define reg_mccid_ccidisappear_pos 0
+#define reg_mccid_ccidisappear_len 1
+#define reg_mccid_ccidisappear_lsb 0
+#define    r_reg_mccid_ccilocatordone   0xF182
+#define reg_mccid_ccilocatordone_pos 0
+#define reg_mccid_ccilocatordone_len 1
+#define reg_mccid_ccilocatordone_lsb 0
+#define    p_reg_mccid_enablecciftrigger    0xF183
+#define reg_mccid_enablecciftrigger_pos 0
+#define reg_mccid_enablecciftrigger_len 1
+#define reg_mccid_enablecciftrigger_lsb 0
+#define    p_reg_mccid_disableacwglaunchevaluationbandwidthtrigger  0xF184
+#define reg_mccid_disableacwglaunchevaluationbandwidthtrigger_pos 0
+#define reg_mccid_disableacwglaunchevaluationbandwidthtrigger_len 1
+#define reg_mccid_disableacwglaunchevaluationbandwidthtrigger_lsb 0
+#define    p_reg_mccid_control_by_ofsm  0xF185
+#define reg_mccid_control_by_ofsm_pos 0
+#define reg_mccid_control_by_ofsm_len 1
+#define reg_mccid_control_by_ofsm_lsb 0
+#define    p_reg_mccid_ofsmcontrolccilocator    0xF186
+#define reg_mccid_ofsmcontrolccilocator_pos 0
+#define reg_mccid_ofsmcontrolccilocator_len 1
+#define reg_mccid_ofsmcontrolccilocator_lsb 0
+#define    p_reg_mccid_disablepotentialccitriggerccilocator 0xF187
+#define reg_mccid_disablepotentialccitriggerccilocator_pos 0
+#define reg_mccid_disablepotentialccitriggerccilocator_len 1
+#define reg_mccid_disablepotentialccitriggerccilocator_lsb 0
+#define    p_reg_mccid_ofsmcontrolccitesting    0xF188
+#define reg_mccid_ofsmcontrolccitesting_pos 0
+#define reg_mccid_ofsmcontrolccitesting_len 1
+#define reg_mccid_ofsmcontrolccitesting_lsb 0
+#define    p_reg_mccid_disableccitestingtriggercheckcci 0xF189
+#define reg_mccid_disableccitestingtriggercheckcci_pos 0
+#define reg_mccid_disableccitestingtriggercheckcci_len 1
+#define reg_mccid_disableccitestingtriggercheckcci_lsb 0
+#define    p_reg_mccid_ofsmcontrolacwgsetccifscstrobe   0xF18A
+#define reg_mccid_ofsmcontrolacwgsetccifscstrobe_pos 0
+#define reg_mccid_ofsmcontrolacwgsetccifscstrobe_len 1
+#define reg_mccid_ofsmcontrolacwgsetccifscstrobe_lsb 0
+#define    p_reg_mccid_disableacwgevaluatingbandwidthtrigger    0xF18B
+#define reg_mccid_disableacwgevaluatingbandwidthtrigger_pos 0
+#define reg_mccid_disableacwgevaluatingbandwidthtrigger_len 1
+#define reg_mccid_disableacwgevaluatingbandwidthtrigger_lsb 0
+#define    p_reg_mccid_ofsmcontrolevaluatingbandwidth   0xF18C
+#define reg_mccid_ofsmcontrolevaluatingbandwidth_pos 0
+#define reg_mccid_ofsmcontrolevaluatingbandwidth_len 1
+#define reg_mccid_ofsmcontrolevaluatingbandwidth_lsb 0
+#define    p_reg_mccid_ofsmcontrolscanningaci   0xF18D
+#define reg_mccid_ofsmcontrolscanningaci_pos 0
+#define reg_mccid_ofsmcontrolscanningaci_len 1
+#define reg_mccid_ofsmcontrolscanningaci_lsb 0
+#define    p_reg_mccid_disablescanningaci   0xF18E
+#define reg_mccid_disablescanningaci_pos 0
+#define reg_mccid_disablescanningaci_len 1
+#define reg_mccid_disablescanningaci_lsb 0
+#define    p_reg_mccid_disableacwgccidetecting  0xF18F
+#define reg_mccid_disableacwgccidetecting_pos 0
+#define reg_mccid_disableacwgccidetecting_len 1
+#define reg_mccid_disableacwgccidetecting_lsb 0
+#define    p_reg_mccid_ofsmcontrolccitimertrigger   0xF190
+#define reg_mccid_ofsmcontrolccitimertrigger_pos 0
+#define reg_mccid_ofsmcontrolccitimertrigger_len 1
+#define reg_mccid_ofsmcontrolccitimertrigger_lsb 0
+#define    p_reg_mccid_disableccitimertrigger   0xF191
+#define reg_mccid_disableccitimertrigger_pos 0
+#define reg_mccid_disableccitimertrigger_len 1
+#define reg_mccid_disableccitimertrigger_lsb 0
+#define    p_reg_mccid_ofsmdisableccitriggercounting    0xF192
+#define reg_mccid_ofsmdisableccitriggercounting_pos 0
+#define reg_mccid_ofsmdisableccitriggercounting_len 1
+#define reg_mccid_ofsmdisableccitriggercounting_lsb 0
+#define    p_reg_mccid_enableccifilteraci   0xF193
+#define reg_mccid_enableccifilteraci_pos 0
+#define reg_mccid_enableccifilteraci_len 1
+#define reg_mccid_enableccifilteraci_lsb 0
+#define    p_reg_mccid_scannedfcwbfs_7_0    0xF194
+#define reg_mccid_scannedfcwbfs_7_0_pos 0
+#define reg_mccid_scannedfcwbfs_7_0_len 8
+#define reg_mccid_scannedfcwbfs_7_0_lsb 0
+#define    p_reg_mccid_scannedfcwbfs_13_8   0xF195
+#define reg_mccid_scannedfcwbfs_13_8_pos 0
+#define reg_mccid_scannedfcwbfs_13_8_len 6
+#define reg_mccid_scannedfcwbfs_13_8_lsb 8
+#define    p_reg_mccid_acwgevaluatingbandwidth  0xF196
+#define reg_mccid_acwgevaluatingbandwidth_pos 0
+#define reg_mccid_acwgevaluatingbandwidth_len 1
+#define reg_mccid_acwgevaluatingbandwidth_lsb 0
+#define    p_reg_mccid_acwglaunchevaluationbandwidth    0xF197
+#define reg_mccid_acwglaunchevaluationbandwidth_pos 0
+#define reg_mccid_acwglaunchevaluationbandwidth_len 1
+#define reg_mccid_acwglaunchevaluationbandwidth_lsb 0
+#define    p_reg_mccid_scannedcandidate 0xF198
+#define reg_mccid_scannedcandidate_pos 0
+#define reg_mccid_scannedcandidate_len 3
+#define reg_mccid_scannedcandidate_lsb 0
+#define    p_reg_mccid_scstrobesearchingcandidate   0xF199
+#define reg_mccid_scstrobesearchingcandidate_pos 0
+#define reg_mccid_scstrobesearchingcandidate_len 2
+#define reg_mccid_scstrobesearchingcandidate_lsb 0
+#define    p_reg_mccid_potentialcci 0xF19A
+#define reg_mccid_potentialcci_pos 0
+#define reg_mccid_potentialcci_len 1
+#define reg_mccid_potentialcci_lsb 0
+#define    p_reg_mccid_cciftimertrigger 0xF19B
+#define reg_mccid_cciftimertrigger_pos 0
+#define reg_mccid_cciftimertrigger_len 1
+#define reg_mccid_cciftimertrigger_lsb 0
+#define    p_reg_mccid_ccitesting   0xF19C
+#define reg_mccid_ccitesting_pos 0
+#define reg_mccid_ccitesting_len 1
+#define reg_mccid_ccitesting_lsb 0
+#define    p_reg_mccid_defaultccilocatormissno  0xF19D
+#define reg_mccid_defaultccilocatormissno_pos 0
+#define reg_mccid_defaultccilocatormissno_len 8
+#define reg_mccid_defaultccilocatormissno_lsb 0
+#define    p_reg_mccid_dagc1_use_despow 0xF19E
+#define reg_mccid_dagc1_use_despow_pos 0
+#define reg_mccid_dagc1_use_despow_len 1
+#define reg_mccid_dagc1_use_despow_lsb 0
+#define    p_reg_mccid_scannedacifrequencybegin_7_0 0xF19F
+#define reg_mccid_scannedacifrequencybegin_7_0_pos 0
+#define reg_mccid_scannedacifrequencybegin_7_0_len 8
+#define reg_mccid_scannedacifrequencybegin_7_0_lsb 0
+#define    p_reg_mccid_scannedacifrequencybegin_13_8    0xF1A0
+#define reg_mccid_scannedacifrequencybegin_13_8_pos 0
+#define reg_mccid_scannedacifrequencybegin_13_8_len 6
+#define reg_mccid_scannedacifrequencybegin_13_8_lsb 8
+#define    p_reg_mccid_scannedacifrequencyend_7_0   0xF1A1
+#define reg_mccid_scannedacifrequencyend_7_0_pos 0
+#define reg_mccid_scannedacifrequencyend_7_0_len 8
+#define reg_mccid_scannedacifrequencyend_7_0_lsb 0
+#define    p_reg_mccid_scannedacifrequencyend_13_8  0xF1A2
+#define reg_mccid_scannedacifrequencyend_13_8_pos 0
+#define reg_mccid_scannedacifrequencyend_13_8_len 6
+#define reg_mccid_scannedacifrequencyend_13_8_lsb 8
+#define    p_reg_bfs_fcw_7_0    0xF1A3
+#define reg_bfs_fcw_7_0_pos 0
+#define reg_bfs_fcw_7_0_len 8
+#define reg_bfs_fcw_7_0_lsb 0
+#define    p_reg_bfs_fcw_15_8   0xF1A4
+#define reg_bfs_fcw_15_8_pos 0
+#define reg_bfs_fcw_15_8_len 8
+#define reg_bfs_fcw_15_8_lsb 8
+#define    p_reg_bfs_fcw_22_16  0xF1A5
+#define reg_bfs_fcw_22_16_pos 0
+#define reg_bfs_fcw_22_16_len 7
+#define reg_bfs_fcw_22_16_lsb 16
+#define    p_reg_cfoe_fcw_inv   0xF1A6
+#define reg_cfoe_fcw_inv_pos 0
+#define reg_cfoe_fcw_inv_len 1
+#define reg_cfoe_fcw_inv_lsb 0
+#define    p_reg_bfs_0if    0xF1A7
+#define reg_bfs_0if_pos 0
+#define reg_bfs_0if_len 1
+#define reg_bfs_0if_lsb 0
+#define    p_reg_sadc_clk   0xF1A9
+#define reg_sadc_clk_pos 0
+#define reg_sadc_clk_len 1
+#define reg_sadc_clk_lsb 0
+#define    p_reg_sadc_tx    0xF1AA
+#define reg_sadc_tx_pos 0
+#define reg_sadc_tx_len 1
+#define reg_sadc_tx_lsb 0
+#define    p_reg_sadc_rx    0xF1AB
+#define reg_sadc_rx_pos 0
+#define reg_sadc_rx_len 1
+#define reg_sadc_rx_lsb 0
+#define    p_reg_sadc_cs    0xF1AC
+#define reg_sadc_cs_pos 0
+#define reg_sadc_cs_len 1
+#define reg_sadc_cs_lsb 0
+#define    p_reg_fix_fcw_7_0    0xF1AD
+#define reg_fix_fcw_7_0_pos 0
+#define reg_fix_fcw_7_0_len 8
+#define reg_fix_fcw_7_0_lsb 0
+#define    p_reg_fix_fcw_15_8   0xF1AE
+#define reg_fix_fcw_15_8_pos 0
+#define reg_fix_fcw_15_8_len 8
+#define reg_fix_fcw_15_8_lsb 8
+#define    p_reg_fix_fcw_22_16  0xF1AF
+#define reg_fix_fcw_22_16_pos 0
+#define reg_fix_fcw_22_16_len 7
+#define reg_fix_fcw_22_16_lsb 16
+#define    r_reg_bfs_fcw_offset_7_0 0xF1B0
+#define reg_bfs_fcw_offset_7_0_pos 0
+#define reg_bfs_fcw_offset_7_0_len 8
+#define reg_bfs_fcw_offset_7_0_lsb 0
+#define    r_reg_bfs_fcw_offset_15_8    0xF1B1
+#define reg_bfs_fcw_offset_15_8_pos 0
+#define reg_bfs_fcw_offset_15_8_len 8
+#define reg_bfs_fcw_offset_15_8_lsb 8
+#define    r_reg_bfs_fcw_offset_22_16   0xF1B2
+#define reg_bfs_fcw_offset_22_16_pos 0
+#define reg_bfs_fcw_offset_22_16_len 7
+#define reg_bfs_fcw_offset_22_16_lsb 16
+#define    r_bfs_fcw_q_7_0  0xF1B3
+#define bfs_fcw_q_7_0_pos 0
+#define bfs_fcw_q_7_0_len 8
+#define bfs_fcw_q_7_0_lsb 0
+#define    r_bfs_fcw_q_15_8 0xF1B4
+#define bfs_fcw_q_15_8_pos 0
+#define bfs_fcw_q_15_8_len 8
+#define bfs_fcw_q_15_8_lsb 8
+#define    r_bfs_fcw_q_22_16    0xF1B5
+#define bfs_fcw_q_22_16_pos 0
+#define bfs_fcw_q_22_16_len 7
+#define bfs_fcw_q_22_16_lsb 16
+#define    p_reg_dagc3_use_despow   0xF1B6
+#define reg_dagc3_use_despow_pos 0
+#define reg_dagc3_use_despow_len 1
+#define reg_dagc3_use_despow_lsb 0
+#define    p_reg_dagc3_log_2_accumulate 0xF1B7
+#define reg_dagc3_log_2_accumulate_pos 0
+#define reg_dagc3_log_2_accumulate_len 5
+#define reg_dagc3_log_2_accumulate_lsb 0
+#define    p_reg_dagc3_desired_level_7_0    0xF1BC
+#define reg_dagc3_desired_level_7_0_pos 0
+#define reg_dagc3_desired_level_7_0_len 8
+#define reg_dagc3_desired_level_7_0_lsb 0
+#define    p_reg_dagc3_desired_level_8  0xF1BD
+#define reg_dagc3_desired_level_8_pos 0
+#define reg_dagc3_desired_level_8_len 1
+#define reg_dagc3_desired_level_8_lsb 8
+#define    p_reg_dagc3_apply_delay  0xF1BE
+#define reg_dagc3_apply_delay_pos 0
+#define reg_dagc3_apply_delay_len 7
+#define reg_dagc3_apply_delay_lsb 0
+#define    p_reg_dagc3_bp_scale 0xF1BF
+#define reg_dagc3_bp_scale_pos 0
+#define reg_dagc3_bp_scale_len 3
+#define reg_dagc3_bp_scale_lsb 0
+#define    p_reg_dagc3_in_sat_cnt_7_0   0xF1C0
+#define reg_dagc3_in_sat_cnt_7_0_pos 0
+#define reg_dagc3_in_sat_cnt_7_0_len 8
+#define reg_dagc3_in_sat_cnt_7_0_lsb 0
+#define    p_reg_dagc3_in_sat_cnt_15_8  0xF1C1
+#define reg_dagc3_in_sat_cnt_15_8_pos 0
+#define reg_dagc3_in_sat_cnt_15_8_len 8
+#define reg_dagc3_in_sat_cnt_15_8_lsb 8
+#define    p_reg_dagc3_in_sat_cnt_23_16 0xF1C2
+#define reg_dagc3_in_sat_cnt_23_16_pos 0
+#define reg_dagc3_in_sat_cnt_23_16_len 8
+#define reg_dagc3_in_sat_cnt_23_16_lsb 16
+#define    p_reg_dagc3_in_sat_cnt_31_24 0xF1C3
+#define reg_dagc3_in_sat_cnt_31_24_pos 0
+#define reg_dagc3_in_sat_cnt_31_24_len 8
+#define reg_dagc3_in_sat_cnt_31_24_lsb 24
+#define    p_reg_dagc3_out_sat_cnt_7_0  0xF1C4
+#define reg_dagc3_out_sat_cnt_7_0_pos 0
+#define reg_dagc3_out_sat_cnt_7_0_len 8
+#define reg_dagc3_out_sat_cnt_7_0_lsb 0
+#define    p_reg_dagc3_out_sat_cnt_15_8 0xF1C5
+#define reg_dagc3_out_sat_cnt_15_8_pos 0
+#define reg_dagc3_out_sat_cnt_15_8_len 8
+#define reg_dagc3_out_sat_cnt_15_8_lsb 8
+#define    p_reg_dagc3_out_sat_cnt_23_16    0xF1C6
+#define reg_dagc3_out_sat_cnt_23_16_pos 0
+#define reg_dagc3_out_sat_cnt_23_16_len 8
+#define reg_dagc3_out_sat_cnt_23_16_lsb 16
+#define    p_reg_dagc3_out_sat_cnt_31_24    0xF1C7
+#define reg_dagc3_out_sat_cnt_31_24_pos 0
+#define reg_dagc3_out_sat_cnt_31_24_len 8
+#define reg_dagc3_out_sat_cnt_31_24_lsb 24
+#define    r_bfs_dagc3_multiplier_7_0   0xF1C8
+#define bfs_dagc3_multiplier_7_0_pos 0
+#define bfs_dagc3_multiplier_7_0_len 8
+#define bfs_dagc3_multiplier_7_0_lsb 0
+#define    r_bfs_dagc3_multiplier_15_8  0xF1C9
+#define bfs_dagc3_multiplier_15_8_pos 0
+#define bfs_dagc3_multiplier_15_8_len 8
+#define bfs_dagc3_multiplier_15_8_lsb 8
+#define    r_bfs_dagc3_right_shift_bits 0xF1CA
+#define bfs_dagc3_right_shift_bits_pos 0
+#define bfs_dagc3_right_shift_bits_len 4
+#define bfs_dagc3_right_shift_bits_lsb 0
+#define    p_reg_dagc3_fixed_gain_7_0   0xF1CB
+#define reg_dagc3_fixed_gain_7_0_pos 0
+#define reg_dagc3_fixed_gain_7_0_len 8
+#define reg_dagc3_fixed_gain_7_0_lsb 0
+#define    p_reg_dagc3_fixed_gain_11_8  0xF1CC
+#define reg_dagc3_fixed_gain_11_8_pos 0
+#define reg_dagc3_fixed_gain_11_8_len 4
+#define reg_dagc3_fixed_gain_11_8_lsb 8
+#define    p_reg_f_adc_7_0  0xF1CD
+#define reg_f_adc_7_0_pos 0
+#define reg_f_adc_7_0_len 8
+#define reg_f_adc_7_0_lsb 0
+#define    p_reg_f_adc_15_8 0xF1CE
+#define reg_f_adc_15_8_pos 0
+#define reg_f_adc_15_8_len 8
+#define reg_f_adc_15_8_lsb 8
+#define    p_reg_f_adc_23_16    0xF1CF
+#define reg_f_adc_23_16_pos 0
+#define reg_f_adc_23_16_len 8
+#define reg_f_adc_23_16_lsb 16
+#define    p_reg_fste_frac_step_size_7_0    0xF1D0
+#define reg_fste_frac_step_size_7_0_pos 0
+#define reg_fste_frac_step_size_7_0_len 8
+#define reg_fste_frac_step_size_7_0_lsb 0
+#define    p_reg_fste_frac_step_size_15_8   0xF1D1
+#define reg_fste_frac_step_size_15_8_pos 0
+#define reg_fste_frac_step_size_15_8_len 8
+#define reg_fste_frac_step_size_15_8_lsb 8
+#define    p_reg_fste_frac_step_size_19_16  0xF1D2
+#define reg_fste_frac_step_size_19_16_pos 0
+#define reg_fste_frac_step_size_19_16_len 4
+#define reg_fste_frac_step_size_19_16_lsb 16
+#define    r_intp_mu_7_0    0xF1D3
+#define intp_mu_7_0_pos 0
+#define intp_mu_7_0_len 8
+#define intp_mu_7_0_lsb 0
+#define    r_intp_mu_15_8   0xF1D4
+#define intp_mu_15_8_pos 0
+#define intp_mu_15_8_len 8
+#define intp_mu_15_8_lsb 8
+#define    r_intp_mu_23_16  0xF1D5
+#define intp_mu_23_16_pos 0
+#define intp_mu_23_16_len 8
+#define intp_mu_23_16_lsb 16
+#define    r_intp_mu_25_24  0xF1D6
+#define intp_mu_25_24_pos 0
+#define intp_mu_25_24_len 2
+#define intp_mu_25_24_lsb 24
+#define    p_intp_muq_7_0   0xF1D7
+#define intp_muq_7_0_pos 0
+#define intp_muq_7_0_len 8
+#define intp_muq_7_0_lsb 0
+#define    p_intp_muq_15_8  0xF1D8
+#define intp_muq_15_8_pos 0
+#define intp_muq_15_8_len 8
+#define intp_muq_15_8_lsb 8
+#define    p_intp_muq_23_16 0xF1D9
+#define intp_muq_23_16_pos 0
+#define intp_muq_23_16_len 8
+#define intp_muq_23_16_lsb 16
+#define    p_reg_sfoe_inv   0xF1DA
+#define reg_sfoe_inv_pos 0
+#define reg_sfoe_inv_len 1
+#define reg_sfoe_inv_lsb 0
+#define    p_intp_ext_en    0xF1DB
+#define intp_ext_en_pos 0
+#define intp_ext_en_len 1
+#define intp_ext_en_lsb 0
+#define    r_intp_ext_done  0xF1DC
+#define intp_ext_done_pos 0
+#define intp_ext_done_len 1
+#define intp_ext_done_lsb 0
+#define    p_intp_ext_in_7_0    0xF1DD
+#define intp_ext_in_7_0_pos 0
+#define intp_ext_in_7_0_len 8
+#define intp_ext_in_7_0_lsb 0
+#define    p_intp_ext_in_15_8   0xF1DE
+#define intp_ext_in_15_8_pos 0
+#define intp_ext_in_15_8_len 8
+#define intp_ext_in_15_8_lsb 8
+#define    p_intp_ext_in_23_16  0xF1DF
+#define intp_ext_in_23_16_pos 0
+#define intp_ext_in_23_16_len 8
+#define intp_ext_in_23_16_lsb 16
+#define    p_intp_ext_in_25_24  0xF1E0
+#define intp_ext_in_25_24_pos 0
+#define intp_ext_in_25_24_len 2
+#define intp_ext_in_25_24_lsb 24
+#define    r_intp_ext_out_7_0   0xF1E1
+#define intp_ext_out_7_0_pos 0
+#define intp_ext_out_7_0_len 8
+#define intp_ext_out_7_0_lsb 0
+#define    r_intp_ext_out_15_8  0xF1E2
+#define intp_ext_out_15_8_pos 0
+#define intp_ext_out_15_8_len 8
+#define intp_ext_out_15_8_lsb 8
+#define    r_intp_ext_out_23_16 0xF1E3
+#define intp_ext_out_23_16_pos 0
+#define intp_ext_out_23_16_len 8
+#define intp_ext_out_23_16_lsb 16
+#define    r_intp_ext_out_28_24 0xF1E4
+#define intp_ext_out_28_24_pos 0
+#define intp_ext_out_28_24_len 5
+#define intp_ext_out_28_24_lsb 24
+#define    p_reg_agc_rst    0xF1E5
+#define reg_agc_rst_pos 0
+#define reg_agc_rst_len 1
+#define reg_agc_rst_lsb 0
+#define    p_rf_agc_en  0xF1E6
+#define rf_agc_en_pos 0
+#define rf_agc_en_len 1
+#define rf_agc_en_lsb 0
+#define    p_agc_lock   0xF1E7
+#define agc_lock_pos 0
+#define agc_lock_len 1
+#define agc_lock_lsb 0
+#define    p_reg_tinr_rst   0xF1E8
+#define reg_tinr_rst_pos 0
+#define reg_tinr_rst_len 1
+#define reg_tinr_rst_lsb 0
+#define    p_reg_tinr_en    0xF1E9
+#define reg_tinr_en_pos 0
+#define reg_tinr_en_len 1
+#define reg_tinr_en_lsb 0
+#define    p_reg_bfs_en 0xF1EA
+#define reg_bfs_en_pos 0
+#define reg_bfs_en_len 1
+#define reg_bfs_en_lsb 0
+#define    p_reg_bfs_rst    0xF1EB
+#define reg_bfs_rst_pos 0
+#define reg_bfs_rst_len 1
+#define reg_bfs_rst_lsb 0
+#define    p_reg_bfs_byp    0xF1EC
+#define reg_bfs_byp_pos 0
+#define reg_bfs_byp_len 1
+#define reg_bfs_byp_lsb 0
+#define    p_intp_en    0xF1EF
+#define intp_en_pos 0
+#define intp_en_len 1
+#define intp_en_lsb 0
+#define    p_intp_rst   0xF1F0
+#define intp_rst_pos 0
+#define intp_rst_len 1
+#define intp_rst_lsb 0
+#define    p_reg_p_acif_en  0xF1F2
+#define reg_p_acif_en_pos 0
+#define reg_p_acif_en_len 1
+#define reg_p_acif_en_lsb 0
+#define    p_reg_p_acif_rst 0xF1F3
+#define reg_p_acif_rst_pos 0
+#define reg_p_acif_rst_len 1
+#define reg_p_acif_rst_lsb 0
+#define    p_reg_p_acif_byp 0xF1F4
+#define reg_p_acif_byp_pos 0
+#define reg_p_acif_byp_len 1
+#define reg_p_acif_byp_lsb 0
+#define    p_dagc2_rst  0xF1F6
+#define dagc2_rst_pos 0
+#define dagc2_rst_len 1
+#define dagc2_rst_lsb 0
+#define    p_dagc2_en   0xF1F7
+#define dagc2_en_pos 0
+#define dagc2_en_len 1
+#define dagc2_en_lsb 0
+#define    p_dagc2_mode 0xF1F8
+#define dagc2_mode_pos 0
+#define dagc2_mode_len 2
+#define dagc2_mode_lsb 0
+#define    p_dagc2_done 0xF1F9
+#define dagc2_done_pos 0
+#define dagc2_done_len 1
+#define dagc2_done_lsb 0
+#define    p_dagc3_rst  0xF1FA
+#define dagc3_rst_pos 0
+#define dagc3_rst_len 1
+#define dagc3_rst_lsb 0
+#define    p_dagc3_en   0xF1FB
+#define dagc3_en_pos 0
+#define dagc3_en_len 1
+#define dagc3_en_lsb 0
+#define    p_dagc3_mode 0xF1FC
+#define dagc3_mode_pos 0
+#define dagc3_mode_len 2
+#define dagc3_mode_lsb 0
+#define    p_dagc3_done 0xF1FD
+#define dagc3_done_pos 0
+#define dagc3_done_len 1
+#define dagc3_done_lsb 0
+#define    p_reg_dagc2_desired_level_7_0    0xF202
+#define reg_dagc2_desired_level_7_0_pos 0
+#define reg_dagc2_desired_level_7_0_len 8
+#define reg_dagc2_desired_level_7_0_lsb 0
+#define    p_reg_dagc2_desired_level_8  0xF203
+#define reg_dagc2_desired_level_8_pos 0
+#define reg_dagc2_desired_level_8_len 1
+#define reg_dagc2_desired_level_8_lsb 8
+#define    p_reg_dagc2_apply_delay  0xF204
+#define reg_dagc2_apply_delay_pos 0
+#define reg_dagc2_apply_delay_len 7
+#define reg_dagc2_apply_delay_lsb 0
+#define    p_reg_dagc2_bypass_scale_ctl 0xF205
+#define reg_dagc2_bypass_scale_ctl_pos 0
+#define reg_dagc2_bypass_scale_ctl_len 3
+#define reg_dagc2_bypass_scale_ctl_lsb 0
+#define    p_reg_dagc2_programmable_shift2  0xF206
+#define reg_dagc2_programmable_shift2_pos 0
+#define reg_dagc2_programmable_shift2_len 8
+#define reg_dagc2_programmable_shift2_lsb 0
+#define    p_reg_dagc2_in_sat_cnt_7_0   0xF207
+#define reg_dagc2_in_sat_cnt_7_0_pos 0
+#define reg_dagc2_in_sat_cnt_7_0_len 8
+#define reg_dagc2_in_sat_cnt_7_0_lsb 0
+#define    p_reg_dagc2_in_sat_cnt_15_8  0xF208
+#define reg_dagc2_in_sat_cnt_15_8_pos 0
+#define reg_dagc2_in_sat_cnt_15_8_len 8
+#define reg_dagc2_in_sat_cnt_15_8_lsb 8
+#define    p_reg_dagc2_in_sat_cnt_23_16 0xF209
+#define reg_dagc2_in_sat_cnt_23_16_pos 0
+#define reg_dagc2_in_sat_cnt_23_16_len 8
+#define reg_dagc2_in_sat_cnt_23_16_lsb 16
+#define    p_reg_dagc2_in_sat_cnt_31_24 0xF20A
+#define reg_dagc2_in_sat_cnt_31_24_pos 0
+#define reg_dagc2_in_sat_cnt_31_24_len 8
+#define reg_dagc2_in_sat_cnt_31_24_lsb 24
+#define    p_reg_dagc2_out_sat_cnt_7_0  0xF20B
+#define reg_dagc2_out_sat_cnt_7_0_pos 0
+#define reg_dagc2_out_sat_cnt_7_0_len 8
+#define reg_dagc2_out_sat_cnt_7_0_lsb 0
+#define    p_reg_dagc2_out_sat_cnt_15_8 0xF20C
+#define reg_dagc2_out_sat_cnt_15_8_pos 0
+#define reg_dagc2_out_sat_cnt_15_8_len 8
+#define reg_dagc2_out_sat_cnt_15_8_lsb 8
+#define    p_reg_dagc2_out_sat_cnt_23_16    0xF20D
+#define reg_dagc2_out_sat_cnt_23_16_pos 0
+#define reg_dagc2_out_sat_cnt_23_16_len 8
+#define reg_dagc2_out_sat_cnt_23_16_lsb 16
+#define    p_reg_dagc2_out_sat_cnt_31_24    0xF20E
+#define reg_dagc2_out_sat_cnt_31_24_pos 0
+#define reg_dagc2_out_sat_cnt_31_24_len 8
+#define reg_dagc2_out_sat_cnt_31_24_lsb 24
+#define    r_reg_dagc2_multiplier_7_0   0xF20F
+#define reg_dagc2_multiplier_7_0_pos 0
+#define reg_dagc2_multiplier_7_0_len 8
+#define reg_dagc2_multiplier_7_0_lsb 0
+#define    r_reg_dagc2_multiplier_15_8  0xF210
+#define reg_dagc2_multiplier_15_8_pos 0
+#define reg_dagc2_multiplier_15_8_len 8
+#define reg_dagc2_multiplier_15_8_lsb 8
+#define    r_reg_dagc2_right_shift_bits 0xF211
+#define reg_dagc2_right_shift_bits_pos 0
+#define reg_dagc2_right_shift_bits_len 4
+#define reg_dagc2_right_shift_bits_lsb 0
+#define    p_reg_dagc2_smbuf_err    0xF212
+#define reg_dagc2_smbuf_err_pos 0
+#define reg_dagc2_smbuf_err_len 1
+#define reg_dagc2_smbuf_err_lsb 0
+#define    p_reg_dagc2_cplxconj 0xF213
+#define reg_dagc2_cplxconj_pos 0
+#define reg_dagc2_cplxconj_len 1
+#define reg_dagc2_cplxconj_lsb 0
+#define    p_reg_dagc2_use_despow   0xF214
+#define reg_dagc2_use_despow_pos 0
+#define reg_dagc2_use_despow_len 1
+#define reg_dagc2_use_despow_lsb 0
+#define    p_reg_dagc2_log_2_accumulate 0xF215
+#define reg_dagc2_log_2_accumulate_pos 0
+#define reg_dagc2_log_2_accumulate_len 5
+#define reg_dagc2_log_2_accumulate_lsb 0
+#define    r_dagc2_dca_gain 0xF216
+#define dagc2_dca_gain_pos 0
+#define dagc2_dca_gain_len 8
+#define dagc2_dca_gain_lsb 0
+#define    p_reg_dca_gain_offset    0xF217
+#define reg_dca_gain_offset_pos 0
+#define reg_dca_gain_offset_len 8
+#define reg_dca_gain_offset_lsb 0
+#define    p_reg_dagc2_FG_mode  0xF218
+#define reg_dagc2_FG_mode_pos 0
+#define reg_dagc2_FG_mode_len 1
+#define reg_dagc2_FG_mode_lsb 0
+#define    p_reg_dagc2_fixed_gain_7_0   0xF219
+#define reg_dagc2_fixed_gain_7_0_pos 0
+#define reg_dagc2_fixed_gain_7_0_len 8
+#define reg_dagc2_fixed_gain_7_0_lsb 0
+#define    p_reg_dagc2_fixed_gain_11_8  0xF21A
+#define reg_dagc2_fixed_gain_11_8_pos 0
+#define reg_dagc2_fixed_gain_11_8_len 4
+#define reg_dagc2_fixed_gain_11_8_lsb 8
+#define    p_reg_td_debug_7_0   0xF21B
+#define reg_td_debug_7_0_pos 0
+#define reg_td_debug_7_0_len 8
+#define reg_td_debug_7_0_lsb 0
+#define    p_reg_td_debug_15_8  0xF21C
+#define reg_td_debug_15_8_pos 0
+#define reg_td_debug_15_8_len 8
+#define reg_td_debug_15_8_lsb 8
+#define    p_reg_td_debug_23_16 0xF21D
+#define reg_td_debug_23_16_pos 0
+#define reg_td_debug_23_16_len 8
+#define reg_td_debug_23_16_lsb 16
+#define    p_reg_td_debug_30_24 0xF21E
+#define reg_td_debug_30_24_pos 0
+#define reg_td_debug_30_24_len 7
+#define reg_td_debug_30_24_lsb 24
+#define    g_reg_clk_sys40  0xF90E
+#define reg_clk_sys40_pos 0
+#define reg_clk_sys40_len 1
+#define reg_clk_sys40_lsb 0
+#define    g_reg_intp_sys_polarity  0xF90F
+#define reg_intp_sys_polarity_pos 0
+#define reg_intp_sys_polarity_len 1
+#define reg_intp_sys_polarity_lsb 0
+#define    g_reg_intp_sys_sc_7_0    0xF910
+#define reg_intp_sys_sc_7_0_pos 0
+#define reg_intp_sys_sc_7_0_len 8
+#define reg_intp_sys_sc_7_0_lsb 0
+#define    g_reg_intp_sys_sc_15_8   0xF911
+#define reg_intp_sys_sc_15_8_pos 0
+#define reg_intp_sys_sc_15_8_len 8
+#define reg_intp_sys_sc_15_8_lsb 8
+#define    g_reg_intp_sys_sc_23_16  0xF912
+#define reg_intp_sys_sc_23_16_pos 0
+#define reg_intp_sys_sc_23_16_len 8
+#define reg_intp_sys_sc_23_16_lsb 16
+#define    g_reg_intp_sys_sc_26_24  0xF913
+#define reg_intp_sys_sc_26_24_pos 0
+#define reg_intp_sys_sc_26_24_len 3
+#define reg_intp_sys_sc_26_24_lsb 24
+#define    g_reg_ofsm_clk   0xF914
+#define reg_ofsm_clk_pos 0
+#define reg_ofsm_clk_len 3
+#define reg_ofsm_clk_lsb 0
+#define    g_reg_fclk_cfg   0xF915
+#define reg_fclk_cfg_pos 0
+#define reg_fclk_cfg_len 1
+#define reg_fclk_cfg_lsb 0
+#define    g_reg_fclk_idi   0xF916
+#define reg_fclk_idi_pos 0
+#define reg_fclk_idi_len 1
+#define reg_fclk_idi_lsb 0
+#define    g_reg_fclk_odi   0xF917
+#define reg_fclk_odi_pos 0
+#define reg_fclk_odi_len 1
+#define reg_fclk_odi_lsb 0
+#define    g_reg_fclk_rsd   0xF918
+#define reg_fclk_rsd_pos 0
+#define reg_fclk_rsd_len 1
+#define reg_fclk_rsd_lsb 0
+#define    g_reg_fclk_vtb   0xF919
+#define reg_fclk_vtb_pos 0
+#define reg_fclk_vtb_len 1
+#define reg_fclk_vtb_lsb 0
+#define    g_reg_fclk_cste  0xF91A
+#define reg_fclk_cste_pos 0
+#define reg_fclk_cste_len 1
+#define reg_fclk_cste_lsb 0
+#define    g_reg_fclk_mp2if 0xF91B
+#define reg_fclk_mp2if_pos 0
+#define reg_fclk_mp2if_len 1
+#define reg_fclk_mp2if_lsb 0
+#define    p_reg_adcout_sync    0xFA00
+#define reg_adcout_sync_pos 0
+#define reg_adcout_sync_len 1
+#define reg_adcout_sync_lsb 0
+#define    p_reg_dagc2o_edge1   0xFA01
+#define reg_dagc2o_edge1_pos 0
+#define reg_dagc2o_edge1_len 1
+#define reg_dagc2o_edge1_lsb 0
+#define    p_reg_dagc2o_edge0   0xFA02
+#define reg_dagc2o_edge0_pos 0
+#define reg_dagc2o_edge0_len 1
+#define reg_dagc2o_edge0_lsb 0
+#define    p_reg_second_rom_on  0xFA03
+#define reg_second_rom_on_pos 0
+#define reg_second_rom_on_len 1
+#define reg_second_rom_on_lsb 0
+#define    p_reg_bypass_host2tuner  0xFA04
+#define reg_bypass_host2tuner_pos 0
+#define reg_bypass_host2tuner_len 1
+#define reg_bypass_host2tuner_lsb 0
+#define    p_cfoe_NS_coeff1_7_0 0xF400
+#define cfoe_NS_coeff1_7_0_pos 0
+#define cfoe_NS_coeff1_7_0_len 8
+#define cfoe_NS_coeff1_7_0_lsb 0
+#define    p_cfoe_NS_coeff1_15_8    0xF401
+#define cfoe_NS_coeff1_15_8_pos 0
+#define cfoe_NS_coeff1_15_8_len 8
+#define cfoe_NS_coeff1_15_8_lsb 8
+#define    p_cfoe_NS_coeff1_23_16   0xF402
+#define cfoe_NS_coeff1_23_16_pos 0
+#define cfoe_NS_coeff1_23_16_len 8
+#define cfoe_NS_coeff1_23_16_lsb 16
+#define    p_cfoe_NS_coeff1_25_24   0xF403
+#define cfoe_NS_coeff1_25_24_pos 0
+#define cfoe_NS_coeff1_25_24_len 2
+#define cfoe_NS_coeff1_25_24_lsb 24
+#define    p_cfoe_NS_coeff2_7_0 0xF404
+#define cfoe_NS_coeff2_7_0_pos 0
+#define cfoe_NS_coeff2_7_0_len 8
+#define cfoe_NS_coeff2_7_0_lsb 0
+#define    p_cfoe_NS_coeff2_15_8    0xF405
+#define cfoe_NS_coeff2_15_8_pos 0
+#define cfoe_NS_coeff2_15_8_len 8
+#define cfoe_NS_coeff2_15_8_lsb 8
+#define    p_cfoe_NS_coeff2_23_16   0xF406
+#define cfoe_NS_coeff2_23_16_pos 0
+#define cfoe_NS_coeff2_23_16_len 8
+#define cfoe_NS_coeff2_23_16_lsb 16
+#define    p_cfoe_NS_coeff2_24  0xF407
+#define cfoe_NS_coeff2_24_pos 0
+#define cfoe_NS_coeff2_24_len 1
+#define cfoe_NS_coeff2_24_lsb 24
+#define    p_cfoe_lf_c1_7_0 0xF408
+#define cfoe_lf_c1_7_0_pos 0
+#define cfoe_lf_c1_7_0_len 8
+#define cfoe_lf_c1_7_0_lsb 0
+#define    p_cfoe_lf_c1_9_8 0xF409
+#define cfoe_lf_c1_9_8_pos 0
+#define cfoe_lf_c1_9_8_len 2
+#define cfoe_lf_c1_9_8_lsb 8
+#define    p_cfoe_lf_c2_7_0 0xF40A
+#define cfoe_lf_c2_7_0_pos 0
+#define cfoe_lf_c2_7_0_len 8
+#define cfoe_lf_c2_7_0_lsb 0
+#define    p_cfoe_lf_c2_9_8 0xF40B
+#define cfoe_lf_c2_9_8_pos 0
+#define cfoe_lf_c2_9_8_len 2
+#define cfoe_lf_c2_9_8_lsb 8
+#define    p_cfoe_ifod_7_0  0xF40C
+#define cfoe_ifod_7_0_pos 0
+#define cfoe_ifod_7_0_len 8
+#define cfoe_ifod_7_0_lsb 0
+#define    p_cfoe_ifod_10_8 0xF40D
+#define cfoe_ifod_10_8_pos 0
+#define cfoe_ifod_10_8_len 3
+#define cfoe_ifod_10_8_lsb 8
+#define    p_cfoe_Divg_ctr_th   0xF40E
+#define cfoe_Divg_ctr_th_pos 0
+#define cfoe_Divg_ctr_th_len 4
+#define cfoe_Divg_ctr_th_lsb 0
+#define    p_cfoe_FOT_divg_th   0xF40F
+#define cfoe_FOT_divg_th_pos 0
+#define cfoe_FOT_divg_th_len 8
+#define cfoe_FOT_divg_th_lsb 0
+#define    p_cfoe_FOT_cnvg_th   0xF410
+#define cfoe_FOT_cnvg_th_pos 0
+#define cfoe_FOT_cnvg_th_len 8
+#define cfoe_FOT_cnvg_th_lsb 0
+#define    p_reg_cfoe_offset_7_0    0xF411
+#define reg_cfoe_offset_7_0_pos 0
+#define reg_cfoe_offset_7_0_len 8
+#define reg_cfoe_offset_7_0_lsb 0
+#define    p_reg_cfoe_offset_10_8   0xF412
+#define reg_cfoe_offset_10_8_pos 0
+#define reg_cfoe_offset_10_8_len 3
+#define reg_cfoe_offset_10_8_lsb 8
+#define    p_reg_cfoe_ifoe_sign_corr    0xF413
+#define reg_cfoe_ifoe_sign_corr_pos 0
+#define reg_cfoe_ifoe_sign_corr_len 1
+#define reg_cfoe_ifoe_sign_corr_lsb 0
+#define    p_cfoe_FOT_pullin_cnt_clr    0xF414
+#define cfoe_FOT_pullin_cnt_clr_pos 0
+#define cfoe_FOT_pullin_cnt_clr_len 1
+#define cfoe_FOT_pullin_cnt_clr_lsb 0
+#define    p_cfoe_FOT_spec_inv  0xF415
+#define cfoe_FOT_spec_inv_pos 0
+#define cfoe_FOT_spec_inv_len 1
+#define cfoe_FOT_spec_inv_lsb 0
+#define    p_cfoe_FOT_pullin_ctr_th 0xF416
+#define cfoe_FOT_pullin_ctr_th_pos 0
+#define cfoe_FOT_pullin_ctr_th_len 4
+#define cfoe_FOT_pullin_ctr_th_lsb 0
+#define    p_cfoe_FOT_sf_ctr_th 0xF417
+#define cfoe_FOT_sf_ctr_th_pos 0
+#define cfoe_FOT_sf_ctr_th_len 4
+#define cfoe_FOT_sf_ctr_th_lsb 0
+#define    p_cfoe_FOT_pullin_th 0xF418
+#define cfoe_FOT_pullin_th_pos 0
+#define cfoe_FOT_pullin_th_len 8
+#define cfoe_FOT_pullin_th_lsb 0
+#define    p_cfoe_FOT_kalman_cnt    0xF419
+#define cfoe_FOT_kalman_cnt_pos 0
+#define cfoe_FOT_kalman_cnt_len 4
+#define cfoe_FOT_kalman_cnt_lsb 0
+#define    p_cfoe_FOT_fsm_info  0xF41A
+#define cfoe_FOT_fsm_info_pos 0
+#define cfoe_FOT_fsm_info_len 4
+#define cfoe_FOT_fsm_info_lsb 0
+#define    r_cfoe_FOT_pullin_cnt    0xF41B
+#define cfoe_FOT_pullin_cnt_pos 0
+#define cfoe_FOT_pullin_cnt_len 4
+#define cfoe_FOT_pullin_cnt_lsb 0
+#define    r_cfoe_FOT_sf_cnt    0xF41C
+#define cfoe_FOT_sf_cnt_pos 0
+#define cfoe_FOT_sf_cnt_len 4
+#define cfoe_FOT_sf_cnt_lsb 0
+#define    r_reg_r_cfoe_ifoe_ifo_metric 0xF41D
+#define reg_r_cfoe_ifoe_ifo_metric_pos 0
+#define reg_r_cfoe_ifoe_ifo_metric_len 8
+#define reg_r_cfoe_ifoe_ifo_metric_lsb 0
+#define    r_reg_r_cfoe_ifoe_cos2num_7_0    0xF41E
+#define reg_r_cfoe_ifoe_cos2num_7_0_pos 0
+#define reg_r_cfoe_ifoe_cos2num_7_0_len 8
+#define reg_r_cfoe_ifoe_cos2num_7_0_lsb 0
+#define    r_reg_r_cfoe_ifoe_cos2num_15_8   0xF41F
+#define reg_r_cfoe_ifoe_cos2num_15_8_pos 0
+#define reg_r_cfoe_ifoe_cos2num_15_8_len 8
+#define reg_r_cfoe_ifoe_cos2num_15_8_lsb 8
+#define    r_reg_r_cfoe_ifoe_cos2num_19_16  0xF420
+#define reg_r_cfoe_ifoe_cos2num_19_16_pos 0
+#define reg_r_cfoe_ifoe_cos2num_19_16_len 4
+#define reg_r_cfoe_ifoe_cos2num_19_16_lsb 16
+#define    p_ste_Nu 0xF460
+#define ste_Nu_pos 0
+#define ste_Nu_len 3
+#define ste_Nu_lsb 0
+#define    p_ste_GI 0xF461
+#define ste_GI_pos 0
+#define ste_GI_len 3
+#define ste_GI_lsb 0
+#define    p_ste_symbol_num 0xF463
+#define ste_symbol_num_pos 0
+#define ste_symbol_num_len 3
+#define ste_symbol_num_lsb 0
+#define    p_ste_sample_num 0xF464
+#define ste_sample_num_pos 0
+#define ste_sample_num_len 2
+#define ste_sample_num_lsb 0
+#define    p_ste_symbol_num_4K  0xF465
+#define ste_symbol_num_4K_pos 0
+#define ste_symbol_num_4K_len 3
+#define ste_symbol_num_4K_lsb 0
+#define    p_ste_FFT_offset_7_0 0xF466
+#define ste_FFT_offset_7_0_pos 0
+#define ste_FFT_offset_7_0_len 8
+#define ste_FFT_offset_7_0_lsb 0
+#define    p_ste_FFT_offset_13_8    0xF467
+#define ste_FFT_offset_13_8_pos 0
+#define ste_FFT_offset_13_8_len 6
+#define ste_FFT_offset_13_8_lsb 8
+#define    p_ste_sample_num_4K  0xF468
+#define ste_sample_num_4K_pos 0
+#define ste_sample_num_4K_len 2
+#define ste_sample_num_4K_lsb 0
+#define    p_ste_adv_start_7_0  0xF469
+#define ste_adv_start_7_0_pos 0
+#define ste_adv_start_7_0_len 8
+#define ste_adv_start_7_0_lsb 0
+#define    p_ste_adv_start_10_8 0xF46A
+#define ste_adv_start_10_8_pos 0
+#define ste_adv_start_10_8_len 3
+#define ste_adv_start_10_8_lsb 8
+#define    p_ste_symbol_num_8K  0xF46B
+#define ste_symbol_num_8K_pos 0
+#define ste_symbol_num_8K_len 3
+#define ste_symbol_num_8K_lsb 0
+#define    p_ste_sample_num_8K  0xF46C
+#define ste_sample_num_8K_pos 0
+#define ste_sample_num_8K_len 2
+#define ste_sample_num_8K_lsb 0
+#define    p_ste_adv_stop   0xF46D
+#define ste_adv_stop_pos 0
+#define ste_adv_stop_len 8
+#define ste_adv_stop_lsb 0
+#define    r_ste_P_value_7_0    0xF46E
+#define ste_P_value_7_0_pos 0
+#define ste_P_value_7_0_len 8
+#define ste_P_value_7_0_lsb 0
+#define    r_ste_P_value_10_8   0xF46F
+#define ste_P_value_10_8_pos 0
+#define ste_P_value_10_8_len 3
+#define ste_P_value_10_8_lsb 8
+#define    p_reg_ste_tstmod 0xF470
+#define reg_ste_tstmod_pos 0
+#define reg_ste_tstmod_len 1
+#define reg_ste_tstmod_lsb 0
+#define    p_reg_ste_buf_en 0xF471
+#define reg_ste_buf_en_pos 0
+#define reg_ste_buf_en_len 1
+#define reg_ste_buf_en_lsb 0
+#define    r_ste_M_value_7_0    0xF472
+#define ste_M_value_7_0_pos 0
+#define ste_M_value_7_0_len 8
+#define ste_M_value_7_0_lsb 0
+#define    r_ste_M_value_10_8   0xF473
+#define ste_M_value_10_8_pos 0
+#define ste_M_value_10_8_len 3
+#define ste_M_value_10_8_lsb 8
+#define    r_ste_H1 0xF474
+#define ste_H1_pos 0
+#define ste_H1_len 7
+#define ste_H1_lsb 0
+#define    r_ste_H2 0xF475
+#define ste_H2_pos 0
+#define ste_H2_len 7
+#define ste_H2_lsb 0
+#define    r_ste_H3 0xF476
+#define ste_H3_pos 0
+#define ste_H3_len 7
+#define ste_H3_lsb 0
+#define    r_ste_H4 0xF477
+#define ste_H4_pos 0
+#define ste_H4_len 7
+#define ste_H4_lsb 0
+#define    r_ste_Corr_value_I_7_0   0xF478
+#define ste_Corr_value_I_7_0_pos 0
+#define ste_Corr_value_I_7_0_len 8
+#define ste_Corr_value_I_7_0_lsb 0
+#define    r_ste_Corr_value_I_15_8  0xF479
+#define ste_Corr_value_I_15_8_pos 0
+#define ste_Corr_value_I_15_8_len 8
+#define ste_Corr_value_I_15_8_lsb 8
+#define    r_ste_Corr_value_I_23_16 0xF47A
+#define ste_Corr_value_I_23_16_pos 0
+#define ste_Corr_value_I_23_16_len 8
+#define ste_Corr_value_I_23_16_lsb 16
+#define    r_ste_Corr_value_I_27_24 0xF47B
+#define ste_Corr_value_I_27_24_pos 0
+#define ste_Corr_value_I_27_24_len 4
+#define ste_Corr_value_I_27_24_lsb 24
+#define    r_ste_Corr_value_Q_7_0   0xF47C
+#define ste_Corr_value_Q_7_0_pos 0
+#define ste_Corr_value_Q_7_0_len 8
+#define ste_Corr_value_Q_7_0_lsb 0
+#define    r_ste_Corr_value_Q_15_8  0xF47D
+#define ste_Corr_value_Q_15_8_pos 0
+#define ste_Corr_value_Q_15_8_len 8
+#define ste_Corr_value_Q_15_8_lsb 8
+#define    r_ste_Corr_value_Q_23_16 0xF47E
+#define ste_Corr_value_Q_23_16_pos 0
+#define ste_Corr_value_Q_23_16_len 8
+#define ste_Corr_value_Q_23_16_lsb 16
+#define    r_ste_Corr_value_Q_27_24 0xF47F
+#define ste_Corr_value_Q_27_24_pos 0
+#define ste_Corr_value_Q_27_24_len 4
+#define ste_Corr_value_Q_27_24_lsb 24
+#define    r_ste_J_num_7_0  0xF480
+#define ste_J_num_7_0_pos 0
+#define ste_J_num_7_0_len 8
+#define ste_J_num_7_0_lsb 0
+#define    r_ste_J_num_15_8 0xF481
+#define ste_J_num_15_8_pos 0
+#define ste_J_num_15_8_len 8
+#define ste_J_num_15_8_lsb 8
+#define    r_ste_J_num_23_16    0xF482
+#define ste_J_num_23_16_pos 0
+#define ste_J_num_23_16_len 8
+#define ste_J_num_23_16_lsb 16
+#define    r_ste_J_num_31_24    0xF483
+#define ste_J_num_31_24_pos 0
+#define ste_J_num_31_24_len 8
+#define ste_J_num_31_24_lsb 24
+#define    r_ste_J_den_7_0  0xF484
+#define ste_J_den_7_0_pos 0
+#define ste_J_den_7_0_len 8
+#define ste_J_den_7_0_lsb 0
+#define    r_ste_J_den_15_8 0xF485
+#define ste_J_den_15_8_pos 0
+#define ste_J_den_15_8_len 8
+#define ste_J_den_15_8_lsb 8
+#define    r_ste_J_den_18_16    0xF486
+#define ste_J_den_18_16_pos 0
+#define ste_J_den_18_16_len 3
+#define ste_J_den_18_16_lsb 16
+#define    r_ste_Beacon_Indicator   0xF488
+#define ste_Beacon_Indicator_pos 0
+#define ste_Beacon_Indicator_len 1
+#define ste_Beacon_Indicator_lsb 0
+#define    p_ste_got_sntc_bcn   0xF48B
+#define ste_got_sntc_bcn_pos 0
+#define ste_got_sntc_bcn_len 1
+#define ste_got_sntc_bcn_lsb 0
+#define    r_tpsd_Frame_Num 0xF4C0
+#define tpsd_Frame_Num_pos 0
+#define tpsd_Frame_Num_len 2
+#define tpsd_Frame_Num_lsb 0
+#define    r_tpsd_Constel   0xF4C1
+#define tpsd_Constel_pos 0
+#define tpsd_Constel_len 2
+#define tpsd_Constel_lsb 0
+#define    r_tpsd_GI    0xF4C2
+#define tpsd_GI_pos 0
+#define tpsd_GI_len 2
+#define tpsd_GI_lsb 0
+#define    r_tpsd_Mode  0xF4C3
+#define tpsd_Mode_pos 0
+#define tpsd_Mode_len 2
+#define tpsd_Mode_lsb 0
+#define    r_tpsd_CR_HP 0xF4C4
+#define tpsd_CR_HP_pos 0
+#define tpsd_CR_HP_len 3
+#define tpsd_CR_HP_lsb 0
+#define    r_tpsd_CR_LP 0xF4C5
+#define tpsd_CR_LP_pos 0
+#define tpsd_CR_LP_len 3
+#define tpsd_CR_LP_lsb 0
+#define    r_tpsd_Hie   0xF4C6
+#define tpsd_Hie_pos 0
+#define tpsd_Hie_len 3
+#define tpsd_Hie_lsb 0
+#define    r_tpsd_Res_Bits  0xF4C7
+#define tpsd_Res_Bits_pos 0
+#define tpsd_Res_Bits_len 5
+#define tpsd_Res_Bits_lsb 0
+#define    r_tpsd_Res_Bits_0    0xF4C8
+#define tpsd_Res_Bits_0_pos 0
+#define tpsd_Res_Bits_0_len 1
+#define tpsd_Res_Bits_0_lsb 0
+#define    r_tpsd_LengthInd 0xF4C9
+#define tpsd_LengthInd_pos 0
+#define tpsd_LengthInd_len 6
+#define tpsd_LengthInd_lsb 0
+#define    r_tpsd_Cell_Id_7_0   0xF4CA
+#define tpsd_Cell_Id_7_0_pos 0
+#define tpsd_Cell_Id_7_0_len 8
+#define tpsd_Cell_Id_7_0_lsb 0
+#define    r_tpsd_Cell_Id_15_8  0xF4CB
+#define tpsd_Cell_Id_15_8_pos 0
+#define tpsd_Cell_Id_15_8_len 8
+#define tpsd_Cell_Id_15_8_lsb 0
+#define    r_tpsd_use_InDepthInt    0xF4CC
+#define tpsd_use_InDepthInt_pos 0
+#define tpsd_use_InDepthInt_len 1
+#define tpsd_use_InDepthInt_lsb 0
+#define    r_tpsd_use_TimeSlicing_HP    0xF4CD
+#define tpsd_use_TimeSlicing_HP_pos 0
+#define tpsd_use_TimeSlicing_HP_len 1
+#define tpsd_use_TimeSlicing_HP_lsb 0
+#define    r_tpsd_use_mpe_fec_HP    0xF4CE
+#define tpsd_use_mpe_fec_HP_pos 0
+#define tpsd_use_mpe_fec_HP_len 1
+#define tpsd_use_mpe_fec_HP_lsb 0
+#define    r_tpsd_use_TimeSlicing_LP    0xF4CF
+#define tpsd_use_TimeSlicing_LP_pos 0
+#define tpsd_use_TimeSlicing_LP_len 1
+#define tpsd_use_TimeSlicing_LP_lsb 0
+#define    r_tpsd_use_mpe_fec_LP    0xF4D0
+#define tpsd_use_mpe_fec_LP_pos 0
+#define tpsd_use_mpe_fec_LP_len 1
+#define tpsd_use_mpe_fec_LP_lsb 0
+#define    r_tpsd_leng23_ind_return 0xF4D1
+#define tpsd_leng23_ind_return_pos 0
+#define tpsd_leng23_ind_return_len 1
+#define tpsd_leng23_ind_return_lsb 0
+#define    p_reg_fft_re_exp 0xF500
+#define reg_fft_re_exp_pos 0
+#define reg_fft_re_exp_len 4
+#define reg_fft_re_exp_lsb 0
+#define    p_reg_fft_re_mts 0xF501
+#define reg_fft_re_mts_pos 0
+#define reg_fft_re_mts_len 8
+#define reg_fft_re_mts_lsb 0
+#define    p_reg_fft_im_exp 0xF502
+#define reg_fft_im_exp_pos 0
+#define reg_fft_im_exp_len 4
+#define reg_fft_im_exp_lsb 0
+#define    p_reg_fft_im_mts 0xF503
+#define reg_fft_im_mts_pos 0
+#define reg_fft_im_mts_len 8
+#define reg_fft_im_mts_lsb 0
+#define    p_reg_fft_conjugate  0xF504
+#define reg_fft_conjugate_pos 0
+#define reg_fft_conjugate_len 1
+#define reg_fft_conjugate_lsb 0
+#define    p_reg_fft_power_en   0xF505
+#define reg_fft_power_en_pos 0
+#define reg_fft_power_en_len 1
+#define reg_fft_power_en_lsb 0
+#define    p_reg_fft_power_factor   0xF506
+#define reg_fft_power_factor_pos 0
+#define reg_fft_power_factor_len 6
+#define reg_fft_power_factor_lsb 0
+#define    p_reg_fft_power_in   0xF507
+#define reg_fft_power_in_pos 0
+#define reg_fft_power_in_len 8
+#define reg_fft_power_in_lsb 0
+#define    p_reg_fft_mask_from0_7_0 0xF508
+#define reg_fft_mask_from0_7_0_pos 0
+#define reg_fft_mask_from0_7_0_len 8
+#define reg_fft_mask_from0_7_0_lsb 0
+#define    p_reg_fft_mask_from0_12_8    0xF509
+#define reg_fft_mask_from0_12_8_pos 0
+#define reg_fft_mask_from0_12_8_len 5
+#define reg_fft_mask_from0_12_8_lsb 8
+#define    p_reg_fft_mask_to0_7_0   0xF50A
+#define reg_fft_mask_to0_7_0_pos 0
+#define reg_fft_mask_to0_7_0_len 8
+#define reg_fft_mask_to0_7_0_lsb 0
+#define    p_reg_fft_mask_to0_12_8  0xF50B
+#define reg_fft_mask_to0_12_8_pos 0
+#define reg_fft_mask_to0_12_8_len 5
+#define reg_fft_mask_to0_12_8_lsb 8
+#define    p_reg_fft_mask_from1_7_0 0xF50C
+#define reg_fft_mask_from1_7_0_pos 0
+#define reg_fft_mask_from1_7_0_len 8
+#define reg_fft_mask_from1_7_0_lsb 0
+#define    p_reg_fft_mask_from1_12_8    0xF50D
+#define reg_fft_mask_from1_12_8_pos 0
+#define reg_fft_mask_from1_12_8_len 5
+#define reg_fft_mask_from1_12_8_lsb 8
+#define    p_reg_fft_mask_to1_7_0   0xF50E
+#define reg_fft_mask_to1_7_0_pos 0
+#define reg_fft_mask_to1_7_0_len 8
+#define reg_fft_mask_to1_7_0_lsb 0
+#define    p_reg_fft_mask_to1_12_8  0xF50F
+#define reg_fft_mask_to1_12_8_pos 0
+#define reg_fft_mask_to1_12_8_len 5
+#define reg_fft_mask_to1_12_8_lsb 8
+#define    p_reg_fft_mask_from2_7_0 0xF510
+#define reg_fft_mask_from2_7_0_pos 0
+#define reg_fft_mask_from2_7_0_len 8
+#define reg_fft_mask_from2_7_0_lsb 0
+#define    p_reg_fft_mask_from2_12_8    0xF511
+#define reg_fft_mask_from2_12_8_pos 0
+#define reg_fft_mask_from2_12_8_len 5
+#define reg_fft_mask_from2_12_8_lsb 8
+#define    p_reg_fft_mask_to2_7_0   0xF512
+#define reg_fft_mask_to2_7_0_pos 0
+#define reg_fft_mask_to2_7_0_len 8
+#define reg_fft_mask_to2_7_0_lsb 0
+#define    p_reg_fft_mask_to2_12_8  0xF513
+#define reg_fft_mask_to2_12_8_pos 0
+#define reg_fft_mask_to2_12_8_len 5
+#define reg_fft_mask_to2_12_8_lsb 8
+#define    p_reg_fft_mask_from3_7_0 0xF514
+#define reg_fft_mask_from3_7_0_pos 0
+#define reg_fft_mask_from3_7_0_len 8
+#define reg_fft_mask_from3_7_0_lsb 0
+#define    p_reg_fft_mask_from3_12_8    0xF515
+#define reg_fft_mask_from3_12_8_pos 0
+#define reg_fft_mask_from3_12_8_len 5
+#define reg_fft_mask_from3_12_8_lsb 8
+#define    p_reg_fft_mask_to3_7_0   0xF516
+#define reg_fft_mask_to3_7_0_pos 0
+#define reg_fft_mask_to3_7_0_len 8
+#define reg_fft_mask_to3_7_0_lsb 0
+#define    p_reg_fft_mask_to3_12_8  0xF517
+#define reg_fft_mask_to3_12_8_pos 0
+#define reg_fft_mask_to3_12_8_len 5
+#define reg_fft_mask_to3_12_8_lsb 8
+#define    r_fd_sntc_frame_num  0xF518
+#define fd_sntc_frame_num_pos 0
+#define fd_sntc_frame_num_len 2
+#define fd_sntc_frame_num_lsb 0
+#define    r_fd_sntc_symbol_count   0xF519
+#define fd_sntc_symbol_count_pos 0
+#define fd_sntc_symbol_count_len 7
+#define fd_sntc_symbol_count_lsb 0
+#define    p_reg_sntc_cnt_lo    0xF51A
+#define reg_sntc_cnt_lo_pos 0
+#define reg_sntc_cnt_lo_len 8
+#define reg_sntc_cnt_lo_lsb 0
+#define    p_reg_sntc_cnt_hi    0xF51B
+#define reg_sntc_cnt_hi_pos 0
+#define reg_sntc_cnt_hi_len 7
+#define reg_sntc_cnt_hi_lsb 0
+#define    p_reg_sntc_fft_in    0xF51C
+#define reg_sntc_fft_in_pos 0
+#define reg_sntc_fft_in_len 1
+#define reg_sntc_fft_in_lsb 0
+#define    r_fd_sntc_en 0xF51D
+#define fd_sntc_en_pos 0
+#define fd_sntc_en_len 1
+#define fd_sntc_en_lsb 0
+#define    p_reg_sntc_x2    0xF51E
+#define reg_sntc_x2_pos 0
+#define reg_sntc_x2_len 1
+#define reg_sntc_x2_lsb 0
+#define    p_reg_cge_en_7_0 0xF51F
+#define reg_cge_en_7_0_pos 0
+#define reg_cge_en_7_0_len 8
+#define reg_cge_en_7_0_lsb 0
+#define    p_reg_cge_en_15_8    0xF520
+#define reg_cge_en_15_8_pos 0
+#define reg_cge_en_15_8_len 8
+#define reg_cge_en_15_8_lsb 8
+#define    p_reg_cge_en_23_16   0xF521
+#define reg_cge_en_23_16_pos 0
+#define reg_cge_en_23_16_len 8
+#define reg_cge_en_23_16_lsb 16
+#define    p_reg_cge_en_31_24   0xF522
+#define reg_cge_en_31_24_pos 0
+#define reg_cge_en_31_24_len 8
+#define reg_cge_en_31_24_lsb 24
+#define    p_reg_cge_en_39_32   0xF523
+#define reg_cge_en_39_32_pos 0
+#define reg_cge_en_39_32_len 8
+#define reg_cge_en_39_32_lsb 32
+#define    p_reg_cge_en_43_40   0xF524
+#define reg_cge_en_43_40_pos 0
+#define reg_cge_en_43_40_len 4
+#define reg_cge_en_43_40_lsb 40
+#define    p_reg_fft_sat_en 0xF525
+#define reg_fft_sat_en_pos 0
+#define reg_fft_sat_en_len 1
+#define reg_fft_sat_en_lsb 0
+#define    p_reg_fft_sat_count_clr  0xF526
+#define reg_fft_sat_count_clr_pos 0
+#define reg_fft_sat_count_clr_len 1
+#define reg_fft_sat_count_clr_lsb 0
+#define    p_reg_fft_rescale_round  0xF527
+#define reg_fft_rescale_round_pos 0
+#define reg_fft_rescale_round_len 1
+#define reg_fft_rescale_round_lsb 0
+#define    r_reg_fft_sat_count_12_7_0   0xF528
+#define reg_fft_sat_count_12_7_0_pos 0
+#define reg_fft_sat_count_12_7_0_len 8
+#define reg_fft_sat_count_12_7_0_lsb 0
+#define    r_reg_fft_sat_count_12_15_8  0xF529
+#define reg_fft_sat_count_12_15_8_pos 0
+#define reg_fft_sat_count_12_15_8_len 8
+#define reg_fft_sat_count_12_15_8_lsb 8
+#define    r_reg_fft_sat_count_10_7_0   0xF52A
+#define reg_fft_sat_count_10_7_0_pos 0
+#define reg_fft_sat_count_10_7_0_len 8
+#define reg_fft_sat_count_10_7_0_lsb 0
+#define    r_reg_fft_sat_count_10_15_8  0xF52B
+#define reg_fft_sat_count_10_15_8_pos 0
+#define reg_fft_sat_count_10_15_8_len 8
+#define reg_fft_sat_count_10_15_8_lsb 8
+#define    p_reg_fft_capture_idx_7_0    0xF52C
+#define reg_fft_capture_idx_7_0_pos 0
+#define reg_fft_capture_idx_7_0_len 8
+#define reg_fft_capture_idx_7_0_lsb 0
+#define    p_reg_fft_capture_idx_12_8   0xF52D
+#define reg_fft_capture_idx_12_8_pos 0
+#define reg_fft_capture_idx_12_8_len 5
+#define reg_fft_capture_idx_12_8_lsb 8
+#define    p_reg_fft_capture    0xF52E
+#define reg_fft_capture_pos 0
+#define reg_fft_capture_len 1
+#define reg_fft_capture_lsb 0
+#define    p_reg_gp_trigger_fd  0xF52F
+#define reg_gp_trigger_fd_pos 0
+#define reg_gp_trigger_fd_len 1
+#define reg_gp_trigger_fd_lsb 0
+#define    p_reg_trigger_sel_fd 0xF530
+#define reg_trigger_sel_fd_pos 0
+#define reg_trigger_sel_fd_len 2
+#define reg_trigger_sel_fd_lsb 0
+#define    p_reg_trigger_module_sel_fd  0xF531
+#define reg_trigger_module_sel_fd_pos 0
+#define reg_trigger_module_sel_fd_len 6
+#define reg_trigger_module_sel_fd_lsb 0
+#define    p_reg_trigger_set_sel_fd 0xF532
+#define reg_trigger_set_sel_fd_pos 0
+#define reg_trigger_set_sel_fd_len 6
+#define reg_trigger_set_sel_fd_lsb 0
+#define    r_reg_fft_idx_pre_max_7_0    0xF533
+#define reg_fft_idx_pre_max_7_0_pos 0
+#define reg_fft_idx_pre_max_7_0_len 8
+#define reg_fft_idx_pre_max_7_0_lsb 0
+#define    r_reg_fft_idx_pre_max_12_8   0xF534
+#define reg_fft_idx_pre_max_12_8_pos 0
+#define reg_fft_idx_pre_max_12_8_len 5
+#define reg_fft_idx_pre_max_12_8_lsb 8
+#define    r_reg_fft_crc    0xF535
+#define reg_fft_crc_pos 0
+#define reg_fft_crc_len 8
+#define reg_fft_crc_lsb 0
+#define    p_fd_fft_shift_max   0xF536
+#define fd_fft_shift_max_pos 0
+#define fd_fft_shift_max_len 4
+#define fd_fft_shift_max_lsb 0
+#define    p_fd_fft_frame_num   0xF537
+#define fd_fft_frame_num_pos 0
+#define fd_fft_frame_num_len 2
+#define fd_fft_frame_num_lsb 0
+#define    p_fd_fft_symbol_count    0xF538
+#define fd_fft_symbol_count_pos 0
+#define fd_fft_symbol_count_len 7
+#define fd_fft_symbol_count_lsb 0
+#define    r_reg_fft_idx_max_7_0    0xF539
+#define reg_fft_idx_max_7_0_pos 0
+#define reg_fft_idx_max_7_0_len 8
+#define reg_fft_idx_max_7_0_lsb 0
+#define    r_reg_fft_idx_max_12_8   0xF53A
+#define reg_fft_idx_max_12_8_pos 0
+#define reg_fft_idx_max_12_8_len 5
+#define reg_fft_idx_max_12_8_lsb 8
+#define    p_reg_fft_rotate_en  0xF53B
+#define reg_fft_rotate_en_pos 0
+#define reg_fft_rotate_en_len 1
+#define reg_fft_rotate_en_lsb 0
+#define    p_reg_fft_rotate_base_7_0    0xF53C
+#define reg_fft_rotate_base_7_0_pos 0
+#define reg_fft_rotate_base_7_0_len 8
+#define reg_fft_rotate_base_7_0_lsb 0
+#define    p_reg_fft_rotate_base_12_8   0xF53D
+#define reg_fft_rotate_base_12_8_pos 0
+#define reg_fft_rotate_base_12_8_len 5
+#define reg_fft_rotate_base_12_8_lsb 8
+#define    r_fd_fpcc_cp_corr_signn  0xF53E
+#define fd_fpcc_cp_corr_signn_pos 0
+#define fd_fpcc_cp_corr_signn_len 8
+#define fd_fpcc_cp_corr_signn_lsb 0
+#define    p_reg_feq_s1 0xF53F
+#define reg_feq_s1_pos 0
+#define reg_feq_s1_len 5
+#define reg_feq_s1_lsb 0
+#define    p_reg_feq_sat_ind    0xF540
+#define reg_feq_sat_ind_pos 0
+#define reg_feq_sat_ind_len 3
+#define reg_feq_sat_ind_lsb 0
+#define    p_reg_p_csi_cal_en   0xF541
+#define reg_p_csi_cal_en_pos 0
+#define reg_p_csi_cal_en_len 1
+#define reg_p_csi_cal_en_lsb 0
+#define    p_reg_p_csi_ar_mode  0xF542
+#define reg_p_csi_ar_mode_pos 0
+#define reg_p_csi_ar_mode_len 2
+#define reg_p_csi_ar_mode_lsb 0
+#define    p_reg_p_csi_accu_sym_num 0xF543
+#define reg_p_csi_accu_sym_num_pos 0
+#define reg_p_csi_accu_sym_num_len 8
+#define reg_p_csi_accu_sym_num_lsb 0
+#define    p_reg_p_csi_eh2_shift_thr    0xF544
+#define reg_p_csi_eh2_shift_thr_pos 0
+#define reg_p_csi_eh2_shift_thr_len 4
+#define reg_p_csi_eh2_shift_thr_lsb 0
+#define    p_reg_p_feq_protect_eh2_shift_thr    0xF545
+#define reg_p_feq_protect_eh2_shift_thr_pos 0
+#define reg_p_feq_protect_eh2_shift_thr_len 4
+#define reg_p_feq_protect_eh2_shift_thr_lsb 0
+#define    p_reg_p_csi_error_accu_s1    0xF546
+#define reg_p_csi_error_accu_s1_pos 0
+#define reg_p_csi_error_accu_s1_len 6
+#define reg_p_csi_error_accu_s1_lsb 0
+#define    p_reg_p_csi_shift2   0xF547
+#define reg_p_csi_shift2_pos 0
+#define reg_p_csi_shift2_len 4
+#define reg_p_csi_shift2_lsb 0
+#define    p_reg_p_csi_mul2 0xF548
+#define reg_p_csi_mul2_pos 0
+#define reg_p_csi_mul2_len 8
+#define reg_p_csi_mul2_lsb 0
+#define    p_reg_p_csi_level2_7_0   0xF549
+#define reg_p_csi_level2_7_0_pos 0
+#define reg_p_csi_level2_7_0_len 8
+#define reg_p_csi_level2_7_0_lsb 0
+#define    p_reg_p_csi_level2_8 0xF54A
+#define reg_p_csi_level2_8_pos 0
+#define reg_p_csi_level2_8_len 1
+#define reg_p_csi_level2_8_lsb 8
+#define    p_reg_p_feq_protect_ratio    0xF54B
+#define reg_p_feq_protect_ratio_pos 0
+#define reg_p_feq_protect_ratio_len 8
+#define reg_p_feq_protect_ratio_lsb 0
+#define    r_reg_csi_rdy    0xF54C
+#define reg_csi_rdy_pos 0
+#define reg_csi_rdy_len 1
+#define reg_csi_rdy_lsb 0
+#define    p_reg_p_feq_h2protect_en 0xF54D
+#define reg_p_feq_h2protect_en_pos 0
+#define reg_p_feq_h2protect_en_len 1
+#define reg_p_feq_h2protect_en_lsb 0
+#define    r_reg_tpsd_lock_f0   0xF54E
+#define reg_tpsd_lock_f0_pos 0
+#define reg_tpsd_lock_f0_len 1
+#define reg_tpsd_lock_f0_lsb 0
+#define    r_reg_tpsd_lock_f1   0xF54F
+#define reg_tpsd_lock_f1_pos 0
+#define reg_tpsd_lock_f1_len 1
+#define reg_tpsd_lock_f1_lsb 0
+#define    p_reg_p_csi_sp_idx_7_0   0xF550
+#define reg_p_csi_sp_idx_7_0_pos 0
+#define reg_p_csi_sp_idx_7_0_len 8
+#define reg_p_csi_sp_idx_7_0_lsb 0
+#define    p_reg_p_csi_sp_idx_11_8  0xF551
+#define reg_p_csi_sp_idx_11_8_pos 0
+#define reg_p_csi_sp_idx_11_8_len 4
+#define reg_p_csi_sp_idx_11_8_lsb 8
+#define    p_fd_fpcc_cp_corr_tone_th    0xF552
+#define fd_fpcc_cp_corr_tone_th_pos 0
+#define fd_fpcc_cp_corr_tone_th_len 6
+#define fd_fpcc_cp_corr_tone_th_lsb 0
+#define    p_fd_fpcc_cp_corr_symbol_log_th  0xF553
+#define fd_fpcc_cp_corr_symbol_log_th_pos 0
+#define fd_fpcc_cp_corr_symbol_log_th_len 4
+#define fd_fpcc_cp_corr_symbol_log_th_lsb 0
+#define    p_fd_fpcc_cp_corr_int    0xF554
+#define fd_fpcc_cp_corr_int_pos 0
+#define fd_fpcc_cp_corr_int_len 1
+#define fd_fpcc_cp_corr_int_lsb 0
+#define    p_reg_fpcc_cp_memidx 0xF555
+#define reg_fpcc_cp_memidx_pos 0
+#define reg_fpcc_cp_memidx_len 8
+#define reg_fpcc_cp_memidx_lsb 0
+#define    p_reg_fpcc_cpmask_en 0xF556
+#define reg_fpcc_cpmask_en_pos 0
+#define reg_fpcc_cpmask_en_len 1
+#define reg_fpcc_cpmask_en_lsb 0
+#define    p_reg_fpcc_cp_grpidx 0xF557
+#define reg_fpcc_cp_grpidx_pos 0
+#define reg_fpcc_cp_grpidx_len 5
+#define reg_fpcc_cp_grpidx_lsb 0
+#define    r_reg_fpcc_cp_sts    0xF558
+#define reg_fpcc_cp_sts_pos 0
+#define reg_fpcc_cp_sts_len 1
+#define reg_fpcc_cp_sts_lsb 0
+#define    p_reg_sfoe_ns_7_0    0xF559
+#define reg_sfoe_ns_7_0_pos 0
+#define reg_sfoe_ns_7_0_len 8
+#define reg_sfoe_ns_7_0_lsb 0
+#define    p_reg_sfoe_ns_14_8   0xF55A
+#define reg_sfoe_ns_14_8_pos 0
+#define reg_sfoe_ns_14_8_len 7
+#define reg_sfoe_ns_14_8_lsb 8
+#define    p_reg_sfoe_c1_7_0    0xF55B
+#define reg_sfoe_c1_7_0_pos 0
+#define reg_sfoe_c1_7_0_len 8
+#define reg_sfoe_c1_7_0_lsb 0
+#define    p_reg_sfoe_c1_9_8    0xF55C
+#define reg_sfoe_c1_9_8_pos 0
+#define reg_sfoe_c1_9_8_len 2
+#define reg_sfoe_c1_9_8_lsb 8
+#define    p_reg_sfoe_c2_7_0    0xF55D
+#define reg_sfoe_c2_7_0_pos 0
+#define reg_sfoe_c2_7_0_len 8
+#define reg_sfoe_c2_7_0_lsb 0
+#define    p_reg_sfoe_c2_9_8    0xF55E
+#define reg_sfoe_c2_9_8_pos 0
+#define reg_sfoe_c2_9_8_len 2
+#define reg_sfoe_c2_9_8_lsb 8
+#define    p_reg_sfoe_lm_counter_th 0xF55F
+#define reg_sfoe_lm_counter_th_pos 0
+#define reg_sfoe_lm_counter_th_len 4
+#define reg_sfoe_lm_counter_th_lsb 0
+#define    p_reg_sfoe_spec_inv  0xF560
+#define reg_sfoe_spec_inv_pos 0
+#define reg_sfoe_spec_inv_len 1
+#define reg_sfoe_spec_inv_lsb 0
+#define    p_reg_sfoe_convg_th  0xF561
+#define reg_sfoe_convg_th_pos 0
+#define reg_sfoe_convg_th_len 8
+#define reg_sfoe_convg_th_lsb 0
+#define    p_reg_sfoe_divg_th   0xF562
+#define reg_sfoe_divg_th_pos 0
+#define reg_sfoe_divg_th_len 8
+#define reg_sfoe_divg_th_lsb 0
+#define    p_reg_sfoe_pullin_ctr_th 0xF563
+#define reg_sfoe_pullin_ctr_th_pos 0
+#define reg_sfoe_pullin_ctr_th_len 4
+#define reg_sfoe_pullin_ctr_th_lsb 0
+#define    p_reg_sfoe_sf_ctr_th 0xF564
+#define reg_sfoe_sf_ctr_th_pos 0
+#define reg_sfoe_sf_ctr_th_len 4
+#define reg_sfoe_sf_ctr_th_lsb 0
+#define    p_reg_sfoe_pullin_th 0xF565
+#define reg_sfoe_pullin_th_pos 0
+#define reg_sfoe_pullin_th_len 8
+#define reg_sfoe_pullin_th_lsb 0
+#define    p_reg_sfoe_kalman_cnt    0xF566
+#define reg_sfoe_kalman_cnt_pos 0
+#define reg_sfoe_kalman_cnt_len 4
+#define reg_sfoe_kalman_cnt_lsb 0
+#define    p_reg_sfoe_fsm_info  0xF567
+#define reg_sfoe_fsm_info_pos 0
+#define reg_sfoe_fsm_info_len 4
+#define reg_sfoe_fsm_info_lsb 0
+#define    r_reg_sfoe_pullin_cnt    0xF568
+#define reg_sfoe_pullin_cnt_pos 0
+#define reg_sfoe_pullin_cnt_len 4
+#define reg_sfoe_pullin_cnt_lsb 0
+#define    r_reg_sfoe_sf_cnt    0xF569
+#define reg_sfoe_sf_cnt_pos 0
+#define reg_sfoe_sf_cnt_len 4
+#define reg_sfoe_sf_cnt_lsb 0
+#define    p_reg_fste_phase_ini_7_0 0xF56A
+#define reg_fste_phase_ini_7_0_pos 0
+#define reg_fste_phase_ini_7_0_len 8
+#define reg_fste_phase_ini_7_0_lsb 0
+#define    p_reg_fste_phase_ini_11_8    0xF56B
+#define reg_fste_phase_ini_11_8_pos 0
+#define reg_fste_phase_ini_11_8_len 4
+#define reg_fste_phase_ini_11_8_lsb 8
+#define    p_reg_fste_phase_inc_7_0 0xF56C
+#define reg_fste_phase_inc_7_0_pos 0
+#define reg_fste_phase_inc_7_0_len 8
+#define reg_fste_phase_inc_7_0_lsb 0
+#define    p_reg_fste_phase_inc_11_8    0xF56D
+#define reg_fste_phase_inc_11_8_pos 0
+#define reg_fste_phase_inc_11_8_len 4
+#define reg_fste_phase_inc_11_8_lsb 8
+#define    p_reg_fste_acum_cost_cnt_max 0xF56E
+#define reg_fste_acum_cost_cnt_max_pos 0
+#define reg_fste_acum_cost_cnt_max_len 4
+#define reg_fste_acum_cost_cnt_max_lsb 0
+#define    p_reg_fste_step_size_std 0xF56F
+#define reg_fste_step_size_std_pos 0
+#define reg_fste_step_size_std_len 4
+#define reg_fste_step_size_std_lsb 0
+#define    p_reg_fste_step_size_max 0xF570
+#define reg_fste_step_size_max_pos 0
+#define reg_fste_step_size_max_len 4
+#define reg_fste_step_size_max_lsb 0
+#define    p_reg_fste_rpd_dir_cnt_max   0xF571
+#define reg_fste_rpd_dir_cnt_max_pos 0
+#define reg_fste_rpd_dir_cnt_max_len 4
+#define reg_fste_rpd_dir_cnt_max_lsb 0
+#define    p_reg_fste_frac_cost_cnt_max_7_0 0xF572
+#define reg_fste_frac_cost_cnt_max_7_0_pos 0
+#define reg_fste_frac_cost_cnt_max_7_0_len 8
+#define reg_fste_frac_cost_cnt_max_7_0_lsb 0
+#define    p_reg_fste_frac_cost_cnt_max_9_8 0xF573
+#define reg_fste_frac_cost_cnt_max_9_8_pos 0
+#define reg_fste_frac_cost_cnt_max_9_8_len 2
+#define reg_fste_frac_cost_cnt_max_9_8_lsb 8
+#define    p_reg_fste_isLongWeakTail    0xF574
+#define reg_fste_isLongWeakTail_pos 0
+#define reg_fste_isLongWeakTail_len 1
+#define reg_fste_isLongWeakTail_lsb 0
+#define    p_reg_fste_isLongWeakHead    0xF575
+#define reg_fste_isLongWeakHead_pos 0
+#define reg_fste_isLongWeakHead_len 1
+#define reg_fste_isLongWeakHead_lsb 0
+#define    p_reg_fste_w0_7_0    0xF576
+#define reg_fste_w0_7_0_pos 0
+#define reg_fste_w0_7_0_len 8
+#define reg_fste_w0_7_0_lsb 0
+#define    p_reg_fste_w0_9_8    0xF577
+#define reg_fste_w0_9_8_pos 0
+#define reg_fste_w0_9_8_len 2
+#define reg_fste_w0_9_8_lsb 8
+#define    p_reg_fste_w1_7_0    0xF578
+#define reg_fste_w1_7_0_pos 0
+#define reg_fste_w1_7_0_len 8
+#define reg_fste_w1_7_0_lsb 0
+#define    p_reg_fste_w1_9_8    0xF579
+#define reg_fste_w1_9_8_pos 0
+#define reg_fste_w1_9_8_len 2
+#define reg_fste_w1_9_8_lsb 8
+#define    p_reg_fste_w2_7_0    0xF57A
+#define reg_fste_w2_7_0_pos 0
+#define reg_fste_w2_7_0_len 8
+#define reg_fste_w2_7_0_lsb 0
+#define    p_reg_fste_w2_9_8    0xF57B
+#define reg_fste_w2_9_8_pos 0
+#define reg_fste_w2_9_8_len 2
+#define reg_fste_w2_9_8_lsb 8
+#define    p_reg_fste_w3_7_0    0xF57C
+#define reg_fste_w3_7_0_pos 0
+#define reg_fste_w3_7_0_len 8
+#define reg_fste_w3_7_0_lsb 0
+#define    p_reg_fste_w3_9_8    0xF57D
+#define reg_fste_w3_9_8_pos 0
+#define reg_fste_w3_9_8_len 2
+#define reg_fste_w3_9_8_lsb 8
+#define    p_reg_fste_w4_7_0    0xF57E
+#define reg_fste_w4_7_0_pos 0
+#define reg_fste_w4_7_0_len 8
+#define reg_fste_w4_7_0_lsb 0
+#define    p_reg_fste_w4_9_8    0xF57F
+#define reg_fste_w4_9_8_pos 0
+#define reg_fste_w4_9_8_len 2
+#define reg_fste_w4_9_8_lsb 8
+#define    p_reg_fste_w5_7_0    0xF580
+#define reg_fste_w5_7_0_pos 0
+#define reg_fste_w5_7_0_len 8
+#define reg_fste_w5_7_0_lsb 0
+#define    p_reg_fste_w5_9_8    0xF581
+#define reg_fste_w5_9_8_pos 0
+#define reg_fste_w5_9_8_len 2
+#define reg_fste_w5_9_8_lsb 8
+#define    p_reg_fste_w6_7_0    0xF582
+#define reg_fste_w6_7_0_pos 0
+#define reg_fste_w6_7_0_len 8
+#define reg_fste_w6_7_0_lsb 0
+#define    p_reg_fste_w6_9_8    0xF583
+#define reg_fste_w6_9_8_pos 0
+#define reg_fste_w6_9_8_len 2
+#define reg_fste_w6_9_8_lsb 8
+#define    p_reg_fste_w7_7_0    0xF584
+#define reg_fste_w7_7_0_pos 0
+#define reg_fste_w7_7_0_len 8
+#define reg_fste_w7_7_0_lsb 0
+#define    p_reg_fste_w7_9_8    0xF585
+#define reg_fste_w7_9_8_pos 0
+#define reg_fste_w7_9_8_len 2
+#define reg_fste_w7_9_8_lsb 8
+#define    p_reg_fste_w8_7_0    0xF586
+#define reg_fste_w8_7_0_pos 0
+#define reg_fste_w8_7_0_len 8
+#define reg_fste_w8_7_0_lsb 0
+#define    p_reg_fste_w8_9_8    0xF587
+#define reg_fste_w8_9_8_pos 0
+#define reg_fste_w8_9_8_len 2
+#define reg_fste_w8_9_8_lsb 8
+#define    p_reg_fste_w9_7_0    0xF588
+#define reg_fste_w9_7_0_pos 0
+#define reg_fste_w9_7_0_len 8
+#define reg_fste_w9_7_0_lsb 0
+#define    p_reg_fste_w9_9_8    0xF589
+#define reg_fste_w9_9_8_pos 0
+#define reg_fste_w9_9_8_len 2
+#define reg_fste_w9_9_8_lsb 8
+#define    p_reg_fste_wa_7_0    0xF58A
+#define reg_fste_wa_7_0_pos 0
+#define reg_fste_wa_7_0_len 8
+#define reg_fste_wa_7_0_lsb 0
+#define    p_reg_fste_wa_9_8    0xF58B
+#define reg_fste_wa_9_8_pos 0
+#define reg_fste_wa_9_8_len 2
+#define reg_fste_wa_9_8_lsb 8
+#define    p_reg_fste_wb_7_0    0xF58C
+#define reg_fste_wb_7_0_pos 0
+#define reg_fste_wb_7_0_len 8
+#define reg_fste_wb_7_0_lsb 0
+#define    p_reg_fste_wb_9_8    0xF58D
+#define reg_fste_wb_9_8_pos 0
+#define reg_fste_wb_9_8_len 2
+#define reg_fste_wb_9_8_lsb 8
+#define    p_reg_fste_wc_7_0    0xF58E
+#define reg_fste_wc_7_0_pos 0
+#define reg_fste_wc_7_0_len 8
+#define reg_fste_wc_7_0_lsb 0
+#define    p_reg_fste_wc_9_8    0xF58F
+#define reg_fste_wc_9_8_pos 0
+#define reg_fste_wc_9_8_len 2
+#define reg_fste_wc_9_8_lsb 8
+#define    p_reg_fste_wd_7_0    0xF590
+#define reg_fste_wd_7_0_pos 0
+#define reg_fste_wd_7_0_len 8
+#define reg_fste_wd_7_0_lsb 0
+#define    p_reg_fste_wd_9_8    0xF591
+#define reg_fste_wd_9_8_pos 0
+#define reg_fste_wd_9_8_len 2
+#define reg_fste_wd_9_8_lsb 8
+#define    p_reg_fste_we_7_0    0xF592
+#define reg_fste_we_7_0_pos 0
+#define reg_fste_we_7_0_len 8
+#define reg_fste_we_7_0_lsb 0
+#define    p_reg_fste_we_9_8    0xF593
+#define reg_fste_we_9_8_pos 0
+#define reg_fste_we_9_8_len 2
+#define reg_fste_we_9_8_lsb 8
+#define    p_reg_fste_wf_7_0    0xF594
+#define reg_fste_wf_7_0_pos 0
+#define reg_fste_wf_7_0_len 8
+#define reg_fste_wf_7_0_lsb 0
+#define    p_reg_fste_wf_9_8    0xF595
+#define reg_fste_wf_9_8_pos 0
+#define reg_fste_wf_9_8_len 2
+#define reg_fste_wf_9_8_lsb 8
+#define    p_reg_fste_wg_7_0    0xF596
+#define reg_fste_wg_7_0_pos 0
+#define reg_fste_wg_7_0_len 8
+#define reg_fste_wg_7_0_lsb 0
+#define    p_reg_fste_wg_9_8    0xF597
+#define reg_fste_wg_9_8_pos 0
+#define reg_fste_wg_9_8_len 2
+#define reg_fste_wg_9_8_lsb 8
+#define    p_reg_fste_wh_7_0    0xF598
+#define reg_fste_wh_7_0_pos 0
+#define reg_fste_wh_7_0_len 8
+#define reg_fste_wh_7_0_lsb 0
+#define    p_reg_fste_wh_9_8    0xF599
+#define reg_fste_wh_9_8_pos 0
+#define reg_fste_wh_9_8_len 2
+#define reg_fste_wh_9_8_lsb 8
+#define    r_fd_fste_i_adj_org  0xF59A
+#define fd_fste_i_adj_org_pos 0
+#define fd_fste_i_adj_org_len 5
+#define fd_fste_i_adj_org_lsb 0
+#define    r_fd_fste_f_adj_7_0  0xF59B
+#define fd_fste_f_adj_7_0_pos 0
+#define fd_fste_f_adj_7_0_len 8
+#define fd_fste_f_adj_7_0_lsb 0
+#define    r_fd_fste_f_adj_15_8 0xF59C
+#define fd_fste_f_adj_15_8_pos 0
+#define fd_fste_f_adj_15_8_len 8
+#define fd_fste_f_adj_15_8_lsb 8
+#define    r_fd_fste_f_adj_19_16    0xF59D
+#define fd_fste_f_adj_19_16_pos 0
+#define fd_fste_f_adj_19_16_len 4
+#define fd_fste_f_adj_19_16_lsb 16
+#define    p_reg_fste_ehw_7_0   0xF59E
+#define reg_fste_ehw_7_0_pos 0
+#define reg_fste_ehw_7_0_len 8
+#define reg_fste_ehw_7_0_lsb 0
+#define    p_reg_fste_ehw_12_8  0xF59F
+#define reg_fste_ehw_12_8_pos 0
+#define reg_fste_ehw_12_8_len 5
+#define reg_fste_ehw_12_8_lsb 8
+#define    p_reg_fste_i_adj_vld 0xF5A0
+#define reg_fste_i_adj_vld_pos 0
+#define reg_fste_i_adj_vld_len 1
+#define reg_fste_i_adj_vld_lsb 0
+#define    p_reg_fste_ceTimesPhasor_real    0xF5A1
+#define reg_fste_ceTimesPhasor_real_pos 0
+#define reg_fste_ceTimesPhasor_real_len 1
+#define reg_fste_ceTimesPhasor_real_lsb 0
+#define    p_reg_fste_ceTimesPhasor_imag    0xF5A2
+#define reg_fste_ceTimesPhasor_imag_pos 0
+#define reg_fste_ceTimesPhasor_imag_len 1
+#define reg_fste_ceTimesPhasor_imag_lsb 0
+#define    p_reg_fste_cerTimesW_real    0xF5A3
+#define reg_fste_cerTimesW_real_pos 0
+#define reg_fste_cerTimesW_real_len 1
+#define reg_fste_cerTimesW_real_lsb 0
+#define    p_reg_fste_cerTimesW_imag    0xF5A4
+#define reg_fste_cerTimesW_imag_pos 0
+#define reg_fste_cerTimesW_imag_len 1
+#define reg_fste_cerTimesW_imag_lsb 0
+#define    p_reg_fste_cerTimesWAccum_real   0xF5A5
+#define reg_fste_cerTimesWAccum_real_pos 0
+#define reg_fste_cerTimesWAccum_real_len 1
+#define reg_fste_cerTimesWAccum_real_lsb 0
+#define    p_reg_fste_cerTimesWAccum_imag   0xF5A6
+#define reg_fste_cerTimesWAccum_imag_pos 0
+#define reg_fste_cerTimesWAccum_imag_len 1
+#define reg_fste_cerTimesWAccum_imag_lsb 0
+#define    p_reg_fste_cost  0xF5A7
+#define reg_fste_cost_pos 0
+#define reg_fste_cost_len 1
+#define reg_fste_cost_lsb 0
+#define    p_fd_tpsd_en 0xF5A8
+#define fd_tpsd_en_pos 0
+#define fd_tpsd_en_len 1
+#define fd_tpsd_en_lsb 0
+#define    p_fd_tpsd_lock   0xF5A9
+#define fd_tpsd_lock_pos 0
+#define fd_tpsd_lock_len 1
+#define fd_tpsd_lock_lsb 0
+#define    r_fd_tpsd_s19    0xF5AA
+#define fd_tpsd_s19_pos 0
+#define fd_tpsd_s19_len 1
+#define fd_tpsd_s19_lsb 0
+#define    r_fd_tpsd_s17    0xF5AB
+#define fd_tpsd_s17_pos 0
+#define fd_tpsd_s17_len 1
+#define fd_tpsd_s17_lsb 0
+#define    p_fd_sfr_ste_en  0xF5AC
+#define fd_sfr_ste_en_pos 0
+#define fd_sfr_ste_en_len 1
+#define fd_sfr_ste_en_lsb 0
+#define    p_fd_sfr_ste_mode    0xF5AD
+#define fd_sfr_ste_mode_pos 0
+#define fd_sfr_ste_mode_len 2
+#define fd_sfr_ste_mode_lsb 0
+#define    p_fd_sfr_ste_done    0xF5AE
+#define fd_sfr_ste_done_pos 0
+#define fd_sfr_ste_done_len 1
+#define fd_sfr_ste_done_lsb 0
+#define    p_reg_cfoe_ffoe_en   0xF5AF
+#define reg_cfoe_ffoe_en_pos 0
+#define reg_cfoe_ffoe_en_len 1
+#define reg_cfoe_ffoe_en_lsb 0
+#define    p_reg_cfoe_ifoe_en   0xF5B0
+#define reg_cfoe_ifoe_en_pos 0
+#define reg_cfoe_ifoe_en_len 1
+#define reg_cfoe_ifoe_en_lsb 0
+#define    p_reg_cfoe_fot_en    0xF5B1
+#define reg_cfoe_fot_en_pos 0
+#define reg_cfoe_fot_en_len 1
+#define reg_cfoe_fot_en_lsb 0
+#define    p_reg_cfoe_fot_lm_en 0xF5B2
+#define reg_cfoe_fot_lm_en_pos 0
+#define reg_cfoe_fot_lm_en_len 1
+#define reg_cfoe_fot_lm_en_lsb 0
+#define    p_reg_cfoe_fot_rst   0xF5B3
+#define reg_cfoe_fot_rst_pos 0
+#define reg_cfoe_fot_rst_len 1
+#define reg_cfoe_fot_rst_lsb 0
+#define    r_fd_cfoe_ffoe_done  0xF5B4
+#define fd_cfoe_ffoe_done_pos 0
+#define fd_cfoe_ffoe_done_len 1
+#define fd_cfoe_ffoe_done_lsb 0
+#define    p_fd_cfoe_metric_vld 0xF5B5
+#define fd_cfoe_metric_vld_pos 0
+#define fd_cfoe_metric_vld_len 1
+#define fd_cfoe_metric_vld_lsb 0
+#define    p_reg_cfoe_ifod_vld  0xF5B6
+#define reg_cfoe_ifod_vld_pos 0
+#define reg_cfoe_ifod_vld_len 1
+#define reg_cfoe_ifod_vld_lsb 0
+#define    r_fd_cfoe_ifoe_done  0xF5B7
+#define fd_cfoe_ifoe_done_pos 0
+#define fd_cfoe_ifoe_done_len 1
+#define fd_cfoe_ifoe_done_lsb 0
+#define    p_reg_cfoe_ifoe_spec_inv 0xF5B8
+#define reg_cfoe_ifoe_spec_inv_pos 0
+#define reg_cfoe_ifoe_spec_inv_len 1
+#define reg_cfoe_ifoe_spec_inv_lsb 0
+#define    p_reg_cfoe_divg_int  0xF5B9
+#define reg_cfoe_divg_int_pos 0
+#define reg_cfoe_divg_int_len 1
+#define reg_cfoe_divg_int_lsb 0
+#define    r_reg_cfoe_divg_flag 0xF5BA
+#define reg_cfoe_divg_flag_pos 0
+#define reg_cfoe_divg_flag_len 1
+#define reg_cfoe_divg_flag_lsb 0
+#define    p_reg_sfoe_en    0xF5BB
+#define reg_sfoe_en_pos 0
+#define reg_sfoe_en_len 1
+#define reg_sfoe_en_lsb 0
+#define    p_reg_sfoe_dis   0xF5BC
+#define reg_sfoe_dis_pos 0
+#define reg_sfoe_dis_len 1
+#define reg_sfoe_dis_lsb 0
+#define    p_reg_sfoe_rst   0xF5BD
+#define reg_sfoe_rst_pos 0
+#define reg_sfoe_rst_len 1
+#define reg_sfoe_rst_lsb 0
+#define    p_reg_sfoe_vld_int   0xF5BE
+#define reg_sfoe_vld_int_pos 0
+#define reg_sfoe_vld_int_len 1
+#define reg_sfoe_vld_int_lsb 0
+#define    p_reg_sfoe_lm_en 0xF5BF
+#define reg_sfoe_lm_en_pos 0
+#define reg_sfoe_lm_en_len 1
+#define reg_sfoe_lm_en_lsb 0
+#define    p_reg_sfoe_divg_int  0xF5C0
+#define reg_sfoe_divg_int_pos 0
+#define reg_sfoe_divg_int_len 1
+#define reg_sfoe_divg_int_lsb 0
+#define    r_reg_sfoe_divg_flag 0xF5C1
+#define reg_sfoe_divg_flag_pos 0
+#define reg_sfoe_divg_flag_len 1
+#define reg_sfoe_divg_flag_lsb 0
+#define    p_reg_fft_rst    0xF5C2
+#define reg_fft_rst_pos 0
+#define reg_fft_rst_len 1
+#define reg_fft_rst_lsb 0
+#define    p_reg_fft_mask2_en   0xF5C3
+#define reg_fft_mask2_en_pos 0
+#define reg_fft_mask2_en_len 1
+#define reg_fft_mask2_en_lsb 0
+#define    p_reg_fft_mask3_en   0xF5C4
+#define reg_fft_mask3_en_pos 0
+#define reg_fft_mask3_en_len 1
+#define reg_fft_mask3_en_lsb 0
+#define    p_reg_fft_crc_en 0xF5C5
+#define reg_fft_crc_en_pos 0
+#define reg_fft_crc_en_len 1
+#define reg_fft_crc_en_lsb 0
+#define    p_reg_fft_mask0_en   0xF5C6
+#define reg_fft_mask0_en_pos 0
+#define reg_fft_mask0_en_len 1
+#define reg_fft_mask0_en_lsb 0
+#define    p_reg_fft_mask1_en   0xF5C7
+#define reg_fft_mask1_en_pos 0
+#define reg_fft_mask1_en_len 1
+#define reg_fft_mask1_en_lsb 0
+#define    p_fd_fste_en 0xF5C8
+#define fd_fste_en_pos 0
+#define fd_fste_en_len 1
+#define fd_fste_en_lsb 0
+#define    p_reg_feq_eh2_comp_en    0xF5C9
+#define reg_feq_eh2_comp_en_pos 0
+#define reg_feq_eh2_comp_en_len 1
+#define reg_feq_eh2_comp_en_lsb 0
+#define    p_reg_feq_read_update    0xF5CA
+#define reg_feq_read_update_pos 0
+#define reg_feq_read_update_len 1
+#define reg_feq_read_update_lsb 0
+#define    p_reg_feq_data_vld   0xF5CB
+#define reg_feq_data_vld_pos 0
+#define reg_feq_data_vld_len 1
+#define reg_feq_data_vld_lsb 0
+#define    p_reg_feq_tone_idx_7_0   0xF5CC
+#define reg_feq_tone_idx_7_0_pos 0
+#define reg_feq_tone_idx_7_0_len 8
+#define reg_feq_tone_idx_7_0_lsb 0
+#define    p_reg_feq_tone_idx_12_8  0xF5CD
+#define reg_feq_tone_idx_12_8_pos 0
+#define reg_feq_tone_idx_12_8_len 5
+#define reg_feq_tone_idx_12_8_lsb 8
+#define    r_reg_feq_data_re_7_0    0xF5CE
+#define reg_feq_data_re_7_0_pos 0
+#define reg_feq_data_re_7_0_len 8
+#define reg_feq_data_re_7_0_lsb 0
+#define    r_reg_feq_data_re_15_8   0xF5CF
+#define reg_feq_data_re_15_8_pos 0
+#define reg_feq_data_re_15_8_len 8
+#define reg_feq_data_re_15_8_lsb 8
+#define    r_reg_feq_data_re_21_16  0xF5D0
+#define reg_feq_data_re_21_16_pos 0
+#define reg_feq_data_re_21_16_len 6
+#define reg_feq_data_re_21_16_lsb 16
+#define    r_reg_feq_data_im_7_0    0xF5D1
+#define reg_feq_data_im_7_0_pos 0
+#define reg_feq_data_im_7_0_len 8
+#define reg_feq_data_im_7_0_lsb 0
+#define    r_reg_feq_data_im_15_8   0xF5D2
+#define reg_feq_data_im_15_8_pos 0
+#define reg_feq_data_im_15_8_len 8
+#define reg_feq_data_im_15_8_lsb 8
+#define    r_reg_feq_data_im_21_16  0xF5D3
+#define reg_feq_data_im_21_16_pos 0
+#define reg_feq_data_im_21_16_len 6
+#define reg_feq_data_im_21_16_lsb 16
+#define    r_reg_feq_data_h2_7_0    0xF5D4
+#define reg_feq_data_h2_7_0_pos 0
+#define reg_feq_data_h2_7_0_len 8
+#define reg_feq_data_h2_7_0_lsb 0
+#define    r_reg_feq_data_h2_15_8   0xF5D5
+#define reg_feq_data_h2_15_8_pos 0
+#define reg_feq_data_h2_15_8_len 8
+#define reg_feq_data_h2_15_8_lsb 8
+#define    r_reg_feq_data_h2_18_16  0xF5D6
+#define reg_feq_data_h2_18_16_pos 0
+#define reg_feq_data_h2_18_16_len 3
+#define reg_feq_data_h2_18_16_lsb 16
+#define    p_reg_fs_en  0xF5D7
+#define reg_fs_en_pos 0
+#define reg_fs_en_len 1
+#define reg_fs_en_lsb 0
+#define    p_reg_fs_offset  0xF5D8
+#define reg_fs_offset_pos 0
+#define reg_fs_offset_len 3
+#define reg_fs_offset_lsb 0
+#define    p_reg_fs_debug   0xF5D9
+#define reg_fs_debug_pos 0
+#define reg_fs_debug_len 1
+#define reg_fs_debug_lsb 0
+#define    p_reg_fs_half_inv    0xF5DA
+#define reg_fs_half_inv_pos 0
+#define reg_fs_half_inv_len 1
+#define reg_fs_half_inv_lsb 0
+#define    p_reg_cdpf_currentfftposition_7_0    0xF5DB
+#define reg_cdpf_currentfftposition_7_0_pos 0
+#define reg_cdpf_currentfftposition_7_0_len 8
+#define reg_cdpf_currentfftposition_7_0_lsb 0
+#define    p_reg_cdpf_currentfftposition_14_8   0xF5DC
+#define reg_cdpf_currentfftposition_14_8_pos 0
+#define reg_cdpf_currentfftposition_14_8_len 7
+#define reg_cdpf_currentfftposition_14_8_lsb 8
+#define    r_reg_cdpf_fftshift_7_0  0xF5DD
+#define reg_cdpf_fftshift_7_0_pos 0
+#define reg_cdpf_fftshift_7_0_len 8
+#define reg_cdpf_fftshift_7_0_lsb 0
+#define    r_reg_cdpf_fftshift_13_8 0xF5DE
+#define reg_cdpf_fftshift_13_8_pos 0
+#define reg_cdpf_fftshift_13_8_len 6
+#define reg_cdpf_fftshift_13_8_lsb 8
+#define    p_reg_cdpf_channelpowerdown_7_0  0xF5DF
+#define reg_cdpf_channelpowerdown_7_0_pos 0
+#define reg_cdpf_channelpowerdown_7_0_len 8
+#define reg_cdpf_channelpowerdown_7_0_lsb 0
+#define    p_reg_cdpf_channelpowerdown_10_8 0xF5E0
+#define reg_cdpf_channelpowerdown_10_8_pos 0
+#define reg_cdpf_channelpowerdown_10_8_len 3
+#define reg_cdpf_channelpowerdown_10_8_lsb 8
+#define    p_reg_cdpf_state 0xF5E1
+#define reg_cdpf_state_pos 0
+#define reg_cdpf_state_len 4
+#define reg_cdpf_state_lsb 0
+#define    p_reg_cdpf_echotestsearchingrange    0xF5E2
+#define reg_cdpf_echotestsearchingrange_pos 0
+#define reg_cdpf_echotestsearchingrange_len 8
+#define reg_cdpf_echotestsearchingrange_lsb 0
+#define    p_reg_cdpf_rxsymboldelay 0xF5E3
+#define reg_cdpf_rxsymboldelay_pos 0
+#define reg_cdpf_rxsymboldelay_len 4
+#define reg_cdpf_rxsymboldelay_lsb 0
+#define    p_reg_cdpf_ceavesymbolno 0xF5E4
+#define reg_cdpf_ceavesymbolno_pos 0
+#define reg_cdpf_ceavesymbolno_len 4
+#define reg_cdpf_ceavesymbolno_lsb 0
+#define    p_reg_cdpf_ceshift   0xF5E5
+#define reg_cdpf_ceshift_pos 0
+#define reg_cdpf_ceshift_len 3
+#define reg_cdpf_ceshift_lsb 0
+#define    p_reg_cdpf_postpreechotry    0xF5E6
+#define reg_cdpf_postpreechotry_pos 0
+#define reg_cdpf_postpreechotry_len 2
+#define reg_cdpf_postpreechotry_lsb 0
+#define    p_reg_cdpf_en    0xF5E7
+#define reg_cdpf_en_pos 0
+#define reg_cdpf_en_len 1
+#define reg_cdpf_en_lsb 0
+#define    p_reg_cdpf_stateready    0xF5E8
+#define reg_cdpf_stateready_pos 0
+#define reg_cdpf_stateready_len 1
+#define reg_cdpf_stateready_lsb 0
+#define    r_reg_cdpf_prepostpowercompare   0xF5E9
+#define reg_cdpf_prepostpowercompare_pos 0
+#define reg_cdpf_prepostpowercompare_len 1
+#define reg_cdpf_prepostpowercompare_lsb 0
+#define    r_reg_cdpf_candidateno   0xF5EA
+#define reg_cdpf_candidateno_pos 0
+#define reg_cdpf_candidateno_len 6
+#define reg_cdpf_candidateno_lsb 0
+#define    p_reg_cdpf_preechopower_7_0  0xF5EB
+#define reg_cdpf_preechopower_7_0_pos 0
+#define reg_cdpf_preechopower_7_0_len 8
+#define reg_cdpf_preechopower_7_0_lsb 0
+#define    p_reg_cdpf_preechopower_15_8 0xF5EC
+#define reg_cdpf_preechopower_15_8_pos 0
+#define reg_cdpf_preechopower_15_8_len 8
+#define reg_cdpf_preechopower_15_8_lsb 8
+#define    p_reg_cdpf_postechopower_7_0 0xF5ED
+#define reg_cdpf_postechopower_7_0_pos 0
+#define reg_cdpf_postechopower_7_0_len 8
+#define reg_cdpf_postechopower_7_0_lsb 0
+#define    p_reg_cdpf_postechopower_15_8    0xF5EE
+#define reg_cdpf_postechopower_15_8_pos 0
+#define reg_cdpf_postechopower_15_8_len 8
+#define reg_cdpf_postechopower_15_8_lsb 8
+#define    p_reg_cdpf_searchingend  0xF5EF
+#define reg_cdpf_searchingend_pos 0
+#define reg_cdpf_searchingend_len 8
+#define reg_cdpf_searchingend_lsb 0
+#define    r_reg_cdpf_candidate_7_0 0xF5F0
+#define reg_cdpf_candidate_7_0_pos 0
+#define reg_cdpf_candidate_7_0_len 8
+#define reg_cdpf_candidate_7_0_lsb 0
+#define    r_reg_cdpf_candidate_15_8    0xF5F1
+#define reg_cdpf_candidate_15_8_pos 0
+#define reg_cdpf_candidate_15_8_len 8
+#define reg_cdpf_candidate_15_8_lsb 8
+#define    p_reg_cdpf_candidate_rptr    0xF5F2
+#define reg_cdpf_candidate_rptr_pos 0
+#define reg_cdpf_candidate_rptr_len 7
+#define reg_cdpf_candidate_rptr_lsb 0
+#define    p_reg_cdpf_candidate_rptr_force  0xF5F3
+#define reg_cdpf_candidate_rptr_force_pos 0
+#define reg_cdpf_candidate_rptr_force_len 1
+#define reg_cdpf_candidate_rptr_force_lsb 0
+#define    p_reg_cdpf_trialshiftoffset_7_0  0xF5F4
+#define reg_cdpf_trialshiftoffset_7_0_pos 0
+#define reg_cdpf_trialshiftoffset_7_0_len 8
+#define reg_cdpf_trialshiftoffset_7_0_lsb 0
+#define    p_reg_cdpf_trialshiftoffset_13_8 0xF5F5
+#define reg_cdpf_trialshiftoffset_13_8_pos 0
+#define reg_cdpf_trialshiftoffset_13_8_len 6
+#define reg_cdpf_trialshiftoffset_13_8_lsb 8
+#define    p_reg_cdpf_channellength_7_0 0xF5F6
+#define reg_cdpf_channellength_7_0_pos 0
+#define reg_cdpf_channellength_7_0_len 8
+#define reg_cdpf_channellength_7_0_lsb 0
+#define    p_reg_cdpf_channellength_12_8    0xF5F7
+#define reg_cdpf_channellength_12_8_pos 0
+#define reg_cdpf_channellength_12_8_len 5
+#define reg_cdpf_channellength_12_8_lsb 8
+#define    p_reg_cdpf_hardwaresort  0xF5F8
+#define reg_cdpf_hardwaresort_pos 0
+#define reg_cdpf_hardwaresort_len 1
+#define reg_cdpf_hardwaresort_lsb 0
+#define    p_reg_cdpf_maxcandidateno    0xF5F9
+#define reg_cdpf_maxcandidateno_pos 0
+#define reg_cdpf_maxcandidateno_len 3
+#define reg_cdpf_maxcandidateno_lsb 0
+#define    p_reg_cdpf_channelleftindex  0xF5FA
+#define reg_cdpf_channelleftindex_pos 0
+#define reg_cdpf_channelleftindex_len 4
+#define reg_cdpf_channelleftindex_lsb 0
+#define    r_reg_cdpf_fdishift_7_0  0xF5FB
+#define reg_cdpf_fdishift_7_0_pos 0
+#define reg_cdpf_fdishift_7_0_len 8
+#define reg_cdpf_fdishift_7_0_lsb 0
+#define    r_reg_cdpf_fdishift_15_8 0xF5FC
+#define reg_cdpf_fdishift_15_8_pos 0
+#define reg_cdpf_fdishift_15_8_len 8
+#define reg_cdpf_fdishift_15_8_lsb 8
+#define    p_reg_cdpf_guardband 0xF5FD
+#define reg_cdpf_guardband_pos 0
+#define reg_cdpf_guardband_len 5
+#define reg_cdpf_guardband_lsb 0
+#define    p_reg_cdpf_maxtonemaxindex_7_0   0xF5FE
+#define reg_cdpf_maxtonemaxindex_7_0_pos 0
+#define reg_cdpf_maxtonemaxindex_7_0_len 8
+#define reg_cdpf_maxtonemaxindex_7_0_lsb 0
+#define    p_reg_cdpf_maxtonemaxindex_12_8  0xF5FF
+#define reg_cdpf_maxtonemaxindex_12_8_pos 0
+#define reg_cdpf_maxtonemaxindex_12_8_len 5
+#define reg_cdpf_maxtonemaxindex_12_8_lsb 8
+#define    p_reg_cdpf_fdiw0 0xF600
+#define reg_cdpf_fdiw0_pos 0
+#define reg_cdpf_fdiw0_len 7
+#define reg_cdpf_fdiw0_lsb 0
+#define    p_reg_cdpf_fdiw1 0xF601
+#define reg_cdpf_fdiw1_pos 0
+#define reg_cdpf_fdiw1_len 7
+#define reg_cdpf_fdiw1_lsb 0
+#define    p_reg_cdpf_fdiw2 0xF602
+#define reg_cdpf_fdiw2_pos 0
+#define reg_cdpf_fdiw2_len 7
+#define reg_cdpf_fdiw2_lsb 0
+#define    p_reg_cdpf_fdiw3 0xF603
+#define reg_cdpf_fdiw3_pos 0
+#define reg_cdpf_fdiw3_len 7
+#define reg_cdpf_fdiw3_lsb 0
+#define    p_reg_cdpf_fdiw4 0xF604
+#define reg_cdpf_fdiw4_pos 0
+#define reg_cdpf_fdiw4_len 7
+#define reg_cdpf_fdiw4_lsb 0
+#define    p_reg_cdpf_fdiw5 0xF605
+#define reg_cdpf_fdiw5_pos 0
+#define reg_cdpf_fdiw5_len 7
+#define reg_cdpf_fdiw5_lsb 0
+#define    p_reg_cdpf_fdiw6 0xF606
+#define reg_cdpf_fdiw6_pos 0
+#define reg_cdpf_fdiw6_len 7
+#define reg_cdpf_fdiw6_lsb 0
+#define    p_reg_cdpf_fdiw7 0xF607
+#define reg_cdpf_fdiw7_pos 0
+#define reg_cdpf_fdiw7_len 7
+#define reg_cdpf_fdiw7_lsb 0
+#define    r_reg_cdpf_fdiwindowsize 0xF608
+#define reg_cdpf_fdiwindowsize_pos 0
+#define reg_cdpf_fdiwindowsize_len 4
+#define reg_cdpf_fdiwindowsize_lsb 0
+#define    p_reg_stes_mode  0xF609
+#define reg_stes_mode_pos 0
+#define reg_stes_mode_len 1
+#define reg_stes_mode_lsb 0
+#define    p_reg_stes_done_st   0xF60A
+#define reg_stes_done_st_pos 0
+#define reg_stes_done_st_len 2
+#define reg_stes_done_st_lsb 0
+#define    p_reg_stes_done  0xF60B
+#define reg_stes_done_pos 0
+#define reg_stes_done_len 1
+#define reg_stes_done_lsb 0
+#define    p_reg_stes_timing_7_0    0xF60C
+#define reg_stes_timing_7_0_pos 0
+#define reg_stes_timing_7_0_len 8
+#define reg_stes_timing_7_0_lsb 0
+#define    p_reg_stes_timing_15_8   0xF60D
+#define reg_stes_timing_15_8_pos 0
+#define reg_stes_timing_15_8_len 8
+#define reg_stes_timing_15_8_lsb 8
+#define    p_reg_stes_sym_tot_adj_thre_7_0  0xF60E
+#define reg_stes_sym_tot_adj_thre_7_0_pos 0
+#define reg_stes_sym_tot_adj_thre_7_0_len 8
+#define reg_stes_sym_tot_adj_thre_7_0_lsb 0
+#define    p_reg_stes_sym_tot_adj_thre_15_8 0xF60F
+#define reg_stes_sym_tot_adj_thre_15_8_pos 0
+#define reg_stes_sym_tot_adj_thre_15_8_len 8
+#define reg_stes_sym_tot_adj_thre_15_8_lsb 8
+#define    p_reg_stes_sym_thre_9_2  0xF610
+#define reg_stes_sym_thre_9_2_pos 0
+#define reg_stes_sym_thre_9_2_len 8
+#define reg_stes_sym_thre_9_2_lsb 0
+#define    p_reg_stes_sym_wo_adj_thre_9_2   0xF611
+#define reg_stes_sym_wo_adj_thre_9_2_pos 0
+#define reg_stes_sym_wo_adj_thre_9_2_len 8
+#define reg_stes_sym_wo_adj_thre_9_2_lsb 0
+#define    p_reg_fste_i_adj_7_0 0xF612
+#define reg_fste_i_adj_7_0_pos 0
+#define reg_fste_i_adj_7_0_len 8
+#define reg_fste_i_adj_7_0_lsb 0
+#define    p_reg_fste_i_adj_15_8    0xF613
+#define reg_fste_i_adj_15_8_pos 0
+#define reg_fste_i_adj_15_8_len 8
+#define reg_fste_i_adj_15_8_lsb 8
+#define    r_fd_stes_iadj_val_7_0   0xF614
+#define fd_stes_iadj_val_7_0_pos 0
+#define fd_stes_iadj_val_7_0_len 8
+#define fd_stes_iadj_val_7_0_lsb 0
+#define    r_fd_stes_iadj_val_15_8  0xF615
+#define fd_stes_iadj_val_15_8_pos 0
+#define fd_stes_iadj_val_15_8_len 8
+#define fd_stes_iadj_val_15_8_lsb 8
+#define    r_fd_stes_symb_cnt_9_2   0xF616
+#define fd_stes_symb_cnt_9_2_pos 0
+#define fd_stes_symb_cnt_9_2_len 8
+#define fd_stes_symb_cnt_9_2_lsb 0
+#define    r_fd_stes_snoi_cnt_9_2   0xF617
+#define fd_stes_snoi_cnt_9_2_pos 0
+#define fd_stes_snoi_cnt_9_2_len 8
+#define fd_stes_snoi_cnt_9_2_lsb 0
+#define    r_fd_last_iadj_val_7_0   0xF618
+#define fd_last_iadj_val_7_0_pos 0
+#define fd_last_iadj_val_7_0_len 8
+#define fd_last_iadj_val_7_0_lsb 0
+#define    r_fd_last_iadj_val_15_8  0xF619
+#define fd_last_iadj_val_15_8_pos 0
+#define fd_last_iadj_val_15_8_len 8
+#define fd_last_iadj_val_15_8_lsb 8
+#define    p_reg_stes_bypass    0xF61A
+#define reg_stes_bypass_pos 0
+#define reg_stes_bypass_len 1
+#define reg_stes_bypass_lsb 0
+#define    p_reg_stes_best_timing_idx   0xF61B
+#define reg_stes_best_timing_idx_pos 0
+#define reg_stes_best_timing_idx_len 4
+#define reg_stes_best_timing_idx_lsb 0
+#define    p_reg_stes_iadj_val_7_0  0xF61C
+#define reg_stes_iadj_val_7_0_pos 0
+#define reg_stes_iadj_val_7_0_len 8
+#define reg_stes_iadj_val_7_0_lsb 0
+#define    p_reg_stes_iadj_val_15_8 0xF61D
+#define reg_stes_iadj_val_15_8_pos 0
+#define reg_stes_iadj_val_15_8_len 8
+#define reg_stes_iadj_val_15_8_lsb 8
+#define    p_reg_p_ste_start_guard_7_0  0xF620
+#define reg_p_ste_start_guard_7_0_pos 0
+#define reg_p_ste_start_guard_7_0_len 8
+#define reg_p_ste_start_guard_7_0_lsb 0
+#define    p_reg_p_ste_start_guard_9_8  0xF621
+#define reg_p_ste_start_guard_9_8_pos 0
+#define reg_p_ste_start_guard_9_8_len 2
+#define reg_p_ste_start_guard_9_8_lsb 8
+#define    p_reg_p_ste_end_guard_7_0    0xF622
+#define reg_p_ste_end_guard_7_0_pos 0
+#define reg_p_ste_end_guard_7_0_len 8
+#define reg_p_ste_end_guard_7_0_lsb 0
+#define    p_reg_p_ste_end_guard_9_8    0xF623
+#define reg_p_ste_end_guard_9_8_pos 0
+#define reg_p_ste_end_guard_9_8_len 2
+#define reg_p_ste_end_guard_9_8_lsb 8
+#define    r_reg_r_ste_wrong_beacon_count   0xF624
+#define reg_r_ste_wrong_beacon_count_pos 0
+#define reg_r_ste_wrong_beacon_count_len 7
+#define reg_r_ste_wrong_beacon_count_lsb 0
+#define    p_reg_p_fccid_en 0xF625
+#define reg_p_fccid_en_pos 0
+#define reg_p_fccid_en_len 1
+#define reg_p_fccid_en_lsb 0
+#define    p_reg_p_fccid_fft_ave_symbol_num 0xF626
+#define reg_p_fccid_fft_ave_symbol_num_pos 0
+#define reg_p_fccid_fft_ave_symbol_num_len 6
+#define reg_p_fccid_fft_ave_symbol_num_lsb 0
+#define    p_reg_p_fccid_fft_work_start_tone_7_0    0xF627
+#define reg_p_fccid_fft_work_start_tone_7_0_pos 0
+#define reg_p_fccid_fft_work_start_tone_7_0_len 8
+#define reg_p_fccid_fft_work_start_tone_7_0_lsb 0
+#define    p_reg_p_fccid_fft_work_start_tone_12_8   0xF628
+#define reg_p_fccid_fft_work_start_tone_12_8_pos 0
+#define reg_p_fccid_fft_work_start_tone_12_8_len 5
+#define reg_p_fccid_fft_work_start_tone_12_8_lsb 8
+#define    p_reg_p_fccid_fft_work_end_tone_7_0  0xF629
+#define reg_p_fccid_fft_work_end_tone_7_0_pos 0
+#define reg_p_fccid_fft_work_end_tone_7_0_len 8
+#define reg_p_fccid_fft_work_end_tone_7_0_lsb 0
+#define    p_reg_p_fccid_fft_work_end_tone_12_8 0xF62A
+#define reg_p_fccid_fft_work_end_tone_12_8_pos 0
+#define reg_p_fccid_fft_work_end_tone_12_8_len 5
+#define reg_p_fccid_fft_work_end_tone_12_8_lsb 8
+#define    p_reg_p_fccid_peak_to_th_divider 0xF62B
+#define reg_p_fccid_peak_to_th_divider_pos 0
+#define reg_p_fccid_peak_to_th_divider_len 4
+#define reg_p_fccid_peak_to_th_divider_lsb 0
+#define    p_reg_p_fccid_peak_to_th_mode    0xF62C
+#define reg_p_fccid_peak_to_th_mode_pos 0
+#define reg_p_fccid_peak_to_th_mode_len 2
+#define reg_p_fccid_peak_to_th_mode_lsb 0
+#define    p_reg_p_fccid_search_mode    0xF62D
+#define reg_p_fccid_search_mode_pos 0
+#define reg_p_fccid_search_mode_len 1
+#define reg_p_fccid_search_mode_lsb 0
+#define    p_reg_p_fccid_group_th   0xF62E
+#define reg_p_fccid_group_th_pos 0
+#define reg_p_fccid_group_th_len 7
+#define reg_p_fccid_group_th_lsb 0
+#define    p_reg_p_fccid_search_rdy 0xF62F
+#define reg_p_fccid_search_rdy_pos 0
+#define reg_p_fccid_search_rdy_len 1
+#define reg_p_fccid_search_rdy_lsb 0
+#define    r_reg_r_fccid_fft_ave_read_out_7_0   0xF630
+#define reg_r_fccid_fft_ave_read_out_7_0_pos 0
+#define reg_r_fccid_fft_ave_read_out_7_0_len 8
+#define reg_r_fccid_fft_ave_read_out_7_0_lsb 0
+#define    r_reg_r_fccid_fft_ave_read_out_15_8  0xF631
+#define reg_r_fccid_fft_ave_read_out_15_8_pos 0
+#define reg_r_fccid_fft_ave_read_out_15_8_len 8
+#define reg_r_fccid_fft_ave_read_out_15_8_lsb 8
+#define    r_reg_r_fccid_large_tone_num_7_0 0xF632
+#define reg_r_fccid_large_tone_num_7_0_pos 0
+#define reg_r_fccid_large_tone_num_7_0_len 8
+#define reg_r_fccid_large_tone_num_7_0_lsb 0
+#define    r_reg_r_fccid_large_tone_num_12_8    0xF633
+#define reg_r_fccid_large_tone_num_12_8_pos 0
+#define reg_r_fccid_large_tone_num_12_8_len 5
+#define reg_r_fccid_large_tone_num_12_8_lsb 8
+#define    r_reg_r_fccid_cci1_start_tone_7_0    0xF634
+#define reg_r_fccid_cci1_start_tone_7_0_pos 0
+#define reg_r_fccid_cci1_start_tone_7_0_len 8
+#define reg_r_fccid_cci1_start_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci1_start_tone_12_8   0xF635
+#define reg_r_fccid_cci1_start_tone_12_8_pos 0
+#define reg_r_fccid_cci1_start_tone_12_8_len 5
+#define reg_r_fccid_cci1_start_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci1_end_tone_7_0  0xF636
+#define reg_r_fccid_cci1_end_tone_7_0_pos 0
+#define reg_r_fccid_cci1_end_tone_7_0_len 8
+#define reg_r_fccid_cci1_end_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci1_end_tone_12_8 0xF637
+#define reg_r_fccid_cci1_end_tone_12_8_pos 0
+#define reg_r_fccid_cci1_end_tone_12_8_len 5
+#define reg_r_fccid_cci1_end_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci1_peak_7_0  0xF638
+#define reg_r_fccid_cci1_peak_7_0_pos 0
+#define reg_r_fccid_cci1_peak_7_0_len 8
+#define reg_r_fccid_cci1_peak_7_0_lsb 0
+#define    r_reg_r_fccid_cci1_peak_15_8 0xF639
+#define reg_r_fccid_cci1_peak_15_8_pos 0
+#define reg_r_fccid_cci1_peak_15_8_len 8
+#define reg_r_fccid_cci1_peak_15_8_lsb 8
+#define    r_reg_r_fccid_cci2_start_tone_7_0    0xF63A
+#define reg_r_fccid_cci2_start_tone_7_0_pos 0
+#define reg_r_fccid_cci2_start_tone_7_0_len 8
+#define reg_r_fccid_cci2_start_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci2_start_tone_12_8   0xF63B
+#define reg_r_fccid_cci2_start_tone_12_8_pos 0
+#define reg_r_fccid_cci2_start_tone_12_8_len 5
+#define reg_r_fccid_cci2_start_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci2_end_tone_7_0  0xF63C
+#define reg_r_fccid_cci2_end_tone_7_0_pos 0
+#define reg_r_fccid_cci2_end_tone_7_0_len 8
+#define reg_r_fccid_cci2_end_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci2_end_tone_12_8 0xF63D
+#define reg_r_fccid_cci2_end_tone_12_8_pos 0
+#define reg_r_fccid_cci2_end_tone_12_8_len 5
+#define reg_r_fccid_cci2_end_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci2_peak_7_0  0xF63E
+#define reg_r_fccid_cci2_peak_7_0_pos 0
+#define reg_r_fccid_cci2_peak_7_0_len 8
+#define reg_r_fccid_cci2_peak_7_0_lsb 0
+#define    r_reg_r_fccid_cci2_peak_15_8 0xF63F
+#define reg_r_fccid_cci2_peak_15_8_pos 0
+#define reg_r_fccid_cci2_peak_15_8_len 8
+#define reg_r_fccid_cci2_peak_15_8_lsb 8
+#define    r_reg_r_fccid_cci3_start_tone_7_0    0xF640
+#define reg_r_fccid_cci3_start_tone_7_0_pos 0
+#define reg_r_fccid_cci3_start_tone_7_0_len 8
+#define reg_r_fccid_cci3_start_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci3_start_tone_12_8   0xF641
+#define reg_r_fccid_cci3_start_tone_12_8_pos 0
+#define reg_r_fccid_cci3_start_tone_12_8_len 5
+#define reg_r_fccid_cci3_start_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci3_end_tone_7_0  0xF642
+#define reg_r_fccid_cci3_end_tone_7_0_pos 0
+#define reg_r_fccid_cci3_end_tone_7_0_len 8
+#define reg_r_fccid_cci3_end_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci3_end_tone_12_8 0xF643
+#define reg_r_fccid_cci3_end_tone_12_8_pos 0
+#define reg_r_fccid_cci3_end_tone_12_8_len 5
+#define reg_r_fccid_cci3_end_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci3_peak_7_0  0xF644
+#define reg_r_fccid_cci3_peak_7_0_pos 0
+#define reg_r_fccid_cci3_peak_7_0_len 8
+#define reg_r_fccid_cci3_peak_7_0_lsb 0
+#define    r_reg_r_fccid_cci3_peak_15_8 0xF645
+#define reg_r_fccid_cci3_peak_15_8_pos 0
+#define reg_r_fccid_cci3_peak_15_8_len 8
+#define reg_r_fccid_cci3_peak_15_8_lsb 8
+#define    r_reg_r_fccid_cci4_start_tone_7_0    0xF646
+#define reg_r_fccid_cci4_start_tone_7_0_pos 0
+#define reg_r_fccid_cci4_start_tone_7_0_len 8
+#define reg_r_fccid_cci4_start_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci4_start_tone_12_8   0xF647
+#define reg_r_fccid_cci4_start_tone_12_8_pos 0
+#define reg_r_fccid_cci4_start_tone_12_8_len 5
+#define reg_r_fccid_cci4_start_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci4_end_tone_7_0  0xF648
+#define reg_r_fccid_cci4_end_tone_7_0_pos 0
+#define reg_r_fccid_cci4_end_tone_7_0_len 8
+#define reg_r_fccid_cci4_end_tone_7_0_lsb 0
+#define    r_reg_r_fccid_cci4_end_tone_12_8 0xF649
+#define reg_r_fccid_cci4_end_tone_12_8_pos 0
+#define reg_r_fccid_cci4_end_tone_12_8_len 5
+#define reg_r_fccid_cci4_end_tone_12_8_lsb 8
+#define    r_reg_r_fccid_cci4_peak_7_0  0xF64A
+#define reg_r_fccid_cci4_peak_7_0_pos 0
+#define reg_r_fccid_cci4_peak_7_0_len 8
+#define reg_r_fccid_cci4_peak_7_0_lsb 0
+#define    r_reg_r_fccid_cci4_peak_15_8 0xF64B
+#define reg_r_fccid_cci4_peak_15_8_pos 0
+#define reg_r_fccid_cci4_peak_15_8_len 8
+#define reg_r_fccid_cci4_peak_15_8_lsb 8
+#define    r_reg_r_fccid_cci1_rank  0xF64C
+#define reg_r_fccid_cci1_rank_pos 0
+#define reg_r_fccid_cci1_rank_len 3
+#define reg_r_fccid_cci1_rank_lsb 0
+#define    r_reg_r_fccid_cci2_rank  0xF64D
+#define reg_r_fccid_cci2_rank_pos 0
+#define reg_r_fccid_cci2_rank_len 3
+#define reg_r_fccid_cci2_rank_lsb 0
+#define    r_reg_r_fccid_cci3_rank  0xF64E
+#define reg_r_fccid_cci3_rank_pos 0
+#define reg_r_fccid_cci3_rank_len 3
+#define reg_r_fccid_cci3_rank_lsb 0
+#define    r_reg_r_fccid_cci4_rank  0xF64F
+#define reg_r_fccid_cci4_rank_pos 0
+#define reg_r_fccid_cci4_rank_len 3
+#define reg_r_fccid_cci4_rank_lsb 0
+#define    p_reg_p_csi_shift3   0xF650
+#define reg_p_csi_shift3_pos 0
+#define reg_p_csi_shift3_len 4
+#define reg_p_csi_shift3_lsb 0
+#define    p_reg_p_csi_mul3 0xF651
+#define reg_p_csi_mul3_pos 0
+#define reg_p_csi_mul3_len 8
+#define reg_p_csi_mul3_lsb 0
+#define    p_reg_p_csi_level3_7_0   0xF652
+#define reg_p_csi_level3_7_0_pos 0
+#define reg_p_csi_level3_7_0_len 8
+#define reg_p_csi_level3_7_0_lsb 0
+#define    p_reg_p_csi_level3_8 0xF653
+#define reg_p_csi_level3_8_pos 0
+#define reg_p_csi_level3_8_len 1
+#define reg_p_csi_level3_8_lsb 8
+#define    p_reg_p_csi_fftout_shift_fix_value   0xF654
+#define reg_p_csi_fftout_shift_fix_value_pos 0
+#define reg_p_csi_fftout_shift_fix_value_len 4
+#define reg_p_csi_fftout_shift_fix_value_lsb 0
+#define    p_reg_p_feq_scale_pow    0xF655
+#define reg_p_feq_scale_pow_pos 0
+#define reg_p_feq_scale_pow_len 6
+#define reg_p_feq_scale_pow_lsb 0
+#define    p_reg_p_csi_cp_idx   0xF656
+#define reg_p_csi_cp_idx_pos 0
+#define reg_p_csi_cp_idx_len 8
+#define reg_p_csi_cp_idx_lsb 0
+#define    p_reg_p_csi_outsh_zero_th_7_0    0xF657
+#define reg_p_csi_outsh_zero_th_7_0_pos 0
+#define reg_p_csi_outsh_zero_th_7_0_len 8
+#define reg_p_csi_outsh_zero_th_7_0_lsb 0
+#define    p_reg_p_csi_outsh_zero_th_10_8   0xF658
+#define reg_p_csi_outsh_zero_th_10_8_pos 0
+#define reg_p_csi_outsh_zero_th_10_8_len 3
+#define reg_p_csi_outsh_zero_th_10_8_lsb 8
+#define    p_reg_p_csi_ar_ratio 0xF659
+#define reg_p_csi_ar_ratio_pos 0
+#define reg_p_csi_ar_ratio_len 8
+#define reg_p_csi_ar_ratio_lsb 0
+#define    p_reg_r_csi_cp_vld   0xF65A
+#define reg_r_csi_cp_vld_pos 0
+#define reg_r_csi_cp_vld_len 1
+#define reg_r_csi_cp_vld_lsb 0
+#define    p_reg_r_csi_sp_vld   0xF65B
+#define reg_r_csi_sp_vld_pos 0
+#define reg_r_csi_sp_vld_len 1
+#define reg_r_csi_sp_vld_lsb 0
+#define    p_reg_p_csi_fft_out_shift_en 0xF65C
+#define reg_p_csi_fft_out_shift_en_pos 0
+#define reg_p_csi_fft_out_shift_en_len 1
+#define reg_p_csi_fft_out_shift_en_lsb 0
+#define    p_reg_p_csi_feq_out_shift_en 0xF65D
+#define reg_p_csi_feq_out_shift_en_pos 0
+#define reg_p_csi_feq_out_shift_en_len 1
+#define reg_p_csi_feq_out_shift_en_lsb 0
+#define    p_reg_r_csi_cp_fft_out   0xF65E
+#define reg_r_csi_cp_fft_out_pos 0
+#define reg_r_csi_cp_fft_out_len 1
+#define reg_r_csi_cp_fft_out_lsb 0
+#define    p_reg_r_csi_sp_feq_log2_out  0xF65F
+#define reg_r_csi_sp_feq_log2_out_pos 0
+#define reg_r_csi_sp_feq_log2_out_len 8
+#define reg_r_csi_sp_feq_log2_out_lsb 0
+#define    p_reg_r_csi_sp_fft_out   0xF660
+#define reg_r_csi_sp_fft_out_pos 0
+#define reg_r_csi_sp_fft_out_len 1
+#define reg_r_csi_sp_fft_out_lsb 0
+#define    p_reg_p_feq_eh2_from_fpcc_en 0xF661
+#define reg_p_feq_eh2_from_fpcc_en_pos 0
+#define reg_p_feq_eh2_from_fpcc_en_len 1
+#define reg_p_feq_eh2_from_fpcc_en_lsb 0
+#define    r_reg_r_fccid_fft_ave_peak_7_0   0xF662
+#define reg_r_fccid_fft_ave_peak_7_0_pos 0
+#define reg_r_fccid_fft_ave_peak_7_0_len 8
+#define reg_r_fccid_fft_ave_peak_7_0_lsb 0
+#define    r_reg_r_fccid_fft_ave_peak_15_8  0xF663
+#define reg_r_fccid_fft_ave_peak_15_8_pos 0
+#define reg_r_fccid_fft_ave_peak_15_8_len 8
+#define reg_r_fccid_fft_ave_peak_15_8_lsb 8
+#define    r_reg_r_fccid_fft_ave_peak_23_16 0xF664
+#define reg_r_fccid_fft_ave_peak_23_16_pos 0
+#define reg_r_fccid_fft_ave_peak_23_16_len 8
+#define reg_r_fccid_fft_ave_peak_23_16_lsb 16
+#define    r_reg_r_fccid_fft_ave_peak_26_24 0xF665
+#define reg_r_fccid_fft_ave_peak_26_24_pos 0
+#define reg_r_fccid_fft_ave_peak_26_24_len 3
+#define reg_r_fccid_fft_ave_peak_26_24_lsb 24
+#define    p_reg_p_fccid_fft_ave_read_rdy   0xF666
+#define reg_p_fccid_fft_ave_read_rdy_pos 0
+#define reg_p_fccid_fft_ave_read_rdy_len 1
+#define reg_p_fccid_fft_ave_read_rdy_lsb 0
+#define    p_reg_p_fccid_fft_ave_read_index_7_0 0xF667
+#define reg_p_fccid_fft_ave_read_index_7_0_pos 0
+#define reg_p_fccid_fft_ave_read_index_7_0_len 8
+#define reg_p_fccid_fft_ave_read_index_7_0_lsb 0
+#define    p_reg_p_fccid_fft_ave_read_index_12_8    0xF668
+#define reg_p_fccid_fft_ave_read_index_12_8_pos 0
+#define reg_p_fccid_fft_ave_read_index_12_8_len 5
+#define reg_p_fccid_fft_ave_read_index_12_8_lsb 8
+#define    p_reg_cdpf_candidate_rw  0xF669
+#define reg_cdpf_candidate_rw_pos 0
+#define reg_cdpf_candidate_rw_len 1
+#define reg_cdpf_candidate_rw_lsb 0
+#define    p_reg_cdpf_candidate_prog_7_0    0xF66A
+#define reg_cdpf_candidate_prog_7_0_pos 0
+#define reg_cdpf_candidate_prog_7_0_len 8
+#define reg_cdpf_candidate_prog_7_0_lsb 0
+#define    p_reg_cdpf_candidate_prog_15_8   0xF66B
+#define reg_cdpf_candidate_prog_15_8_pos 0
+#define reg_cdpf_candidate_prog_15_8_len 8
+#define reg_cdpf_candidate_prog_15_8_lsb 8
+#define    p_reg_cdpf_candidateno_prog  0xF66C
+#define reg_cdpf_candidateno_prog_pos 0
+#define reg_cdpf_candidateno_prog_len 6
+#define reg_cdpf_candidateno_prog_lsb 0
+#define    p_reg_cdpf_candidateno_switch    0xF66D
+#define reg_cdpf_candidateno_switch_pos 0
+#define reg_cdpf_candidateno_switch_len 1
+#define reg_cdpf_candidateno_switch_lsb 0
+#define    g_reg_tpsd_txmod 0xF900
+#define reg_tpsd_txmod_pos 0
+#define reg_tpsd_txmod_len 2
+#define reg_tpsd_txmod_lsb 0
+#define    g_reg_tpsd_gi    0xF901
+#define reg_tpsd_gi_pos 0
+#define reg_tpsd_gi_len 2
+#define reg_tpsd_gi_lsb 0
+#define    g_reg_tpsd_hier  0xF902
+#define reg_tpsd_hier_pos 0
+#define reg_tpsd_hier_len 3
+#define reg_tpsd_hier_lsb 0
+#define    g_reg_tpsd_const 0xF903
+#define reg_tpsd_const_pos 0
+#define reg_tpsd_const_len 2
+#define reg_tpsd_const_lsb 0
+#define    g_reg_bw 0xF904
+#define reg_bw_pos 0
+#define reg_bw_len 2
+#define reg_bw_lsb 0
+#define    g_reg_dec_pri    0xF905
+#define reg_dec_pri_pos 0
+#define reg_dec_pri_len 1
+#define reg_dec_pri_lsb 0
+#define    g_reg_tpsd_hpcr  0xF906
+#define reg_tpsd_hpcr_pos 0
+#define reg_tpsd_hpcr_len 3
+#define reg_tpsd_hpcr_lsb 0
+#define    g_reg_tpsd_lpcr  0xF907
+#define reg_tpsd_lpcr_pos 0
+#define reg_tpsd_lpcr_len 3
+#define reg_tpsd_lpcr_lsb 0
+#define    g_reg_tpsd_indep 0xF908
+#define reg_tpsd_indep_pos 0
+#define reg_tpsd_indep_len 1
+#define reg_tpsd_indep_lsb 0
+#define    g_reg_tpsd_tslice    0xF909
+#define reg_tpsd_tslice_pos 0
+#define reg_tpsd_tslice_len 1
+#define reg_tpsd_tslice_lsb 0
+#define    g_reg_tpsd_mpefec    0xF90A
+#define reg_tpsd_mpefec_pos 0
+#define reg_tpsd_mpefec_len 1
+#define reg_tpsd_mpefec_lsb 0
+#define    g_reg_sntc_en    0xF90B
+#define reg_sntc_en_pos 0
+#define reg_sntc_en_len 1
+#define reg_sntc_en_lsb 0
+#define    g_reg_intp_sys_div   0xF90C
+#define reg_intp_sys_div_pos 0
+#define reg_intp_sys_div_len 1
+#define reg_intp_sys_div_lsb 0
+#define    g_reg_clk_sntc_sel   0xF90D
+#define reg_clk_sntc_sel_pos 0
+#define reg_clk_sntc_sel_len 3
+#define reg_clk_sntc_sel_lsb 0
+#define    p_reg_ce_gs_force    0xFD00
+#define reg_ce_gs_force_pos 0
+#define reg_ce_gs_force_len 1
+#define reg_ce_gs_force_lsb 0
+#define    p_reg_ce_dagcgain_delay  0xFD01
+#define reg_ce_dagcgain_delay_pos 0
+#define reg_ce_dagcgain_delay_len 2
+#define reg_ce_dagcgain_delay_lsb 0
+#define    p_reg_ce_derot_en    0xFD02
+#define reg_ce_derot_en_pos 0
+#define reg_ce_derot_en_len 1
+#define reg_ce_derot_en_lsb 0
+#define    p_reg_ce_fctrl_en    0xFD05
+#define reg_ce_fctrl_en_pos 0
+#define reg_ce_fctrl_en_len 1
+#define reg_ce_fctrl_en_lsb 0
+#define    p_reg_ce_en  0xFD06
+#define reg_ce_en_pos 0
+#define reg_ce_en_len 1
+#define reg_ce_en_lsb 0
+#define    p_reg_ce_sat_wes 0xFD07
+#define reg_ce_sat_wes_pos 0
+#define reg_ce_sat_wes_len 1
+#define reg_ce_sat_wes_lsb 0
+#define    p_reg_ce_sat_sigma2  0xFD08
+#define reg_ce_sat_sigma2_pos 0
+#define reg_ce_sat_sigma2_len 1
+#define reg_ce_sat_sigma2_lsb 0
+#define    p_reg_ce_sat_tdi_br_re   0xFD09
+#define reg_ce_sat_tdi_br_re_pos 0
+#define reg_ce_sat_tdi_br_re_len 1
+#define reg_ce_sat_tdi_br_re_lsb 0
+#define    p_reg_ce_sat_tdi_br_im   0xFD0A
+#define reg_ce_sat_tdi_br_im_pos 0
+#define reg_ce_sat_tdi_br_im_len 1
+#define reg_ce_sat_tdi_br_im_lsb 0
+#define    p_reg_ce_sat_tdi_ar_re   0xFD0B
+#define reg_ce_sat_tdi_ar_re_pos 0
+#define reg_ce_sat_tdi_ar_re_len 1
+#define reg_ce_sat_tdi_ar_re_lsb 0
+#define    p_reg_ce_sat_tdi_ar_im   0xFD0C
+#define reg_ce_sat_tdi_ar_im_pos 0
+#define reg_ce_sat_tdi_ar_im_len 1
+#define reg_ce_sat_tdi_ar_im_lsb 0
+#define    p_reg_ce_sat_fdi_br_re   0xFD0D
+#define reg_ce_sat_fdi_br_re_pos 0
+#define reg_ce_sat_fdi_br_re_len 1
+#define reg_ce_sat_fdi_br_re_lsb 0
+#define    p_reg_ce_sat_fdi_br_im   0xFD0E
+#define reg_ce_sat_fdi_br_im_pos 0
+#define reg_ce_sat_fdi_br_im_len 1
+#define reg_ce_sat_fdi_br_im_lsb 0
+#define    p_reg_ce_var_forced_value    0xFD0F
+#define reg_ce_var_forced_value_pos 0
+#define reg_ce_var_forced_value_len 3
+#define reg_ce_var_forced_value_lsb 0
+#define    p_reg_ce_s1  0xFD10
+#define reg_ce_s1_pos 0
+#define reg_ce_s1_len 5
+#define reg_ce_s1_lsb 0
+#define    r_reg_ce_tdi_flatness_7_0    0xFD11
+#define reg_ce_tdi_flatness_7_0_pos 0
+#define reg_ce_tdi_flatness_7_0_len 8
+#define reg_ce_tdi_flatness_7_0_lsb 0
+#define    r_reg_ce_tdi_flatness_8  0xFD12
+#define reg_ce_tdi_flatness_8_pos 0
+#define reg_ce_tdi_flatness_8_len 1
+#define reg_ce_tdi_flatness_8_lsb 8
+#define    r_reg_ce_tone_7_0    0xFD13
+#define reg_ce_tone_7_0_pos 0
+#define reg_ce_tone_7_0_len 8
+#define reg_ce_tone_7_0_lsb 0
+#define    r_reg_ce_tone_12_8   0xFD14
+#define reg_ce_tone_12_8_pos 0
+#define reg_ce_tone_12_8_len 5
+#define reg_ce_tone_12_8_lsb 8
+#define    p_reg_ce_centroid_drift_th   0xFD15
+#define reg_ce_centroid_drift_th_pos 0
+#define reg_ce_centroid_drift_th_len 8
+#define reg_ce_centroid_drift_th_lsb 0
+#define    p_reg_ce_centroid_bias_inc_7_0   0xFD16
+#define reg_ce_centroid_bias_inc_7_0_pos 0
+#define reg_ce_centroid_bias_inc_7_0_len 8
+#define reg_ce_centroid_bias_inc_7_0_lsb 0
+#define    p_reg_ce_centroid_bias_inc_8 0xFD17
+#define reg_ce_centroid_bias_inc_8_pos 0
+#define reg_ce_centroid_bias_inc_8_len 1
+#define reg_ce_centroid_bias_inc_8_lsb 8
+#define    p_reg_ce_centroid_count_max  0xFD18
+#define reg_ce_centroid_count_max_pos 0
+#define reg_ce_centroid_count_max_len 4
+#define reg_ce_centroid_count_max_lsb 0
+#define    p_reg_ce_var_th0_7_0 0xFD19
+#define reg_ce_var_th0_7_0_pos 0
+#define reg_ce_var_th0_7_0_len 8
+#define reg_ce_var_th0_7_0_lsb 0
+#define    p_reg_ce_var_th0_15_8    0xFD1A
+#define reg_ce_var_th0_15_8_pos 0
+#define reg_ce_var_th0_15_8_len 8
+#define reg_ce_var_th0_15_8_lsb 8
+#define    p_reg_ce_var_th1_7_0 0xFD1B
+#define reg_ce_var_th1_7_0_pos 0
+#define reg_ce_var_th1_7_0_len 8
+#define reg_ce_var_th1_7_0_lsb 0
+#define    p_reg_ce_var_th1_15_8    0xFD1C
+#define reg_ce_var_th1_15_8_pos 0
+#define reg_ce_var_th1_15_8_len 8
+#define reg_ce_var_th1_15_8_lsb 8
+#define    p_reg_ce_var_th2_7_0 0xFD1D
+#define reg_ce_var_th2_7_0_pos 0
+#define reg_ce_var_th2_7_0_len 8
+#define reg_ce_var_th2_7_0_lsb 0
+#define    p_reg_ce_var_th2_15_8    0xFD1E
+#define reg_ce_var_th2_15_8_pos 0
+#define reg_ce_var_th2_15_8_len 8
+#define reg_ce_var_th2_15_8_lsb 8
+#define    p_reg_ce_var_th3_7_0 0xFD1F
+#define reg_ce_var_th3_7_0_pos 0
+#define reg_ce_var_th3_7_0_len 8
+#define reg_ce_var_th3_7_0_lsb 0
+#define    p_reg_ce_var_th3_15_8    0xFD20
+#define reg_ce_var_th3_15_8_pos 0
+#define reg_ce_var_th3_15_8_len 8
+#define reg_ce_var_th3_15_8_lsb 8
+#define    p_reg_ce_var_th4_7_0 0xFD21
+#define reg_ce_var_th4_7_0_pos 0
+#define reg_ce_var_th4_7_0_len 8
+#define reg_ce_var_th4_7_0_lsb 0
+#define    p_reg_ce_var_th4_15_8    0xFD22
+#define reg_ce_var_th4_15_8_pos 0
+#define reg_ce_var_th4_15_8_len 8
+#define reg_ce_var_th4_15_8_lsb 8
+#define    p_reg_ce_var_th5_7_0 0xFD23
+#define reg_ce_var_th5_7_0_pos 0
+#define reg_ce_var_th5_7_0_len 8
+#define reg_ce_var_th5_7_0_lsb 0
+#define    p_reg_ce_var_th5_15_8    0xFD24
+#define reg_ce_var_th5_15_8_pos 0
+#define reg_ce_var_th5_15_8_len 8
+#define reg_ce_var_th5_15_8_lsb 8
+#define    p_reg_ce_var_th6_7_0 0xFD25
+#define reg_ce_var_th6_7_0_pos 0
+#define reg_ce_var_th6_7_0_len 8
+#define reg_ce_var_th6_7_0_lsb 0
+#define    p_reg_ce_var_th6_15_8    0xFD26
+#define reg_ce_var_th6_15_8_pos 0
+#define reg_ce_var_th6_15_8_len 8
+#define reg_ce_var_th6_15_8_lsb 8
+#define    p_reg_ce_var_max 0xFD27
+#define reg_ce_var_max_pos 0
+#define reg_ce_var_max_len 3
+#define reg_ce_var_max_lsb 0
+#define    p_reg_ce_cent_forced_en  0xFD28
+#define reg_ce_cent_forced_en_pos 0
+#define reg_ce_cent_forced_en_len 1
+#define reg_ce_cent_forced_en_lsb 0
+#define    p_reg_ce_var_forced_en   0xFD29
+#define reg_ce_var_forced_en_pos 0
+#define reg_ce_var_forced_en_len 1
+#define reg_ce_var_forced_en_lsb 0
+#define    p_reg_ce_fctrl_auto_reset_en 0xFD2A
+#define reg_ce_fctrl_auto_reset_en_pos 0
+#define reg_ce_fctrl_auto_reset_en_len 1
+#define reg_ce_fctrl_auto_reset_en_lsb 0
+#define    p_reg_ce_cent_auto_clr_en    0xFD2B
+#define reg_ce_cent_auto_clr_en_pos 0
+#define reg_ce_cent_auto_clr_en_len 1
+#define reg_ce_cent_auto_clr_en_lsb 0
+#define    p_reg_ce_fctrl_reset 0xFD2C
+#define reg_ce_fctrl_reset_pos 0
+#define reg_ce_fctrl_reset_len 1
+#define reg_ce_fctrl_reset_lsb 0
+#define    p_reg_ce_cent_forced_value_7_0   0xFD2D
+#define reg_ce_cent_forced_value_7_0_pos 0
+#define reg_ce_cent_forced_value_7_0_len 8
+#define reg_ce_cent_forced_value_7_0_lsb 0
+#define    p_reg_ce_cent_forced_value_11_8  0xFD2E
+#define reg_ce_cent_forced_value_11_8_pos 0
+#define reg_ce_cent_forced_value_11_8_len 4
+#define reg_ce_cent_forced_value_11_8_lsb 8
+#define    p_reg_ce_cent_auto_clr_value_7_0 0xFD2F
+#define reg_ce_cent_auto_clr_value_7_0_pos 0
+#define reg_ce_cent_auto_clr_value_7_0_len 8
+#define reg_ce_cent_auto_clr_value_7_0_lsb 0
+#define    p_reg_ce_cent_auto_clr_value_11_8    0xFD30
+#define reg_ce_cent_auto_clr_value_11_8_pos 0
+#define reg_ce_cent_auto_clr_value_11_8_len 4
+#define reg_ce_cent_auto_clr_value_11_8_lsb 8
+#define    p_reg_ce_centroid_max_7_0    0xFD31
+#define reg_ce_centroid_max_7_0_pos 0
+#define reg_ce_centroid_max_7_0_len 8
+#define reg_ce_centroid_max_7_0_lsb 0
+#define    p_reg_ce_centroid_max_11_8   0xFD32
+#define reg_ce_centroid_max_11_8_pos 0
+#define reg_ce_centroid_max_11_8_len 4
+#define reg_ce_centroid_max_11_8_lsb 8
+#define    p_reg_ce_fctrl_rd    0xFD33
+#define reg_ce_fctrl_rd_pos 0
+#define reg_ce_fctrl_rd_len 1
+#define reg_ce_fctrl_rd_lsb 0
+#define    r_reg_ce_centroid_out_7_0    0xFD34
+#define reg_ce_centroid_out_7_0_pos 0
+#define reg_ce_centroid_out_7_0_len 8
+#define reg_ce_centroid_out_7_0_lsb 0
+#define    r_reg_ce_centroid_out_11_8   0xFD35
+#define reg_ce_centroid_out_11_8_pos 0
+#define reg_ce_centroid_out_11_8_len 4
+#define reg_ce_centroid_out_11_8_lsb 8
+#define    r_reg_ce_fctrl_rdy   0xFD36
+#define reg_ce_fctrl_rdy_pos 0
+#define reg_ce_fctrl_rdy_len 1
+#define reg_ce_fctrl_rdy_lsb 0
+#define    r_reg_ce_var 0xFD37
+#define reg_ce_var_pos 0
+#define reg_ce_var_len 3
+#define reg_ce_var_lsb 0
+#define    r_reg_ce_bias_7_0    0xFD38
+#define reg_ce_bias_7_0_pos 0
+#define reg_ce_bias_7_0_len 8
+#define reg_ce_bias_7_0_lsb 0
+#define    r_reg_ce_bias_11_8   0xFD39
+#define reg_ce_bias_11_8_pos 0
+#define reg_ce_bias_11_8_len 4
+#define reg_ce_bias_11_8_lsb 8
+#define    r_reg_ce_m1_7_0  0xFD3A
+#define reg_ce_m1_7_0_pos 0
+#define reg_ce_m1_7_0_len 8
+#define reg_ce_m1_7_0_lsb 0
+#define    r_reg_ce_m1_11_8 0xFD3B
+#define reg_ce_m1_11_8_pos 0
+#define reg_ce_m1_11_8_len 4
+#define reg_ce_m1_11_8_lsb 8
+#define    r_reg_ce_rh0_7_0 0xFD3C
+#define reg_ce_rh0_7_0_pos 0
+#define reg_ce_rh0_7_0_len 8
+#define reg_ce_rh0_7_0_lsb 0
+#define    r_reg_ce_rh0_15_8    0xFD3D
+#define reg_ce_rh0_15_8_pos 0
+#define reg_ce_rh0_15_8_len 8
+#define reg_ce_rh0_15_8_lsb 8
+#define    r_reg_ce_rh0_23_16   0xFD3E
+#define reg_ce_rh0_23_16_pos 0
+#define reg_ce_rh0_23_16_len 8
+#define reg_ce_rh0_23_16_lsb 16
+#define    r_reg_ce_rh0_31_24   0xFD3F
+#define reg_ce_rh0_31_24_pos 0
+#define reg_ce_rh0_31_24_len 8
+#define reg_ce_rh0_31_24_lsb 24
+#define    p_reg_ce_tdi_delta   0xFD40
+#define reg_ce_tdi_delta_pos 0
+#define reg_ce_tdi_delta_len 3
+#define reg_ce_tdi_delta_lsb 0
+#define    p_reg_ce_fdi_delta   0xFD41
+#define reg_ce_fdi_delta_pos 0
+#define reg_ce_fdi_delta_len 3
+#define reg_ce_fdi_delta_lsb 0
+#define    p_reg_ce_fste_delta  0xFD42
+#define reg_ce_fste_delta_pos 0
+#define reg_ce_fste_delta_len 3
+#define reg_ce_fste_delta_lsb 0
+#define    r_reg_ce_fft_s1  0xFD43
+#define reg_ce_fft_s1_pos 0
+#define reg_ce_fft_s1_len 4
+#define reg_ce_fft_s1_lsb 0
+#define    r_reg_feq_fix_eh2_7_0    0xFD44
+#define reg_feq_fix_eh2_7_0_pos 0
+#define reg_feq_fix_eh2_7_0_len 8
+#define reg_feq_fix_eh2_7_0_lsb 0
+#define    r_reg_feq_fix_eh2_15_8   0xFD45
+#define reg_feq_fix_eh2_15_8_pos 0
+#define reg_feq_fix_eh2_15_8_len 8
+#define reg_feq_fix_eh2_15_8_lsb 8
+#define    r_reg_feq_fix_eh2_23_16  0xFD46
+#define reg_feq_fix_eh2_23_16_pos 0
+#define reg_feq_fix_eh2_23_16_len 8
+#define reg_feq_fix_eh2_23_16_lsb 16
+#define    r_reg_feq_fix_eh2_31_24  0xFD47
+#define reg_feq_fix_eh2_31_24_pos 0
+#define reg_feq_fix_eh2_31_24_len 8
+#define reg_feq_fix_eh2_31_24_lsb 24
+#define    r_reg_ce_m2_central_7_0  0xFD48
+#define reg_ce_m2_central_7_0_pos 0
+#define reg_ce_m2_central_7_0_len 8
+#define reg_ce_m2_central_7_0_lsb 0
+#define    r_reg_ce_m2_central_15_8 0xFD49
+#define reg_ce_m2_central_15_8_pos 0
+#define reg_ce_m2_central_15_8_len 8
+#define reg_ce_m2_central_15_8_lsb 8
+#define    r_reg_ce_sigma2_7_0  0xFD4A
+#define reg_ce_sigma2_7_0_pos 0
+#define reg_ce_sigma2_7_0_len 8
+#define reg_ce_sigma2_7_0_lsb 0
+#define    r_reg_ce_sigma2_15_8 0xFD4B
+#define reg_ce_sigma2_15_8_pos 0
+#define reg_ce_sigma2_15_8_len 8
+#define reg_ce_sigma2_15_8_lsb 8
+#define    r_reg_ce_sigma2_19_16    0xFD4C
+#define reg_ce_sigma2_19_16_pos 0
+#define reg_ce_sigma2_19_16_len 4
+#define reg_ce_sigma2_19_16_lsb 16
+#define    r_reg_ce_data_im_7_0 0xFD4D
+#define reg_ce_data_im_7_0_pos 0
+#define reg_ce_data_im_7_0_len 8
+#define reg_ce_data_im_7_0_lsb 0
+#define    r_reg_ce_data_im_14_8    0xFD4E
+#define reg_ce_data_im_14_8_pos 0
+#define reg_ce_data_im_14_8_len 7
+#define reg_ce_data_im_14_8_lsb 8
+#define    r_reg_ce_data_re_7_0 0xFD4F
+#define reg_ce_data_re_7_0_pos 0
+#define reg_ce_data_re_7_0_len 8
+#define reg_ce_data_re_7_0_lsb 0
+#define    r_reg_ce_data_re_14_8    0xFD50
+#define reg_ce_data_re_14_8_pos 0
+#define reg_ce_data_re_14_8_len 7
+#define reg_ce_data_re_14_8_lsb 8
+#define    p_reg_ce_var_default_value   0xFD51
+#define reg_ce_var_default_value_pos 0
+#define reg_ce_var_default_value_len 3
+#define reg_ce_var_default_value_lsb 0
+#define    p_reg_ce_cent_default_value_7_0  0xFD52
+#define reg_ce_cent_default_value_7_0_pos 0
+#define reg_ce_cent_default_value_7_0_len 8
+#define reg_ce_cent_default_value_7_0_lsb 0
+#define    p_reg_ce_cent_default_value_11_8 0xFD53
+#define reg_ce_cent_default_value_11_8_pos 0
+#define reg_ce_cent_default_value_11_8_len 4
+#define reg_ce_cent_default_value_11_8_lsb 8
+#define    r_reg_ce_var_hw  0xFD54
+#define reg_ce_var_hw_pos 0
+#define reg_ce_var_hw_len 3
+#define reg_ce_var_hw_lsb 0
+#define    r_reg_ce_cent_hw_7_0 0xFD55
+#define reg_ce_cent_hw_7_0_pos 0
+#define reg_ce_cent_hw_7_0_len 8
+#define reg_ce_cent_hw_7_0_lsb 0
+#define    r_reg_ce_cent_hw_11_8    0xFD56
+#define reg_ce_cent_hw_11_8_pos 0
+#define reg_ce_cent_hw_11_8_len 4
+#define reg_ce_cent_hw_11_8_lsb 8
+#define    p_reg_ce_fdi_cp_test_en  0xFD57
+#define reg_ce_fdi_cp_test_en_pos 0
+#define reg_ce_fdi_cp_test_en_len 1
+#define reg_ce_fdi_cp_test_en_lsb 0
+#define    p_reg_ce_cptestindex0_7_0    0xFD58
+#define reg_ce_cptestindex0_7_0_pos 0
+#define reg_ce_cptestindex0_7_0_len 8
+#define reg_ce_cptestindex0_7_0_lsb 0
+#define    p_reg_ce_cptestindex0_12_8   0xFD59
+#define reg_ce_cptestindex0_12_8_pos 0
+#define reg_ce_cptestindex0_12_8_len 5
+#define reg_ce_cptestindex0_12_8_lsb 8
+#define    p_reg_ce_cptestfdi0  0xFD5A
+#define reg_ce_cptestfdi0_pos 0
+#define reg_ce_cptestfdi0_len 3
+#define reg_ce_cptestfdi0_lsb 0
+#define    p_reg_ce_cptestindex1_7_0    0xFD5B
+#define reg_ce_cptestindex1_7_0_pos 0
+#define reg_ce_cptestindex1_7_0_len 8
+#define reg_ce_cptestindex1_7_0_lsb 0
+#define    p_reg_ce_cptestindex1_12_8   0xFD5C
+#define reg_ce_cptestindex1_12_8_pos 0
+#define reg_ce_cptestindex1_12_8_len 5
+#define reg_ce_cptestindex1_12_8_lsb 8
+#define    p_reg_ce_cptestfdi1  0xFD5D
+#define reg_ce_cptestfdi1_pos 0
+#define reg_ce_cptestfdi1_len 3
+#define reg_ce_cptestfdi1_lsb 0
+#define    p_reg_ce_cptestindex2_7_0    0xFD5E
+#define reg_ce_cptestindex2_7_0_pos 0
+#define reg_ce_cptestindex2_7_0_len 8
+#define reg_ce_cptestindex2_7_0_lsb 0
+#define    p_reg_ce_cptestindex2_12_8   0xFD5F
+#define reg_ce_cptestindex2_12_8_pos 0
+#define reg_ce_cptestindex2_12_8_len 5
+#define reg_ce_cptestindex2_12_8_lsb 8
+#define    p_reg_ce_cptestfdi2  0xFD60
+#define reg_ce_cptestfdi2_pos 0
+#define reg_ce_cptestfdi2_len 3
+#define reg_ce_cptestfdi2_lsb 0
+#define    p_reg_ce_cptestindex3_7_0    0xFD61
+#define reg_ce_cptestindex3_7_0_pos 0
+#define reg_ce_cptestindex3_7_0_len 8
+#define reg_ce_cptestindex3_7_0_lsb 0
+#define    p_reg_ce_cptestindex3_12_8   0xFD62
+#define reg_ce_cptestindex3_12_8_pos 0
+#define reg_ce_cptestindex3_12_8_len 5
+#define reg_ce_cptestindex3_12_8_lsb 8
+#define    p_reg_ce_cptestfdi3  0xFD63
+#define reg_ce_cptestfdi3_pos 0
+#define reg_ce_cptestfdi3_len 3
+#define reg_ce_cptestfdi3_lsb 0
+#define    p_reg_ce_cptestindex4_7_0    0xFD64
+#define reg_ce_cptestindex4_7_0_pos 0
+#define reg_ce_cptestindex4_7_0_len 8
+#define reg_ce_cptestindex4_7_0_lsb 0
+#define    p_reg_ce_cptestindex4_12_8   0xFD65
+#define reg_ce_cptestindex4_12_8_pos 0
+#define reg_ce_cptestindex4_12_8_len 5
+#define reg_ce_cptestindex4_12_8_lsb 8
+#define    p_reg_ce_cptestfdi4  0xFD66
+#define reg_ce_cptestfdi4_pos 0
+#define reg_ce_cptestfdi4_len 3
+#define reg_ce_cptestfdi4_lsb 0
+#define    p_reg_ce_cptestindex5_7_0    0xFD67
+#define reg_ce_cptestindex5_7_0_pos 0
+#define reg_ce_cptestindex5_7_0_len 8
+#define reg_ce_cptestindex5_7_0_lsb 0
+#define    p_reg_ce_cptestindex5_12_8   0xFD68
+#define reg_ce_cptestindex5_12_8_pos 0
+#define reg_ce_cptestindex5_12_8_len 5
+#define reg_ce_cptestindex5_12_8_lsb 8
+#define    p_reg_ce_cptestfdi5  0xFD69
+#define reg_ce_cptestfdi5_pos 0
+#define reg_ce_cptestfdi5_len 3
+#define reg_ce_cptestfdi5_lsb 0
+#define    p_reg_ce_cptestindex6_7_0    0xFD6A
+#define reg_ce_cptestindex6_7_0_pos 0
+#define reg_ce_cptestindex6_7_0_len 8
+#define reg_ce_cptestindex6_7_0_lsb 0
+#define    p_reg_ce_cptestindex6_12_8   0xFD6B
+#define reg_ce_cptestindex6_12_8_pos 0
+#define reg_ce_cptestindex6_12_8_len 5
+#define reg_ce_cptestindex6_12_8_lsb 8
+#define    p_reg_ce_cptestfdi6  0xFD6C
+#define reg_ce_cptestfdi6_pos 0
+#define reg_ce_cptestfdi6_len 3
+#define reg_ce_cptestfdi6_lsb 0
+#define    p_reg_ce_cptestindex7_7_0    0xFD6D
+#define reg_ce_cptestindex7_7_0_pos 0
+#define reg_ce_cptestindex7_7_0_len 8
+#define reg_ce_cptestindex7_7_0_lsb 0
+#define    p_reg_ce_cptestindex7_12_8   0xFD6E
+#define reg_ce_cptestindex7_12_8_pos 0
+#define reg_ce_cptestindex7_12_8_len 5
+#define reg_ce_cptestindex7_12_8_lsb 8
+#define    p_reg_ce_cptestfdi7  0xFD6F
+#define reg_ce_cptestfdi7_pos 0
+#define reg_ce_cptestfdi7_len 3
+#define reg_ce_cptestfdi7_lsb 0
+#define    p_reg_ce_cp_replace_tdiout_en    0xFD74
+#define reg_ce_cp_replace_tdiout_en_pos 0
+#define reg_ce_cp_replace_tdiout_en_len 1
+#define reg_ce_cp_replace_tdiout_en_lsb 0
+#define    p_reg_ce_tdi_mask0_en    0xFD7D
+#define reg_ce_tdi_mask0_en_pos 0
+#define reg_ce_tdi_mask0_en_len 1
+#define reg_ce_tdi_mask0_en_lsb 0
+#define    p_reg_ce_tdi_mask_from0_7_0  0xFD7E
+#define reg_ce_tdi_mask_from0_7_0_pos 0
+#define reg_ce_tdi_mask_from0_7_0_len 8
+#define reg_ce_tdi_mask_from0_7_0_lsb 0
+#define    p_reg_ce_tdi_mask_from0_12_8 0xFD7F
+#define reg_ce_tdi_mask_from0_12_8_pos 0
+#define reg_ce_tdi_mask_from0_12_8_len 5
+#define reg_ce_tdi_mask_from0_12_8_lsb 8
+#define    p_reg_ce_tdi_mask_to0_7_0    0xFD80
+#define reg_ce_tdi_mask_to0_7_0_pos 0
+#define reg_ce_tdi_mask_to0_7_0_len 8
+#define reg_ce_tdi_mask_to0_7_0_lsb 0
+#define    p_reg_ce_tdi_mask_to0_12_8   0xFD81
+#define reg_ce_tdi_mask_to0_12_8_pos 0
+#define reg_ce_tdi_mask_to0_12_8_len 5
+#define reg_ce_tdi_mask_to0_12_8_lsb 8
+#define    p_reg_ce_tdi_mask1_en    0xFD82
+#define reg_ce_tdi_mask1_en_pos 0
+#define reg_ce_tdi_mask1_en_len 1
+#define reg_ce_tdi_mask1_en_lsb 0
+#define    p_reg_ce_tdi_mask_from1_7_0  0xFD83
+#define reg_ce_tdi_mask_from1_7_0_pos 0
+#define reg_ce_tdi_mask_from1_7_0_len 8
+#define reg_ce_tdi_mask_from1_7_0_lsb 0
+#define    p_reg_ce_tdi_mask_from1_12_8 0xFD84
+#define reg_ce_tdi_mask_from1_12_8_pos 0
+#define reg_ce_tdi_mask_from1_12_8_len 5
+#define reg_ce_tdi_mask_from1_12_8_lsb 8
+#define    p_reg_ce_tdi_mask_to1_7_0    0xFD85
+#define reg_ce_tdi_mask_to1_7_0_pos 0
+#define reg_ce_tdi_mask_to1_7_0_len 8
+#define reg_ce_tdi_mask_to1_7_0_lsb 0
+#define    p_reg_ce_tdi_mask_to1_12_8   0xFD86
+#define reg_ce_tdi_mask_to1_12_8_pos 0
+#define reg_ce_tdi_mask_to1_12_8_len 5
+#define reg_ce_tdi_mask_to1_12_8_lsb 8
+#define    p_reg_ce_2nd_var_max 0xFD87
+#define reg_ce_2nd_var_max_pos 0
+#define reg_ce_2nd_var_max_len 3
+#define reg_ce_2nd_var_max_lsb 0
+#define    p_reg_ce_2nd_cent_forced_en  0xFD88
+#define reg_ce_2nd_cent_forced_en_pos 0
+#define reg_ce_2nd_cent_forced_en_len 1
+#define reg_ce_2nd_cent_forced_en_lsb 0
+#define    p_reg_ce_2nd_var_forced_en   0xFD89
+#define reg_ce_2nd_var_forced_en_pos 0
+#define reg_ce_2nd_var_forced_en_len 1
+#define reg_ce_2nd_var_forced_en_lsb 0
+#define    p_reg_ce_2nd_fctrl_auto_reset_en 0xFD8A
+#define reg_ce_2nd_fctrl_auto_reset_en_pos 0
+#define reg_ce_2nd_fctrl_auto_reset_en_len 1
+#define reg_ce_2nd_fctrl_auto_reset_en_lsb 0
+#define    p_reg_ce_2nd_cent_auto_clr_en    0xFD8B
+#define reg_ce_2nd_cent_auto_clr_en_pos 0
+#define reg_ce_2nd_cent_auto_clr_en_len 1
+#define reg_ce_2nd_cent_auto_clr_en_lsb 0
+#define    p_reg_ce_2nd_cent_forced_value_7_0   0xFD8C
+#define reg_ce_2nd_cent_forced_value_7_0_pos 0
+#define reg_ce_2nd_cent_forced_value_7_0_len 8
+#define reg_ce_2nd_cent_forced_value_7_0_lsb 0
+#define    p_reg_ce_2nd_cent_forced_value_11_8  0xFD8D
+#define reg_ce_2nd_cent_forced_value_11_8_pos 0
+#define reg_ce_2nd_cent_forced_value_11_8_len 4
+#define reg_ce_2nd_cent_forced_value_11_8_lsb 8
+#define    p_reg_ce_2nd_cent_auto_clr_value_7_0 0xFD8E
+#define reg_ce_2nd_cent_auto_clr_value_7_0_pos 0
+#define reg_ce_2nd_cent_auto_clr_value_7_0_len 8
+#define reg_ce_2nd_cent_auto_clr_value_7_0_lsb 0
+#define    p_reg_ce_2nd_cent_auto_clr_value_11_8    0xFD8F
+#define reg_ce_2nd_cent_auto_clr_value_11_8_pos 0
+#define reg_ce_2nd_cent_auto_clr_value_11_8_len 4
+#define reg_ce_2nd_cent_auto_clr_value_11_8_lsb 8
+#define    p_reg_ce_gs_s1_var   0xFD90
+#define reg_ce_gs_s1_var_pos 0
+#define reg_ce_gs_s1_var_len 4
+#define reg_ce_gs_s1_var_lsb 0
+#define    p_reg_ce_2nd_centroid_max_7_0    0xFD91
+#define reg_ce_2nd_centroid_max_7_0_pos 0
+#define reg_ce_2nd_centroid_max_7_0_len 8
+#define reg_ce_2nd_centroid_max_7_0_lsb 0
+#define    p_reg_ce_2nd_centroid_max_11_8   0xFD92
+#define reg_ce_2nd_centroid_max_11_8_pos 0
+#define reg_ce_2nd_centroid_max_11_8_len 4
+#define reg_ce_2nd_centroid_max_11_8_lsb 8
+#define    r_reg_ce_2nd_centroid_out_7_0    0xFD93
+#define reg_ce_2nd_centroid_out_7_0_pos 0
+#define reg_ce_2nd_centroid_out_7_0_len 8
+#define reg_ce_2nd_centroid_out_7_0_lsb 0
+#define    r_reg_ce_2nd_centroid_out_11_8   0xFD94
+#define reg_ce_2nd_centroid_out_11_8_pos 0
+#define reg_ce_2nd_centroid_out_11_8_len 4
+#define reg_ce_2nd_centroid_out_11_8_lsb 8
+#define    r_reg_ce_2nd_fctrl_rdy   0xFD95
+#define reg_ce_2nd_fctrl_rdy_pos 0
+#define reg_ce_2nd_fctrl_rdy_len 1
+#define reg_ce_2nd_fctrl_rdy_lsb 0
+#define    r_reg_ce_2nd_var 0xFD96
+#define reg_ce_2nd_var_pos 0
+#define reg_ce_2nd_var_len 3
+#define reg_ce_2nd_var_lsb 0
+#define    r_reg_ce_2nd_bias_7_0    0xFD97
+#define reg_ce_2nd_bias_7_0_pos 0
+#define reg_ce_2nd_bias_7_0_len 8
+#define reg_ce_2nd_bias_7_0_lsb 0
+#define    r_reg_ce_2nd_bias_11_8   0xFD98
+#define reg_ce_2nd_bias_11_8_pos 0
+#define reg_ce_2nd_bias_11_8_len 4
+#define reg_ce_2nd_bias_11_8_lsb 8
+#define    r_reg_ce_2nd_m1_7_0  0xFD99
+#define reg_ce_2nd_m1_7_0_pos 0
+#define reg_ce_2nd_m1_7_0_len 8
+#define reg_ce_2nd_m1_7_0_lsb 0
+#define    r_reg_ce_2nd_m1_11_8 0xFD9A
+#define reg_ce_2nd_m1_11_8_pos 0
+#define reg_ce_2nd_m1_11_8_len 4
+#define reg_ce_2nd_m1_11_8_lsb 8
+#define    p_reg_ce_2nd_var_forced_value    0xFD9B
+#define reg_ce_2nd_var_forced_value_pos 0
+#define reg_ce_2nd_var_forced_value_len 3
+#define reg_ce_2nd_var_forced_value_lsb 0
+#define    r_reg_ce_2nd_m2_central_7_0  0xFD9C
+#define reg_ce_2nd_m2_central_7_0_pos 0
+#define reg_ce_2nd_m2_central_7_0_len 8
+#define reg_ce_2nd_m2_central_7_0_lsb 0
+#define    r_reg_ce_2nd_m2_central_15_8 0xFD9D
+#define reg_ce_2nd_m2_central_15_8_pos 0
+#define reg_ce_2nd_m2_central_15_8_len 8
+#define reg_ce_2nd_m2_central_15_8_lsb 8
+#define    p_reg_ce_2nd_var_default_value   0xFD9E
+#define reg_ce_2nd_var_default_value_pos 0
+#define reg_ce_2nd_var_default_value_len 3
+#define reg_ce_2nd_var_default_value_lsb 0
+#define    p_reg_ce_2nd_cent_default_value_7_0  0xFD9F
+#define reg_ce_2nd_cent_default_value_7_0_pos 0
+#define reg_ce_2nd_cent_default_value_7_0_len 8
+#define reg_ce_2nd_cent_default_value_7_0_lsb 0
+#define    p_reg_ce_2nd_cent_default_value_11_8 0xFDA0
+#define reg_ce_2nd_cent_default_value_11_8_pos 0
+#define reg_ce_2nd_cent_default_value_11_8_len 4
+#define reg_ce_2nd_cent_default_value_11_8_lsb 8
+#define    p_reg_ce_use_fdi_long    0xFDA1
+#define reg_ce_use_fdi_long_pos 0
+#define reg_ce_use_fdi_long_len 1
+#define reg_ce_use_fdi_long_lsb 0
+#define    p_reg_p_ce_tdi_lms_en    0xFDA2
+#define reg_p_ce_tdi_lms_en_pos 0
+#define reg_p_ce_tdi_lms_en_len 1
+#define reg_p_ce_tdi_lms_en_lsb 0
+#define    p_reg_p_ce_tdi_lms_bufshift  0xFDA3
+#define reg_p_ce_tdi_lms_bufshift_pos 0
+#define reg_p_ce_tdi_lms_bufshift_len 2
+#define reg_p_ce_tdi_lms_bufshift_lsb 0
+#define    p_reg_p_ce_tdi_lms_ave_ratio 0xFDA4
+#define reg_p_ce_tdi_lms_ave_ratio_pos 0
+#define reg_p_ce_tdi_lms_ave_ratio_len 5
+#define reg_p_ce_tdi_lms_ave_ratio_lsb 0
+#define    p_reg_p_ce_conf2_in_con0_en  0xFDA5
+#define reg_p_ce_conf2_in_con0_en_pos 0
+#define reg_p_ce_conf2_in_con0_en_len 1
+#define reg_p_ce_conf2_in_con0_en_lsb 0
+#define    p_fec_rsd_packet_unit_7_0    0xF700
+#define fec_rsd_packet_unit_7_0_pos 0
+#define fec_rsd_packet_unit_7_0_len 8
+#define fec_rsd_packet_unit_7_0_lsb 0
+#define    p_fec_rsd_packet_unit_15_8   0xF701
+#define fec_rsd_packet_unit_15_8_pos 0
+#define fec_rsd_packet_unit_15_8_len 8
+#define fec_rsd_packet_unit_15_8_lsb 8
+#define    r_reg_rsd_bit_err_cnt_7_0    0xF702
+#define reg_rsd_bit_err_cnt_7_0_pos 0
+#define reg_rsd_bit_err_cnt_7_0_len 8
+#define reg_rsd_bit_err_cnt_7_0_lsb 0
+#define    r_reg_rsd_bit_err_cnt_15_8   0xF703
+#define reg_rsd_bit_err_cnt_15_8_pos 0
+#define reg_rsd_bit_err_cnt_15_8_len 8
+#define reg_rsd_bit_err_cnt_15_8_lsb 8
+#define    r_reg_rsd_bit_err_cnt_23_16  0xF704
+#define reg_rsd_bit_err_cnt_23_16_pos 0
+#define reg_rsd_bit_err_cnt_23_16_len 8
+#define reg_rsd_bit_err_cnt_23_16_lsb 16
+#define    r_reg_rsd_abort_packet_cnt_7_0   0xF705
+#define reg_rsd_abort_packet_cnt_7_0_pos 0
+#define reg_rsd_abort_packet_cnt_7_0_len 8
+#define reg_rsd_abort_packet_cnt_7_0_lsb 0
+#define    r_reg_rsd_abort_packet_cnt_15_8  0xF706
+#define reg_rsd_abort_packet_cnt_15_8_pos 0
+#define reg_rsd_abort_packet_cnt_15_8_len 8
+#define reg_rsd_abort_packet_cnt_15_8_lsb 8
+#define    p_fec_RSD_PKT_NUM_PER_UNIT_7_0   0xF707
+#define fec_RSD_PKT_NUM_PER_UNIT_7_0_pos 0
+#define fec_RSD_PKT_NUM_PER_UNIT_7_0_len 8
+#define fec_RSD_PKT_NUM_PER_UNIT_7_0_lsb 0
+#define    p_fec_RSD_PKT_NUM_PER_UNIT_15_8  0xF708
+#define fec_RSD_PKT_NUM_PER_UNIT_15_8_pos 0
+#define fec_RSD_PKT_NUM_PER_UNIT_15_8_len 8
+#define fec_RSD_PKT_NUM_PER_UNIT_15_8_lsb 8
+#define    p_fec_RS_TH_1_7_0    0xF709
+#define fec_RS_TH_1_7_0_pos 0
+#define fec_RS_TH_1_7_0_len 8
+#define fec_RS_TH_1_7_0_lsb 0
+#define    p_fec_RS_TH_1_15_8   0xF70A
+#define fec_RS_TH_1_15_8_pos 0
+#define fec_RS_TH_1_15_8_len 8
+#define fec_RS_TH_1_15_8_lsb 8
+#define    p_fec_RS_TH_2    0xF70B
+#define fec_RS_TH_2_pos 0
+#define fec_RS_TH_2_len 8
+#define fec_RS_TH_2_lsb 0
+#define    p_fec_rsd_ber_rst    0xF70C
+#define fec_rsd_ber_rst_pos 0
+#define fec_rsd_ber_rst_len 1
+#define fec_rsd_ber_rst_lsb 0
+#define    p_reg_rsd_ber_rdy    0xF70D
+#define reg_rsd_ber_rdy_pos 0
+#define reg_rsd_ber_rdy_len 1
+#define reg_rsd_ber_rdy_lsb 0
+#define    p_reg_rsd_trigger_retrain    0xF70E
+#define reg_rsd_trigger_retrain_pos 0
+#define reg_rsd_trigger_retrain_len 1
+#define reg_rsd_trigger_retrain_lsb 0
+#define    p_reg_sync_recover   0xF70F
+#define reg_sync_recover_pos 0
+#define reg_sync_recover_len 1
+#define reg_sync_recover_lsb 0
+#define    p_fec_crc_en 0xF710
+#define fec_crc_en_pos 0
+#define fec_crc_en_len 1
+#define fec_crc_en_lsb 0
+#define    p_fec_mon_en 0xF711
+#define fec_mon_en_pos 0
+#define fec_mon_en_len 1
+#define fec_mon_en_lsb 0
+#define    p_reg_sync_chk   0xF712
+#define reg_sync_chk_pos 0
+#define reg_sync_chk_len 1
+#define reg_sync_chk_lsb 0
+#define    p_fec_dummy_reg_2    0xF713
+#define fec_dummy_reg_2_pos 0
+#define fec_dummy_reg_2_len 3
+#define fec_dummy_reg_2_lsb 0
+#define    p_reg_fec_data_en    0xF714
+#define reg_fec_data_en_pos 0
+#define reg_fec_data_en_len 1
+#define reg_fec_data_en_lsb 0
+#define    p_fec_vtb_rsd_mon_en 0xF715
+#define fec_vtb_rsd_mon_en_pos 0
+#define fec_vtb_rsd_mon_en_len 1
+#define fec_vtb_rsd_mon_en_lsb 0
+#define    p_reg_fec_sw_rst 0xF716
+#define reg_fec_sw_rst_pos 0
+#define reg_fec_sw_rst_len 1
+#define reg_fec_sw_rst_lsb 0
+#define    r_fec_vtb_pm_crc 0xF717
+#define fec_vtb_pm_crc_pos 0
+#define fec_vtb_pm_crc_len 8
+#define fec_vtb_pm_crc_lsb 0
+#define    r_fec_vtb_tb_7_crc   0xF718
+#define fec_vtb_tb_7_crc_pos 0
+#define fec_vtb_tb_7_crc_len 8
+#define fec_vtb_tb_7_crc_lsb 0
+#define    r_fec_vtb_tb_6_crc   0xF719
+#define fec_vtb_tb_6_crc_pos 0
+#define fec_vtb_tb_6_crc_len 8
+#define fec_vtb_tb_6_crc_lsb 0
+#define    r_fec_vtb_tb_5_crc   0xF71A
+#define fec_vtb_tb_5_crc_pos 0
+#define fec_vtb_tb_5_crc_len 8
+#define fec_vtb_tb_5_crc_lsb 0
+#define    r_fec_vtb_tb_4_crc   0xF71B
+#define fec_vtb_tb_4_crc_pos 0
+#define fec_vtb_tb_4_crc_len 8
+#define fec_vtb_tb_4_crc_lsb 0
+#define    r_fec_vtb_tb_3_crc   0xF71C
+#define fec_vtb_tb_3_crc_pos 0
+#define fec_vtb_tb_3_crc_len 8
+#define fec_vtb_tb_3_crc_lsb 0
+#define    r_fec_vtb_tb_2_crc   0xF71D
+#define fec_vtb_tb_2_crc_pos 0
+#define fec_vtb_tb_2_crc_len 8
+#define fec_vtb_tb_2_crc_lsb 0
+#define    r_fec_vtb_tb_1_crc   0xF71E
+#define fec_vtb_tb_1_crc_pos 0
+#define fec_vtb_tb_1_crc_len 8
+#define fec_vtb_tb_1_crc_lsb 0
+#define    r_fec_vtb_tb_0_crc   0xF71F
+#define fec_vtb_tb_0_crc_pos 0
+#define fec_vtb_tb_0_crc_len 8
+#define fec_vtb_tb_0_crc_lsb 0
+#define    r_fec_rsd_bank0_crc  0xF720
+#define fec_rsd_bank0_crc_pos 0
+#define fec_rsd_bank0_crc_len 8
+#define fec_rsd_bank0_crc_lsb 0
+#define    r_fec_rsd_bank1_crc  0xF721
+#define fec_rsd_bank1_crc_pos 0
+#define fec_rsd_bank1_crc_len 8
+#define fec_rsd_bank1_crc_lsb 0
+#define    r_fec_idi_vtb_crc    0xF722
+#define fec_idi_vtb_crc_pos 0
+#define fec_idi_vtb_crc_len 8
+#define fec_idi_vtb_crc_lsb 0
+#define    p_reg_fec_rsd_packet_unit_exp    0xF723
+#define reg_fec_rsd_packet_unit_exp_pos 0
+#define reg_fec_rsd_packet_unit_exp_len 4
+#define reg_fec_rsd_packet_unit_exp_lsb 0
+#define    p_reg_rsd_bit_err_exp_rdy    0xF724
+#define reg_rsd_bit_err_exp_rdy_pos 0
+#define reg_rsd_bit_err_exp_rdy_len 1
+#define reg_rsd_bit_err_exp_rdy_lsb 0
+#define    r_reg_rsd_bit_err_exp    0xF725
+#define reg_rsd_bit_err_exp_pos 0
+#define reg_rsd_bit_err_exp_len 5
+#define reg_rsd_bit_err_exp_lsb 0
+#define    p_fec_rsd_packet_unit1_7_0   0xF726
+#define fec_rsd_packet_unit1_7_0_pos 0
+#define fec_rsd_packet_unit1_7_0_len 8
+#define fec_rsd_packet_unit1_7_0_lsb 0
+#define    p_fec_rsd_packet_unit1_15_8  0xF727
+#define fec_rsd_packet_unit1_15_8_pos 0
+#define fec_rsd_packet_unit1_15_8_len 8
+#define fec_rsd_packet_unit1_15_8_lsb 8
+#define    r_reg_rsd_bit_err_cnt1_7_0   0xF728
+#define reg_rsd_bit_err_cnt1_7_0_pos 0
+#define reg_rsd_bit_err_cnt1_7_0_len 8
+#define reg_rsd_bit_err_cnt1_7_0_lsb 0
+#define    r_reg_rsd_bit_err_cnt1_15_8  0xF729
+#define reg_rsd_bit_err_cnt1_15_8_pos 0
+#define reg_rsd_bit_err_cnt1_15_8_len 8
+#define reg_rsd_bit_err_cnt1_15_8_lsb 8
+#define    r_reg_rsd_bit_err_cnt1_23_16 0xF72A
+#define reg_rsd_bit_err_cnt1_23_16_pos 0
+#define reg_rsd_bit_err_cnt1_23_16_len 8
+#define reg_rsd_bit_err_cnt1_23_16_lsb 16
+#define    r_reg_rsd_abort_packet_cnt1_7_0  0xF72B
+#define reg_rsd_abort_packet_cnt1_7_0_pos 0
+#define reg_rsd_abort_packet_cnt1_7_0_len 8
+#define reg_rsd_abort_packet_cnt1_7_0_lsb 0
+#define    r_reg_rsd_abort_packet_cnt1_15_8 0xF72C
+#define reg_rsd_abort_packet_cnt1_15_8_pos 0
+#define reg_rsd_abort_packet_cnt1_15_8_len 8
+#define reg_rsd_abort_packet_cnt1_15_8_lsb 8
+#define    p_fec_rsd_ber_rst1   0xF72D
+#define fec_rsd_ber_rst1_pos 0
+#define fec_rsd_ber_rst1_len 1
+#define fec_rsd_ber_rst1_lsb 0
+#define    p_reg_rsd_ber_rdy1   0xF72E
+#define reg_rsd_ber_rdy1_pos 0
+#define reg_rsd_ber_rdy1_len 1
+#define reg_rsd_ber_rdy1_lsb 0
+#define    p_reg_dca_txmod_sel  0xF72F
+#define reg_dca_txmod_sel_pos 0
+#define reg_dca_txmod_sel_len 1
+#define reg_dca_txmod_sel_lsb 0
+#define    p_reg_dca_platch 0xF730
+#define reg_dca_platch_pos 0
+#define reg_dca_platch_len 1
+#define reg_dca_platch_lsb 0
+#define    p_reg_dca_upper_chip 0xF731
+#define reg_dca_upper_chip_pos 0
+#define reg_dca_upper_chip_len 1
+#define reg_dca_upper_chip_lsb 0
+#define    p_reg_dca_lower_chip 0xF732
+#define reg_dca_lower_chip_pos 0
+#define reg_dca_lower_chip_len 1
+#define reg_dca_lower_chip_lsb 0
+#define    p_reg_dca_enl    0xF733
+#define reg_dca_enl_pos 0
+#define reg_dca_enl_len 1
+#define reg_dca_enl_lsb 0
+#define    p_reg_dca_enu    0xF734
+#define reg_dca_enu_pos 0
+#define reg_dca_enu_len 1
+#define reg_dca_enu_lsb 0
+#define    p_reg_dca_th 0xF735
+#define reg_dca_th_pos 0
+#define reg_dca_th_len 5
+#define reg_dca_th_lsb 0
+#define    p_reg_dca_scale  0xF736
+#define reg_dca_scale_pos 0
+#define reg_dca_scale_len 4
+#define reg_dca_scale_lsb 0
+#define    p_reg_dca_tone_7_0   0xF737
+#define reg_dca_tone_7_0_pos 0
+#define reg_dca_tone_7_0_len 8
+#define reg_dca_tone_7_0_lsb 0
+#define    p_reg_dca_tone_12_8  0xF738
+#define reg_dca_tone_12_8_pos 0
+#define reg_dca_tone_12_8_len 5
+#define reg_dca_tone_12_8_lsb 8
+#define    p_reg_dca_time_7_0   0xF739
+#define reg_dca_time_7_0_pos 0
+#define reg_dca_time_7_0_len 8
+#define reg_dca_time_7_0_lsb 0
+#define    p_reg_dca_time_15_8  0xF73A
+#define reg_dca_time_15_8_pos 0
+#define reg_dca_time_15_8_len 8
+#define reg_dca_time_15_8_lsb 8
+#define    r_fec_dcasm  0xF73B
+#define fec_dcasm_pos 0
+#define fec_dcasm_len 3
+#define fec_dcasm_lsb 0
+#define    p_reg_dca_stand_alone    0xF73C
+#define reg_dca_stand_alone_pos 0
+#define reg_dca_stand_alone_len 1
+#define reg_dca_stand_alone_lsb 0
+#define    p_reg_dca_upper_out_en   0xF73D
+#define reg_dca_upper_out_en_pos 0
+#define reg_dca_upper_out_en_len 1
+#define reg_dca_upper_out_en_lsb 0
+#define    p_reg_dca_rc_en  0xF73E
+#define reg_dca_rc_en_pos 0
+#define reg_dca_rc_en_len 1
+#define reg_dca_rc_en_lsb 0
+#define    p_reg_dca_retrain_send   0xF73F
+#define reg_dca_retrain_send_pos 0
+#define reg_dca_retrain_send_len 1
+#define reg_dca_retrain_send_lsb 0
+#define    p_reg_dca_retrain_rec    0xF740
+#define reg_dca_retrain_rec_pos 0
+#define reg_dca_retrain_rec_len 1
+#define reg_dca_retrain_rec_lsb 0
+#define    p_reg_dca_gi_gap 0xF741
+#define reg_dca_gi_gap_pos 0
+#define reg_dca_gi_gap_len 8
+#define reg_dca_gi_gap_lsb 0
+#define    r_reg_dca_rec_up_tpsd_txmod  0xF742
+#define reg_dca_rec_up_tpsd_txmod_pos 0
+#define reg_dca_rec_up_tpsd_txmod_len 2
+#define reg_dca_rec_up_tpsd_txmod_lsb 0
+#define    r_reg_dca_rec_up_tpsd_const  0xF743
+#define reg_dca_rec_up_tpsd_const_pos 0
+#define reg_dca_rec_up_tpsd_const_len 2
+#define reg_dca_rec_up_tpsd_const_lsb 0
+#define    r_reg_dca_rec_up_tpsd_indep  0xF744
+#define reg_dca_rec_up_tpsd_indep_pos 0
+#define reg_dca_rec_up_tpsd_indep_len 1
+#define reg_dca_rec_up_tpsd_indep_lsb 0
+#define    r_reg_dca_rec_up_tpsd_hier   0xF745
+#define reg_dca_rec_up_tpsd_hier_pos 0
+#define reg_dca_rec_up_tpsd_hier_len 2
+#define reg_dca_rec_up_tpsd_hier_lsb 0
+#define    r_reg_dca_rec_up_tpsd_hpcr   0xF746
+#define reg_dca_rec_up_tpsd_hpcr_pos 0
+#define reg_dca_rec_up_tpsd_hpcr_len 3
+#define reg_dca_rec_up_tpsd_hpcr_lsb 0
+#define    r_reg_dca_rec_up_tpsd_lpcr   0xF747
+#define reg_dca_rec_up_tpsd_lpcr_pos 0
+#define reg_dca_rec_up_tpsd_lpcr_len 3
+#define reg_dca_rec_up_tpsd_lpcr_lsb 0
+#define    r_reg_dca_rec_up_tpsd_lock   0xF748
+#define reg_dca_rec_up_tpsd_lock_pos 0
+#define reg_dca_rec_up_tpsd_lock_len 1
+#define reg_dca_rec_up_tpsd_lock_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_txmod  0xF749
+#define reg_dca_rec_lo_tpsd_txmod_pos 0
+#define reg_dca_rec_lo_tpsd_txmod_len 2
+#define reg_dca_rec_lo_tpsd_txmod_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_const  0xF74A
+#define reg_dca_rec_lo_tpsd_const_pos 0
+#define reg_dca_rec_lo_tpsd_const_len 2
+#define reg_dca_rec_lo_tpsd_const_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_indep  0xF74B
+#define reg_dca_rec_lo_tpsd_indep_pos 0
+#define reg_dca_rec_lo_tpsd_indep_len 1
+#define reg_dca_rec_lo_tpsd_indep_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_hier   0xF74C
+#define reg_dca_rec_lo_tpsd_hier_pos 0
+#define reg_dca_rec_lo_tpsd_hier_len 2
+#define reg_dca_rec_lo_tpsd_hier_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_hpcr   0xF74D
+#define reg_dca_rec_lo_tpsd_hpcr_pos 0
+#define reg_dca_rec_lo_tpsd_hpcr_len 3
+#define reg_dca_rec_lo_tpsd_hpcr_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_lpcr   0xF74E
+#define reg_dca_rec_lo_tpsd_lpcr_pos 0
+#define reg_dca_rec_lo_tpsd_lpcr_len 3
+#define reg_dca_rec_lo_tpsd_lpcr_lsb 0
+#define    r_reg_dca_rec_lo_tpsd_lock   0xF74F
+#define reg_dca_rec_lo_tpsd_lock_pos 0
+#define reg_dca_rec_lo_tpsd_lock_len 1
+#define reg_dca_rec_lo_tpsd_lock_lsb 0
+#define    p_reg_dca_gpr_ctr_up_send    0xF750
+#define reg_dca_gpr_ctr_up_send_pos 0
+#define reg_dca_gpr_ctr_up_send_len 8
+#define reg_dca_gpr_ctr_up_send_lsb 0
+#define    p_reg_dca_gpr_dat_up_send_0  0xF751
+#define reg_dca_gpr_dat_up_send_0_pos 0
+#define reg_dca_gpr_dat_up_send_0_len 8
+#define reg_dca_gpr_dat_up_send_0_lsb 0
+#define    p_reg_dca_gpr_dat_up_send_1  0xF752
+#define reg_dca_gpr_dat_up_send_1_pos 0
+#define reg_dca_gpr_dat_up_send_1_len 8
+#define reg_dca_gpr_dat_up_send_1_lsb 0
+#define    p_reg_dca_gpr_dat_up_send_2  0xF753
+#define reg_dca_gpr_dat_up_send_2_pos 0
+#define reg_dca_gpr_dat_up_send_2_len 8
+#define reg_dca_gpr_dat_up_send_2_lsb 0
+#define    p_reg_dca_gpr_dat_up_send_3  0xF754
+#define reg_dca_gpr_dat_up_send_3_pos 0
+#define reg_dca_gpr_dat_up_send_3_len 8
+#define reg_dca_gpr_dat_up_send_3_lsb 0
+#define    p_reg_dca_gpr_dat_up_send_4  0xF755
+#define reg_dca_gpr_dat_up_send_4_pos 0
+#define reg_dca_gpr_dat_up_send_4_len 8
+#define reg_dca_gpr_dat_up_send_4_lsb 0
+#define    p_reg_dca_gpr_dat_up_send_5  0xF756
+#define reg_dca_gpr_dat_up_send_5_pos 0
+#define reg_dca_gpr_dat_up_send_5_len 8
+#define reg_dca_gpr_dat_up_send_5_lsb 0
+#define    p_reg_dca_over_wr_up_send    0xF757
+#define reg_dca_over_wr_up_send_pos 0
+#define reg_dca_over_wr_up_send_len 1
+#define reg_dca_over_wr_up_send_lsb 0
+#define    p_reg_dca_int_up_send    0xF758
+#define reg_dca_int_up_send_pos 0
+#define reg_dca_int_up_send_len 1
+#define reg_dca_int_up_send_lsb 0
+#define    p_reg_dca_gpr_ctr_lo_send    0xF759
+#define reg_dca_gpr_ctr_lo_send_pos 0
+#define reg_dca_gpr_ctr_lo_send_len 8
+#define reg_dca_gpr_ctr_lo_send_lsb 0
+#define    p_reg_dca_gpr_dat_lo_send_0  0xF75A
+#define reg_dca_gpr_dat_lo_send_0_pos 0
+#define reg_dca_gpr_dat_lo_send_0_len 8
+#define reg_dca_gpr_dat_lo_send_0_lsb 0
+#define    p_reg_dca_gpr_dat_lo_send_1  0xF75B
+#define reg_dca_gpr_dat_lo_send_1_pos 0
+#define reg_dca_gpr_dat_lo_send_1_len 8
+#define reg_dca_gpr_dat_lo_send_1_lsb 0
+#define    p_reg_dca_gpr_dat_lo_send_2  0xF75C
+#define reg_dca_gpr_dat_lo_send_2_pos 0
+#define reg_dca_gpr_dat_lo_send_2_len 8
+#define reg_dca_gpr_dat_lo_send_2_lsb 0
+#define    p_reg_dca_gpr_dat_lo_send_3  0xF75D
+#define reg_dca_gpr_dat_lo_send_3_pos 0
+#define reg_dca_gpr_dat_lo_send_3_len 8
+#define reg_dca_gpr_dat_lo_send_3_lsb 0
+#define    p_reg_dca_gpr_dat_lo_send_4  0xF75E
+#define reg_dca_gpr_dat_lo_send_4_pos 0
+#define reg_dca_gpr_dat_lo_send_4_len 8
+#define reg_dca_gpr_dat_lo_send_4_lsb 0
+#define    p_reg_dca_gpr_dat_lo_send_5  0xF75F
+#define reg_dca_gpr_dat_lo_send_5_pos 0
+#define reg_dca_gpr_dat_lo_send_5_len 8
+#define reg_dca_gpr_dat_lo_send_5_lsb 0
+#define    p_reg_dca_over_wr_lo_send    0xF760
+#define reg_dca_over_wr_lo_send_pos 0
+#define reg_dca_over_wr_lo_send_len 1
+#define reg_dca_over_wr_lo_send_lsb 0
+#define    p_reg_dca_int_lo_send    0xF761
+#define reg_dca_int_lo_send_pos 0
+#define reg_dca_int_lo_send_len 1
+#define reg_dca_int_lo_send_lsb 0
+#define    r_reg_dca_gpr_ctr_up_rec 0xF762
+#define reg_dca_gpr_ctr_up_rec_pos 0
+#define reg_dca_gpr_ctr_up_rec_len 8
+#define reg_dca_gpr_ctr_up_rec_lsb 0
+#define    r_reg_dca_gpr_dat_up_rec_0   0xF763
+#define reg_dca_gpr_dat_up_rec_0_pos 0
+#define reg_dca_gpr_dat_up_rec_0_len 8
+#define reg_dca_gpr_dat_up_rec_0_lsb 0
+#define    r_reg_dca_gpr_dat_up_rec_1   0xF764
+#define reg_dca_gpr_dat_up_rec_1_pos 0
+#define reg_dca_gpr_dat_up_rec_1_len 8
+#define reg_dca_gpr_dat_up_rec_1_lsb 0
+#define    r_reg_dca_gpr_dat_up_rec_2   0xF765
+#define reg_dca_gpr_dat_up_rec_2_pos 0
+#define reg_dca_gpr_dat_up_rec_2_len 8
+#define reg_dca_gpr_dat_up_rec_2_lsb 0
+#define    r_reg_dca_gpr_dat_up_rec_3   0xF766
+#define reg_dca_gpr_dat_up_rec_3_pos 0
+#define reg_dca_gpr_dat_up_rec_3_len 8
+#define reg_dca_gpr_dat_up_rec_3_lsb 0
+#define    r_reg_dca_gpr_dat_up_rec_4   0xF767
+#define reg_dca_gpr_dat_up_rec_4_pos 0
+#define reg_dca_gpr_dat_up_rec_4_len 8
+#define reg_dca_gpr_dat_up_rec_4_lsb 0
+#define    r_reg_dca_gpr_dat_up_rec_5   0xF768
+#define reg_dca_gpr_dat_up_rec_5_pos 0
+#define reg_dca_gpr_dat_up_rec_5_len 8
+#define reg_dca_gpr_dat_up_rec_5_lsb 0
+#define    r_reg_dca_over_wr_up_rec 0xF769
+#define reg_dca_over_wr_up_rec_pos 0
+#define reg_dca_over_wr_up_rec_len 1
+#define reg_dca_over_wr_up_rec_lsb 0
+#define    p_reg_dca_int_up_rec 0xF76A
+#define reg_dca_int_up_rec_pos 0
+#define reg_dca_int_up_rec_len 1
+#define reg_dca_int_up_rec_lsb 0
+#define    p_reg_dca_fw_read_yet_up 0xF76B
+#define reg_dca_fw_read_yet_up_pos 0
+#define reg_dca_fw_read_yet_up_len 1
+#define reg_dca_fw_read_yet_up_lsb 0
+#define    r_reg_dca_gpr_ctr_lo_rec 0xF76C
+#define reg_dca_gpr_ctr_lo_rec_pos 0
+#define reg_dca_gpr_ctr_lo_rec_len 8
+#define reg_dca_gpr_ctr_lo_rec_lsb 0
+#define    r_reg_dca_gpr_dat_lo_rec_0   0xF76D
+#define reg_dca_gpr_dat_lo_rec_0_pos 0
+#define reg_dca_gpr_dat_lo_rec_0_len 8
+#define reg_dca_gpr_dat_lo_rec_0_lsb 0
+#define    r_reg_dca_gpr_dat_lo_rec_1   0xF76E
+#define reg_dca_gpr_dat_lo_rec_1_pos 0
+#define reg_dca_gpr_dat_lo_rec_1_len 8
+#define reg_dca_gpr_dat_lo_rec_1_lsb 0
+#define    r_reg_dca_gpr_dat_lo_rec_2   0xF76F
+#define reg_dca_gpr_dat_lo_rec_2_pos 0
+#define reg_dca_gpr_dat_lo_rec_2_len 8
+#define reg_dca_gpr_dat_lo_rec_2_lsb 0
+#define    r_reg_dca_gpr_dat_lo_rec_3   0xF770
+#define reg_dca_gpr_dat_lo_rec_3_pos 0
+#define reg_dca_gpr_dat_lo_rec_3_len 8
+#define reg_dca_gpr_dat_lo_rec_3_lsb 0
+#define    r_reg_dca_gpr_dat_lo_rec_4   0xF771
+#define reg_dca_gpr_dat_lo_rec_4_pos 0
+#define reg_dca_gpr_dat_lo_rec_4_len 8
+#define reg_dca_gpr_dat_lo_rec_4_lsb 0
+#define    r_reg_dca_gpr_dat_lo_rec_5   0xF772
+#define reg_dca_gpr_dat_lo_rec_5_pos 0
+#define reg_dca_gpr_dat_lo_rec_5_len 8
+#define reg_dca_gpr_dat_lo_rec_5_lsb 0
+#define    r_reg_dca_over_wr_lo_rec 0xF773
+#define reg_dca_over_wr_lo_rec_pos 0
+#define reg_dca_over_wr_lo_rec_len 1
+#define reg_dca_over_wr_lo_rec_lsb 0
+#define    p_reg_dca_int_lo_rec 0xF774
+#define reg_dca_int_lo_rec_pos 0
+#define reg_dca_int_lo_rec_len 1
+#define reg_dca_int_lo_rec_lsb 0
+#define    p_reg_dca_fw_read_yet_lo 0xF775
+#define reg_dca_fw_read_yet_lo_pos 0
+#define reg_dca_fw_read_yet_lo_len 1
+#define reg_dca_fw_read_yet_lo_lsb 0
+#define    p_reg_dca_en 0xF776
+#define reg_dca_en_pos 0
+#define reg_dca_en_len 1
+#define reg_dca_en_lsb 0
+#define    p_reg_dca_ulrdy_delay    0xF777
+#define reg_dca_ulrdy_delay_pos 0
+#define reg_dca_ulrdy_delay_len 8
+#define reg_dca_ulrdy_delay_lsb 0
+#define    p_reg_dca_fpga_latch 0xF778
+#define reg_dca_fpga_latch_pos 0
+#define reg_dca_fpga_latch_len 8
+#define reg_dca_fpga_latch_lsb 0
+#define    p_reg_dca_vldld_err  0xF779
+#define reg_dca_vldld_err_pos 0
+#define reg_dca_vldld_err_len 1
+#define reg_dca_vldld_err_lsb 0
+#define    p_reg_dca_vldud_err  0xF77A
+#define reg_dca_vldud_err_pos 0
+#define reg_dca_vldud_err_len 1
+#define reg_dca_vldud_err_lsb 0
+#define    p_reg_dca_modeu_err  0xF77B
+#define reg_dca_modeu_err_pos 0
+#define reg_dca_modeu_err_len 1
+#define reg_dca_modeu_err_lsb 0
+#define    p_reg_dca_model_err  0xF77C
+#define reg_dca_model_err_pos 0
+#define reg_dca_model_err_len 1
+#define reg_dca_model_err_lsb 0
+#define    p_reg_dca_interrupt  0xF77D
+#define reg_dca_interrupt_pos 0
+#define reg_dca_interrupt_len 1
+#define reg_dca_interrupt_lsb 0
+#define    p_reg_dca_auto_reset_en  0xF77E
+#define reg_dca_auto_reset_en_pos 0
+#define reg_dca_auto_reset_en_len 1
+#define reg_dca_auto_reset_en_lsb 0
+#define    p_reg_qnt_valuew_7_0 0xF77F
+#define reg_qnt_valuew_7_0_pos 0
+#define reg_qnt_valuew_7_0_len 8
+#define reg_qnt_valuew_7_0_lsb 0
+#define    p_reg_qnt_valuew_10_8    0xF780
+#define reg_qnt_valuew_10_8_pos 0
+#define reg_qnt_valuew_10_8_len 3
+#define reg_qnt_valuew_10_8_lsb 8
+#define    p_reg_qnt_nfvaluew_7_0   0xF781
+#define reg_qnt_nfvaluew_7_0_pos 0
+#define reg_qnt_nfvaluew_7_0_len 8
+#define reg_qnt_nfvaluew_7_0_lsb 0
+#define    p_reg_qnt_nfvaluew_10_8  0xF782
+#define reg_qnt_nfvaluew_10_8_pos 0
+#define reg_qnt_nfvaluew_10_8_len 3
+#define reg_qnt_nfvaluew_10_8_lsb 8
+#define    p_reg_qnt_flatness_thr_7_0   0xF783
+#define reg_qnt_flatness_thr_7_0_pos 0
+#define reg_qnt_flatness_thr_7_0_len 8
+#define reg_qnt_flatness_thr_7_0_lsb 0
+#define    p_reg_qnt_flatness_thr_8 0xF784
+#define reg_qnt_flatness_thr_8_pos 0
+#define reg_qnt_flatness_thr_8_len 1
+#define reg_qnt_flatness_thr_8_lsb 8
+#define    p_reg_llr_to_be_monitor  0xF785
+#define reg_llr_to_be_monitor_pos 0
+#define reg_llr_to_be_monitor_len 1
+#define reg_llr_to_be_monitor_lsb 0
+#define    p_reg_qnt_vbc_rdy    0xF786
+#define reg_qnt_vbc_rdy_pos 0
+#define reg_qnt_vbc_rdy_len 1
+#define reg_qnt_vbc_rdy_lsb 0
+#define    p_reg_qnt_noncmb_vbc_rdy 0xF787
+#define reg_qnt_noncmb_vbc_rdy_pos 0
+#define reg_qnt_noncmb_vbc_rdy_len 1
+#define reg_qnt_noncmb_vbc_rdy_lsb 0
+#define    p_reg_use_eh2_mean   0xF788
+#define reg_use_eh2_mean_pos 0
+#define reg_use_eh2_mean_len 1
+#define reg_use_eh2_mean_lsb 0
+#define    p_reg_qnt_vbc_ccid_mode  0xF789
+#define reg_qnt_vbc_ccid_mode_pos 0
+#define reg_qnt_vbc_ccid_mode_len 1
+#define reg_qnt_vbc_ccid_mode_lsb 0
+#define    p_reg_qnt_cci_bandsize   0xF78A
+#define reg_qnt_cci_bandsize_pos 0
+#define reg_qnt_cci_bandsize_len 4
+#define reg_qnt_cci_bandsize_lsb 0
+#define    p_reg_qnt_vbc_sframe_num 0xF78B
+#define reg_qnt_vbc_sframe_num_pos 0
+#define reg_qnt_vbc_sframe_num_len 8
+#define reg_qnt_vbc_sframe_num_lsb 0
+#define    p_reg_sbx_gain_diff_7_0  0xF78C
+#define reg_sbx_gain_diff_7_0_pos 0
+#define reg_sbx_gain_diff_7_0_len 8
+#define reg_sbx_gain_diff_7_0_lsb 0
+#define    p_reg_sbx_gain_diff_8    0xF78D
+#define reg_sbx_gain_diff_8_pos 0
+#define reg_sbx_gain_diff_8_len 1
+#define reg_sbx_gain_diff_8_lsb 8
+#define    p_reg_sbx_gain_diff_rdy  0xF78E
+#define reg_sbx_gain_diff_rdy_pos 0
+#define reg_sbx_gain_diff_rdy_len 1
+#define reg_sbx_gain_diff_rdy_lsb 0
+#define    p_reg_sbx_noncmb_gain_diff_7_0   0xF78F
+#define reg_sbx_noncmb_gain_diff_7_0_pos 0
+#define reg_sbx_noncmb_gain_diff_7_0_len 8
+#define reg_sbx_noncmb_gain_diff_7_0_lsb 0
+#define    p_reg_sbx_noncmb_gain_diff_8 0xF790
+#define reg_sbx_noncmb_gain_diff_8_pos 0
+#define reg_sbx_noncmb_gain_diff_8_len 1
+#define reg_sbx_noncmb_gain_diff_8_lsb 8
+#define    p_reg_sbx_noncmb_gain_diff_rdy   0xF791
+#define reg_sbx_noncmb_gain_diff_rdy_pos 0
+#define reg_sbx_noncmb_gain_diff_rdy_len 1
+#define reg_sbx_noncmb_gain_diff_rdy_lsb 0
+#define    r_reg_qnt_vbc_err_7_0    0xF792
+#define reg_qnt_vbc_err_7_0_pos 0
+#define reg_qnt_vbc_err_7_0_len 8
+#define reg_qnt_vbc_err_7_0_lsb 0
+#define    r_reg_qnt_vbc_err_15_8   0xF793
+#define reg_qnt_vbc_err_15_8_pos 0
+#define reg_qnt_vbc_err_15_8_len 8
+#define reg_qnt_vbc_err_15_8_lsb 8
+#define    r_reg_qnt_vbc_err_23_16  0xF794
+#define reg_qnt_vbc_err_23_16_pos 0
+#define reg_qnt_vbc_err_23_16_len 8
+#define reg_qnt_vbc_err_23_16_lsb 16
+#define    r_reg_qnt_noncmb_vbc_err_7_0 0xF795
+#define reg_qnt_noncmb_vbc_err_7_0_pos 0
+#define reg_qnt_noncmb_vbc_err_7_0_len 8
+#define reg_qnt_noncmb_vbc_err_7_0_lsb 0
+#define    r_reg_qnt_noncmb_vbc_err_15_8    0xF796
+#define reg_qnt_noncmb_vbc_err_15_8_pos 0
+#define reg_qnt_noncmb_vbc_err_15_8_len 8
+#define reg_qnt_noncmb_vbc_err_15_8_lsb 8
+#define    r_reg_qnt_noncmb_vbc_err_23_16   0xF797
+#define reg_qnt_noncmb_vbc_err_23_16_pos 0
+#define reg_qnt_noncmb_vbc_err_23_16_len 8
+#define reg_qnt_noncmb_vbc_err_23_16_lsb 16
+#define    p_reg_sbx_signalquality_threshold    0xF798
+#define reg_sbx_signalquality_threshold_pos 0
+#define reg_sbx_signalquality_threshold_len 4
+#define reg_sbx_signalquality_threshold_lsb 0
+#define    r_reg_sbx_signalquality_ind  0xF799
+#define reg_sbx_signalquality_ind_pos 0
+#define reg_sbx_signalquality_ind_len 1
+#define reg_sbx_signalquality_ind_lsb 0
+#define    p_reg_p_sbxqnt_th1   0xF79A
+#define reg_p_sbxqnt_th1_pos 0
+#define reg_p_sbxqnt_th1_len 8
+#define reg_p_sbxqnt_th1_lsb 0
+#define    p_reg_p_sbxqnt_th2   0xF79B
+#define reg_p_sbxqnt_th2_pos 0
+#define reg_p_sbxqnt_th2_len 8
+#define reg_p_sbxqnt_th2_lsb 0
+#define    p_reg_p_sbxqnt_th3   0xF79C
+#define reg_p_sbxqnt_th3_pos 0
+#define reg_p_sbxqnt_th3_len 8
+#define reg_p_sbxqnt_th3_lsb 0
+#define    p_reg_p_sbxqnt_th4   0xF79D
+#define reg_p_sbxqnt_th4_pos 0
+#define reg_p_sbxqnt_th4_len 8
+#define reg_p_sbxqnt_th4_lsb 0
+#define    p_reg_p_sbxqnt_th5   0xF79E
+#define reg_p_sbxqnt_th5_pos 0
+#define reg_p_sbxqnt_th5_len 8
+#define reg_p_sbxqnt_th5_lsb 0
+#define    p_reg_p_sbxqnt_th6   0xF79F
+#define reg_p_sbxqnt_th6_pos 0
+#define reg_p_sbxqnt_th6_len 8
+#define reg_p_sbxqnt_th6_lsb 0
+#define    p_reg_p_sbxqnt_th7   0xF800
+#define reg_p_sbxqnt_th7_pos 0
+#define reg_p_sbxqnt_th7_len 8
+#define reg_p_sbxqnt_th7_lsb 0
+#define    p_reg_p_sbxqnt_th8   0xF801
+#define reg_p_sbxqnt_th8_pos 0
+#define reg_p_sbxqnt_th8_len 8
+#define reg_p_sbxqnt_th8_lsb 0
+#define    p_reg_p_sbxqnt_th9   0xF802
+#define reg_p_sbxqnt_th9_pos 0
+#define reg_p_sbxqnt_th9_len 8
+#define reg_p_sbxqnt_th9_lsb 0
+#define    p_reg_p_sbxqnt_th10  0xF803
+#define reg_p_sbxqnt_th10_pos 0
+#define reg_p_sbxqnt_th10_len 8
+#define reg_p_sbxqnt_th10_lsb 0
+#define    p_reg_p_sbxqnt_th11  0xF804
+#define reg_p_sbxqnt_th11_pos 0
+#define reg_p_sbxqnt_th11_len 8
+#define reg_p_sbxqnt_th11_lsb 0
+#define    p_reg_p_sbxqnt_th12  0xF805
+#define reg_p_sbxqnt_th12_pos 0
+#define reg_p_sbxqnt_th12_len 8
+#define reg_p_sbxqnt_th12_lsb 0
+#define    p_reg_p_sbxqnt_th13_7_0  0xF806
+#define reg_p_sbxqnt_th13_7_0_pos 0
+#define reg_p_sbxqnt_th13_7_0_len 8
+#define reg_p_sbxqnt_th13_7_0_lsb 0
+#define    p_reg_p_sbxqnt_th13_9_8  0xF807
+#define reg_p_sbxqnt_th13_9_8_pos 0
+#define reg_p_sbxqnt_th13_9_8_len 2
+#define reg_p_sbxqnt_th13_9_8_lsb 8
+#define    p_reg_p_sbxqnt_th14_7_0  0xF808
+#define reg_p_sbxqnt_th14_7_0_pos 0
+#define reg_p_sbxqnt_th14_7_0_len 8
+#define reg_p_sbxqnt_th14_7_0_lsb 0
+#define    p_reg_p_sbxqnt_th14_9_8  0xF809
+#define reg_p_sbxqnt_th14_9_8_pos 0
+#define reg_p_sbxqnt_th14_9_8_len 2
+#define reg_p_sbxqnt_th14_9_8_lsb 8
+#define    p_reg_p_sbxqnt_th15_7_0  0xF80A
+#define reg_p_sbxqnt_th15_7_0_pos 0
+#define reg_p_sbxqnt_th15_7_0_len 8
+#define reg_p_sbxqnt_th15_7_0_lsb 0
+#define    p_reg_p_sbxqnt_th15_9_8  0xF80B
+#define reg_p_sbxqnt_th15_9_8_pos 0
+#define reg_p_sbxqnt_th15_9_8_len 2
+#define reg_p_sbxqnt_th15_9_8_lsb 8
+#define    p_reg_p_sbxqnt_vzh2_th0  0xF80C
+#define reg_p_sbxqnt_vzh2_th0_pos 0
+#define reg_p_sbxqnt_vzh2_th0_len 8
+#define reg_p_sbxqnt_vzh2_th0_lsb 0
+#define    p_reg_p_sbxqnt_vzh2_th1  0xF80D
+#define reg_p_sbxqnt_vzh2_th1_pos 0
+#define reg_p_sbxqnt_vzh2_th1_len 8
+#define reg_p_sbxqnt_vzh2_th1_lsb 0
+#define    p_reg_p_sbxqnt_vzh2_th2  0xF80E
+#define reg_p_sbxqnt_vzh2_th2_pos 0
+#define reg_p_sbxqnt_vzh2_th2_len 8
+#define reg_p_sbxqnt_vzh2_th2_lsb 0
+#define    p_reg_p_qnt_w_comp1  0xF80F
+#define reg_p_qnt_w_comp1_pos 0
+#define reg_p_qnt_w_comp1_len 8
+#define reg_p_qnt_w_comp1_lsb 0
+#define    p_reg_p_qnt_w_comp2  0xF810
+#define reg_p_qnt_w_comp2_pos 0
+#define reg_p_qnt_w_comp2_len 8
+#define reg_p_qnt_w_comp2_lsb 0
+#define    p_reg_p_qnt_w_comp3  0xF811
+#define reg_p_qnt_w_comp3_pos 0
+#define reg_p_qnt_w_comp3_len 8
+#define reg_p_qnt_w_comp3_lsb 0
+#define    p_reg_p_vtb_in_0 0xF821
+#define reg_p_vtb_in_0_pos 0
+#define reg_p_vtb_in_0_len 6
+#define reg_p_vtb_in_0_lsb 0
+#define    p_reg_p_vtb_in_1 0xF822
+#define reg_p_vtb_in_1_pos 0
+#define reg_p_vtb_in_1_len 6
+#define reg_p_vtb_in_1_lsb 0
+#define    p_reg_p_vtb_in_2 0xF823
+#define reg_p_vtb_in_2_pos 0
+#define reg_p_vtb_in_2_len 6
+#define reg_p_vtb_in_2_lsb 0
+#define    p_reg_p_vtb_in_3 0xF824
+#define reg_p_vtb_in_3_pos 0
+#define reg_p_vtb_in_3_len 6
+#define reg_p_vtb_in_3_lsb 0
+#define    p_reg_p_vtb_in_4 0xF825
+#define reg_p_vtb_in_4_pos 0
+#define reg_p_vtb_in_4_len 6
+#define reg_p_vtb_in_4_lsb 0
+#define    p_reg_p_vtb_in_5 0xF826
+#define reg_p_vtb_in_5_pos 0
+#define reg_p_vtb_in_5_len 6
+#define reg_p_vtb_in_5_lsb 0
+#define    p_reg_p_vtb_in_6 0xF827
+#define reg_p_vtb_in_6_pos 0
+#define reg_p_vtb_in_6_len 6
+#define reg_p_vtb_in_6_lsb 0
+#define    p_reg_p_vtb_in_7 0xF828
+#define reg_p_vtb_in_7_pos 0
+#define reg_p_vtb_in_7_len 6
+#define reg_p_vtb_in_7_lsb 0
+#define    p_reg_p_vtb_in_8 0xF829
+#define reg_p_vtb_in_8_pos 0
+#define reg_p_vtb_in_8_len 6
+#define reg_p_vtb_in_8_lsb 0
+#define    p_reg_p_vtb_in_9 0xF82A
+#define reg_p_vtb_in_9_pos 0
+#define reg_p_vtb_in_9_len 6
+#define reg_p_vtb_in_9_lsb 0
+#define    p_reg_p_vtb_in_10    0xF82B
+#define reg_p_vtb_in_10_pos 0
+#define reg_p_vtb_in_10_len 6
+#define reg_p_vtb_in_10_lsb 0
+#define    p_reg_p_vtb_in_11    0xF82C
+#define reg_p_vtb_in_11_pos 0
+#define reg_p_vtb_in_11_len 6
+#define reg_p_vtb_in_11_lsb 0
+#define    p_reg_p_vtb_in_12    0xF82D
+#define reg_p_vtb_in_12_pos 0
+#define reg_p_vtb_in_12_len 6
+#define reg_p_vtb_in_12_lsb 0
+#define    p_reg_p_vtb_in_13    0xF82E
+#define reg_p_vtb_in_13_pos 0
+#define reg_p_vtb_in_13_len 6
+#define reg_p_vtb_in_13_lsb 0
+#define    p_reg_p_vtb_in_14    0xF82F
+#define reg_p_vtb_in_14_pos 0
+#define reg_p_vtb_in_14_len 6
+#define reg_p_vtb_in_14_lsb 0
+#define    p_reg_p_vtb_in_15    0xF830
+#define reg_p_vtb_in_15_pos 0
+#define reg_p_vtb_in_15_len 6
+#define reg_p_vtb_in_15_lsb 0
+#define    I2C_i2c_m_slave_addr 0xF940
+#define i2c_m_slave_addr_pos 0
+#define i2c_m_slave_addr_len 8
+#define i2c_m_slave_addr_lsb 0
+#define    I2C_i2c_m_data1  0xF941
+#define i2c_m_data1_pos 0
+#define i2c_m_data1_len 8
+#define i2c_m_data1_lsb 0
+#define    I2C_i2c_m_data2  0xF942
+#define i2c_m_data2_pos 0
+#define i2c_m_data2_len 8
+#define i2c_m_data2_lsb 0
+#define    I2C_i2c_m_data3  0xF943
+#define i2c_m_data3_pos 0
+#define i2c_m_data3_len 8
+#define i2c_m_data3_lsb 0
+#define    I2C_i2c_m_data4  0xF944
+#define i2c_m_data4_pos 0
+#define i2c_m_data4_len 8
+#define i2c_m_data4_lsb 0
+#define    I2C_i2c_m_data5  0xF945
+#define i2c_m_data5_pos 0
+#define i2c_m_data5_len 8
+#define i2c_m_data5_lsb 0
+#define    I2C_i2c_m_data6  0xF946
+#define i2c_m_data6_pos 0
+#define i2c_m_data6_len 8
+#define i2c_m_data6_lsb 0
+#define    I2C_i2c_m_data7  0xF947
+#define i2c_m_data7_pos 0
+#define i2c_m_data7_len 8
+#define i2c_m_data7_lsb 0
+#define    I2C_i2c_m_data8  0xF948
+#define i2c_m_data8_pos 0
+#define i2c_m_data8_len 8
+#define i2c_m_data8_lsb 0
+#define    I2C_i2c_m_data9  0xF949
+#define i2c_m_data9_pos 0
+#define i2c_m_data9_len 8
+#define i2c_m_data9_lsb 0
+#define    I2C_i2c_m_data10 0xF94A
+#define i2c_m_data10_pos 0
+#define i2c_m_data10_len 8
+#define i2c_m_data10_lsb 0
+#define    I2C_i2c_m_data11 0xF94B
+#define i2c_m_data11_pos 0
+#define i2c_m_data11_len 8
+#define i2c_m_data11_lsb 0
+#define    I2C_i2c_m_data12 0xF94C
+#define i2c_m_data12_pos 0
+#define i2c_m_data12_len 8
+#define i2c_m_data12_lsb 0
+#define    I2C_i2c_m_data13 0xF94D
+#define i2c_m_data13_pos 0
+#define i2c_m_data13_len 8
+#define i2c_m_data13_lsb 0
+#define    I2C_i2c_m_data14 0xF94E
+#define i2c_m_data14_pos 0
+#define i2c_m_data14_len 8
+#define i2c_m_data14_lsb 0
+#define    I2C_i2c_m_data15 0xF94F
+#define i2c_m_data15_pos 0
+#define i2c_m_data15_len 8
+#define i2c_m_data15_lsb 0
+#define    I2C_i2c_m_data16 0xF950
+#define i2c_m_data16_pos 0
+#define i2c_m_data16_len 8
+#define i2c_m_data16_lsb 0
+#define    I2C_i2c_m_data17 0xF951
+#define i2c_m_data17_pos 0
+#define i2c_m_data17_len 8
+#define i2c_m_data17_lsb 0
+#define    I2C_i2c_m_data18 0xF952
+#define i2c_m_data18_pos 0
+#define i2c_m_data18_len 8
+#define i2c_m_data18_lsb 0
+#define    I2C_i2c_m_data19 0xF953
+#define i2c_m_data19_pos 0
+#define i2c_m_data19_len 8
+#define i2c_m_data19_lsb 0
+#define    I2C_i2c_m_cmd_rw 0xF954
+#define i2c_m_cmd_rw_pos 0
+#define i2c_m_cmd_rw_len 1
+#define i2c_m_cmd_rw_lsb 0
+#define    I2C_i2c_m_cmd_rwlen  0xF954
+#define i2c_m_cmd_rwlen_pos 3
+#define i2c_m_cmd_rwlen_len 4
+#define i2c_m_cmd_rwlen_lsb 0
+#define    I2C_i2c_m_status_cmd_exe 0xF955
+#define i2c_m_status_cmd_exe_pos 0
+#define i2c_m_status_cmd_exe_len 1
+#define i2c_m_status_cmd_exe_lsb 0
+#define    I2C_i2c_m_status_wdat_done   0xF955
+#define i2c_m_status_wdat_done_pos 1
+#define i2c_m_status_wdat_done_len 1
+#define i2c_m_status_wdat_done_lsb 0
+#define    I2C_i2c_m_status_wdat_fail   0xF955
+#define i2c_m_status_wdat_fail_pos 2
+#define i2c_m_status_wdat_fail_len 1
+#define i2c_m_status_wdat_fail_lsb 0
+#define    I2C_i2c_m_status_rdat_rdy    0xF955
+#define i2c_m_status_rdat_rdy_pos 3
+#define i2c_m_status_rdat_rdy_len 1
+#define i2c_m_status_rdat_rdy_lsb 0
+#define    I2C_i2c_m_period 0xF956
+#define i2c_m_period_pos 0
+#define i2c_m_period_len 8
+#define i2c_m_period_lsb 0
+#define    I2C_i2c_m_reg_msb_lsb    0xF957
+#define i2c_m_reg_msb_lsb_pos 0
+#define i2c_m_reg_msb_lsb_len 1
+#define i2c_m_reg_msb_lsb_lsb 0
+#define    I2C_reg_ofdm_rst 0xF957
+#define reg_ofdm_rst_pos 1
+#define reg_ofdm_rst_len 1
+#define reg_ofdm_rst_lsb 0
+#define    I2C_reg_sample_period_on_tuner   0xF957
+#define reg_sample_period_on_tuner_pos 2
+#define reg_sample_period_on_tuner_len 1
+#define reg_sample_period_on_tuner_lsb 0
+#define    I2C_reg_sel_tuner    0xF957
+#define reg_sel_tuner_pos 3
+#define reg_sel_tuner_len 1
+#define reg_sel_tuner_lsb 0
+#define    I2C_reg_ofdm_rst_en  0xF957
+#define reg_ofdm_rst_en_pos 4
+#define reg_ofdm_rst_en_len 1
+#define reg_ofdm_rst_en_lsb 0
+#define    p_mp2if_psb_overflow 0xF980
+#define mp2if_psb_overflow_pos 0
+#define mp2if_psb_overflow_len 1
+#define mp2if_psb_overflow_lsb 0
+#define    p_mp2if_no_modify_tei_bit    0xF981
+#define mp2if_no_modify_tei_bit_pos 0
+#define mp2if_no_modify_tei_bit_len 1
+#define mp2if_no_modify_tei_bit_lsb 0
+#define    p_mp2if_keep_sf_sync_byte    0xF982
+#define mp2if_keep_sf_sync_byte_pos 0
+#define mp2if_keep_sf_sync_byte_len 1
+#define mp2if_keep_sf_sync_byte_lsb 0
+#define    p_mp2if_data_access_disable  0xF983
+#define mp2if_data_access_disable_pos 0
+#define mp2if_data_access_disable_len 1
+#define mp2if_data_access_disable_lsb 0
+#define    p_mp2if_mpeg_ser_do7 0xF984
+#define mp2if_mpeg_ser_do7_pos 0
+#define mp2if_mpeg_ser_do7_len 1
+#define mp2if_mpeg_ser_do7_lsb 0
+#define    p_mp2if_mpeg_ser_mode    0xF985
+#define mp2if_mpeg_ser_mode_pos 0
+#define mp2if_mpeg_ser_mode_len 1
+#define mp2if_mpeg_ser_mode_lsb 0
+#define    p_mp2if_mpeg_par_mode    0xF986
+#define mp2if_mpeg_par_mode_pos 0
+#define mp2if_mpeg_par_mode_len 1
+#define mp2if_mpeg_par_mode_lsb 0
+#define    r_mp2if_psb_empty    0xF987
+#define mp2if_psb_empty_pos 0
+#define mp2if_psb_empty_len 1
+#define mp2if_psb_empty_lsb 0
+#define    r_mp2if_ts_not_188   0xF988
+#define mp2if_ts_not_188_pos 0
+#define mp2if_ts_not_188_len 1
+#define mp2if_ts_not_188_lsb 0
+#define    p_mp2if_mssync_len   0xF989
+#define mp2if_mssync_len_pos 0
+#define mp2if_mssync_len_len 1
+#define mp2if_mssync_len_lsb 0
+#define    p_mp2if_msdo_msb 0xF98A
+#define mp2if_msdo_msb_pos 0
+#define mp2if_msdo_msb_len 1
+#define mp2if_msdo_msb_lsb 0
+#define    p_mp2if_mpeg_clk_gated   0xF98B
+#define mp2if_mpeg_clk_gated_pos 0
+#define mp2if_mpeg_clk_gated_len 1
+#define mp2if_mpeg_clk_gated_lsb 0
+#define    p_mp2if_mpeg_err_pol 0xF98C
+#define mp2if_mpeg_err_pol_pos 0
+#define mp2if_mpeg_err_pol_len 1
+#define mp2if_mpeg_err_pol_lsb 0
+#define    p_mp2if_mpeg_sync_pol    0xF98D
+#define mp2if_mpeg_sync_pol_pos 0
+#define mp2if_mpeg_sync_pol_len 1
+#define mp2if_mpeg_sync_pol_lsb 0
+#define    p_mp2if_mpeg_vld_pol 0xF98E
+#define mp2if_mpeg_vld_pol_pos 0
+#define mp2if_mpeg_vld_pol_len 1
+#define mp2if_mpeg_vld_pol_lsb 0
+#define    p_mp2if_mpeg_clk_pol 0xF98F
+#define mp2if_mpeg_clk_pol_pos 0
+#define mp2if_mpeg_clk_pol_len 1
+#define mp2if_mpeg_clk_pol_lsb 0
+#define    p_reg_mpeg_full_speed    0xF990
+#define reg_mpeg_full_speed_pos 0
+#define reg_mpeg_full_speed_len 1
+#define reg_mpeg_full_speed_lsb 0
+#define    p_mp2if_pid_complement   0xF991
+#define mp2if_pid_complement_pos 0
+#define mp2if_pid_complement_len 1
+#define mp2if_pid_complement_lsb 0
+#define    p_mp2if_pid_rst  0xF992
+#define mp2if_pid_rst_pos 0
+#define mp2if_pid_rst_len 1
+#define mp2if_pid_rst_lsb 0
+#define    p_mp2if_pid_en   0xF993
+#define mp2if_pid_en_pos 0
+#define mp2if_pid_en_len 1
+#define mp2if_pid_en_lsb 0
+#define    p_mp2if_pid_index_en 0xF994
+#define mp2if_pid_index_en_pos 0
+#define mp2if_pid_index_en_len 1
+#define mp2if_pid_index_en_lsb 0
+#define    p_mp2if_pid_index    0xF995
+#define mp2if_pid_index_pos 0
+#define mp2if_pid_index_len 5
+#define mp2if_pid_index_lsb 0
+#define    p_mp2if_pid_dat_l    0xF996
+#define mp2if_pid_dat_l_pos 0
+#define mp2if_pid_dat_l_len 8
+#define mp2if_pid_dat_l_lsb 0
+#define    p_mp2if_pid_dat_h    0xF997
+#define mp2if_pid_dat_h_pos 0
+#define mp2if_pid_dat_h_len 5
+#define mp2if_pid_dat_h_lsb 0
+#define    p_reg_latch_clk  0xF998
+#define reg_latch_clk_pos 0
+#define reg_latch_clk_len 1
+#define reg_latch_clk_lsb 0
+#define    r_mp2if_sync_byte_locked 0xF999
+#define mp2if_sync_byte_locked_pos 0
+#define mp2if_sync_byte_locked_len 1
+#define mp2if_sync_byte_locked_lsb 0
+#define    p_mp2if_ignore_sync_byte 0xF99A
+#define mp2if_ignore_sync_byte_pos 0
+#define mp2if_ignore_sync_byte_len 1
+#define mp2if_ignore_sync_byte_lsb 0
+#define    p_reg_mp2if_clk_en   0xF99B
+#define reg_mp2if_clk_en_pos 0
+#define reg_mp2if_clk_en_len 1
+#define reg_mp2if_clk_en_lsb 0
+#define    p_reg_mpeg_vld_tgl   0xF99C
+#define reg_mpeg_vld_tgl_pos 0
+#define reg_mpeg_vld_tgl_len 1
+#define reg_mpeg_vld_tgl_lsb 0
+#define    p_reg_mp2_sw_rst 0xF99D
+#define reg_mp2_sw_rst_pos 0
+#define reg_mp2_sw_rst_len 1
+#define reg_mp2_sw_rst_lsb 0
+#define    p_mp2if_psb_en   0xF99E
+#define mp2if_psb_en_pos 0
+#define mp2if_psb_en_len 1
+#define mp2if_psb_en_lsb 0
+#define    r_mp2if_usb20_mode   0xF99F
+#define mp2if_usb20_mode_pos 0
+#define mp2if_usb20_mode_len 1
+#define mp2if_usb20_mode_lsb 0
+#define    r_mp2if_strap_usb20_mode 0xF9A0
+#define mp2if_strap_usb20_mode_pos 0
+#define mp2if_strap_usb20_mode_len 1
+#define mp2if_strap_usb20_mode_lsb 0
+#define    r_mp2if_lost_pkt_cnt_l   0xF9A1
+#define mp2if_lost_pkt_cnt_l_pos 0
+#define mp2if_lost_pkt_cnt_l_len 8
+#define mp2if_lost_pkt_cnt_l_lsb 0
+#define    r_mp2if_lost_pkt_cnt_h   0xF9A2
+#define mp2if_lost_pkt_cnt_h_pos 0
+#define mp2if_lost_pkt_cnt_h_len 8
+#define mp2if_lost_pkt_cnt_h_lsb 0
+#define    p_reg_mp2if2_en  0xF9A3
+#define reg_mp2if2_en_pos 0
+#define reg_mp2if2_en_len 1
+#define reg_mp2if2_en_lsb 0
+#define    p_reg_mp2if2_sw_rst  0xF9A4
+#define reg_mp2if2_sw_rst_pos 0
+#define reg_mp2if2_sw_rst_len 1
+#define reg_mp2if2_sw_rst_lsb 0
+#define    p_reg_mp2if2_half_psb    0xF9A5
+#define reg_mp2if2_half_psb_pos 0
+#define reg_mp2if2_half_psb_len 1
+#define reg_mp2if2_half_psb_lsb 0
+#define    p_reg_ts_byte_endian 0xF9A6
+#define reg_ts_byte_endian_pos 0
+#define reg_ts_byte_endian_len 1
+#define reg_ts_byte_endian_lsb 0
+#define    p_reg_mp2_dioif  0xF9A7
+#define reg_mp2_dioif_pos 0
+#define reg_mp2_dioif_len 1
+#define reg_mp2_dioif_lsb 0
+#define    p_reg_mp2_dioif_fast 0xF9A8
+#define reg_mp2_dioif_fast_pos 0
+#define reg_mp2_dioif_fast_len 1
+#define reg_mp2_dioif_fast_lsb 0
+#define    p_reg_tpsd_bw_mp2if  0xF9A9
+#define reg_tpsd_bw_mp2if_pos 0
+#define reg_tpsd_bw_mp2if_len 2
+#define reg_tpsd_bw_mp2if_lsb 0
+#define    p_reg_tpsd_gi_mp2if  0xF9AA
+#define reg_tpsd_gi_mp2if_pos 0
+#define reg_tpsd_gi_mp2if_len 2
+#define reg_tpsd_gi_mp2if_lsb 0
+#define    p_reg_tpsd_cr_mp2if  0xF9AB
+#define reg_tpsd_cr_mp2if_pos 0
+#define reg_tpsd_cr_mp2if_len 3
+#define reg_tpsd_cr_mp2if_lsb 0
+#define    p_reg_tpsd_cons_mp2if    0xF9AC
+#define reg_tpsd_cons_mp2if_pos 0
+#define reg_tpsd_cons_mp2if_len 2
+#define reg_tpsd_cons_mp2if_lsb 0
+#define    p_reg_fw_table_en    0xF9AD
+#define reg_fw_table_en_pos 0
+#define reg_fw_table_en_len 1
+#define reg_fw_table_en_lsb 0
+#define    p_reg_p_aud_pk_gen_aud_pk_size   0xF9AD
+#define reg_p_aud_pk_gen_aud_pk_size_pos 1
+#define reg_p_aud_pk_gen_aud_pk_size_len 6
+#define reg_p_aud_pk_gen_aud_pk_size_lsb 0
+#define    p_mp2if_psb_num_blk  0xF9AE
+#define mp2if_psb_num_blk_pos 0
+#define mp2if_psb_num_blk_len 6
+#define mp2if_psb_num_blk_lsb 0
+#define    p_reg_fec_fake   0xF9AF
+#define reg_fec_fake_pos 0
+#define reg_fec_fake_len 1
+#define reg_fec_fake_lsb 0
+#define    p_reg_p_ccir_atv_en  0xF9AF
+#define reg_p_ccir_atv_en_pos 1
+#define reg_p_ccir_atv_en_len 1
+#define reg_p_ccir_atv_en_lsb 0
+#define    p_reg_video_stop_n   0xF9AF
+#define reg_video_stop_n_pos 2
+#define reg_video_stop_n_len 1
+#define reg_video_stop_n_lsb 0
+#define    p_reg_audio_stop_n   0xF9AF
+#define reg_audio_stop_n_pos 3
+#define reg_audio_stop_n_len 1
+#define reg_audio_stop_n_lsb 0
+#define    p_mp2if_i2smode  0xF9AF
+#define mp2if_i2smode_pos 4
+#define mp2if_i2smode_len 2
+#define mp2if_i2smode_lsb 0
+#define    p_mp2if_word_size    0xF9AF
+#define mp2if_word_size_pos 6
+#define mp2if_word_size_len 2
+#define mp2if_word_size_lsb 0
+#define    p_reg_packet_gap 0xF9B0
+#define reg_packet_gap_pos 0
+#define reg_packet_gap_len 8
+#define reg_packet_gap_lsb 0
+#define    p_reg_ts_dat_inv 0xF9B2
+#define reg_ts_dat_inv_pos 0
+#define reg_ts_dat_inv_len 1
+#define reg_ts_dat_inv_lsb 0
+#define    p_reg_ts_lsb_1st 0xF9B3
+#define reg_ts_lsb_1st_pos 0
+#define reg_ts_lsb_1st_len 1
+#define reg_ts_lsb_1st_lsb 0
+#define    p_reg_ts_capt_bg_sel 0xF9B4
+#define reg_ts_capt_bg_sel_pos 0
+#define reg_ts_capt_bg_sel_len 1
+#define reg_ts_capt_bg_sel_lsb 0
+#define    p_reg_mp2if_stop_en  0xF9B5
+#define reg_mp2if_stop_en_pos 0
+#define reg_mp2if_stop_en_len 1
+#define reg_mp2if_stop_en_lsb 0
+#define    p_reg_mp2if2_pes_base    0xF9B6
+#define reg_mp2if2_pes_base_pos 0
+#define reg_mp2if2_pes_base_len 1
+#define reg_mp2if2_pes_base_lsb 0
+#define    p_reg_ts_sync_inv    0xF9B7
+#define reg_ts_sync_inv_pos 0
+#define reg_ts_sync_inv_len 1
+#define reg_ts_sync_inv_lsb 0
+#define    p_reg_ts_vld_inv 0xF9B8
+#define reg_ts_vld_inv_pos 0
+#define reg_ts_vld_inv_len 1
+#define reg_ts_vld_inv_lsb 0
+#define    p_reg_sys_buf_overflow   0xF9B9
+#define reg_sys_buf_overflow_pos 0
+#define reg_sys_buf_overflow_len 1
+#define reg_sys_buf_overflow_lsb 0
+#define    p_reg_top_dummy0 0xF9BB
+#define reg_top_dummy0_pos 0
+#define reg_top_dummy0_len 8
+#define reg_top_dummy0_lsb 0
+#define    p_reg_top_dummy1 0xF9BC
+#define reg_top_dummy1_pos 0
+#define reg_top_dummy1_len 8
+#define reg_top_dummy1_lsb 0
+#define    p_reg_top_dummy2 0xF9BD
+#define reg_top_dummy2_pos 0
+#define reg_top_dummy2_len 8
+#define reg_top_dummy2_lsb 0
+#define    p_reg_top_dummy3 0xF9BE
+#define reg_top_dummy3_pos 0
+#define reg_top_dummy3_len 8
+#define reg_top_dummy3_lsb 0
+#define    p_reg_top_dummy4 0xF9BF
+#define reg_top_dummy4_pos 0
+#define reg_top_dummy4_len 8
+#define reg_top_dummy4_lsb 0
+#define    p_reg_top_dummy5 0xF9C0
+#define reg_top_dummy5_pos 0
+#define reg_top_dummy5_len 8
+#define reg_top_dummy5_lsb 0
+#define    p_reg_top_dummy6 0xF9C1
+#define reg_top_dummy6_pos 0
+#define reg_top_dummy6_len 8
+#define reg_top_dummy6_lsb 0
+#define    p_reg_top_dummy7 0xF9C2
+#define reg_top_dummy7_pos 0
+#define reg_top_dummy7_len 8
+#define reg_top_dummy7_lsb 0
+#define    p_reg_top_dummy8 0xF9C3
+#define reg_top_dummy8_pos 0
+#define reg_top_dummy8_len 8
+#define reg_top_dummy8_lsb 0
+#define    p_reg_top_dummy9 0xF9C4
+#define reg_top_dummy9_pos 0
+#define reg_top_dummy9_len 8
+#define reg_top_dummy9_lsb 0
+#define    p_reg_top_dummyA 0xF9C5
+#define reg_top_dummyA_pos 0
+#define reg_top_dummyA_len 8
+#define reg_top_dummyA_lsb 0
+#define    p_reg_top_dummyB 0xF9C6
+#define reg_top_dummyB_pos 0
+#define reg_top_dummyB_len 8
+#define reg_top_dummyB_lsb 0
+#define    p_reg_top_dummyC 0xF9C7
+#define reg_top_dummyC_pos 0
+#define reg_top_dummyC_len 8
+#define reg_top_dummyC_lsb 0
+#define    p_reg_top_dummyD 0xF9C8
+#define reg_top_dummyD_pos 0
+#define reg_top_dummyD_len 8
+#define reg_top_dummyD_lsb 0
+#define    p_reg_top_dummyE 0xF9C9
+#define reg_top_dummyE_pos 0
+#define reg_top_dummyE_len 8
+#define reg_top_dummyE_lsb 0
+#define    p_reg_top_dummyF 0xF9CA
+#define reg_top_dummyF_pos 0
+#define reg_top_dummyF_len 8
+#define reg_top_dummyF_lsb 0
+#define    p_reg_mp2if_clk_coeff    0xF9CB
+#define reg_mp2if_clk_coeff_pos 0
+#define reg_mp2if_clk_coeff_len 7
+#define reg_mp2if_clk_coeff_lsb 0
+#define    p_reg_tsip_en    0xF9CC
+#define reg_tsip_en_pos 0
+#define reg_tsip_en_len 1
+#define reg_tsip_en_lsb 0
+#define    p_reg_tsis_en    0xF9CD
+#define reg_tsis_en_pos 0
+#define reg_tsis_en_len 1
+#define reg_tsis_en_lsb 0
+#define    p_reg_tsip_br    0xF9CE
+#define reg_tsip_br_pos 0
+#define reg_tsip_br_len 1
+#define reg_tsip_br_lsb 0
+#define    p_reg_tsip_frm_inv   0xF9D0
+#define reg_tsip_frm_inv_pos 0
+#define reg_tsip_frm_inv_len 1
+#define reg_tsip_frm_inv_lsb 0
+#define    p_reg_tsip_str_inv   0xF9D1
+#define reg_tsip_str_inv_pos 0
+#define reg_tsip_str_inv_len 1
+#define reg_tsip_str_inv_lsb 0
+#define    p_reg_tsip_fail_inv  0xF9D2
+#define reg_tsip_fail_inv_pos 0
+#define reg_tsip_fail_inv_len 1
+#define reg_tsip_fail_inv_lsb 0
+#define    p_reg_tsip_frm_ignore    0xF9D3
+#define reg_tsip_frm_ignore_pos 0
+#define reg_tsip_frm_ignore_len 1
+#define reg_tsip_frm_ignore_lsb 0
+#define    p_reg_tsip_str_ignore    0xF9D4
+#define reg_tsip_str_ignore_pos 0
+#define reg_tsip_str_ignore_len 1
+#define reg_tsip_str_ignore_lsb 0
+#define    p_reg_tsip_fail_ignore   0xF9D5
+#define reg_tsip_fail_ignore_pos 0
+#define reg_tsip_fail_ignore_len 1
+#define reg_tsip_fail_ignore_lsb 0
+#define    p_reg_tsip_endian    0xF9D6
+#define reg_tsip_endian_pos 0
+#define reg_tsip_endian_len 1
+#define reg_tsip_endian_lsb 0
+#define    p_reg_tsip_overflow  0xF9D7
+#define reg_tsip_overflow_pos 0
+#define reg_tsip_overflow_len 1
+#define reg_tsip_overflow_lsb 0
+#define    p_reg_ts_in_src  0xF9D8
+#define reg_ts_in_src_pos 0
+#define reg_ts_in_src_len 1
+#define reg_ts_in_src_lsb 0
+#define    r_reg_clk_sel    0xF9D9
+#define reg_clk_sel_pos 0
+#define reg_clk_sel_len 2
+#define reg_clk_sel_lsb 0
+#define    r_reg_tog_sel    0xF9DA
+#define reg_tog_sel_pos 0
+#define reg_tog_sel_len 2
+#define reg_tog_sel_lsb 0
+#define    p_reg_ts_str_ignore  0xF9DB
+#define reg_ts_str_ignore_pos 0
+#define reg_ts_str_ignore_len 1
+#define reg_ts_str_ignore_lsb 0
+#define    p_reg_ts_frm_ignore  0xF9DC
+#define reg_ts_frm_ignore_pos 0
+#define reg_ts_frm_ignore_len 1
+#define reg_ts_frm_ignore_lsb 0
+#define    p_reg_clk_sel_fix    0xF9DD
+#define reg_clk_sel_fix_pos 0
+#define reg_clk_sel_fix_len 2
+#define reg_clk_sel_fix_lsb 0
+#define    p_reg_tog_sel_fix    0xF9DE
+#define reg_tog_sel_fix_pos 0
+#define reg_tog_sel_fix_len 2
+#define reg_tog_sel_fix_lsb 0
+#define    p_reg_en_fix 0xF9DF
+#define reg_en_fix_pos 0
+#define reg_en_fix_len 1
+#define reg_en_fix_lsb 0
+#define    p_reg_check_tpsd_hier    0xF9E0
+#define reg_check_tpsd_hier_pos 0
+#define reg_check_tpsd_hier_len 1
+#define reg_check_tpsd_hier_lsb 0
+#define    p_reg_p_i2s_master_mode  0xF9E1
+#define reg_p_i2s_master_mode_pos 0
+#define reg_p_i2s_master_mode_len 1
+#define reg_p_i2s_master_mode_lsb 0
+#define    p_reg_p_sc_lr_ratio  0xF9E2
+#define reg_p_sc_lr_ratio_pos 0
+#define reg_p_sc_lr_ratio_len 2
+#define reg_p_sc_lr_ratio_lsb 0
+#define    p_reg_p_i2s_fs_type  0xF9E2
+#define reg_p_i2s_fs_type_pos 2
+#define reg_p_i2s_fs_type_len 2
+#define reg_p_i2s_fs_type_lsb 0
+#define    r_reg_r_pp_fullq 0xF9E3
+#define reg_r_pp_fullq_pos 0
+#define reg_r_pp_fullq_len 1
+#define reg_r_pp_fullq_lsb 0
+#define    p_reg_r_ccir_rst 0xF9E3
+#define reg_r_ccir_rst_pos 1
+#define reg_r_ccir_rst_len 1
+#define reg_r_ccir_rst_lsb 0
+#define    p_reg_p_full_en  0xF9E3
+#define reg_p_full_en_pos 2
+#define reg_p_full_en_len 1
+#define reg_p_full_en_lsb 0
+#define    p_reg_p_vbi_dis  0xF9E3
+#define reg_p_vbi_dis_pos 3
+#define reg_p_vbi_dis_len 1
+#define reg_p_vbi_dis_lsb 0
+#define    p_reg_p_ccir_all 0xF9E3
+#define reg_p_ccir_all_pos 4
+#define reg_p_ccir_all_len 1
+#define reg_p_ccir_all_lsb 0
+#define    p_reg_p_ccir_vbi_raw_en  0xF9E3
+#define reg_p_ccir_vbi_raw_en_pos 5
+#define reg_p_ccir_vbi_raw_en_len 1
+#define reg_p_ccir_vbi_raw_en_lsb 0
+#define    p_reg_err_byte_en    0xF9E4
+#define reg_err_byte_en_pos 0
+#define reg_err_byte_en_len 1
+#define reg_err_byte_en_lsb 0
+#define    p_reg_mp2_f_adc_7_0  0xF9E5
+#define reg_mp2_f_adc_7_0_pos 0
+#define reg_mp2_f_adc_7_0_len 8
+#define reg_mp2_f_adc_7_0_lsb 0
+#define    p_reg_mp2_f_adc_15_8 0xF9E6
+#define reg_mp2_f_adc_15_8_pos 0
+#define reg_mp2_f_adc_15_8_len 8
+#define reg_mp2_f_adc_15_8_lsb 8
+#define    p_reg_mp2_f_adc_23_16    0xF9E7
+#define reg_mp2_f_adc_23_16_pos 0
+#define reg_mp2_f_adc_23_16_len 8
+#define reg_mp2_f_adc_23_16_lsb 16
+#define    p_reg_set_util   0xF9E8
+#define reg_set_util_pos 0
+#define reg_set_util_len 8
+#define reg_set_util_lsb 0
+#define    r_reg_err_byte   0xF9E9
+#define reg_err_byte_pos 0
+#define reg_err_byte_len 8
+#define reg_err_byte_lsb 0
+#define    p_reg_p_ln_num1  0xF9EA
+#define reg_p_ln_num1_pos 0
+#define reg_p_ln_num1_len 5
+#define reg_p_ln_num1_lsb 0
+#define    p_reg_p_ln_num2_2_0  0xF9EA
+#define reg_p_ln_num2_2_0_pos 5
+#define reg_p_ln_num2_2_0_len 3
+#define reg_p_ln_num2_2_0_lsb 0
+#define    p_reg_p_ln_num2_4_3  0xF9EB
+#define reg_p_ln_num2_4_3_pos 0
+#define reg_p_ln_num2_4_3_len 2
+#define reg_p_ln_num2_4_3_lsb 3
+#define    p_reg_p_ln_num3_5_0  0xF9EB
+#define reg_p_ln_num3_5_0_pos 2
+#define reg_p_ln_num3_5_0_len 6
+#define reg_p_ln_num3_5_0_lsb 0
+#define    p_reg_p_ln_num3_8_6  0xF9EC
+#define reg_p_ln_num3_8_6_pos 0
+#define reg_p_ln_num3_8_6_len 3
+#define reg_p_ln_num3_8_6_lsb 6
+#define    p_reg_p_ln_num4_4_0  0xF9EC
+#define reg_p_ln_num4_4_0_pos 3
+#define reg_p_ln_num4_4_0_len 5
+#define reg_p_ln_num4_4_0_lsb 0
+#define    p_reg_p_ln_num4_8_5  0xF9ED
+#define reg_p_ln_num4_8_5_pos 0
+#define reg_p_ln_num4_8_5_len 4
+#define reg_p_ln_num4_8_5_lsb 5
+#define    p_reg_p_ln_num5_3_0  0xF9ED
+#define reg_p_ln_num5_3_0_pos 4
+#define reg_p_ln_num5_3_0_len 4
+#define reg_p_ln_num5_3_0_lsb 0
+#define    p_reg_p_ln_num5_8_4  0xF9EE
+#define reg_p_ln_num5_8_4_pos 0
+#define reg_p_ln_num5_8_4_len 5
+#define reg_p_ln_num5_8_4_lsb 4
+#define    p_reg_p_ln_num6_2_0  0xF9EE
+#define reg_p_ln_num6_2_0_pos 5
+#define reg_p_ln_num6_2_0_len 3
+#define reg_p_ln_num6_2_0_lsb 0
+#define    p_reg_p_ln_num6_8_3  0xF9EF
+#define reg_p_ln_num6_8_3_pos 0
+#define reg_p_ln_num6_8_3_len 6
+#define reg_p_ln_num6_8_3_lsb 3
+#define    p_reg_p_pixel_num_7_0    0xF9F0
+#define reg_p_pixel_num_7_0_pos 0
+#define reg_p_pixel_num_7_0_len 8
+#define reg_p_pixel_num_7_0_lsb 0
+#define    p_reg_p_pixel_num_10_8   0xF9F1
+#define reg_p_pixel_num_10_8_pos 0
+#define reg_p_pixel_num_10_8_len 3
+#define reg_p_pixel_num_10_8_lsb 8
+#define    p_reg_p_ccir_yuv_en  0xF9F1
+#define reg_p_ccir_yuv_en_pos 3
+#define reg_p_ccir_yuv_en_len 1
+#define reg_p_ccir_yuv_en_lsb 0
+#define    p_reg_p_ccir_size_sft    0xF9F1
+#define reg_p_ccir_size_sft_pos 4
+#define reg_p_ccir_size_sft_len 2
+#define reg_p_ccir_size_sft_lsb 0
+#define    p_reg_p_psb_cnt_sft  0xF9F1
+#define reg_p_psb_cnt_sft_pos 6
+#define reg_p_psb_cnt_sft_len 2
+#define reg_p_psb_cnt_sft_lsb 0
+#define    p_reg_p_tpsd_lock_trigger    0xF9F2
+#define reg_p_tpsd_lock_trigger_pos 0
+#define reg_p_tpsd_lock_trigger_len 1
+#define reg_p_tpsd_lock_trigger_lsb 0
+#define    p_reg_p_ccir_clk_sel 0xF9F3
+#define reg_p_ccir_clk_sel_pos 0
+#define reg_p_ccir_clk_sel_len 1
+#define reg_p_ccir_clk_sel_lsb 0
+#define    p_reg_i2c_16_8_data_sel  0xFB00
+#define reg_i2c_16_8_data_sel_pos 0
+#define reg_i2c_16_8_data_sel_len 1
+#define reg_i2c_16_8_data_sel_lsb 0
+#define    p_reg_i2c_slave_trigger_byte 0xFB01
+#define reg_i2c_slave_trigger_byte_pos 0
+#define reg_i2c_slave_trigger_byte_len 1
+#define reg_i2c_slave_trigger_byte_lsb 0
+#define    p_reg_wdti_level 0xFB05
+#define reg_wdti_level_pos 0
+#define reg_wdti_level_len 1
+#define reg_wdti_level_lsb 0
+#define    p_reg_rssi_avg_sel_lat   0xFB06
+#define reg_rssi_avg_sel_lat_pos 0
+#define reg_rssi_avg_sel_lat_len 2
+#define reg_rssi_avg_sel_lat_lsb 0
+#define    r_ofsm_rssi_avg_7_0  0xFB07
+#define ofsm_rssi_avg_7_0_pos 0
+#define ofsm_rssi_avg_7_0_len 8
+#define ofsm_rssi_avg_7_0_lsb 0
+#define    r_ofsm_rssi_avg_9_8  0xFB08
+#define ofsm_rssi_avg_9_8_pos 0
+#define ofsm_rssi_avg_9_8_len 2
+#define ofsm_rssi_avg_9_8_lsb 8
+#define    r_ofsm_mbist_fail_mon51  0xFB09
+#define ofsm_mbist_fail_mon51_pos 0
+#define ofsm_mbist_fail_mon51_len 1
+#define ofsm_mbist_fail_mon51_lsb 0
+#define    r_ofsm_mbist_fail_com    0xFB0A
+#define ofsm_mbist_fail_com_pos 0
+#define ofsm_mbist_fail_com_len 1
+#define ofsm_mbist_fail_com_lsb 0
+#define    r_ofsm_mbist_fail_fft    0xFB0B
+#define ofsm_mbist_fail_fft_pos 0
+#define ofsm_mbist_fail_fft_len 1
+#define ofsm_mbist_fail_fft_lsb 0
+#define    r_ofsm_mbist_fail_fd 0xFB0C
+#define ofsm_mbist_fail_fd_pos 0
+#define ofsm_mbist_fail_fd_len 1
+#define ofsm_mbist_fail_fd_lsb 0
+#define    r_ofsm_mbist_fail_link   0xFB0D
+#define ofsm_mbist_fail_link_pos 0
+#define ofsm_mbist_fail_link_len 1
+#define ofsm_mbist_fail_link_lsb 0
+#define    r_ofsm_mbist_fail_mpe    0xFB0E
+#define ofsm_mbist_fail_mpe_pos 0
+#define ofsm_mbist_fail_mpe_len 1
+#define ofsm_mbist_fail_mpe_lsb 0
+#define    r_ofsm_mbist_done_mpe    0xFB0F
+#define ofsm_mbist_done_mpe_pos 0
+#define ofsm_mbist_done_mpe_len 1
+#define ofsm_mbist_done_mpe_lsb 0
+#define    r_ofsm_mbist_mode_mpe    0xFB10
+#define ofsm_mbist_mode_mpe_pos 0
+#define ofsm_mbist_mode_mpe_len 1
+#define ofsm_mbist_mode_mpe_lsb 0
+#define    p_ofsm_cmd_reg   0xFB11
+#define ofsm_cmd_reg_pos 0
+#define ofsm_cmd_reg_len 8
+#define ofsm_cmd_reg_lsb 0
+#define    p_ofsm_addr_reg_h    0xFB12
+#define ofsm_addr_reg_h_pos 0
+#define ofsm_addr_reg_h_len 8
+#define ofsm_addr_reg_h_lsb 0
+#define    p_ofsm_addr_reg_l    0xFB13
+#define ofsm_addr_reg_l_pos 0
+#define ofsm_addr_reg_l_len 8
+#define ofsm_addr_reg_l_lsb 0
+#define    p_ofsm_data_reg_0    0xFB14
+#define ofsm_data_reg_0_pos 0
+#define ofsm_data_reg_0_len 8
+#define ofsm_data_reg_0_lsb 0
+#define    p_ofsm_data_reg_1    0xFB15
+#define ofsm_data_reg_1_pos 0
+#define ofsm_data_reg_1_len 8
+#define ofsm_data_reg_1_lsb 0
+#define    p_ofsm_data_reg_2    0xFB16
+#define ofsm_data_reg_2_pos 0
+#define ofsm_data_reg_2_len 8
+#define ofsm_data_reg_2_lsb 0
+#define    p_ofsm_data_reg_3    0xFB17
+#define ofsm_data_reg_3_pos 0
+#define ofsm_data_reg_3_len 8
+#define ofsm_data_reg_3_lsb 0
+#define    p_ofsm_data_reg_4    0xFB18
+#define ofsm_data_reg_4_pos 0
+#define ofsm_data_reg_4_len 8
+#define ofsm_data_reg_4_lsb 0
+#define    p_ofsm_data_reg_5    0xFB19
+#define ofsm_data_reg_5_pos 0
+#define ofsm_data_reg_5_len 8
+#define ofsm_data_reg_5_lsb 0
+#define    p_ofsm_data_reg_6    0xFB1A
+#define ofsm_data_reg_6_pos 0
+#define ofsm_data_reg_6_len 8
+#define ofsm_data_reg_6_lsb 0
+#define    p_ofsm_data_reg_7    0xFB1B
+#define ofsm_data_reg_7_pos 0
+#define ofsm_data_reg_7_len 8
+#define ofsm_data_reg_7_lsb 0
+#define    p_ofsm_data_reg_8    0xFB1C
+#define ofsm_data_reg_8_pos 0
+#define ofsm_data_reg_8_len 8
+#define ofsm_data_reg_8_lsb 0
+#define    p_ofsm_data_reg_9    0xFB1D
+#define ofsm_data_reg_9_pos 0
+#define ofsm_data_reg_9_len 8
+#define ofsm_data_reg_9_lsb 0
+#define    p_ofsm_data_reg_10   0xFB1E
+#define ofsm_data_reg_10_pos 0
+#define ofsm_data_reg_10_len 8
+#define ofsm_data_reg_10_lsb 0
+#define    p_ofsm_data_reg_11   0xFB1F
+#define ofsm_data_reg_11_pos 0
+#define ofsm_data_reg_11_len 8
+#define ofsm_data_reg_11_lsb 0
+#define    p_ofsm_data_reg_12   0xFB20
+#define ofsm_data_reg_12_pos 0
+#define ofsm_data_reg_12_len 8
+#define ofsm_data_reg_12_lsb 0
+#define    p_ofsm_data_reg_13   0xFB21
+#define ofsm_data_reg_13_pos 0
+#define ofsm_data_reg_13_len 8
+#define ofsm_data_reg_13_lsb 0
+#define    p_ofsm_data_reg_14   0xFB22
+#define ofsm_data_reg_14_pos 0
+#define ofsm_data_reg_14_len 8
+#define ofsm_data_reg_14_lsb 0
+#define    p_ofsm_data_reg_15   0xFB23
+#define ofsm_data_reg_15_pos 0
+#define ofsm_data_reg_15_len 8
+#define ofsm_data_reg_15_lsb 0
+#define    p_reg_afe_mem0   0xFB24
+#define reg_afe_mem0_pos 0
+#define reg_afe_mem0_len 8
+#define reg_afe_mem0_lsb 0
+#define    p_reg_afe_mem1   0xFB25
+#define reg_afe_mem1_pos 0
+#define reg_afe_mem1_len 8
+#define reg_afe_mem1_lsb 0
+#define    p_reg_afe_mem2   0xFB26
+#define reg_afe_mem2_pos 0
+#define reg_afe_mem2_len 8
+#define reg_afe_mem2_lsb 0
+#define    p_reg_afe_mem3   0xFB27
+#define reg_afe_mem3_pos 0
+#define reg_afe_mem3_len 8
+#define reg_afe_mem3_lsb 0
+#define    p_reg_afe_mem4   0xFB28
+#define reg_afe_mem4_pos 0
+#define reg_afe_mem4_len 8
+#define reg_afe_mem4_lsb 0
+#define    p_reg_afe_mem5   0xFB29
+#define reg_afe_mem5_pos 0
+#define reg_afe_mem5_len 8
+#define reg_afe_mem5_lsb 0
+#define    p_reg_afe_mem6   0xFB2A
+#define reg_afe_mem6_pos 0
+#define reg_afe_mem6_len 8
+#define reg_afe_mem6_lsb 0
+#define    p_reg_afe_mem7   0xFB2B
+#define reg_afe_mem7_pos 0
+#define reg_afe_mem7_len 8
+#define reg_afe_mem7_lsb 0
+#define    p_reg_i2cbootreq 0xFB2C
+#define reg_i2cbootreq_pos 0
+#define reg_i2cbootreq_len 1
+#define reg_i2cbootreq_lsb 0
+#define    p_reg_rst_i2cm   0xFB30
+#define reg_rst_i2cm_pos 0
+#define reg_rst_i2cm_len 1
+#define reg_rst_i2cm_lsb 0
+#define    p_reg_rst_i2cs   0xFB31
+#define reg_rst_i2cs_pos 0
+#define reg_rst_i2cs_len 1
+#define reg_rst_i2cs_lsb 0
+#define    r_reg_top_gpioscli   0xFB32
+#define reg_top_gpioscli_pos 0
+#define reg_top_gpioscli_len 1
+#define reg_top_gpioscli_lsb 0
+#define    p_reg_top_gpiosclo   0xFB33
+#define reg_top_gpiosclo_pos 0
+#define reg_top_gpiosclo_len 1
+#define reg_top_gpiosclo_lsb 0
+#define    p_reg_top_gpiosclen  0xFB34
+#define reg_top_gpiosclen_pos 0
+#define reg_top_gpiosclen_len 1
+#define reg_top_gpiosclen_lsb 0
+#define    p_reg_top_gpiosclon  0xFB35
+#define reg_top_gpiosclon_pos 0
+#define reg_top_gpiosclon_len 1
+#define reg_top_gpiosclon_lsb 0
+#define    r_reg_top_gpiosdai   0xFB36
+#define reg_top_gpiosdai_pos 0
+#define reg_top_gpiosdai_len 1
+#define reg_top_gpiosdai_lsb 0
+#define    p_reg_top_gpiosdao   0xFB37
+#define reg_top_gpiosdao_pos 0
+#define reg_top_gpiosdao_len 1
+#define reg_top_gpiosdao_lsb 0
+#define    p_reg_top_gpiosdaen  0xFB38
+#define reg_top_gpiosdaen_pos 0
+#define reg_top_gpiosdaen_len 1
+#define reg_top_gpiosdaen_lsb 0
+#define    p_reg_top_gpiosdaon  0xFB39
+#define reg_top_gpiosdaon_pos 0
+#define reg_top_gpiosdaon_len 1
+#define reg_top_gpiosdaon_lsb 0
+#define    p_reg_fix_rom_en 0xFB3A
+#define reg_fix_rom_en_pos 0
+#define reg_fix_rom_en_len 1
+#define reg_fix_rom_en_lsb 0
+#define    p_reg_ofsm_bug_addh_0    0xFB3B
+#define reg_ofsm_bug_addh_0_pos 0
+#define reg_ofsm_bug_addh_0_len 8
+#define reg_ofsm_bug_addh_0_lsb 0
+#define    p_reg_ofsm_bug_addl_0    0xFB3C
+#define reg_ofsm_bug_addl_0_pos 0
+#define reg_ofsm_bug_addl_0_len 8
+#define reg_ofsm_bug_addl_0_lsb 0
+#define    p_reg_ofsm_bug_addh_1    0xFB3D
+#define reg_ofsm_bug_addh_1_pos 0
+#define reg_ofsm_bug_addh_1_len 8
+#define reg_ofsm_bug_addh_1_lsb 0
+#define    p_reg_ofsm_bug_addl_1    0xFB3E
+#define reg_ofsm_bug_addl_1_pos 0
+#define reg_ofsm_bug_addl_1_len 8
+#define reg_ofsm_bug_addl_1_lsb 0
+#define    p_reg_ofsm_bug_addh_2    0xFB3F
+#define reg_ofsm_bug_addh_2_pos 0
+#define reg_ofsm_bug_addh_2_len 8
+#define reg_ofsm_bug_addh_2_lsb 0
+#define    p_reg_ofsm_bug_addl_2    0xFB40
+#define reg_ofsm_bug_addl_2_pos 0
+#define reg_ofsm_bug_addl_2_len 8
+#define reg_ofsm_bug_addl_2_lsb 0
+#define    p_reg_ofsm_bug_addh_3    0xFB41
+#define reg_ofsm_bug_addh_3_pos 0
+#define reg_ofsm_bug_addh_3_len 8
+#define reg_ofsm_bug_addh_3_lsb 0
+#define    p_reg_ofsm_bug_addl_3    0xFB42
+#define reg_ofsm_bug_addl_3_pos 0
+#define reg_ofsm_bug_addl_3_len 8
+#define reg_ofsm_bug_addl_3_lsb 0
+#define    p_reg_ofsm_bug_addh_4    0xFB43
+#define reg_ofsm_bug_addh_4_pos 0
+#define reg_ofsm_bug_addh_4_len 8
+#define reg_ofsm_bug_addh_4_lsb 0
+#define    p_reg_ofsm_bug_addl_4    0xFB44
+#define reg_ofsm_bug_addl_4_pos 0
+#define reg_ofsm_bug_addl_4_len 8
+#define reg_ofsm_bug_addl_4_lsb 0
+#define    p_reg_ofsm_bug_addh_5    0xFB45
+#define reg_ofsm_bug_addh_5_pos 0
+#define reg_ofsm_bug_addh_5_len 8
+#define reg_ofsm_bug_addh_5_lsb 0
+#define    p_reg_ofsm_bug_addl_5    0xFB46
+#define reg_ofsm_bug_addl_5_pos 0
+#define reg_ofsm_bug_addl_5_len 8
+#define reg_ofsm_bug_addl_5_lsb 0
+#define    p_reg_ofsm_bug_addh_6    0xFB47
+#define reg_ofsm_bug_addh_6_pos 0
+#define reg_ofsm_bug_addh_6_len 8
+#define reg_ofsm_bug_addh_6_lsb 0
+#define    p_reg_ofsm_bug_addl_6    0xFB48
+#define reg_ofsm_bug_addl_6_pos 0
+#define reg_ofsm_bug_addl_6_len 8
+#define reg_ofsm_bug_addl_6_lsb 0
+#define    p_reg_ofsm_bug_addh_7    0xFB49
+#define reg_ofsm_bug_addh_7_pos 0
+#define reg_ofsm_bug_addh_7_len 8
+#define reg_ofsm_bug_addh_7_lsb 0
+#define    p_reg_ofsm_bug_addl_7    0xFB4A
+#define reg_ofsm_bug_addl_7_pos 0
+#define reg_ofsm_bug_addl_7_len 8
+#define reg_ofsm_bug_addl_7_lsb 0
+#define    p_reg_ofsm_bug_addh_8    0xFB4B
+#define reg_ofsm_bug_addh_8_pos 0
+#define reg_ofsm_bug_addh_8_len 8
+#define reg_ofsm_bug_addh_8_lsb 0
+#define    p_reg_ofsm_bug_addl_8    0xFB4C
+#define reg_ofsm_bug_addl_8_pos 0
+#define reg_ofsm_bug_addl_8_len 8
+#define reg_ofsm_bug_addl_8_lsb 0
+#define    p_reg_ofsm_bug_addh_9    0xFB4D
+#define reg_ofsm_bug_addh_9_pos 0
+#define reg_ofsm_bug_addh_9_len 8
+#define reg_ofsm_bug_addh_9_lsb 0
+#define    p_reg_ofsm_bug_addl_9    0xFB4E
+#define reg_ofsm_bug_addl_9_pos 0
+#define reg_ofsm_bug_addl_9_len 8
+#define reg_ofsm_bug_addl_9_lsb 0
+#define    p_reg_ofsm_bug_addh_10   0xFB4F
+#define reg_ofsm_bug_addh_10_pos 0
+#define reg_ofsm_bug_addh_10_len 8
+#define reg_ofsm_bug_addh_10_lsb 0
+#define    p_reg_ofsm_bug_addl_10   0xFB50
+#define reg_ofsm_bug_addl_10_pos 0
+#define reg_ofsm_bug_addl_10_len 8
+#define reg_ofsm_bug_addl_10_lsb 0
+#define    p_reg_ofsm_bug_addh_11   0xFB51
+#define reg_ofsm_bug_addh_11_pos 0
+#define reg_ofsm_bug_addh_11_len 8
+#define reg_ofsm_bug_addh_11_lsb 0
+#define    p_reg_ofsm_bug_addl_11   0xFB52
+#define reg_ofsm_bug_addl_11_pos 0
+#define reg_ofsm_bug_addl_11_len 8
+#define reg_ofsm_bug_addl_11_lsb 0
+#define    p_reg_ofsm_bug_addh_12   0xFB53
+#define reg_ofsm_bug_addh_12_pos 0
+#define reg_ofsm_bug_addh_12_len 8
+#define reg_ofsm_bug_addh_12_lsb 0
+#define    p_reg_ofsm_bug_addl_12   0xFB54
+#define reg_ofsm_bug_addl_12_pos 0
+#define reg_ofsm_bug_addl_12_len 8
+#define reg_ofsm_bug_addl_12_lsb 0
+#define    p_reg_ofsm_bug_addh_13   0xFB55
+#define reg_ofsm_bug_addh_13_pos 0
+#define reg_ofsm_bug_addh_13_len 8
+#define reg_ofsm_bug_addh_13_lsb 0
+#define    p_reg_ofsm_bug_addl_13   0xFB56
+#define reg_ofsm_bug_addl_13_pos 0
+#define reg_ofsm_bug_addl_13_len 8
+#define reg_ofsm_bug_addl_13_lsb 0
+#define    p_reg_ofsm_bug_addh_14   0xFB57
+#define reg_ofsm_bug_addh_14_pos 0
+#define reg_ofsm_bug_addh_14_len 8
+#define reg_ofsm_bug_addh_14_lsb 0
+#define    p_reg_ofsm_bug_addl_14   0xFB58
+#define reg_ofsm_bug_addl_14_pos 0
+#define reg_ofsm_bug_addl_14_len 8
+#define reg_ofsm_bug_addl_14_lsb 0
+#define    p_reg_ofsm_bug_addh_15   0xFB59
+#define reg_ofsm_bug_addh_15_pos 0
+#define reg_ofsm_bug_addh_15_len 8
+#define reg_ofsm_bug_addh_15_lsb 0
+#define    p_reg_ofsm_bug_addl_15   0xFB5A
+#define reg_ofsm_bug_addl_15_pos 0
+#define reg_ofsm_bug_addl_15_len 8
+#define reg_ofsm_bug_addl_15_lsb 0
+#define    p_reg_ofsm_jmp_addh_0    0xFB5B
+#define reg_ofsm_jmp_addh_0_pos 0
+#define reg_ofsm_jmp_addh_0_len 8
+#define reg_ofsm_jmp_addh_0_lsb 0
+#define    p_reg_ofsm_jmp_addl_0    0xFB5C
+#define reg_ofsm_jmp_addl_0_pos 0
+#define reg_ofsm_jmp_addl_0_len 8
+#define reg_ofsm_jmp_addl_0_lsb 0
+#define    p_reg_ofsm_jmp_addh_1    0xFB5D
+#define reg_ofsm_jmp_addh_1_pos 0
+#define reg_ofsm_jmp_addh_1_len 8
+#define reg_ofsm_jmp_addh_1_lsb 0
+#define    p_reg_ofsm_jmp_addl_1    0xFB5E
+#define reg_ofsm_jmp_addl_1_pos 0
+#define reg_ofsm_jmp_addl_1_len 8
+#define reg_ofsm_jmp_addl_1_lsb 0
+#define    p_reg_ofsm_jmp_addh_2    0xFB5F
+#define reg_ofsm_jmp_addh_2_pos 0
+#define reg_ofsm_jmp_addh_2_len 8
+#define reg_ofsm_jmp_addh_2_lsb 0
+#define    p_reg_ofsm_jmp_addl_2    0xFB60
+#define reg_ofsm_jmp_addl_2_pos 0
+#define reg_ofsm_jmp_addl_2_len 8
+#define reg_ofsm_jmp_addl_2_lsb 0
+#define    p_reg_ofsm_jmp_addh_3    0xFB61
+#define reg_ofsm_jmp_addh_3_pos 0
+#define reg_ofsm_jmp_addh_3_len 8
+#define reg_ofsm_jmp_addh_3_lsb 0
+#define    p_reg_ofsm_jmp_addl_3    0xFB62
+#define reg_ofsm_jmp_addl_3_pos 0
+#define reg_ofsm_jmp_addl_3_len 8
+#define reg_ofsm_jmp_addl_3_lsb 0
+#define    p_reg_ofsm_jmp_addh_4    0xFB63
+#define reg_ofsm_jmp_addh_4_pos 0
+#define reg_ofsm_jmp_addh_4_len 8
+#define reg_ofsm_jmp_addh_4_lsb 0
+#define    p_reg_ofsm_jmp_addl_4    0xFB64
+#define reg_ofsm_jmp_addl_4_pos 0
+#define reg_ofsm_jmp_addl_4_len 8
+#define reg_ofsm_jmp_addl_4_lsb 0
+#define    p_reg_ofsm_jmp_addh_5    0xFB65
+#define reg_ofsm_jmp_addh_5_pos 0
+#define reg_ofsm_jmp_addh_5_len 8
+#define reg_ofsm_jmp_addh_5_lsb 0
+#define    p_reg_ofsm_jmp_addl_5    0xFB66
+#define reg_ofsm_jmp_addl_5_pos 0
+#define reg_ofsm_jmp_addl_5_len 8
+#define reg_ofsm_jmp_addl_5_lsb 0
+#define    p_reg_ofsm_jmp_addh_6    0xFB67
+#define reg_ofsm_jmp_addh_6_pos 0
+#define reg_ofsm_jmp_addh_6_len 8
+#define reg_ofsm_jmp_addh_6_lsb 0
+#define    p_reg_ofsm_jmp_addl_6    0xFB68
+#define reg_ofsm_jmp_addl_6_pos 0
+#define reg_ofsm_jmp_addl_6_len 8
+#define reg_ofsm_jmp_addl_6_lsb 0
+#define    p_reg_ofsm_jmp_addh_7    0xFB69
+#define reg_ofsm_jmp_addh_7_pos 0
+#define reg_ofsm_jmp_addh_7_len 8
+#define reg_ofsm_jmp_addh_7_lsb 0
+#define    p_reg_ofsm_jmp_addl_7    0xFB6A
+#define reg_ofsm_jmp_addl_7_pos 0
+#define reg_ofsm_jmp_addl_7_len 8
+#define reg_ofsm_jmp_addl_7_lsb 0
+#define    p_reg_ofsm_jmp_addh_8    0xFB6B
+#define reg_ofsm_jmp_addh_8_pos 0
+#define reg_ofsm_jmp_addh_8_len 8
+#define reg_ofsm_jmp_addh_8_lsb 0
+#define    p_reg_ofsm_jmp_addl_8    0xFB6C
+#define reg_ofsm_jmp_addl_8_pos 0
+#define reg_ofsm_jmp_addl_8_len 8
+#define reg_ofsm_jmp_addl_8_lsb 0
+#define    p_reg_ofsm_jmp_addh_9    0xFB6D
+#define reg_ofsm_jmp_addh_9_pos 0
+#define reg_ofsm_jmp_addh_9_len 8
+#define reg_ofsm_jmp_addh_9_lsb 0
+#define    p_reg_ofsm_jmp_addl_9    0xFB6E
+#define reg_ofsm_jmp_addl_9_pos 0
+#define reg_ofsm_jmp_addl_9_len 8
+#define reg_ofsm_jmp_addl_9_lsb 0
+#define    p_reg_ofsm_jmp_addh_10   0xFB6F
+#define reg_ofsm_jmp_addh_10_pos 0
+#define reg_ofsm_jmp_addh_10_len 8
+#define reg_ofsm_jmp_addh_10_lsb 0
+#define    p_reg_ofsm_jmp_addl_10   0xFB70
+#define reg_ofsm_jmp_addl_10_pos 0
+#define reg_ofsm_jmp_addl_10_len 8
+#define reg_ofsm_jmp_addl_10_lsb 0
+#define    p_reg_ofsm_jmp_addh_11   0xFB71
+#define reg_ofsm_jmp_addh_11_pos 0
+#define reg_ofsm_jmp_addh_11_len 8
+#define reg_ofsm_jmp_addh_11_lsb 0
+#define    p_reg_ofsm_jmp_addl_11   0xFB72
+#define reg_ofsm_jmp_addl_11_pos 0
+#define reg_ofsm_jmp_addl_11_len 8
+#define reg_ofsm_jmp_addl_11_lsb 0
+#define    p_reg_ofsm_jmp_addh_12   0xFB73
+#define reg_ofsm_jmp_addh_12_pos 0
+#define reg_ofsm_jmp_addh_12_len 8
+#define reg_ofsm_jmp_addh_12_lsb 0
+#define    p_reg_ofsm_jmp_addl_12   0xFB74
+#define reg_ofsm_jmp_addl_12_pos 0
+#define reg_ofsm_jmp_addl_12_len 8
+#define reg_ofsm_jmp_addl_12_lsb 0
+#define    p_reg_ofsm_jmp_addh_13   0xFB75
+#define reg_ofsm_jmp_addh_13_pos 0
+#define reg_ofsm_jmp_addh_13_len 8
+#define reg_ofsm_jmp_addh_13_lsb 0
+#define    p_reg_ofsm_jmp_addl_13   0xFB76
+#define reg_ofsm_jmp_addl_13_pos 0
+#define reg_ofsm_jmp_addl_13_len 8
+#define reg_ofsm_jmp_addl_13_lsb 0
+#define    p_reg_ofsm_jmp_addh_14   0xFB77
+#define reg_ofsm_jmp_addh_14_pos 0
+#define reg_ofsm_jmp_addh_14_len 8
+#define reg_ofsm_jmp_addh_14_lsb 0
+#define    p_reg_ofsm_jmp_addl_14   0xFB78
+#define reg_ofsm_jmp_addl_14_pos 0
+#define reg_ofsm_jmp_addl_14_len 8
+#define reg_ofsm_jmp_addl_14_lsb 0
+#define    p_reg_ofsm_jmp_addh_15   0xFB79
+#define reg_ofsm_jmp_addh_15_pos 0
+#define reg_ofsm_jmp_addh_15_len 8
+#define reg_ofsm_jmp_addh_15_lsb 0
+#define    p_reg_ofsm_jmp_addl_15   0xFB7A
+#define reg_ofsm_jmp_addl_15_pos 0
+#define reg_ofsm_jmp_addl_15_len 8
+#define reg_ofsm_jmp_addl_15_lsb 0
+#define    p_reg_sw_mon51   0xFB7B
+#define reg_sw_mon51_pos 0
+#define reg_sw_mon51_len 7
+#define reg_sw_mon51_lsb 0
+#define    p_reg_ofdm_mon51_flag    0xFB7C
+#define reg_ofdm_mon51_flag_pos 0
+#define reg_ofdm_mon51_flag_len 1
+#define reg_ofdm_mon51_flag_lsb 0
+#define    p_reg_ofdm_force_mon51   0xFB7D
+#define reg_ofdm_force_mon51_pos 0
+#define reg_ofdm_force_mon51_len 1
+#define reg_ofdm_force_mon51_lsb 0
+#define    p_reg_ofdm_which_cpu 0xFB7E
+#define reg_ofdm_which_cpu_pos 0
+#define reg_ofdm_which_cpu_len 1
+#define reg_ofdm_which_cpu_lsb 0
+#define    p_reg_ofdm_code_ready    0xFB7F
+#define reg_ofdm_code_ready_pos 0
+#define reg_ofdm_code_ready_len 1
+#define reg_ofdm_code_ready_lsb 0
+#define    p_reg_ofdm_mailbox_wend  0xFB80
+#define reg_ofdm_mailbox_wend_pos 0
+#define reg_ofdm_mailbox_wend_len 1
+#define reg_ofdm_mailbox_wend_lsb 0
+#define    r_reg_fast_slow_train    0xFB81
+#define reg_fast_slow_train_pos 0
+#define reg_fast_slow_train_len 1
+#define reg_fast_slow_train_lsb 0
+#define    p_reg_ofdm_mailbox_wptr  0xFB82
+#define reg_ofdm_mailbox_wptr_pos 0
+#define reg_ofdm_mailbox_wptr_len 8
+#define reg_ofdm_mailbox_wptr_lsb 0
+#define    p_reg_ofdm_mailbox_int   0xFB86
+#define reg_ofdm_mailbox_int_pos 0
+#define reg_ofdm_mailbox_int_len 1
+#define reg_ofdm_mailbox_int_lsb 0
+#define    p_reg_ofdm_lnk2ofdm_int  0xFB87
+#define reg_ofdm_lnk2ofdm_int_pos 0
+#define reg_ofdm_lnk2ofdm_int_len 1
+#define reg_ofdm_lnk2ofdm_int_lsb 0
+#define    p_reg_ofdm_ofdm2lnk_int  0xFB88
+#define reg_ofdm_ofdm2lnk_int_pos 0
+#define reg_ofdm_ofdm2lnk_int_len 1
+#define reg_ofdm_ofdm2lnk_int_lsb 0
+#define    r_reg_load_ofdm_reg  0xFB8F
+#define reg_load_ofdm_reg_pos 0
+#define reg_load_ofdm_reg_len 1
+#define reg_load_ofdm_reg_lsb 0
+#define    p_reg_lnk_mbx_rd_length_7_0  0xFB90
+#define reg_lnk_mbx_rd_length_7_0_pos 0
+#define reg_lnk_mbx_rd_length_7_0_len 8
+#define reg_lnk_mbx_rd_length_7_0_lsb 0
+#define    p_reg_lnk_mbx_rd_length_15_8 0xFB91
+#define reg_lnk_mbx_rd_length_15_8_pos 0
+#define reg_lnk_mbx_rd_length_15_8_len 8
+#define reg_lnk_mbx_rd_length_15_8_lsb 8
+#define    p_reg_lnk_mbx_rd_length_17_16    0xFB92
+#define reg_lnk_mbx_rd_length_17_16_pos 0
+#define reg_lnk_mbx_rd_length_17_16_len 2
+#define reg_lnk_mbx_rd_length_17_16_lsb 16
+#define    p_reg_lnk_rd_data_sel    0xFB93
+#define reg_lnk_rd_data_sel_pos 0
+#define reg_lnk_rd_data_sel_len 2
+#define reg_lnk_rd_data_sel_lsb 0
+#define    p_reg_ofdm2lnk_data_7_0  0xFB96
+#define reg_ofdm2lnk_data_7_0_pos 0
+#define reg_ofdm2lnk_data_7_0_len 8
+#define reg_ofdm2lnk_data_7_0_lsb 0
+#define    p_reg_ofdm2lnk_data_15_8 0xFB97
+#define reg_ofdm2lnk_data_15_8_pos 0
+#define reg_ofdm2lnk_data_15_8_len 8
+#define reg_ofdm2lnk_data_15_8_lsb 8
+#define    p_reg_ofdm2lnk_data_23_16    0xFB98
+#define reg_ofdm2lnk_data_23_16_pos 0
+#define reg_ofdm2lnk_data_23_16_len 8
+#define reg_ofdm2lnk_data_23_16_lsb 16
+#define    p_reg_ofdm2lnk_data_31_24    0xFB99
+#define reg_ofdm2lnk_data_31_24_pos 0
+#define reg_ofdm2lnk_data_31_24_len 8
+#define reg_ofdm2lnk_data_31_24_lsb 24
+#define    p_reg_ofdm2lnk_data_39_32    0xFB9A
+#define reg_ofdm2lnk_data_39_32_pos 0
+#define reg_ofdm2lnk_data_39_32_len 8
+#define reg_ofdm2lnk_data_39_32_lsb 32
+#define    p_reg_ofdm2lnk_data_47_40    0xFB9B
+#define reg_ofdm2lnk_data_47_40_pos 0
+#define reg_ofdm2lnk_data_47_40_len 8
+#define reg_ofdm2lnk_data_47_40_lsb 40
+#define    p_reg_ofdm2lnk_data_55_48    0xFB9C
+#define reg_ofdm2lnk_data_55_48_pos 0
+#define reg_ofdm2lnk_data_55_48_len 8
+#define reg_ofdm2lnk_data_55_48_lsb 48
+#define    p_reg_ofdm2lnk_data_63_56    0xFB9D
+#define reg_ofdm2lnk_data_63_56_pos 0
+#define reg_ofdm2lnk_data_63_56_len 8
+#define reg_ofdm2lnk_data_63_56_lsb 56
+#define    p_reg_lnktoofdm_data_7_0 0xFB9E
+#define reg_lnktoofdm_data_7_0_pos 0
+#define reg_lnktoofdm_data_7_0_len 8
+#define reg_lnktoofdm_data_7_0_lsb 0
+#define    p_reg_lnktoofdm_data_15_8    0xFB9F
+#define reg_lnktoofdm_data_15_8_pos 0
+#define reg_lnktoofdm_data_15_8_len 8
+#define reg_lnktoofdm_data_15_8_lsb 8
+#define    p_reg_lnktoofdm_data_23_16   0xFBA0
+#define reg_lnktoofdm_data_23_16_pos 0
+#define reg_lnktoofdm_data_23_16_len 8
+#define reg_lnktoofdm_data_23_16_lsb 16
+#define    p_reg_lnktoofdm_data_31_24   0xFBA1
+#define reg_lnktoofdm_data_31_24_pos 0
+#define reg_lnktoofdm_data_31_24_len 8
+#define reg_lnktoofdm_data_31_24_lsb 24
+#define    p_reg_lnktoofdm_data_39_32   0xFBA2
+#define reg_lnktoofdm_data_39_32_pos 0
+#define reg_lnktoofdm_data_39_32_len 8
+#define reg_lnktoofdm_data_39_32_lsb 32
+#define    p_reg_lnktoofdm_data_47_40   0xFBA3
+#define reg_lnktoofdm_data_47_40_pos 0
+#define reg_lnktoofdm_data_47_40_len 8
+#define reg_lnktoofdm_data_47_40_lsb 40
+#define    p_reg_lnktoofdm_data_55_48   0xFBA4
+#define reg_lnktoofdm_data_55_48_pos 0
+#define reg_lnktoofdm_data_55_48_len 8
+#define reg_lnktoofdm_data_55_48_lsb 48
+#define    p_reg_lnktoofdm_data_63_56   0xFBA5
+#define reg_lnktoofdm_data_63_56_pos 0
+#define reg_lnktoofdm_data_63_56_len 8
+#define reg_lnktoofdm_data_63_56_lsb 56
+#define    p_reg_dbgif32_sel    0xFBA6
+#define reg_dbgif32_sel_pos 0
+#define reg_dbgif32_sel_len 2
+#define reg_dbgif32_sel_lsb 0
+#define    p_reg_dyn1_clk   0xFBA7
+#define reg_dyn1_clk_pos 0
+#define reg_dyn1_clk_len 1
+#define reg_dyn1_clk_lsb 0
+#define    p_reg_dyn0_clk   0xFBA8
+#define reg_dyn0_clk_pos 0
+#define reg_dyn0_clk_len 1
+#define reg_dyn0_clk_lsb 0
+#define    p_reg_free_clk   0xFBA9
+#define reg_free_clk_pos 0
+#define reg_free_clk_len 1
+#define reg_free_clk_lsb 0
+#define    p_reg_ofdm_stick_mem_end_7_0 0xFBAD
+#define reg_ofdm_stick_mem_end_7_0_pos 0
+#define reg_ofdm_stick_mem_end_7_0_len 8
+#define reg_ofdm_stick_mem_end_7_0_lsb 0
+#define    p_reg_ofdm_stick_mem_end_15_8    0xFBAE
+#define reg_ofdm_stick_mem_end_15_8_pos 0
+#define reg_ofdm_stick_mem_end_15_8_len 8
+#define reg_ofdm_stick_mem_end_15_8_lsb 8
+#define    p_reg_ofdm_cpu_reset 0xFBAF
+#define reg_ofdm_cpu_reset_pos 0
+#define reg_ofdm_cpu_reset_len 1
+#define reg_ofdm_cpu_reset_lsb 0
+#define    p_reg_ofdm_bank_float_en 0xFBB0
+#define reg_ofdm_bank_float_en_pos 0
+#define reg_ofdm_bank_float_en_len 1
+#define reg_ofdm_bank_float_en_lsb 0
+#define    p_reg_ofdm_bank_float_start  0xFBB1
+#define reg_ofdm_bank_float_start_pos 0
+#define reg_ofdm_bank_float_start_len 8
+#define reg_ofdm_bank_float_start_lsb 0
+#define    p_reg_ofdm_bank_float_stop   0xFBB2
+#define reg_ofdm_bank_float_stop_pos 0
+#define reg_ofdm_bank_float_stop_len 8
+#define reg_ofdm_bank_float_stop_lsb 0
+#define    r_ofsm_bond0_i   0xFBB3
+#define ofsm_bond0_i_pos 0
+#define ofsm_bond0_i_len 1
+#define ofsm_bond0_i_lsb 0
+#define    r_ofsm_bond1_i   0xFBB4
+#define ofsm_bond1_i_pos 0
+#define ofsm_bond1_i_len 1
+#define ofsm_bond1_i_lsb 0
+#define    r_io_mux_pwron_clk_strap 0xD800
+#define io_mux_pwron_clk_strap_pos 0
+#define io_mux_pwron_clk_strap_len 4
+#define io_mux_pwron_clk_strap_lsb 0
+#define    r_io_mux_pwron_mode_strap    0xD801
+#define io_mux_pwron_mode_strap_pos 0
+#define io_mux_pwron_mode_strap_len 4
+#define io_mux_pwron_mode_strap_lsb 0
+#define    r_io_mux_pwron_hosta 0xD802
+#define io_mux_pwron_hosta_pos 0
+#define io_mux_pwron_hosta_len 1
+#define io_mux_pwron_hosta_lsb 0
+#define    r_reg_top_revid  0xD803
+#define reg_top_revid_pos 0
+#define reg_top_revid_len 4
+#define reg_top_revid_lsb 0
+#define    r_io_mux_bond0_i 0xD804
+#define io_mux_bond0_i_pos 0
+#define io_mux_bond0_i_len 1
+#define io_mux_bond0_i_lsb 0
+#define    r_io_mux_bondu0_i    0xD805
+#define io_mux_bondu0_i_pos 0
+#define io_mux_bondu0_i_len 1
+#define io_mux_bondu0_i_lsb 0
+#define    p_reg_ofsm_suspend   0xD806
+#define reg_ofsm_suspend_pos 0
+#define reg_ofsm_suspend_len 1
+#define reg_ofsm_suspend_lsb 0
+#define    p_reg_tslice_off 0xD807
+#define reg_tslice_off_pos 0
+#define reg_tslice_off_len 1
+#define reg_tslice_off_lsb 0
+#define    p_io_mux_wake_int    0xD808
+#define io_mux_wake_int_pos 0
+#define io_mux_wake_int_len 1
+#define io_mux_wake_int_lsb 0
+#define    p_reg_top_pwrdw_hwen 0xD809
+#define reg_top_pwrdw_hwen_pos 0
+#define reg_top_pwrdw_hwen_len 1
+#define reg_top_pwrdw_hwen_lsb 0
+#define    p_reg_top_pwrdw_inv  0xD80A
+#define reg_top_pwrdw_inv_pos 0
+#define reg_top_pwrdw_inv_len 1
+#define reg_top_pwrdw_inv_lsb 0
+#define    p_reg_top_pwrdw  0xD80B
+#define reg_top_pwrdw_pos 0
+#define reg_top_pwrdw_len 1
+#define reg_top_pwrdw_lsb 0
+#define    p_io_mux_wake_int_en 0xD80C
+#define io_mux_wake_int_en_pos 0
+#define io_mux_wake_int_en_len 1
+#define io_mux_wake_int_en_lsb 0
+#define    p_io_mux_pwrdw_int   0xD80D
+#define io_mux_pwrdw_int_pos 0
+#define io_mux_pwrdw_int_len 1
+#define io_mux_pwrdw_int_lsb 0
+#define    p_reg_top_adcdly 0xD80E
+#define reg_top_adcdly_pos 0
+#define reg_top_adcdly_len 2
+#define reg_top_adcdly_lsb 0
+#define    p_reg_top_debug  0xD80F
+#define reg_top_debug_pos 0
+#define reg_top_debug_len 1
+#define reg_top_debug_lsb 0
+#define    p_reg_top_pcout  0xD810
+#define reg_top_pcout_pos 0
+#define reg_top_pcout_len 1
+#define reg_top_pcout_lsb 0
+#define    p_reg_top_rs232  0xD811
+#define reg_top_rs232_pos 0
+#define reg_top_rs232_len 1
+#define reg_top_rs232_lsb 0
+#define    p_reg_iqmode 0xD812
+#define reg_iqmode_pos 0
+#define reg_iqmode_len 1
+#define reg_iqmode_lsb 0
+#define    p_reg_top_rstfd  0xD813
+#define reg_top_rstfd_pos 0
+#define reg_top_rstfd_len 1
+#define reg_top_rstfd_lsb 0
+#define    p_reg_sdio_clksel    0xD814
+#define reg_sdio_clksel_pos 0
+#define reg_sdio_clksel_len 1
+#define reg_sdio_clksel_lsb 0
+#define    p_reg_utmi_clksel    0xD815
+#define reg_utmi_clksel_pos 0
+#define reg_utmi_clksel_len 8
+#define reg_utmi_clksel_lsb 0
+#define    p_reg_top_suscnt 0xD816
+#define reg_top_suscnt_pos 0
+#define reg_top_suscnt_len 2
+#define reg_top_suscnt_lsb 0
+#define    p_reg_top_dist2f 0xD817
+#define reg_top_dist2f_pos 0
+#define reg_top_dist2f_len 1
+#define reg_top_dist2f_lsb 0
+#define    p_reg_top_extusb 0xD818
+#define reg_top_extusb_pos 0
+#define reg_top_extusb_len 1
+#define reg_top_extusb_lsb 0
+#define    p_reg_top_adcfifo    0xD819
+#define reg_top_adcfifo_pos 0
+#define reg_top_adcfifo_len 1
+#define reg_top_adcfifo_lsb 0
+#define    p_reg_top_clkoen 0xD81A
+#define reg_top_clkoen_pos 0
+#define reg_top_clkoen_len 1
+#define reg_top_clkoen_lsb 0
+#define    p_reg_top_stpck  0xD81B
+#define reg_top_stpck_pos 0
+#define reg_top_stpck_len 1
+#define reg_top_stpck_lsb 0
+#define    p_reg_top_freeck 0xD81C
+#define reg_top_freeck_pos 0
+#define reg_top_freeck_len 1
+#define reg_top_freeck_lsb 0
+#define    p_reg_top_dio_sel    0xD81D
+#define reg_top_dio_sel_pos 0
+#define reg_top_dio_sel_len 1
+#define reg_top_dio_sel_lsb 0
+#define    p_reg_top_int_en 0xD81E
+#define reg_top_int_en_pos 0
+#define reg_top_int_en_len 1
+#define reg_top_int_en_lsb 0
+#define    p_reg_top_int_inv    0xD81F
+#define reg_top_int_inv_pos 0
+#define reg_top_int_inv_len 1
+#define reg_top_int_inv_lsb 0
+#define    p_reg_tsip_clk_inv   0xD820
+#define reg_tsip_clk_inv_pos 0
+#define reg_tsip_clk_inv_len 1
+#define reg_tsip_clk_inv_lsb 0
+#define    p_reg_ts_clk_inv 0xD821
+#define reg_ts_clk_inv_pos 0
+#define reg_ts_clk_inv_len 1
+#define reg_ts_clk_inv_lsb 0
+#define    p_reg_ts_hybrid  0xD822
+#define reg_ts_hybrid_pos 0
+#define reg_ts_hybrid_len 1
+#define reg_ts_hybrid_lsb 0
+#define    p_reg_ccir_sel   0xD823
+#define reg_ccir_sel_pos 0
+#define reg_ccir_sel_len 4
+#define reg_ccir_sel_lsb 0
+#define    p_reg_top_sys_gate   0xD824
+#define reg_top_sys_gate_pos 0
+#define reg_top_sys_gate_len 1
+#define reg_top_sys_gate_lsb 0
+#define    p_reg_top_padpu  0xD825
+#define reg_top_padpu_pos 0
+#define reg_top_padpu_len 1
+#define reg_top_padpu_lsb 0
+#define    p_reg_top_padpd  0xD826
+#define reg_top_padpd_pos 0
+#define reg_top_padpd_len 1
+#define reg_top_padpd_lsb 0
+#define    p_reg_top_padodpu    0xD827
+#define reg_top_padodpu_pos 0
+#define reg_top_padodpu_len 1
+#define reg_top_padodpu_lsb 0
+#define    p_reg_top_thirdodpu  0xD828
+#define reg_top_thirdodpu_pos 0
+#define reg_top_thirdodpu_len 1
+#define reg_top_thirdodpu_lsb 0
+#define    p_reg_top_agc_od 0xD829
+#define reg_top_agc_od_pos 0
+#define reg_top_agc_od_len 1
+#define reg_top_agc_od_lsb 0
+#define    p_reg_top_padmpdr2   0xD82A
+#define reg_top_padmpdr2_pos 0
+#define reg_top_padmpdr2_len 1
+#define reg_top_padmpdr2_lsb 0
+#define    p_reg_top_padmpdr4   0xD82B
+#define reg_top_padmpdr4_pos 0
+#define reg_top_padmpdr4_len 1
+#define reg_top_padmpdr4_lsb 0
+#define    p_reg_top_padmpdr8   0xD82C
+#define reg_top_padmpdr8_pos 0
+#define reg_top_padmpdr8_len 1
+#define reg_top_padmpdr8_lsb 0
+#define    p_reg_top_padmpdrsr  0xD82D
+#define reg_top_padmpdrsr_pos 0
+#define reg_top_padmpdrsr_len 1
+#define reg_top_padmpdrsr_lsb 0
+#define    p_reg_top_padmppu    0xD82E
+#define reg_top_padmppu_pos 0
+#define reg_top_padmppu_len 1
+#define reg_top_padmppu_lsb 0
+#define    p_reg_top_padmppd    0xD82F
+#define reg_top_padmppd_pos 0
+#define reg_top_padmppd_len 1
+#define reg_top_padmppd_lsb 0
+#define    p_reg_top_padmiscdr2 0xD830
+#define reg_top_padmiscdr2_pos 0
+#define reg_top_padmiscdr2_len 1
+#define reg_top_padmiscdr2_lsb 0
+#define    p_reg_top_padmiscdr4 0xD831
+#define reg_top_padmiscdr4_pos 0
+#define reg_top_padmiscdr4_len 1
+#define reg_top_padmiscdr4_lsb 0
+#define    p_reg_top_padmiscdr8 0xD832
+#define reg_top_padmiscdr8_pos 0
+#define reg_top_padmiscdr8_len 1
+#define reg_top_padmiscdr8_lsb 0
+#define    p_reg_top_padmiscdrsr    0xD833
+#define reg_top_padmiscdrsr_pos 0
+#define reg_top_padmiscdrsr_len 1
+#define reg_top_padmiscdrsr_lsb 0
+#define    p_reg_top_padmiscpu  0xD834
+#define reg_top_padmiscpu_pos 0
+#define reg_top_padmiscpu_len 1
+#define reg_top_padmiscpu_lsb 0
+#define    p_reg_top_padmiscpd  0xD835
+#define reg_top_padmiscpd_pos 0
+#define reg_top_padmiscpd_len 1
+#define reg_top_padmiscpd_lsb 0
+#define    p_reg_host_b0_smt    0xD836
+#define reg_host_b0_smt_pos 0
+#define reg_host_b0_smt_len 1
+#define reg_host_b0_smt_lsb 0
+#define    p_reg_host_b1_smt    0xD837
+#define reg_host_b1_smt_pos 0
+#define reg_host_b1_smt_len 1
+#define reg_host_b1_smt_lsb 0
+#define    p_reg_host_b2_smt    0xD838
+#define reg_host_b2_smt_pos 0
+#define reg_host_b2_smt_len 1
+#define reg_host_b2_smt_lsb 0
+#define    p_reg_host_b3_smt    0xD839
+#define reg_host_b3_smt_pos 0
+#define reg_host_b3_smt_len 1
+#define reg_host_b3_smt_lsb 0
+#define    p_reg_host_b4_smt    0xD83A
+#define reg_host_b4_smt_pos 0
+#define reg_host_b4_smt_len 1
+#define reg_host_b4_smt_lsb 0
+#define    p_reg_host_b5_smt    0xD83B
+#define reg_host_b5_smt_pos 0
+#define reg_host_b5_smt_len 1
+#define reg_host_b5_smt_lsb 0
+#define    p_reg_host_b6_smt    0xD83C
+#define reg_host_b6_smt_pos 0
+#define reg_host_b6_smt_len 1
+#define reg_host_b6_smt_lsb 0
+#define    p_reg_host_b7_smt    0xD83D
+#define reg_host_b7_smt_pos 0
+#define reg_host_b7_smt_len 1
+#define reg_host_b7_smt_lsb 0
+#define    p_reg_host_b8_smt    0xD83E
+#define reg_host_b8_smt_pos 0
+#define reg_host_b8_smt_len 1
+#define reg_host_b8_smt_lsb 0
+#define    p_reg_host_b9_smt    0xD83F
+#define reg_host_b9_smt_pos 0
+#define reg_host_b9_smt_len 1
+#define reg_host_b9_smt_lsb 0
+#define    p_reg_host_b10_smt   0xD840
+#define reg_host_b10_smt_pos 0
+#define reg_host_b10_smt_len 1
+#define reg_host_b10_smt_lsb 0
+#define    p_reg_host_b11_smt   0xD841
+#define reg_host_b11_smt_pos 0
+#define reg_host_b11_smt_len 1
+#define reg_host_b11_smt_lsb 0
+#define    p_reg_host_a0_smt    0xD842
+#define reg_host_a0_smt_pos 0
+#define reg_host_a0_smt_len 1
+#define reg_host_a0_smt_lsb 0
+#define    p_reg_host_a1_smt    0xD843
+#define reg_host_a1_smt_pos 0
+#define reg_host_a1_smt_len 1
+#define reg_host_a1_smt_lsb 0
+#define    p_reg_host_a2_smt    0xD844
+#define reg_host_a2_smt_pos 0
+#define reg_host_a2_smt_len 1
+#define reg_host_a2_smt_lsb 0
+#define    p_reg_host_a3_smt    0xD845
+#define reg_host_a3_smt_pos 0
+#define reg_host_a3_smt_len 1
+#define reg_host_a3_smt_lsb 0
+#define    p_reg_host_a4_smt    0xD846
+#define reg_host_a4_smt_pos 0
+#define reg_host_a4_smt_len 1
+#define reg_host_a4_smt_lsb 0
+#define    p_reg_host_a5_smt    0xD847
+#define reg_host_a5_smt_pos 0
+#define reg_host_a5_smt_len 1
+#define reg_host_a5_smt_lsb 0
+#define    p_reg_host_a6_smt    0xD848
+#define reg_host_a6_smt_pos 0
+#define reg_host_a6_smt_len 1
+#define reg_host_a6_smt_lsb 0
+#define    p_reg_host_a7_smt    0xD849
+#define reg_host_a7_smt_pos 0
+#define reg_host_a7_smt_len 1
+#define reg_host_a7_smt_lsb 0
+#define    p_reg_host_a8_smt    0xD84A
+#define reg_host_a8_smt_pos 0
+#define reg_host_a8_smt_len 1
+#define reg_host_a8_smt_lsb 0
+#define    p_reg_host_a9_smt    0xD84B
+#define reg_host_a9_smt_pos 0
+#define reg_host_a9_smt_len 1
+#define reg_host_a9_smt_lsb 0
+#define    p_reg_host_a10_smt   0xD84C
+#define reg_host_a10_smt_pos 0
+#define reg_host_a10_smt_len 1
+#define reg_host_a10_smt_lsb 0
+#define    p_reg_host_a11_smt   0xD84D
+#define reg_host_a11_smt_pos 0
+#define reg_host_a11_smt_len 1
+#define reg_host_a11_smt_lsb 0
+#define    p_reg_testmode_pds   0xD84E
+#define reg_testmode_pds_pos 0
+#define reg_testmode_pds_len 3
+#define reg_testmode_pds_lsb 0
+#define    p_reg_debug31_pds    0xD84F
+#define reg_debug31_pds_pos 0
+#define reg_debug31_pds_len 3
+#define reg_debug31_pds_lsb 0
+#define    p_reg_debug30_pds    0xD850
+#define reg_debug30_pds_pos 0
+#define reg_debug30_pds_len 3
+#define reg_debug30_pds_lsb 0
+#define    p_reg_debug29_pds    0xD851
+#define reg_debug29_pds_pos 0
+#define reg_debug29_pds_len 3
+#define reg_debug29_pds_lsb 0
+#define    p_reg_debug28_pds    0xD852
+#define reg_debug28_pds_pos 0
+#define reg_debug28_pds_len 3
+#define reg_debug28_pds_lsb 0
+#define    p_reg_debug27_pds    0xD853
+#define reg_debug27_pds_pos 0
+#define reg_debug27_pds_len 3
+#define reg_debug27_pds_lsb 0
+#define    p_reg_debug26_pds    0xD854
+#define reg_debug26_pds_pos 0
+#define reg_debug26_pds_len 3
+#define reg_debug26_pds_lsb 0
+#define    p_reg_debug25_pds    0xD855
+#define reg_debug25_pds_pos 0
+#define reg_debug25_pds_len 3
+#define reg_debug25_pds_lsb 0
+#define    p_reg_debug24_pds    0xD856
+#define reg_debug24_pds_pos 0
+#define reg_debug24_pds_len 3
+#define reg_debug24_pds_lsb 0
+#define    p_reg_debug23_pds    0xD857
+#define reg_debug23_pds_pos 0
+#define reg_debug23_pds_len 3
+#define reg_debug23_pds_lsb 0
+#define    p_reg_debug22_pds    0xD858
+#define reg_debug22_pds_pos 0
+#define reg_debug22_pds_len 3
+#define reg_debug22_pds_lsb 0
+#define    p_reg_gpioh1_pds 0xD859
+#define reg_gpioh1_pds_pos 0
+#define reg_gpioh1_pds_len 3
+#define reg_gpioh1_pds_lsb 0
+#define    p_reg_gpioh2_pds 0xD85A
+#define reg_gpioh2_pds_pos 0
+#define reg_gpioh2_pds_len 3
+#define reg_gpioh2_pds_lsb 0
+#define    p_reg_gpioh3_pds 0xD85B
+#define reg_gpioh3_pds_pos 0
+#define reg_gpioh3_pds_len 3
+#define reg_gpioh3_pds_lsb 0
+#define    p_reg_gpioh4_pds 0xD85C
+#define reg_gpioh4_pds_pos 0
+#define reg_gpioh4_pds_len 3
+#define reg_gpioh4_pds_lsb 0
+#define    p_reg_iosda_pds  0xD85D
+#define reg_iosda_pds_pos 0
+#define reg_iosda_pds_len 3
+#define reg_iosda_pds_lsb 0
+#define    p_reg_ioscl_pds  0xD85E
+#define reg_ioscl_pds_pos 0
+#define reg_ioscl_pds_len 3
+#define reg_ioscl_pds_lsb 0
+#define    p_reg_gpioh5_pds 0xD85F
+#define reg_gpioh5_pds_pos 0
+#define reg_gpioh5_pds_len 3
+#define reg_gpioh5_pds_lsb 0
+#define    p_reg_bond0_pds  0xD860
+#define reg_bond0_pds_pos 0
+#define reg_bond0_pds_len 3
+#define reg_bond0_pds_lsb 0
+#define    p_reg_i2caddr6_pds   0xD861
+#define reg_i2caddr6_pds_pos 0
+#define reg_i2caddr6_pds_len 3
+#define reg_i2caddr6_pds_lsb 0
+#define    p_reg_i2caddr5_pds   0xD862
+#define reg_i2caddr5_pds_pos 0
+#define reg_i2caddr5_pds_len 3
+#define reg_i2caddr5_pds_lsb 0
+#define    p_reg_i2caddr4_pds   0xD863
+#define reg_i2caddr4_pds_pos 0
+#define reg_i2caddr4_pds_len 3
+#define reg_i2caddr4_pds_lsb 0
+#define    p_reg_host_a0_pds    0xD864
+#define reg_host_a0_pds_pos 0
+#define reg_host_a0_pds_len 3
+#define reg_host_a0_pds_lsb 0
+#define    p_reg_host_a1_pds    0xD865
+#define reg_host_a1_pds_pos 0
+#define reg_host_a1_pds_len 3
+#define reg_host_a1_pds_lsb 0
+#define    p_reg_debug21_pds    0xD866
+#define reg_debug21_pds_pos 0
+#define reg_debug21_pds_len 3
+#define reg_debug21_pds_lsb 0
+#define    p_reg_debug20_pds    0xD867
+#define reg_debug20_pds_pos 0
+#define reg_debug20_pds_len 3
+#define reg_debug20_pds_lsb 0
+#define    p_reg_debug19_pds    0xD868
+#define reg_debug19_pds_pos 0
+#define reg_debug19_pds_len 3
+#define reg_debug19_pds_lsb 0
+#define    p_reg_debug18_pds    0xD869
+#define reg_debug18_pds_pos 0
+#define reg_debug18_pds_len 3
+#define reg_debug18_pds_lsb 0
+#define    p_reg_debug17_pds    0xD86A
+#define reg_debug17_pds_pos 0
+#define reg_debug17_pds_len 3
+#define reg_debug17_pds_lsb 0
+#define    p_reg_host_a2_pds    0xD86B
+#define reg_host_a2_pds_pos 0
+#define reg_host_a2_pds_len 3
+#define reg_host_a2_pds_lsb 0
+#define    p_reg_host_a3_pds    0xD86C
+#define reg_host_a3_pds_pos 0
+#define reg_host_a3_pds_len 3
+#define reg_host_a3_pds_lsb 0
+#define    p_reg_host_a4_pds    0xD86D
+#define reg_host_a4_pds_pos 0
+#define reg_host_a4_pds_len 3
+#define reg_host_a4_pds_lsb 0
+#define    p_reg_host_a5_pds    0xD86E
+#define reg_host_a5_pds_pos 0
+#define reg_host_a5_pds_len 3
+#define reg_host_a5_pds_lsb 0
+#define    p_reg_host_a6_pds    0xD86F
+#define reg_host_a6_pds_pos 0
+#define reg_host_a6_pds_len 3
+#define reg_host_a6_pds_lsb 0
+#define    p_reg_p160sel_pds    0xD870
+#define reg_p160sel_pds_pos 0
+#define reg_p160sel_pds_len 3
+#define reg_p160sel_pds_lsb 0
+#define    p_reg_gpioh13_pds    0xD871
+#define reg_gpioh13_pds_pos 0
+#define reg_gpioh13_pds_len 3
+#define reg_gpioh13_pds_lsb 0
+#define    p_reg_gpioh12_pds    0xD872
+#define reg_gpioh12_pds_pos 0
+#define reg_gpioh12_pds_len 3
+#define reg_gpioh12_pds_lsb 0
+#define    p_reg_gpioh11_pds    0xD873
+#define reg_gpioh11_pds_pos 0
+#define reg_gpioh11_pds_len 3
+#define reg_gpioh11_pds_lsb 0
+#define    p_reg_host_a7_pds    0xD874
+#define reg_host_a7_pds_pos 0
+#define reg_host_a7_pds_len 3
+#define reg_host_a7_pds_lsb 0
+#define    p_reg_host_a8_pds    0xD875
+#define reg_host_a8_pds_pos 0
+#define reg_host_a8_pds_len 3
+#define reg_host_a8_pds_lsb 0
+#define    p_reg_host_a9_pds    0xD876
+#define reg_host_a9_pds_pos 0
+#define reg_host_a9_pds_len 3
+#define reg_host_a9_pds_lsb 0
+#define    p_reg_host_a10_pds   0xD877
+#define reg_host_a10_pds_pos 0
+#define reg_host_a10_pds_len 3
+#define reg_host_a10_pds_lsb 0
+#define    p_reg_host_a11_pds   0xD878
+#define reg_host_a11_pds_pos 0
+#define reg_host_a11_pds_len 3
+#define reg_host_a11_pds_lsb 0
+#define    p_reg_bondu0_pds 0xD879
+#define reg_bondu0_pds_pos 0
+#define reg_bondu0_pds_len 3
+#define reg_bondu0_pds_lsb 0
+#define    p_reg_host_b0_pds    0xD87A
+#define reg_host_b0_pds_pos 0
+#define reg_host_b0_pds_len 3
+#define reg_host_b0_pds_lsb 0
+#define    p_reg_host_b1_pds    0xD87B
+#define reg_host_b1_pds_pos 0
+#define reg_host_b1_pds_len 3
+#define reg_host_b1_pds_lsb 0
+#define    p_reg_host_b2_pds    0xD87C
+#define reg_host_b2_pds_pos 0
+#define reg_host_b2_pds_len 3
+#define reg_host_b2_pds_lsb 0
+#define    p_reg_host_b3_pds    0xD87D
+#define reg_host_b3_pds_pos 0
+#define reg_host_b3_pds_len 3
+#define reg_host_b3_pds_lsb 0
+#define    p_reg_host_b4_pds    0xD87E
+#define reg_host_b4_pds_pos 0
+#define reg_host_b4_pds_len 3
+#define reg_host_b4_pds_lsb 0
+#define    p_reg_host_b5_pds    0xD87F
+#define reg_host_b5_pds_pos 0
+#define reg_host_b5_pds_len 3
+#define reg_host_b5_pds_lsb 0
+#define    p_reg_host_b6_pds    0xD880
+#define reg_host_b6_pds_pos 0
+#define reg_host_b6_pds_len 3
+#define reg_host_b6_pds_lsb 0
+#define    p_reg_host_b7_pds    0xD881
+#define reg_host_b7_pds_pos 0
+#define reg_host_b7_pds_len 3
+#define reg_host_b7_pds_lsb 0
+#define    p_reg_afe_f12_pds    0xD882
+#define reg_afe_f12_pds_pos 0
+#define reg_afe_f12_pds_len 3
+#define reg_afe_f12_pds_lsb 0
+#define    p_reg_host_b8_pds    0xD883
+#define reg_host_b8_pds_pos 0
+#define reg_host_b8_pds_len 3
+#define reg_host_b8_pds_lsb 0
+#define    p_reg_host_b9_pds    0xD884
+#define reg_host_b9_pds_pos 0
+#define reg_host_b9_pds_len 3
+#define reg_host_b9_pds_lsb 0
+#define    p_reg_host_b10_pds   0xD885
+#define reg_host_b10_pds_pos 0
+#define reg_host_b10_pds_len 3
+#define reg_host_b10_pds_lsb 0
+#define    p_reg_host_b11_pds   0xD886
+#define reg_host_b11_pds_pos 0
+#define reg_host_b11_pds_len 3
+#define reg_host_b11_pds_lsb 0
+#define    p_reg_debug16_pds    0xD887
+#define reg_debug16_pds_pos 0
+#define reg_debug16_pds_len 3
+#define reg_debug16_pds_lsb 0
+#define    p_reg_debug15_pds    0xD888
+#define reg_debug15_pds_pos 0
+#define reg_debug15_pds_len 3
+#define reg_debug15_pds_lsb 0
+#define    p_reg_debug14_pds    0xD889
+#define reg_debug14_pds_pos 0
+#define reg_debug14_pds_len 3
+#define reg_debug14_pds_lsb 0
+#define    p_reg_debug13_pds    0xD88A
+#define reg_debug13_pds_pos 0
+#define reg_debug13_pds_len 3
+#define reg_debug13_pds_lsb 0
+#define    p_reg_debug12_pds    0xD88B
+#define reg_debug12_pds_pos 0
+#define reg_debug12_pds_len 3
+#define reg_debug12_pds_lsb 0
+#define    p_reg_debug11_pds    0xD88C
+#define reg_debug11_pds_pos 0
+#define reg_debug11_pds_len 3
+#define reg_debug11_pds_lsb 0
+#define    p_reg_debug10_pds    0xD88D
+#define reg_debug10_pds_pos 0
+#define reg_debug10_pds_len 3
+#define reg_debug10_pds_lsb 0
+#define    p_reg_debug9_pds 0xD88E
+#define reg_debug9_pds_pos 0
+#define reg_debug9_pds_len 3
+#define reg_debug9_pds_lsb 0
+#define    p_reg_debug8_pds 0xD88F
+#define reg_debug8_pds_pos 0
+#define reg_debug8_pds_len 3
+#define reg_debug8_pds_lsb 0
+#define    p_reg_debug7_pds 0xD890
+#define reg_debug7_pds_pos 0
+#define reg_debug7_pds_len 3
+#define reg_debug7_pds_lsb 0
+#define    p_reg_debug6_pds 0xD891
+#define reg_debug6_pds_pos 0
+#define reg_debug6_pds_len 3
+#define reg_debug6_pds_lsb 0
+#define    p_reg_debug5_pds 0xD892
+#define reg_debug5_pds_pos 0
+#define reg_debug5_pds_len 3
+#define reg_debug5_pds_lsb 0
+#define    p_reg_debug4_pds 0xD893
+#define reg_debug4_pds_pos 0
+#define reg_debug4_pds_len 3
+#define reg_debug4_pds_lsb 0
+#define    p_reg_clko_pds   0xD894
+#define reg_clko_pds_pos 0
+#define reg_clko_pds_len 3
+#define reg_clko_pds_lsb 0
+#define    p_reg_gpioh6_pds 0xD895
+#define reg_gpioh6_pds_pos 0
+#define reg_gpioh6_pds_len 3
+#define reg_gpioh6_pds_lsb 0
+#define    p_reg_gpioh7_pds 0xD896
+#define reg_gpioh7_pds_pos 0
+#define reg_gpioh7_pds_len 3
+#define reg_gpioh7_pds_lsb 0
+#define    p_reg_gpioh8_pds 0xD897
+#define reg_gpioh8_pds_pos 0
+#define reg_gpioh8_pds_len 3
+#define reg_gpioh8_pds_lsb 0
+#define    p_reg_gpioh9_pds 0xD898
+#define reg_gpioh9_pds_pos 0
+#define reg_gpioh9_pds_len 3
+#define reg_gpioh9_pds_lsb 0
+#define    p_reg_gpioh10_pds    0xD899
+#define reg_gpioh10_pds_pos 0
+#define reg_gpioh10_pds_len 3
+#define reg_gpioh10_pds_lsb 0
+#define    p_reg_debug3_pds 0xD89A
+#define reg_debug3_pds_pos 0
+#define reg_debug3_pds_len 3
+#define reg_debug3_pds_lsb 0
+#define    p_reg_debug2_pds 0xD89B
+#define reg_debug2_pds_pos 0
+#define reg_debug2_pds_len 3
+#define reg_debug2_pds_lsb 0
+#define    p_reg_debug1_pds 0xD89C
+#define reg_debug1_pds_pos 0
+#define reg_debug1_pds_len 3
+#define reg_debug1_pds_lsb 0
+#define    p_reg_debug0_pds 0xD89D
+#define reg_debug0_pds_pos 0
+#define reg_debug0_pds_len 3
+#define reg_debug0_pds_lsb 0
+#define    p_reg_gpiot1_pds 0xD89E
+#define reg_gpiot1_pds_pos 0
+#define reg_gpiot1_pds_len 3
+#define reg_gpiot1_pds_lsb 0
+#define    p_reg_gpiot2_pds 0xD89F
+#define reg_gpiot2_pds_pos 0
+#define reg_gpiot2_pds_len 3
+#define reg_gpiot2_pds_lsb 0
+#define    p_reg_rfagc_pds  0xD8A0
+#define reg_rfagc_pds_pos 0
+#define reg_rfagc_pds_len 3
+#define reg_rfagc_pds_lsb 0
+#define    p_reg_ifagc_pds  0xD8A1
+#define reg_ifagc_pds_pos 0
+#define reg_ifagc_pds_len 3
+#define reg_ifagc_pds_lsb 0
+#define    p_reg_gpiot3_pds 0xD8A2
+#define reg_gpiot3_pds_pos 0
+#define reg_gpiot3_pds_len 3
+#define reg_gpiot3_pds_lsb 0
+#define    p_reg_i2caddr3_pds   0xD8A3
+#define reg_i2caddr3_pds_pos 0
+#define reg_i2caddr3_pds_len 3
+#define reg_i2caddr3_pds_lsb 0
+#define    p_reg_i2caddr2_pds   0xD8A4
+#define reg_i2caddr2_pds_pos 0
+#define reg_i2caddr2_pds_len 3
+#define reg_i2caddr2_pds_lsb 0
+#define    p_reg_i2caddr1_pds   0xD8A5
+#define reg_i2caddr1_pds_pos 0
+#define reg_i2caddr1_pds_len 3
+#define reg_i2caddr1_pds_lsb 0
+#define    p_reg_afe_sel33_pds  0xD8A6
+#define reg_afe_sel33_pds_pos 0
+#define reg_afe_sel33_pds_len 3
+#define reg_afe_sel33_pds_lsb 0
+#define    p_reg_iotunscl_pds   0xD8A7
+#define reg_iotunscl_pds_pos 0
+#define reg_iotunscl_pds_len 3
+#define reg_iotunscl_pds_lsb 0
+#define    p_reg_iotunsda_pds   0xD8A8
+#define reg_iotunsda_pds_pos 0
+#define reg_iotunsda_pds_len 3
+#define reg_iotunsda_pds_lsb 0
+#define    p_reg_rxdofsm_pds    0xD8A9
+#define reg_rxdofsm_pds_pos 0
+#define reg_rxdofsm_pds_len 3
+#define reg_rxdofsm_pds_lsb 0
+#define    p_reg_txdofsm_pds    0xD8AA
+#define reg_txdofsm_pds_pos 0
+#define reg_txdofsm_pds_len 3
+#define reg_txdofsm_pds_lsb 0
+#define    p_reg_rxdlink_pds    0xD8AB
+#define reg_rxdlink_pds_pos 0
+#define reg_rxdlink_pds_len 3
+#define reg_rxdlink_pds_lsb 0
+#define    p_reg_txdlink_pds    0xD8AC
+#define reg_txdlink_pds_pos 0
+#define reg_txdlink_pds_len 3
+#define reg_txdlink_pds_lsb 0
+#define    p_reg_ck_test_pds    0xD8AD
+#define reg_ck_test_pds_pos 0
+#define reg_ck_test_pds_len 3
+#define reg_ck_test_pds_lsb 0
+#define    r_reg_top_gpioh1_i   0xD8AE
+#define reg_top_gpioh1_i_pos 0
+#define reg_top_gpioh1_i_len 1
+#define reg_top_gpioh1_i_lsb 0
+#define    p_reg_top_gpioh1_o   0xD8AF
+#define reg_top_gpioh1_o_pos 0
+#define reg_top_gpioh1_o_len 1
+#define reg_top_gpioh1_o_lsb 0
+#define    p_reg_top_gpioh1_en  0xD8B0
+#define reg_top_gpioh1_en_pos 0
+#define reg_top_gpioh1_en_len 1
+#define reg_top_gpioh1_en_lsb 0
+#define    p_reg_top_gpioh1_on  0xD8B1
+#define reg_top_gpioh1_on_pos 0
+#define reg_top_gpioh1_on_len 1
+#define reg_top_gpioh1_on_lsb 0
+#define    r_reg_top_gpioh3_i   0xD8B2
+#define reg_top_gpioh3_i_pos 0
+#define reg_top_gpioh3_i_len 1
+#define reg_top_gpioh3_i_lsb 0
+#define    p_reg_top_gpioh3_o   0xD8B3
+#define reg_top_gpioh3_o_pos 0
+#define reg_top_gpioh3_o_len 1
+#define reg_top_gpioh3_o_lsb 0
+#define    p_reg_top_gpioh3_en  0xD8B4
+#define reg_top_gpioh3_en_pos 0
+#define reg_top_gpioh3_en_len 1
+#define reg_top_gpioh3_en_lsb 0
+#define    p_reg_top_gpioh3_on  0xD8B5
+#define reg_top_gpioh3_on_pos 0
+#define reg_top_gpioh3_on_len 1
+#define reg_top_gpioh3_on_lsb 0
+#define    r_reg_top_gpioh2_i   0xD8B6
+#define reg_top_gpioh2_i_pos 0
+#define reg_top_gpioh2_i_len 1
+#define reg_top_gpioh2_i_lsb 0
+#define    p_reg_top_gpioh2_o   0xD8B7
+#define reg_top_gpioh2_o_pos 0
+#define reg_top_gpioh2_o_len 1
+#define reg_top_gpioh2_o_lsb 0
+#define    p_reg_top_gpioh2_en  0xD8B8
+#define reg_top_gpioh2_en_pos 0
+#define reg_top_gpioh2_en_len 1
+#define reg_top_gpioh2_en_lsb 0
+#define    p_reg_top_gpioh2_on  0xD8B9
+#define reg_top_gpioh2_on_pos 0
+#define reg_top_gpioh2_on_len 1
+#define reg_top_gpioh2_on_lsb 0
+#define    r_reg_top_gpioh5_i   0xD8BA
+#define reg_top_gpioh5_i_pos 0
+#define reg_top_gpioh5_i_len 1
+#define reg_top_gpioh5_i_lsb 0
+#define    p_reg_top_gpioh5_o   0xD8BB
+#define reg_top_gpioh5_o_pos 0
+#define reg_top_gpioh5_o_len 1
+#define reg_top_gpioh5_o_lsb 0
+#define    p_reg_top_gpioh5_en  0xD8BC
+#define reg_top_gpioh5_en_pos 0
+#define reg_top_gpioh5_en_len 1
+#define reg_top_gpioh5_en_lsb 0
+#define    p_reg_top_gpioh5_on  0xD8BD
+#define reg_top_gpioh5_on_pos 0
+#define reg_top_gpioh5_on_len 1
+#define reg_top_gpioh5_on_lsb 0
+#define    r_reg_top_gpioh4_i   0xD8BE
+#define reg_top_gpioh4_i_pos 0
+#define reg_top_gpioh4_i_len 1
+#define reg_top_gpioh4_i_lsb 0
+#define    p_reg_top_gpioh4_o   0xD8BF
+#define reg_top_gpioh4_o_pos 0
+#define reg_top_gpioh4_o_len 1
+#define reg_top_gpioh4_o_lsb 0
+#define    p_reg_top_gpioh4_en  0xD8C0
+#define reg_top_gpioh4_en_pos 0
+#define reg_top_gpioh4_en_len 1
+#define reg_top_gpioh4_en_lsb 0
+#define    p_reg_top_gpioh4_on  0xD8C1
+#define reg_top_gpioh4_on_pos 0
+#define reg_top_gpioh4_on_len 1
+#define reg_top_gpioh4_on_lsb 0
+#define    r_reg_top_gpioh7_i   0xD8C2
+#define reg_top_gpioh7_i_pos 0
+#define reg_top_gpioh7_i_len 1
+#define reg_top_gpioh7_i_lsb 0
+#define    p_reg_top_gpioh7_o   0xD8C3
+#define reg_top_gpioh7_o_pos 0
+#define reg_top_gpioh7_o_len 1
+#define reg_top_gpioh7_o_lsb 0
+#define    p_reg_top_gpioh7_en  0xD8C4
+#define reg_top_gpioh7_en_pos 0
+#define reg_top_gpioh7_en_len 1
+#define reg_top_gpioh7_en_lsb 0
+#define    p_reg_top_gpioh7_on  0xD8C5
+#define reg_top_gpioh7_on_pos 0
+#define reg_top_gpioh7_on_len 1
+#define reg_top_gpioh7_on_lsb 0
+#define    r_reg_top_gpioh6_i   0xD8C6
+#define reg_top_gpioh6_i_pos 0
+#define reg_top_gpioh6_i_len 1
+#define reg_top_gpioh6_i_lsb 0
+#define    p_reg_top_gpioh6_o   0xD8C7
+#define reg_top_gpioh6_o_pos 0
+#define reg_top_gpioh6_o_len 1
+#define reg_top_gpioh6_o_lsb 0
+#define    p_reg_top_gpioh6_en  0xD8C8
+#define reg_top_gpioh6_en_pos 0
+#define reg_top_gpioh6_en_len 1
+#define reg_top_gpioh6_en_lsb 0
+#define    p_reg_top_gpioh6_on  0xD8C9
+#define reg_top_gpioh6_on_pos 0
+#define reg_top_gpioh6_on_len 1
+#define reg_top_gpioh6_on_lsb 0
+#define    r_reg_top_gpioh9_i   0xD8CA
+#define reg_top_gpioh9_i_pos 0
+#define reg_top_gpioh9_i_len 1
+#define reg_top_gpioh9_i_lsb 0
+#define    p_reg_top_gpioh9_o   0xD8CB
+#define reg_top_gpioh9_o_pos 0
+#define reg_top_gpioh9_o_len 1
+#define reg_top_gpioh9_o_lsb 0
+#define    p_reg_top_gpioh9_en  0xD8CC
+#define reg_top_gpioh9_en_pos 0
+#define reg_top_gpioh9_en_len 1
+#define reg_top_gpioh9_en_lsb 0
+#define    p_reg_top_gpioh9_on  0xD8CD
+#define reg_top_gpioh9_on_pos 0
+#define reg_top_gpioh9_on_len 1
+#define reg_top_gpioh9_on_lsb 0
+#define    r_reg_top_gpioh8_i   0xD8CE
+#define reg_top_gpioh8_i_pos 0
+#define reg_top_gpioh8_i_len 1
+#define reg_top_gpioh8_i_lsb 0
+#define    p_reg_top_gpioh8_o   0xD8CF
+#define reg_top_gpioh8_o_pos 0
+#define reg_top_gpioh8_o_len 1
+#define reg_top_gpioh8_o_lsb 0
+#define    p_reg_top_gpioh8_en  0xD8D0
+#define reg_top_gpioh8_en_pos 0
+#define reg_top_gpioh8_en_len 1
+#define reg_top_gpioh8_en_lsb 0
+#define    p_reg_top_gpioh8_on  0xD8D1
+#define reg_top_gpioh8_on_pos 0
+#define reg_top_gpioh8_on_len 1
+#define reg_top_gpioh8_on_lsb 0
+#define    r_reg_top_gpioh11_i  0xD8D2
+#define reg_top_gpioh11_i_pos 0
+#define reg_top_gpioh11_i_len 1
+#define reg_top_gpioh11_i_lsb 0
+#define    p_reg_top_gpioh11_o  0xD8D3
+#define reg_top_gpioh11_o_pos 0
+#define reg_top_gpioh11_o_len 1
+#define reg_top_gpioh11_o_lsb 0
+#define    p_reg_top_gpioh11_en 0xD8D4
+#define reg_top_gpioh11_en_pos 0
+#define reg_top_gpioh11_en_len 1
+#define reg_top_gpioh11_en_lsb 0
+#define    p_reg_top_gpioh11_on 0xD8D5
+#define reg_top_gpioh11_on_pos 0
+#define reg_top_gpioh11_on_len 1
+#define reg_top_gpioh11_on_lsb 0
+#define    r_reg_top_gpioh10_i  0xD8D6
+#define reg_top_gpioh10_i_pos 0
+#define reg_top_gpioh10_i_len 1
+#define reg_top_gpioh10_i_lsb 0
+#define    p_reg_top_gpioh10_o  0xD8D7
+#define reg_top_gpioh10_o_pos 0
+#define reg_top_gpioh10_o_len 1
+#define reg_top_gpioh10_o_lsb 0
+#define    p_reg_top_gpioh10_en 0xD8D8
+#define reg_top_gpioh10_en_pos 0
+#define reg_top_gpioh10_en_len 1
+#define reg_top_gpioh10_en_lsb 0
+#define    p_reg_top_gpioh10_on 0xD8D9
+#define reg_top_gpioh10_on_pos 0
+#define reg_top_gpioh10_on_len 1
+#define reg_top_gpioh10_on_lsb 0
+#define    r_reg_top_gpioh13_i  0xD8DA
+#define reg_top_gpioh13_i_pos 0
+#define reg_top_gpioh13_i_len 1
+#define reg_top_gpioh13_i_lsb 0
+#define    p_reg_top_gpioh13_o  0xD8DB
+#define reg_top_gpioh13_o_pos 0
+#define reg_top_gpioh13_o_len 1
+#define reg_top_gpioh13_o_lsb 0
+#define    p_reg_top_gpioh13_en 0xD8DC
+#define reg_top_gpioh13_en_pos 0
+#define reg_top_gpioh13_en_len 1
+#define reg_top_gpioh13_en_lsb 0
+#define    p_reg_top_gpioh13_on 0xD8DD
+#define reg_top_gpioh13_on_pos 0
+#define reg_top_gpioh13_on_len 1
+#define reg_top_gpioh13_on_lsb 0
+#define    r_reg_top_gpioh12_i  0xD8DE
+#define reg_top_gpioh12_i_pos 0
+#define reg_top_gpioh12_i_len 1
+#define reg_top_gpioh12_i_lsb 0
+#define    p_reg_top_gpioh12_o  0xD8DF
+#define reg_top_gpioh12_o_pos 0
+#define reg_top_gpioh12_o_len 1
+#define reg_top_gpioh12_o_lsb 0
+#define    p_reg_top_gpioh12_en 0xD8E0
+#define reg_top_gpioh12_en_pos 0
+#define reg_top_gpioh12_en_len 1
+#define reg_top_gpioh12_en_lsb 0
+#define    p_reg_top_gpioh12_on 0xD8E1
+#define reg_top_gpioh12_on_pos 0
+#define reg_top_gpioh12_on_len 1
+#define reg_top_gpioh12_on_lsb 0
+#define    r_reg_top_gpiot1_i   0xD8E2
+#define reg_top_gpiot1_i_pos 0
+#define reg_top_gpiot1_i_len 1
+#define reg_top_gpiot1_i_lsb 0
+#define    p_reg_top_gpiot1_o   0xD8E3
+#define reg_top_gpiot1_o_pos 0
+#define reg_top_gpiot1_o_len 1
+#define reg_top_gpiot1_o_lsb 0
+#define    p_reg_top_gpiot1_en  0xD8E4
+#define reg_top_gpiot1_en_pos 0
+#define reg_top_gpiot1_en_len 1
+#define reg_top_gpiot1_en_lsb 0
+#define    p_reg_top_gpiot1_on  0xD8E5
+#define reg_top_gpiot1_on_pos 0
+#define reg_top_gpiot1_on_len 1
+#define reg_top_gpiot1_on_lsb 0
+#define    r_reg_top_gpiot3_i   0xD8E6
+#define reg_top_gpiot3_i_pos 0
+#define reg_top_gpiot3_i_len 1
+#define reg_top_gpiot3_i_lsb 0
+#define    p_reg_top_gpiot3_o   0xD8E7
+#define reg_top_gpiot3_o_pos 0
+#define reg_top_gpiot3_o_len 1
+#define reg_top_gpiot3_o_lsb 0
+#define    p_reg_top_gpiot3_en  0xD8E8
+#define reg_top_gpiot3_en_pos 0
+#define reg_top_gpiot3_en_len 1
+#define reg_top_gpiot3_en_lsb 0
+#define    p_reg_top_gpiot3_on  0xD8E9
+#define reg_top_gpiot3_on_pos 0
+#define reg_top_gpiot3_on_len 1
+#define reg_top_gpiot3_on_lsb 0
+#define    r_reg_top_gpiot2_i   0xD8EA
+#define reg_top_gpiot2_i_pos 0
+#define reg_top_gpiot2_i_len 1
+#define reg_top_gpiot2_i_lsb 0
+#define    p_reg_top_gpiot2_o   0xD8EB
+#define reg_top_gpiot2_o_pos 0
+#define reg_top_gpiot2_o_len 1
+#define reg_top_gpiot2_o_lsb 0
+#define    p_reg_top_gpiot2_en  0xD8EC
+#define reg_top_gpiot2_en_pos 0
+#define reg_top_gpiot2_en_len 1
+#define reg_top_gpiot2_en_lsb 0
+#define    p_reg_top_gpiot2_on  0xD8ED
+#define reg_top_gpiot2_on_pos 0
+#define reg_top_gpiot2_on_len 1
+#define reg_top_gpiot2_on_lsb 0
+#define    p_reg_top_lock2_out  0xD8EE
+#define reg_top_lock2_out_pos 0
+#define reg_top_lock2_out_len 1
+#define reg_top_lock2_out_lsb 0
+#define    p_reg_top_lock2_tpsd 0xD8EF
+#define reg_top_lock2_tpsd_pos 0
+#define reg_top_lock2_tpsd_len 1
+#define reg_top_lock2_tpsd_lsb 0
+#define    p_reg_top_lock2_o    0xD8F0
+#define reg_top_lock2_o_pos 0
+#define reg_top_lock2_o_len 1
+#define reg_top_lock2_o_lsb 0
+#define    p_reg_top_lock2_en   0xD8F1
+#define reg_top_lock2_en_pos 0
+#define reg_top_lock2_en_len 1
+#define reg_top_lock2_en_lsb 0
+#define    p_reg_top_lock2_on   0xD8F2
+#define reg_top_lock2_on_pos 0
+#define reg_top_lock2_on_len 1
+#define reg_top_lock2_on_lsb 0
+#define    p_reg_top_lock1_out  0xD8F3
+#define reg_top_lock1_out_pos 0
+#define reg_top_lock1_out_len 1
+#define reg_top_lock1_out_lsb 0
+#define    p_reg_top_lock1_tpsd 0xD8F4
+#define reg_top_lock1_tpsd_pos 0
+#define reg_top_lock1_tpsd_len 1
+#define reg_top_lock1_tpsd_lsb 0
+#define    p_reg_top_lock1_o    0xD8F5
+#define reg_top_lock1_o_pos 0
+#define reg_top_lock1_o_len 1
+#define reg_top_lock1_o_lsb 0
+#define    p_reg_top_lock1_en   0xD8F6
+#define reg_top_lock1_en_pos 0
+#define reg_top_lock1_en_len 1
+#define reg_top_lock1_en_lsb 0
+#define    p_reg_top_lock1_on   0xD8F7
+#define reg_top_lock1_on_pos 0
+#define reg_top_lock1_on_len 1
+#define reg_top_lock1_on_lsb 0
+#define    p_reg_top_lock4_out  0xD8F8
+#define reg_top_lock4_out_pos 0
+#define reg_top_lock4_out_len 1
+#define reg_top_lock4_out_lsb 0
+#define    p_reg_top_lock4_tpsd 0xD8F9
+#define reg_top_lock4_tpsd_pos 0
+#define reg_top_lock4_tpsd_len 1
+#define reg_top_lock4_tpsd_lsb 0
+#define    p_reg_top_lock4_o    0xD8FA
+#define reg_top_lock4_o_pos 0
+#define reg_top_lock4_o_len 1
+#define reg_top_lock4_o_lsb 0
+#define    p_reg_top_lock4_en   0xD8FB
+#define reg_top_lock4_en_pos 0
+#define reg_top_lock4_en_len 1
+#define reg_top_lock4_en_lsb 0
+#define    p_reg_top_lock4_on   0xD8FC
+#define reg_top_lock4_on_pos 0
+#define reg_top_lock4_on_len 1
+#define reg_top_lock4_on_lsb 0
+#define    p_reg_top_lock3_out  0xD8FD
+#define reg_top_lock3_out_pos 0
+#define reg_top_lock3_out_len 1
+#define reg_top_lock3_out_lsb 0
+#define    p_reg_top_lock3_tpsd 0xD8FE
+#define reg_top_lock3_tpsd_pos 0
+#define reg_top_lock3_tpsd_len 1
+#define reg_top_lock3_tpsd_lsb 0
+#define    p_reg_top_lock3_o    0xD8FF
+#define reg_top_lock3_o_pos 0
+#define reg_top_lock3_o_len 1
+#define reg_top_lock3_o_lsb 0
+#define    p_reg_top_lock3_en   0xD900
+#define reg_top_lock3_en_pos 0
+#define reg_top_lock3_en_len 1
+#define reg_top_lock3_en_lsb 0
+#define    p_reg_top_lock3_on   0xD901
+#define reg_top_lock3_on_pos 0
+#define reg_top_lock3_on_len 1
+#define reg_top_lock3_on_lsb 0
+#define    p_reg_top_pwm0_en    0xD902
+#define reg_top_pwm0_en_pos 0
+#define reg_top_pwm0_en_len 1
+#define reg_top_pwm0_en_lsb 0
+#define    p_reg_top_pwm1_en    0xD903
+#define reg_top_pwm1_en_pos 0
+#define reg_top_pwm1_en_len 1
+#define reg_top_pwm1_en_lsb 0
+#define    p_reg_top_pwm2_en    0xD904
+#define reg_top_pwm2_en_pos 0
+#define reg_top_pwm2_en_len 1
+#define reg_top_pwm2_en_lsb 0
+#define    p_reg_top_pwm3_en    0xD905
+#define reg_top_pwm3_en_pos 0
+#define reg_top_pwm3_en_len 1
+#define reg_top_pwm3_en_lsb 0
+#define    p_reg_top_pwm0_gpio  0xD906
+#define reg_top_pwm0_gpio_pos 0
+#define reg_top_pwm0_gpio_len 1
+#define reg_top_pwm0_gpio_lsb 0
+#define    p_reg_top_pwm0_pos   0xD907
+#define reg_top_pwm0_pos_pos 0
+#define reg_top_pwm0_pos_len 3
+#define reg_top_pwm0_pos_lsb 0
+#define    p_reg_top_pwm0_width 0xD908
+#define reg_top_pwm0_width_pos 0
+#define reg_top_pwm0_width_len 2
+#define reg_top_pwm0_width_lsb 0
+#define    p_reg_top_pwm0_duration  0xD909
+#define reg_top_pwm0_duration_pos 0
+#define reg_top_pwm0_duration_len 8
+#define reg_top_pwm0_duration_lsb 0
+#define    p_reg_top_pwm1_gpio  0xD90A
+#define reg_top_pwm1_gpio_pos 0
+#define reg_top_pwm1_gpio_len 1
+#define reg_top_pwm1_gpio_lsb 0
+#define    p_reg_top_pwm1_pos   0xD90B
+#define reg_top_pwm1_pos_pos 0
+#define reg_top_pwm1_pos_len 3
+#define reg_top_pwm1_pos_lsb 0
+#define    p_reg_top_pwm1_width 0xD90C
+#define reg_top_pwm1_width_pos 0
+#define reg_top_pwm1_width_len 2
+#define reg_top_pwm1_width_lsb 0
+#define    p_reg_top_pwm1_duration  0xD90D
+#define reg_top_pwm1_duration_pos 0
+#define reg_top_pwm1_duration_len 8
+#define reg_top_pwm1_duration_lsb 0
+#define    p_reg_top_pwm2_gpio  0xD90E
+#define reg_top_pwm2_gpio_pos 0
+#define reg_top_pwm2_gpio_len 1
+#define reg_top_pwm2_gpio_lsb 0
+#define    p_reg_top_pwm2_pos   0xD90F
+#define reg_top_pwm2_pos_pos 0
+#define reg_top_pwm2_pos_len 3
+#define reg_top_pwm2_pos_lsb 0
+#define    p_reg_top_pwm2_width 0xD910
+#define reg_top_pwm2_width_pos 0
+#define reg_top_pwm2_width_len 2
+#define reg_top_pwm2_width_lsb 0
+#define    p_reg_top_pwm2_duration  0xD911
+#define reg_top_pwm2_duration_pos 0
+#define reg_top_pwm2_duration_len 8
+#define reg_top_pwm2_duration_lsb 0
+#define    p_reg_top_pwm3_gpio  0xD912
+#define reg_top_pwm3_gpio_pos 0
+#define reg_top_pwm3_gpio_len 1
+#define reg_top_pwm3_gpio_lsb 0
+#define    p_reg_top_pwm3_pos   0xD913
+#define reg_top_pwm3_pos_pos 0
+#define reg_top_pwm3_pos_len 3
+#define reg_top_pwm3_pos_lsb 0
+#define    p_reg_top_pwm3_width 0xD914
+#define reg_top_pwm3_width_pos 0
+#define reg_top_pwm3_width_len 2
+#define reg_top_pwm3_width_lsb 0
+#define    p_reg_top_pwm3_duration  0xD915
+#define reg_top_pwm3_duration_pos 0
+#define reg_top_pwm3_duration_len 8
+#define reg_top_pwm3_duration_lsb 0
+#define    p_reg_top_hosta_mpeg_par_mode    0xD916
+#define reg_top_hosta_mpeg_par_mode_pos 0
+#define reg_top_hosta_mpeg_par_mode_len 1
+#define reg_top_hosta_mpeg_par_mode_lsb 0
+#define    p_reg_top_hosta_mpeg_ser_mode    0xD917
+#define reg_top_hosta_mpeg_ser_mode_pos 0
+#define reg_top_hosta_mpeg_ser_mode_len 1
+#define reg_top_hosta_mpeg_ser_mode_lsb 0
+#define    p_reg_top_hosta_mpeg_ser_do7 0xD918
+#define reg_top_hosta_mpeg_ser_do7_pos 0
+#define reg_top_hosta_mpeg_ser_do7_len 1
+#define reg_top_hosta_mpeg_ser_do7_lsb 0
+#define    p_reg_top_hosta_dca_upper    0xD919
+#define reg_top_hosta_dca_upper_pos 0
+#define reg_top_hosta_dca_upper_len 1
+#define reg_top_hosta_dca_upper_lsb 0
+#define    p_reg_top_hosta_dca_lower    0xD91A
+#define reg_top_hosta_dca_lower_pos 0
+#define reg_top_hosta_dca_lower_len 1
+#define reg_top_hosta_dca_lower_lsb 0
+#define    p_reg_top_hostb_mpeg_par_mode    0xD91B
+#define reg_top_hostb_mpeg_par_mode_pos 0
+#define reg_top_hostb_mpeg_par_mode_len 1
+#define reg_top_hostb_mpeg_par_mode_lsb 0
+#define    p_reg_top_hostb_mpeg_ser_mode    0xD91C
+#define reg_top_hostb_mpeg_ser_mode_pos 0
+#define reg_top_hostb_mpeg_ser_mode_len 1
+#define reg_top_hostb_mpeg_ser_mode_lsb 0
+#define    p_reg_top_hostb_mpeg_ser_do7 0xD91D
+#define reg_top_hostb_mpeg_ser_do7_pos 0
+#define reg_top_hostb_mpeg_ser_do7_len 1
+#define reg_top_hostb_mpeg_ser_do7_lsb 0
+#define    p_reg_top_hostb_dca_upper    0xD91E
+#define reg_top_hostb_dca_upper_pos 0
+#define reg_top_hostb_dca_upper_len 1
+#define reg_top_hostb_dca_upper_lsb 0
+#define    p_reg_top_hostb_dca_lower    0xD91F
+#define reg_top_hostb_dca_lower_pos 0
+#define reg_top_hostb_dca_lower_len 1
+#define reg_top_hostb_dca_lower_lsb 0
+#define    p_reg_top_host_reverse   0xD920
+#define reg_top_host_reverse_pos 0
+#define reg_top_host_reverse_len 1
+#define reg_top_host_reverse_lsb 0
+#define    p_reg_top_hosta_ccir 0xD921
+#define reg_top_hosta_ccir_pos 0
+#define reg_top_hosta_ccir_len 1
+#define reg_top_hosta_ccir_lsb 0
+#define    p_reg_top_hostb_ccir 0xD922
+#define reg_top_hostb_ccir_pos 0
+#define reg_top_hostb_ccir_len 1
+#define reg_top_hostb_ccir_lsb 0
+#define    p_reg_top_i2s_master_mode    0xD923
+#define reg_top_i2s_master_mode_pos 0
+#define reg_top_i2s_master_mode_len 1
+#define reg_top_i2s_master_mode_lsb 0
+#define    p_reg_usb_cfg_speed  0xDD00
+#define reg_usb_cfg_speed_pos 0
+#define reg_usb_cfg_speed_len 1
+#define reg_usb_cfg_speed_lsb 0
+#define    p_reg_usb_cfg_utmi16 0xDD00
+#define reg_usb_cfg_utmi16_pos 1
+#define reg_usb_cfg_utmi16_len 1
+#define reg_usb_cfg_utmi16_lsb 0
+#define    p_reg_usb_cfg_test   0xDD00
+#define reg_usb_cfg_test_pos 3
+#define reg_usb_cfg_test_len 3
+#define reg_usb_cfg_test_lsb 0
+#define    p_reg_usb_port_sim_reset 0xDD00
+#define reg_usb_port_sim_reset_pos 6
+#define reg_usb_port_sim_reset_len 1
+#define reg_usb_port_sim_reset_lsb 0
+#define    p_reg_usb_port_run   0xDD00
+#define reg_usb_port_run_pos 7
+#define reg_usb_port_run_len 1
+#define reg_usb_port_run_lsb 0
+#define    r_usb_line_state_0   0xDD01
+#define usb_line_state_0_pos 0
+#define usb_line_state_0_len 1
+#define usb_line_state_0_lsb 0
+#define    r_usb_line_state_1   0xDD01
+#define usb_line_state_1_pos 1
+#define usb_line_state_1_len 1
+#define usb_line_state_1_lsb 0
+#define    r_reg_usb_status_speed   0xDD01
+#define reg_usb_status_speed_pos 2
+#define reg_usb_status_speed_len 1
+#define reg_usb_status_speed_lsb 0
+#define    r_reg_usb_status_connect 0xDD01
+#define reg_usb_status_connect_pos 3
+#define reg_usb_status_connect_len 1
+#define reg_usb_status_connect_lsb 0
+#define    r_reg_usb_rx_buf 0xDD01
+#define reg_usb_rx_buf_pos 4
+#define reg_usb_rx_buf_len 1
+#define reg_usb_rx_buf_lsb 0
+#define    r_reg_usb_port_reset 0xDD01
+#define reg_usb_port_reset_pos 5
+#define reg_usb_port_reset_len 1
+#define reg_usb_port_reset_lsb 0
+#define    r_reg_usb_port_suspend   0xDD01
+#define reg_usb_port_suspend_pos 6
+#define reg_usb_port_suspend_len 1
+#define reg_usb_port_suspend_lsb 0
+#define    p_reg_ep1_tx_type    0xDD07
+#define reg_ep1_tx_type_pos 2
+#define reg_ep1_tx_type_len 1
+#define reg_ep1_tx_type_lsb 0
+#define    p_reg_ep2_rx_type    0xDD07
+#define reg_ep2_rx_type_pos 3
+#define reg_ep2_rx_type_len 1
+#define reg_ep2_rx_type_lsb 0
+#define    p_reg_ep3_tx_type    0xDD07
+#define reg_ep3_tx_type_pos 4
+#define reg_ep3_tx_type_len 1
+#define reg_ep3_tx_type_lsb 0
+#define    p_reg_ep4_tx_type    0xDD07
+#define reg_ep4_tx_type_pos 5
+#define reg_ep4_tx_type_len 1
+#define reg_ep4_tx_type_lsb 0
+#define    p_reg_ep5_tx_type    0xDD07
+#define reg_ep5_tx_type_pos 6
+#define reg_ep5_tx_type_len 1
+#define reg_ep5_tx_type_lsb 0
+#define    p_reg_ep6_tx_type    0xDD07
+#define reg_ep6_tx_type_pos 7
+#define reg_ep6_tx_type_len 1
+#define reg_ep6_tx_type_lsb 0
+#define    p_reg_ep0_max_pkt    0xDD08
+#define reg_ep0_max_pkt_pos 0
+#define reg_ep0_max_pkt_len 8
+#define reg_ep0_max_pkt_lsb 0
+#define    p_reg_ep2_max_pkt    0xDD0A
+#define reg_ep2_max_pkt_pos 0
+#define reg_ep2_max_pkt_len 8
+#define reg_ep2_max_pkt_lsb 0
+#define    p_reg_ep4_max_pkt    0xDD0C
+#define reg_ep4_max_pkt_pos 0
+#define reg_ep4_max_pkt_len 8
+#define reg_ep4_max_pkt_lsb 0
+#define    p_reg_ep5_max_pkt    0xDD0D
+#define reg_ep5_max_pkt_pos 0
+#define reg_ep5_max_pkt_len 8
+#define reg_ep5_max_pkt_lsb 0
+#define    p_reg_ep6_max_pkt_7_0    0xDD0E
+#define reg_ep6_max_pkt_7_0_pos 0
+#define reg_ep6_max_pkt_7_0_len 8
+#define reg_ep6_max_pkt_7_0_lsb 0
+#define    p_reg_ep6_max_pkt_15_8   0xDD0F
+#define reg_ep6_max_pkt_15_8_pos 0
+#define reg_ep6_max_pkt_15_8_len 8
+#define reg_ep6_max_pkt_15_8_lsb 8
+#define    p_reg_usb_addr   0xDD10
+#define reg_usb_addr_pos 0
+#define reg_usb_addr_len 7
+#define reg_usb_addr_lsb 0
+#define    p_reg_usb_addr_now   0xDD10
+#define reg_usb_addr_now_pos 7
+#define reg_usb_addr_now_len 1
+#define reg_usb_addr_now_lsb 0
+#define    p_reg_ep0_tx_en  0xDD11
+#define reg_ep0_tx_en_pos 0
+#define reg_ep0_tx_en_len 1
+#define reg_ep0_tx_en_lsb 0
+#define    p_reg_ep0_rx_en  0xDD11
+#define reg_ep0_rx_en_pos 1
+#define reg_ep0_rx_en_len 1
+#define reg_ep0_rx_en_lsb 0
+#define    p_reg_ep1_tx_en  0xDD11
+#define reg_ep1_tx_en_pos 2
+#define reg_ep1_tx_en_len 1
+#define reg_ep1_tx_en_lsb 0
+#define    p_reg_ep2_rx_en  0xDD11
+#define reg_ep2_rx_en_pos 3
+#define reg_ep2_rx_en_len 1
+#define reg_ep2_rx_en_lsb 0
+#define    p_reg_ep3_tx_en  0xDD11
+#define reg_ep3_tx_en_pos 4
+#define reg_ep3_tx_en_len 1
+#define reg_ep3_tx_en_lsb 0
+#define    p_reg_ep4_tx_en  0xDD11
+#define reg_ep4_tx_en_pos 5
+#define reg_ep4_tx_en_len 1
+#define reg_ep4_tx_en_lsb 0
+#define    p_reg_ep5_tx_en  0xDD11
+#define reg_ep5_tx_en_pos 6
+#define reg_ep5_tx_en_len 1
+#define reg_ep5_tx_en_lsb 0
+#define    p_reg_ep6_tx_en  0xDD11
+#define reg_ep6_tx_en_pos 7
+#define reg_ep6_tx_en_len 1
+#define reg_ep6_tx_en_lsb 0
+#define    p_reg_ep0_tx_stall   0xDD12
+#define reg_ep0_tx_stall_pos 0
+#define reg_ep0_tx_stall_len 1
+#define reg_ep0_tx_stall_lsb 0
+#define    p_reg_ep0_rx_stall   0xDD12
+#define reg_ep0_rx_stall_pos 1
+#define reg_ep0_rx_stall_len 1
+#define reg_ep0_rx_stall_lsb 0
+#define    p_reg_ep1_tx_stall   0xDD12
+#define reg_ep1_tx_stall_pos 2
+#define reg_ep1_tx_stall_len 1
+#define reg_ep1_tx_stall_lsb 0
+#define    p_reg_ep2_rx_stall   0xDD12
+#define reg_ep2_rx_stall_pos 3
+#define reg_ep2_rx_stall_len 1
+#define reg_ep2_rx_stall_lsb 0
+#define    p_reg_ep3_tx_stall   0xDD12
+#define reg_ep3_tx_stall_pos 4
+#define reg_ep3_tx_stall_len 1
+#define reg_ep3_tx_stall_lsb 0
+#define    p_reg_ep4_tx_stall   0xDD12
+#define reg_ep4_tx_stall_pos 5
+#define reg_ep4_tx_stall_len 1
+#define reg_ep4_tx_stall_lsb 0
+#define    p_reg_ep5_tx_stall   0xDD12
+#define reg_ep5_tx_stall_pos 6
+#define reg_ep5_tx_stall_len 1
+#define reg_ep5_tx_stall_lsb 0
+#define    p_reg_ep6_tx_stall   0xDD12
+#define reg_ep6_tx_stall_pos 7
+#define reg_ep6_tx_stall_len 1
+#define reg_ep6_tx_stall_lsb 0
+#define    p_reg_ep0_tx_nak 0xDD13
+#define reg_ep0_tx_nak_pos 0
+#define reg_ep0_tx_nak_len 1
+#define reg_ep0_tx_nak_lsb 0
+#define    p_reg_ep0_rx_nak 0xDD13
+#define reg_ep0_rx_nak_pos 1
+#define reg_ep0_rx_nak_len 1
+#define reg_ep0_rx_nak_lsb 0
+#define    p_reg_ep1_tx_nak 0xDD13
+#define reg_ep1_tx_nak_pos 2
+#define reg_ep1_tx_nak_len 1
+#define reg_ep1_tx_nak_lsb 0
+#define    p_reg_ep2_rx_nak 0xDD13
+#define reg_ep2_rx_nak_pos 3
+#define reg_ep2_rx_nak_len 1
+#define reg_ep2_rx_nak_lsb 0
+#define    p_reg_ep3_tx_nak 0xDD13
+#define reg_ep3_tx_nak_pos 4
+#define reg_ep3_tx_nak_len 1
+#define reg_ep3_tx_nak_lsb 0
+#define    p_reg_ep4_tx_nak 0xDD13
+#define reg_ep4_tx_nak_pos 5
+#define reg_ep4_tx_nak_len 1
+#define reg_ep4_tx_nak_lsb 0
+#define    p_reg_ep5_tx_nak 0xDD13
+#define reg_ep5_tx_nak_pos 6
+#define reg_ep5_tx_nak_len 1
+#define reg_ep5_tx_nak_lsb 0
+#define    p_reg_ep6_tx_nak 0xDD13
+#define reg_ep6_tx_nak_pos 7
+#define reg_ep6_tx_nak_len 1
+#define reg_ep6_tx_nak_lsb 0
+#define    p_reg_ep0_tx_nak_int_en  0xDD14
+#define reg_ep0_tx_nak_int_en_pos 0
+#define reg_ep0_tx_nak_int_en_len 1
+#define reg_ep0_tx_nak_int_en_lsb 0
+#define    p_reg_ep0_rx_nak_int_en  0xDD14
+#define reg_ep0_rx_nak_int_en_pos 1
+#define reg_ep0_rx_nak_int_en_len 1
+#define reg_ep0_rx_nak_int_en_lsb 0
+#define    p_reg_ep1_tx_nak_int_en  0xDD14
+#define reg_ep1_tx_nak_int_en_pos 2
+#define reg_ep1_tx_nak_int_en_len 1
+#define reg_ep1_tx_nak_int_en_lsb 0
+#define    p_reg_ep2_rx_nak_int_en  0xDD14
+#define reg_ep2_rx_nak_int_en_pos 3
+#define reg_ep2_rx_nak_int_en_len 1
+#define reg_ep2_rx_nak_int_en_lsb 0
+#define    p_reg_ep3_tx_nak_int_en  0xDD14
+#define reg_ep3_tx_nak_int_en_pos 4
+#define reg_ep3_tx_nak_int_en_len 1
+#define reg_ep3_tx_nak_int_en_lsb 0
+#define    p_reg_ep4_tx_nak_int_en  0xDD14
+#define reg_ep4_tx_nak_int_en_pos 5
+#define reg_ep4_tx_nak_int_en_len 1
+#define reg_ep4_tx_nak_int_en_lsb 0
+#define    p_reg_ep5_tx_nak_int_en  0xDD14
+#define reg_ep5_tx_nak_int_en_pos 6
+#define reg_ep5_tx_nak_int_en_len 1
+#define reg_ep5_tx_nak_int_en_lsb 0
+#define    p_reg_ep6_tx_nak_int_en  0xDD14
+#define reg_ep6_tx_nak_int_en_pos 7
+#define reg_ep6_tx_nak_int_en_len 1
+#define reg_ep6_tx_nak_int_en_lsb 0
+#define    p_reg_ep0_tx_done_int_en 0xDD15
+#define reg_ep0_tx_done_int_en_pos 0
+#define reg_ep0_tx_done_int_en_len 1
+#define reg_ep0_tx_done_int_en_lsb 0
+#define    p_reg_ep0_rx_done_int_en 0xDD15
+#define reg_ep0_rx_done_int_en_pos 1
+#define reg_ep0_rx_done_int_en_len 1
+#define reg_ep0_rx_done_int_en_lsb 0
+#define    p_reg_ep1_tx_done_int_en 0xDD15
+#define reg_ep1_tx_done_int_en_pos 2
+#define reg_ep1_tx_done_int_en_len 1
+#define reg_ep1_tx_done_int_en_lsb 0
+#define    p_reg_ep2_rx_done_int_en 0xDD15
+#define reg_ep2_rx_done_int_en_pos 3
+#define reg_ep2_rx_done_int_en_len 1
+#define reg_ep2_rx_done_int_en_lsb 0
+#define    p_reg_ep3_tx_done_int_en 0xDD15
+#define reg_ep3_tx_done_int_en_pos 4
+#define reg_ep3_tx_done_int_en_len 1
+#define reg_ep3_tx_done_int_en_lsb 0
+#define    p_reg_ep4_tx_done_int_en 0xDD15
+#define reg_ep4_tx_done_int_en_pos 5
+#define reg_ep4_tx_done_int_en_len 1
+#define reg_ep4_tx_done_int_en_lsb 0
+#define    p_reg_ep5_tx_done_int_en 0xDD15
+#define reg_ep5_tx_done_int_en_pos 6
+#define reg_ep5_tx_done_int_en_len 1
+#define reg_ep5_tx_done_int_en_lsb 0
+#define    p_reg_ep6_tx_done_int_en 0xDD15
+#define reg_ep6_tx_done_int_en_pos 7
+#define reg_ep6_tx_done_int_en_len 1
+#define reg_ep6_tx_done_int_en_lsb 0
+#define    p_reg_ep0_tx_fail_int_en 0xDD16
+#define reg_ep0_tx_fail_int_en_pos 0
+#define reg_ep0_tx_fail_int_en_len 1
+#define reg_ep0_tx_fail_int_en_lsb 0
+#define    p_reg_ep0_rx_fail_int_en 0xDD16
+#define reg_ep0_rx_fail_int_en_pos 1
+#define reg_ep0_rx_fail_int_en_len 1
+#define reg_ep0_rx_fail_int_en_lsb 0
+#define    p_reg_ep1_tx_fail_int_en 0xDD16
+#define reg_ep1_tx_fail_int_en_pos 2
+#define reg_ep1_tx_fail_int_en_len 1
+#define reg_ep1_tx_fail_int_en_lsb 0
+#define    p_reg_ep2_rx_fail_int_en 0xDD16
+#define reg_ep2_rx_fail_int_en_pos 3
+#define reg_ep2_rx_fail_int_en_len 1
+#define reg_ep2_rx_fail_int_en_lsb 0
+#define    p_reg_ep3_tx_fail_int_en 0xDD16
+#define reg_ep3_tx_fail_int_en_pos 4
+#define reg_ep3_tx_fail_int_en_len 1
+#define reg_ep3_tx_fail_int_en_lsb 0
+#define    p_reg_ep4_tx_fail_int_en 0xDD16
+#define reg_ep4_tx_fail_int_en_pos 5
+#define reg_ep4_tx_fail_int_en_len 1
+#define reg_ep4_tx_fail_int_en_lsb 0
+#define    p_reg_ep5_tx_fail_int_en 0xDD16
+#define reg_ep5_tx_fail_int_en_pos 6
+#define reg_ep5_tx_fail_int_en_len 1
+#define reg_ep5_tx_fail_int_en_lsb 0
+#define    p_reg_ep6_tx_fail_int_en 0xDD16
+#define reg_ep6_tx_fail_int_en_pos 7
+#define reg_ep6_tx_fail_int_en_len 1
+#define reg_ep6_tx_fail_int_en_lsb 0
+#define    p_reg_suspend_int_en 0xDD17
+#define reg_suspend_int_en_pos 0
+#define reg_suspend_int_en_len 1
+#define reg_suspend_int_en_lsb 0
+#define    p_reg_bus_reset_int_en   0xDD17
+#define reg_bus_reset_int_en_pos 1
+#define reg_bus_reset_int_en_len 1
+#define reg_bus_reset_int_en_lsb 0
+#define    p_reg_ep0_setup_int_en   0xDD17
+#define reg_ep0_setup_int_en_pos 2
+#define reg_ep0_setup_int_en_len 1
+#define reg_ep0_setup_int_en_lsb 0
+#define    p_reg_ep0_tx_nak_int 0xDD18
+#define reg_ep0_tx_nak_int_pos 0
+#define reg_ep0_tx_nak_int_len 1
+#define reg_ep0_tx_nak_int_lsb 0
+#define    p_reg_ep0_rx_nak_int 0xDD18
+#define reg_ep0_rx_nak_int_pos 1
+#define reg_ep0_rx_nak_int_len 1
+#define reg_ep0_rx_nak_int_lsb 0
+#define    p_reg_ep1_tx_nak_int 0xDD18
+#define reg_ep1_tx_nak_int_pos 2
+#define reg_ep1_tx_nak_int_len 1
+#define reg_ep1_tx_nak_int_lsb 0
+#define    p_reg_ep2_rx_nak_int 0xDD18
+#define reg_ep2_rx_nak_int_pos 3
+#define reg_ep2_rx_nak_int_len 1
+#define reg_ep2_rx_nak_int_lsb 0
+#define    p_reg_ep3_tx_nak_int 0xDD18
+#define reg_ep3_tx_nak_int_pos 4
+#define reg_ep3_tx_nak_int_len 1
+#define reg_ep3_tx_nak_int_lsb 0
+#define    p_reg_ep4_tx_nak_int 0xDD18
+#define reg_ep4_tx_nak_int_pos 5
+#define reg_ep4_tx_nak_int_len 1
+#define reg_ep4_tx_nak_int_lsb 0
+#define    p_reg_ep5_tx_nak_int 0xDD18
+#define reg_ep5_tx_nak_int_pos 6
+#define reg_ep5_tx_nak_int_len 1
+#define reg_ep5_tx_nak_int_lsb 0
+#define    p_reg_ep6_tx_nak_int 0xDD18
+#define reg_ep6_tx_nak_int_pos 7
+#define reg_ep6_tx_nak_int_len 1
+#define reg_ep6_tx_nak_int_lsb 0
+#define    p_reg_ep0_tx_done_int    0xDD19
+#define reg_ep0_tx_done_int_pos 0
+#define reg_ep0_tx_done_int_len 1
+#define reg_ep0_tx_done_int_lsb 0
+#define    p_reg_ep0_rx_done_int    0xDD19
+#define reg_ep0_rx_done_int_pos 1
+#define reg_ep0_rx_done_int_len 1
+#define reg_ep0_rx_done_int_lsb 0
+#define    p_reg_ep1_tx_done_int    0xDD19
+#define reg_ep1_tx_done_int_pos 2
+#define reg_ep1_tx_done_int_len 1
+#define reg_ep1_tx_done_int_lsb 0
+#define    p_reg_ep2_rx_done_int    0xDD19
+#define reg_ep2_rx_done_int_pos 3
+#define reg_ep2_rx_done_int_len 1
+#define reg_ep2_rx_done_int_lsb 0
+#define    p_reg_ep3_tx_done_int    0xDD19
+#define reg_ep3_tx_done_int_pos 4
+#define reg_ep3_tx_done_int_len 1
+#define reg_ep3_tx_done_int_lsb 0
+#define    p_reg_ep4_tx_done_int    0xDD19
+#define reg_ep4_tx_done_int_pos 5
+#define reg_ep4_tx_done_int_len 1
+#define reg_ep4_tx_done_int_lsb 0
+#define    p_reg_ep5_tx_done_int    0xDD19
+#define reg_ep5_tx_done_int_pos 6
+#define reg_ep5_tx_done_int_len 1
+#define reg_ep5_tx_done_int_lsb 0
+#define    p_reg_ep6_tx_done_int    0xDD19
+#define reg_ep6_tx_done_int_pos 7
+#define reg_ep6_tx_done_int_len 1
+#define reg_ep6_tx_done_int_lsb 0
+#define    p_reg_ep0_tx_fail_int    0xDD1A
+#define reg_ep0_tx_fail_int_pos 0
+#define reg_ep0_tx_fail_int_len 1
+#define reg_ep0_tx_fail_int_lsb 0
+#define    p_reg_ep0_rx_fail_int    0xDD1A
+#define reg_ep0_rx_fail_int_pos 1
+#define reg_ep0_rx_fail_int_len 1
+#define reg_ep0_rx_fail_int_lsb 0
+#define    p_reg_ep1_tx_fail_int    0xDD1A
+#define reg_ep1_tx_fail_int_pos 2
+#define reg_ep1_tx_fail_int_len 1
+#define reg_ep1_tx_fail_int_lsb 0
+#define    p_reg_ep2_rx_fail_int    0xDD1A
+#define reg_ep2_rx_fail_int_pos 3
+#define reg_ep2_rx_fail_int_len 1
+#define reg_ep2_rx_fail_int_lsb 0
+#define    p_reg_ep3_tx_fail_int    0xDD1A
+#define reg_ep3_tx_fail_int_pos 4
+#define reg_ep3_tx_fail_int_len 1
+#define reg_ep3_tx_fail_int_lsb 0
+#define    p_reg_ep4_tx_fail_int    0xDD1A
+#define reg_ep4_tx_fail_int_pos 5
+#define reg_ep4_tx_fail_int_len 1
+#define reg_ep4_tx_fail_int_lsb 0
+#define    p_reg_ep5_tx_fail_int    0xDD1A
+#define reg_ep5_tx_fail_int_pos 6
+#define reg_ep5_tx_fail_int_len 1
+#define reg_ep5_tx_fail_int_lsb 0
+#define    p_reg_ep6_tx_fail_int    0xDD1A
+#define reg_ep6_tx_fail_int_pos 7
+#define reg_ep6_tx_fail_int_len 1
+#define reg_ep6_tx_fail_int_lsb 0
+#define    p_reg_suspend_int    0xDD1B
+#define reg_suspend_int_pos 0
+#define reg_suspend_int_len 1
+#define reg_suspend_int_lsb 0
+#define    p_reg_bus_reset_int  0xDD1B
+#define reg_bus_reset_int_pos 1
+#define reg_bus_reset_int_len 1
+#define reg_bus_reset_int_lsb 0
+#define    p_reg_ep0_setup_int  0xDD1B
+#define reg_ep0_setup_int_pos 2
+#define reg_ep0_setup_int_len 1
+#define reg_ep0_setup_int_lsb 0
+#define    r_usbc_int   0xDD1B
+#define usbc_int_pos 3
+#define usbc_int_len 1
+#define usbc_int_lsb 0
+#define    r_usb_ir_int 0xDD1B
+#define usb_ir_int_pos 4
+#define usb_ir_int_len 1
+#define usb_ir_int_lsb 0
+#define    p_reg_ep0_tx_rst 0xDD1D
+#define reg_ep0_tx_rst_pos 0
+#define reg_ep0_tx_rst_len 1
+#define reg_ep0_tx_rst_lsb 0
+#define    p_reg_ep0_rx_rst 0xDD1D
+#define reg_ep0_rx_rst_pos 1
+#define reg_ep0_rx_rst_len 1
+#define reg_ep0_rx_rst_lsb 0
+#define    p_reg_ep1_tx_rst 0xDD1D
+#define reg_ep1_tx_rst_pos 2
+#define reg_ep1_tx_rst_len 1
+#define reg_ep1_tx_rst_lsb 0
+#define    p_reg_ep2_rx_rst 0xDD1D
+#define reg_ep2_rx_rst_pos 3
+#define reg_ep2_rx_rst_len 1
+#define reg_ep2_rx_rst_lsb 0
+#define    p_reg_ep3_tx_rst 0xDD1D
+#define reg_ep3_tx_rst_pos 4
+#define reg_ep3_tx_rst_len 1
+#define reg_ep3_tx_rst_lsb 0
+#define    p_reg_ep4_tx_rst 0xDD1D
+#define reg_ep4_tx_rst_pos 5
+#define reg_ep4_tx_rst_len 1
+#define reg_ep4_tx_rst_lsb 0
+#define    p_reg_ep5_tx_rst 0xDD1D
+#define reg_ep5_tx_rst_pos 6
+#define reg_ep5_tx_rst_len 1
+#define reg_ep5_tx_rst_lsb 0
+#define    p_reg_ep6_tx_rst 0xDD1D
+#define reg_ep6_tx_rst_pos 7
+#define reg_ep6_tx_rst_len 1
+#define reg_ep6_tx_rst_lsb 0
+#define    r_reg_ep0_tx_active  0xDD1E
+#define reg_ep0_tx_active_pos 0
+#define reg_ep0_tx_active_len 1
+#define reg_ep0_tx_active_lsb 0
+#define    r_reg_ep0_rx_active  0xDD1E
+#define reg_ep0_rx_active_pos 1
+#define reg_ep0_rx_active_len 1
+#define reg_ep0_rx_active_lsb 0
+#define    r_reg_ep1_tx_active  0xDD1E
+#define reg_ep1_tx_active_pos 2
+#define reg_ep1_tx_active_len 1
+#define reg_ep1_tx_active_lsb 0
+#define    r_reg_ep2_rx_active  0xDD1E
+#define reg_ep2_rx_active_pos 3
+#define reg_ep2_rx_active_len 1
+#define reg_ep2_rx_active_lsb 0
+#define    r_reg_ep3_tx_active  0xDD1E
+#define reg_ep3_tx_active_pos 4
+#define reg_ep3_tx_active_len 1
+#define reg_ep3_tx_active_lsb 0
+#define    r_reg_ep4_tx_active  0xDD1E
+#define reg_ep4_tx_active_pos 5
+#define reg_ep4_tx_active_len 1
+#define reg_ep4_tx_active_lsb 0
+#define    r_reg_ep5_tx_active  0xDD1E
+#define reg_ep5_tx_active_pos 6
+#define reg_ep5_tx_active_len 1
+#define reg_ep5_tx_active_lsb 0
+#define    r_reg_ep6_tx_active  0xDD1E
+#define reg_ep6_tx_active_pos 7
+#define reg_ep6_tx_active_len 1
+#define reg_ep6_tx_active_lsb 0
+#define    p_reg_usb_setup_reset    0xDD1F
+#define reg_usb_setup_reset_pos 0
+#define reg_usb_setup_reset_len 1
+#define reg_usb_setup_reset_lsb 0
+#define    p_reg_usb_ep4_retry_new  0xDD1F
+#define reg_usb_ep4_retry_new_pos 1
+#define reg_usb_ep4_retry_new_len 1
+#define reg_usb_ep4_retry_new_lsb 0
+#define    p_reg_usb_ep5_retry_new  0xDD1F
+#define reg_usb_ep5_retry_new_pos 2
+#define reg_usb_ep5_retry_new_len 1
+#define reg_usb_ep5_retry_new_lsb 0
+#define    p_reg_usb_ep6_retry_new  0xDD1F
+#define reg_usb_ep6_retry_new_pos 3
+#define reg_usb_ep6_retry_new_len 1
+#define reg_usb_ep6_retry_new_lsb 0
+#define    p_reg_usb_iso_mult_cnt   0xDD20
+#define reg_usb_iso_mult_cnt_pos 0
+#define reg_usb_iso_mult_cnt_len 2
+#define reg_usb_iso_mult_cnt_lsb 0
+#define    p_reg_p_iso_fix_en   0xDD21
+#define reg_p_iso_fix_en_pos 0
+#define reg_p_iso_fix_en_len 1
+#define reg_p_iso_fix_en_lsb 0
+#define    p_reg_p_iso_fix_rst  0xDD22
+#define reg_p_iso_fix_rst_pos 0
+#define reg_p_iso_fix_rst_len 1
+#define reg_p_iso_fix_rst_lsb 0
+#define    p_reg_p_read_point_7_0   0xDD23
+#define reg_p_read_point_7_0_pos 0
+#define reg_p_read_point_7_0_len 8
+#define reg_p_read_point_7_0_lsb 0
+#define    p_reg_p_read_point_11_8  0xDD24
+#define reg_p_read_point_11_8_pos 0
+#define reg_p_read_point_11_8_len 4
+#define reg_p_read_point_11_8_lsb 8
+#define    p_reg_p_dbg_ctrl 0xDD25
+#define reg_p_dbg_ctrl_pos 0
+#define reg_p_dbg_ctrl_len 3
+#define reg_p_dbg_ctrl_lsb 0
+#define    p_reg_p_data_swap    0xDD26
+#define reg_p_data_swap_pos 0
+#define reg_p_data_swap_len 2
+#define reg_p_data_swap_lsb 0
+#define    p_reg_ep_rx_addr 0xDD80
+#define reg_ep_rx_addr_pos 2
+#define reg_ep_rx_addr_len 6
+#define reg_ep_rx_addr_lsb 0
+#define    p_reg_ep0_tx_addr    0xDD81
+#define reg_ep0_tx_addr_pos 2
+#define reg_ep0_tx_addr_len 6
+#define reg_ep0_tx_addr_lsb 0
+#define    p_reg_ep1_tx_addr    0xDD82
+#define reg_ep1_tx_addr_pos 2
+#define reg_ep1_tx_addr_len 6
+#define reg_ep1_tx_addr_lsb 0
+#define    p_reg_ep3_tx_addr    0xDD83
+#define reg_ep3_tx_addr_pos 2
+#define reg_ep3_tx_addr_len 6
+#define reg_ep3_tx_addr_lsb 0
+#define    p_reg_ep_rx_len  0xDD84
+#define reg_ep_rx_len_pos 0
+#define reg_ep_rx_len_len 8
+#define reg_ep_rx_len_lsb 0
+#define    p_reg_ep0_tx_len 0xDD85
+#define reg_ep0_tx_len_pos 0
+#define reg_ep0_tx_len_len 8
+#define reg_ep0_tx_len_lsb 0
+#define    p_reg_ep1_tx_len 0xDD86
+#define reg_ep1_tx_len_pos 0
+#define reg_ep1_tx_len_len 8
+#define reg_ep1_tx_len_lsb 0
+#define    p_reg_ep3_tx_len 0xDD87
+#define reg_ep3_tx_len_pos 0
+#define reg_ep3_tx_len_len 8
+#define reg_ep3_tx_len_lsb 0
+#define    p_reg_ep4_tx_len_7_0 0xDD88
+#define reg_ep4_tx_len_7_0_pos 0
+#define reg_ep4_tx_len_7_0_len 8
+#define reg_ep4_tx_len_7_0_lsb 0
+#define    p_reg_ep4_tx_len_15_8    0xDD89
+#define reg_ep4_tx_len_15_8_pos 0
+#define reg_ep4_tx_len_15_8_len 8
+#define reg_ep4_tx_len_15_8_lsb 8
+#define    p_reg_ep5_tx_len_7_0 0xDD8A
+#define reg_ep5_tx_len_7_0_pos 0
+#define reg_ep5_tx_len_7_0_len 8
+#define reg_ep5_tx_len_7_0_lsb 0
+#define    p_reg_ep5_tx_len_15_8    0xDD8B
+#define reg_ep5_tx_len_15_8_pos 0
+#define reg_ep5_tx_len_15_8_len 8
+#define reg_ep5_tx_len_15_8_lsb 8
+#define    p_reg_usb_reset_addr 0xDD8C
+#define reg_usb_reset_addr_pos 0
+#define reg_usb_reset_addr_len 7
+#define reg_usb_reset_addr_lsb 0
+#define    p_reg_usb_reset  0xDD8C
+#define reg_usb_reset_pos 7
+#define reg_usb_reset_len 1
+#define reg_usb_reset_lsb 0
+#define    p_reg_usb_sync_in    0xDD8D
+#define reg_usb_sync_in_pos 0
+#define reg_usb_sync_in_len 1
+#define reg_usb_sync_in_lsb 0
+#define    p_reg_usb_sync_txready   0xDD8D
+#define reg_usb_sync_txready_pos 1
+#define reg_usb_sync_txready_len 1
+#define reg_usb_sync_txready_lsb 0
+#define    p_reg_utmi_phy_suspend   0xDD8D
+#define reg_utmi_phy_suspend_pos 2
+#define reg_utmi_phy_suspend_len 1
+#define reg_utmi_phy_suspend_lsb 0
+#define    p_reg_usb_min_len    0xDD8D
+#define reg_usb_min_len_pos 3
+#define reg_usb_min_len_len 1
+#define reg_usb_min_len_lsb 0
+#define    p_reg_usb_phy_clksel 0xDD8D
+#define reg_usb_phy_clksel_pos 4
+#define reg_usb_phy_clksel_len 1
+#define reg_usb_phy_clksel_lsb 0
+#define    p_reg_ep6_tx_len_7_0 0xDD8E
+#define reg_ep6_tx_len_7_0_pos 0
+#define reg_ep6_tx_len_7_0_len 8
+#define reg_ep6_tx_len_7_0_lsb 0
+#define    p_reg_ep6_tx_len_15_8    0xDD8F
+#define reg_ep6_tx_len_15_8_pos 0
+#define reg_ep6_tx_len_15_8_len 8
+#define reg_ep6_tx_len_15_8_lsb 8
+#define    p_reg_usb_clk_phase  0xDD93
+#define reg_usb_clk_phase_pos 0
+#define reg_usb_clk_phase_len 2
+#define reg_usb_clk_phase_lsb 0
+#define    p_reg_usb_clk_sel    0xDD93
+#define reg_usb_clk_sel_pos 4
+#define reg_usb_clk_sel_len 4
+#define reg_usb_clk_sel_lsb 0
+#define    p_reg_usb_fifo_ptr   0xDD94
+#define reg_usb_fifo_ptr_pos 0
+#define reg_usb_fifo_ptr_len 3
+#define reg_usb_fifo_ptr_lsb 0
+#define    p_reg_usb_fifo_byte  0xDD94
+#define reg_usb_fifo_byte_pos 3
+#define reg_usb_fifo_byte_len 2
+#define reg_usb_fifo_byte_lsb 0
+#define    p_reg_usb_fifo_sys   0xDD94
+#define reg_usb_fifo_sys_pos 5
+#define reg_usb_fifo_sys_len 1
+#define reg_usb_fifo_sys_lsb 0
+#define    p_usbdma_utmi_d_ctl_7_0  0xDD9E
+#define usbdma_utmi_d_ctl_7_0_pos 0
+#define usbdma_utmi_d_ctl_7_0_len 8
+#define usbdma_utmi_d_ctl_7_0_lsb 0
+#define    p_usbdma_utmi_d_ctl_13_8 0xDD9F
+#define usbdma_utmi_d_ctl_13_8_pos 0
+#define usbdma_utmi_d_ctl_13_8_len 6
+#define usbdma_utmi_d_ctl_13_8_lsb 8
+#define    p_usbdma_utmi_a_ctl_7_0  0xDDA0
+#define usbdma_utmi_a_ctl_7_0_pos 0
+#define usbdma_utmi_a_ctl_7_0_len 8
+#define usbdma_utmi_a_ctl_7_0_lsb 0
+#define    p_usbdma_utmi_a_ctl_15_8 0xDDA1
+#define usbdma_utmi_a_ctl_15_8_pos 0
+#define usbdma_utmi_a_ctl_15_8_len 8
+#define usbdma_utmi_a_ctl_15_8_lsb 8
+#define    p_usbdma_utmi_a_ctl_23_16    0xDDA2
+#define usbdma_utmi_a_ctl_23_16_pos 0
+#define usbdma_utmi_a_ctl_23_16_len 8
+#define usbdma_utmi_a_ctl_23_16_lsb 16
+#define    p_usbdma_utmi_a_ctl_31_24    0xDDA3
+#define usbdma_utmi_a_ctl_31_24_pos 0
+#define usbdma_utmi_a_ctl_31_24_len 8
+#define usbdma_utmi_a_ctl_31_24_lsb 24
+#define    p_usbdma_utmi_a_ctl_39_32    0xDDA4
+#define usbdma_utmi_a_ctl_39_32_pos 0
+#define usbdma_utmi_a_ctl_39_32_len 8
+#define usbdma_utmi_a_ctl_39_32_lsb 32
+#define    p_usbdma_utmi_a_ctl_47_40    0xDDA5
+#define usbdma_utmi_a_ctl_47_40_pos 0
+#define usbdma_utmi_a_ctl_47_40_len 8
+#define usbdma_utmi_a_ctl_47_40_lsb 40
+#define    p_usbdma_utmi_pwrmode    0xDDA6
+#define usbdma_utmi_pwrmode_pos 3
+#define usbdma_utmi_pwrmode_len 1
+#define usbdma_utmi_pwrmode_lsb 0
+#define    p_usbdma_utmi_test_out   0xDDA6
+#define usbdma_utmi_test_out_pos 4
+#define usbdma_utmi_test_out_len 1
+#define usbdma_utmi_test_out_lsb 0
+#define    p_usbdma_utmi_vbus_int_en    0xDDA7
+#define usbdma_utmi_vbus_int_en_pos 0
+#define usbdma_utmi_vbus_int_en_len 1
+#define usbdma_utmi_vbus_int_en_lsb 0
+#define    p_usbdma_utmi_vbus_int_pol   0xDDA7
+#define usbdma_utmi_vbus_int_pol_pos 1
+#define usbdma_utmi_vbus_int_pol_len 1
+#define usbdma_utmi_vbus_int_pol_lsb 0
+#define    r_usbdma_utmi_vbus_int   0xDDA8
+#define usbdma_utmi_vbus_int_pos 0
+#define usbdma_utmi_vbus_int_len 1
+#define usbdma_utmi_vbus_int_lsb 0
+#define    r_usbdma_utmi_vbus_status    0xDDA8
+#define usbdma_utmi_vbus_status_pos 1
+#define usbdma_utmi_vbus_status_len 1
+#define usbdma_utmi_vbus_status_lsb 0
+#define    r_usbdma_utmi_clkrdy 0xDDA8
+#define usbdma_utmi_clkrdy_pos 2
+#define usbdma_utmi_clkrdy_len 1
+#define usbdma_utmi_clkrdy_lsb 0
+#define    p_reg_p_usb_iso_ccir_rst 0xDDA9
+#define reg_p_usb_iso_ccir_rst_pos 0
+#define reg_p_usb_iso_ccir_rst_len 1
+#define reg_p_usb_iso_ccir_rst_lsb 0
+#define    p_reg_p_usb_iso_ccir 0xDDA9
+#define reg_p_usb_iso_ccir_pos 1
+#define reg_p_usb_iso_ccir_len 1
+#define reg_p_usb_iso_ccir_lsb 0
+#define    p_reg_p_ccir_fix_en  0xDDAA
+#define reg_p_ccir_fix_en_pos 0
+#define reg_p_ccir_fix_en_len 1
+#define reg_p_ccir_fix_en_lsb 0
+#define    p_ir_sys_clk 0xDF80
+#define ir_sys_clk_pos 0
+#define ir_sys_clk_len 8
+#define ir_sys_clk_lsb 0
+#define    p_ir_sample_clk  0xDF81
+#define ir_sample_clk_pos 0
+#define ir_sample_clk_len 2
+#define ir_sample_clk_lsb 0
+#define    p_ir_idle_polarity   0xDF81
+#define ir_idle_polarity_pos 2
+#define ir_idle_polarity_len 1
+#define ir_idle_polarity_lsb 0
+#define    p_ir_fifo_ovfl   0xDF82
+#define ir_fifo_ovfl_pos 0
+#define ir_fifo_ovfl_len 1
+#define ir_fifo_ovfl_lsb 0
+#define    r_ir_fifo_empty  0xDF82
+#define ir_fifo_empty_pos 1
+#define ir_fifo_empty_len 1
+#define ir_fifo_empty_lsb 0
+#define    r_ir_fifo_cnt    0xDF82
+#define ir_fifo_cnt_pos 2
+#define ir_fifo_cnt_len 3
+#define ir_fifo_cnt_lsb 0
+#define    p_ir_fifo_rst    0xDF82
+#define ir_fifo_rst_pos 5
+#define ir_fifo_rst_len 1
+#define ir_fifo_rst_lsb 0
+#define    p_reg_ir_out_th0_7_0 0xDF84
+#define reg_ir_out_th0_7_0_pos 0
+#define reg_ir_out_th0_7_0_len 8
+#define reg_ir_out_th0_7_0_lsb 0
+#define    p_reg_ir_out_th0_14_8    0xDF85
+#define reg_ir_out_th0_14_8_pos 0
+#define reg_ir_out_th0_14_8_len 7
+#define reg_ir_out_th0_14_8_lsb 8
+#define    p_reg_ir_out_th1_7_0 0xDF86
+#define reg_ir_out_th1_7_0_pos 0
+#define reg_ir_out_th1_7_0_len 8
+#define reg_ir_out_th1_7_0_lsb 0
+#define    p_reg_ir_out_th1_14_8    0xDF87
+#define reg_ir_out_th1_14_8_pos 0
+#define reg_ir_out_th1_14_8_len 7
+#define reg_ir_out_th1_14_8_lsb 8
+#define    p_reg_ir_out_th2_7_0 0xDF88
+#define reg_ir_out_th2_7_0_pos 0
+#define reg_ir_out_th2_7_0_len 8
+#define reg_ir_out_th2_7_0_lsb 0
+#define    p_reg_ir_out_th2_14_8    0xDF89
+#define reg_ir_out_th2_14_8_pos 0
+#define reg_ir_out_th2_14_8_len 7
+#define reg_ir_out_th2_14_8_lsb 8
+#define    p_reg_ir_out_th3_7_0 0xDF8A
+#define reg_ir_out_th3_7_0_pos 0
+#define reg_ir_out_th3_7_0_len 8
+#define reg_ir_out_th3_7_0_lsb 0
+#define    p_reg_ir_out_th3_14_8    0xDF8B
+#define reg_ir_out_th3_14_8_pos 0
+#define reg_ir_out_th3_14_8_len 7
+#define reg_ir_out_th3_14_8_lsb 8
+#define    p_reg_ir_out_th4_7_0 0xDF8C
+#define reg_ir_out_th4_7_0_pos 0
+#define reg_ir_out_th4_7_0_len 8
+#define reg_ir_out_th4_7_0_lsb 0
+#define    p_reg_ir_out_th4_14_8    0xDF8D
+#define reg_ir_out_th4_14_8_pos 0
+#define reg_ir_out_th4_14_8_len 7
+#define reg_ir_out_th4_14_8_lsb 8
+#define    p_reg_ir_out_th5_7_0 0xDF8E
+#define reg_ir_out_th5_7_0_pos 0
+#define reg_ir_out_th5_7_0_len 8
+#define reg_ir_out_th5_7_0_lsb 0
+#define    p_reg_ir_out_th5_14_8    0xDF8F
+#define reg_ir_out_th5_14_8_pos 0
+#define reg_ir_out_th5_14_8_len 7
+#define reg_ir_out_th5_14_8_lsb 8
+#define    p_reg_ir_out_th6_7_0 0xDF90
+#define reg_ir_out_th6_7_0_pos 0
+#define reg_ir_out_th6_7_0_len 8
+#define reg_ir_out_th6_7_0_lsb 0
+#define    p_reg_ir_out_th6_14_8    0xDF91
+#define reg_ir_out_th6_14_8_pos 0
+#define reg_ir_out_th6_14_8_len 7
+#define reg_ir_out_th6_14_8_lsb 8
+#define    p_reg_ir_out_th7_7_0 0xDF92
+#define reg_ir_out_th7_7_0_pos 0
+#define reg_ir_out_th7_7_0_len 8
+#define reg_ir_out_th7_7_0_lsb 0
+#define    p_reg_ir_out_th7_14_8    0xDF93
+#define reg_ir_out_th7_14_8_pos 0
+#define reg_ir_out_th7_14_8_len 7
+#define reg_ir_out_th7_14_8_lsb 8
+#define    p_reg_ir_out_th8_7_0 0xDF94
+#define reg_ir_out_th8_7_0_pos 0
+#define reg_ir_out_th8_7_0_len 8
+#define reg_ir_out_th8_7_0_lsb 0
+#define    p_reg_ir_out_th8_14_8    0xDF95
+#define reg_ir_out_th8_14_8_pos 0
+#define reg_ir_out_th8_14_8_len 7
+#define reg_ir_out_th8_14_8_lsb 8
+#define    p_reg_ir_out_th9_7_0 0xDF96
+#define reg_ir_out_th9_7_0_pos 0
+#define reg_ir_out_th9_7_0_len 8
+#define reg_ir_out_th9_7_0_lsb 0
+#define    p_reg_ir_out_th9_14_8    0xDF97
+#define reg_ir_out_th9_14_8_pos 0
+#define reg_ir_out_th9_14_8_len 7
+#define reg_ir_out_th9_14_8_lsb 8
+#define    p_reg_ir_out_th10_7_0    0xDF98
+#define reg_ir_out_th10_7_0_pos 0
+#define reg_ir_out_th10_7_0_len 8
+#define reg_ir_out_th10_7_0_lsb 0
+#define    p_reg_ir_out_th10_14_8   0xDF99
+#define reg_ir_out_th10_14_8_pos 0
+#define reg_ir_out_th10_14_8_len 7
+#define reg_ir_out_th10_14_8_lsb 8
+#define    p_reg_ir_out_th11_7_0    0xDF9A
+#define reg_ir_out_th11_7_0_pos 0
+#define reg_ir_out_th11_7_0_len 8
+#define reg_ir_out_th11_7_0_lsb 0
+#define    p_reg_ir_out_th11_14_8   0xDF9B
+#define reg_ir_out_th11_14_8_pos 0
+#define reg_ir_out_th11_14_8_len 7
+#define reg_ir_out_th11_14_8_lsb 8
+#define    p_reg_ir_out_th12_7_0    0xDF9C
+#define reg_ir_out_th12_7_0_pos 0
+#define reg_ir_out_th12_7_0_len 8
+#define reg_ir_out_th12_7_0_lsb 0
+#define    p_reg_ir_out_th12_14_8   0xDF9D
+#define reg_ir_out_th12_14_8_pos 0
+#define reg_ir_out_th12_14_8_len 7
+#define reg_ir_out_th12_14_8_lsb 8
+#define    p_reg_ir_out_th13_7_0    0xDF9E
+#define reg_ir_out_th13_7_0_pos 0
+#define reg_ir_out_th13_7_0_len 8
+#define reg_ir_out_th13_7_0_lsb 0
+#define    p_reg_ir_out_th13_14_8   0xDF9F
+#define reg_ir_out_th13_14_8_pos 0
+#define reg_ir_out_th13_14_8_len 7
+#define reg_ir_out_th13_14_8_lsb 8
+#define    p_reg_ir_out_th14_7_0    0xDFA0
+#define reg_ir_out_th14_7_0_pos 0
+#define reg_ir_out_th14_7_0_len 8
+#define reg_ir_out_th14_7_0_lsb 0
+#define    p_reg_ir_out_th14_14_8   0xDFA1
+#define reg_ir_out_th14_14_8_pos 0
+#define reg_ir_out_th14_14_8_len 7
+#define reg_ir_out_th14_14_8_lsb 8
+#define    p_reg_tuner_data_7_0 0xF000
+#define reg_tuner_data_7_0_pos 0
+#define reg_tuner_data_7_0_len 8
+#define reg_tuner_data_7_0_lsb 0
+#define    p_reg_tuner_data_15_8    0xF001
+#define reg_tuner_data_15_8_pos 0
+#define reg_tuner_data_15_8_len 8
+#define reg_tuner_data_15_8_lsb 8
+#define    p_reg_tuner_data_23_16   0xF002
+#define reg_tuner_data_23_16_pos 0
+#define reg_tuner_data_23_16_len 8
+#define reg_tuner_data_23_16_lsb 16
+#define    p_reg_tuner_data_31_24   0xF003
+#define reg_tuner_data_31_24_pos 0
+#define reg_tuner_data_31_24_len 8
+#define reg_tuner_data_31_24_lsb 24
+#define    p_reg_tuner_data_39_32   0xF004
+#define reg_tuner_data_39_32_pos 0
+#define reg_tuner_data_39_32_len 8
+#define reg_tuner_data_39_32_lsb 32
+#define    p_reg_tuner_data_47_40   0xF005
+#define reg_tuner_data_47_40_pos 0
+#define reg_tuner_data_47_40_len 8
+#define reg_tuner_data_47_40_lsb 40
+#define    p_reg_tuner_data_55_48   0xF006
+#define reg_tuner_data_55_48_pos 0
+#define reg_tuner_data_55_48_len 8
+#define reg_tuner_data_55_48_lsb 48
+#define    p_reg_tuner_data_63_56   0xF007
+#define reg_tuner_data_63_56_pos 0
+#define reg_tuner_data_63_56_len 8
+#define reg_tuner_data_63_56_lsb 56
+#define    p_reg_tuner_data_71_64   0xF008
+#define reg_tuner_data_71_64_pos 0
+#define reg_tuner_data_71_64_len 8
+#define reg_tuner_data_71_64_lsb 64
+#define    p_reg_tuner_data_79_72   0xF009
+#define reg_tuner_data_79_72_pos 0
+#define reg_tuner_data_79_72_len 8
+#define reg_tuner_data_79_72_lsb 72
+#define    p_reg_tuner_data_87_80   0xF00A
+#define reg_tuner_data_87_80_pos 0
+#define reg_tuner_data_87_80_len 8
+#define reg_tuner_data_87_80_lsb 80
+#define    p_reg_tuner_data_95_88   0xF00B
+#define reg_tuner_data_95_88_pos 0
+#define reg_tuner_data_95_88_len 8
+#define reg_tuner_data_95_88_lsb 88
+#define    p_reg_tuner_data_103_96  0xF00C
+#define reg_tuner_data_103_96_pos 0
+#define reg_tuner_data_103_96_len 8
+#define reg_tuner_data_103_96_lsb 96
+#define    p_reg_tuner_data_111_104 0xF00D
+#define reg_tuner_data_111_104_pos 0
+#define reg_tuner_data_111_104_len 8
+#define reg_tuner_data_111_104_lsb 104
+#define    p_reg_tuner_data_119_112 0xF00E
+#define reg_tuner_data_119_112_pos 0
+#define reg_tuner_data_119_112_len 8
+#define reg_tuner_data_119_112_lsb 112
+#define    p_reg_tuner_data_127_120 0xF00F
+#define reg_tuner_data_127_120_pos 0
+#define reg_tuner_data_127_120_len 8
+#define reg_tuner_data_127_120_lsb 120
+#define    p_reg_tuner_data_135_128 0xF010
+#define reg_tuner_data_135_128_pos 0
+#define reg_tuner_data_135_128_len 8
+#define reg_tuner_data_135_128_lsb 128
+#define    p_reg_tuner_data_143_136 0xF011
+#define reg_tuner_data_143_136_pos 0
+#define reg_tuner_data_143_136_len 8
+#define reg_tuner_data_143_136_lsb 136
+#define    p_reg_tuner_data_151_144 0xF012
+#define reg_tuner_data_151_144_pos 0
+#define reg_tuner_data_151_144_len 8
+#define reg_tuner_data_151_144_lsb 144
+#define    p_reg_tuner_data_159_152 0xF013
+#define reg_tuner_data_159_152_pos 0
+#define reg_tuner_data_159_152_len 8
+#define reg_tuner_data_159_152_lsb 152
+#define    p_reg_tuner_data_167_160 0xF014
+#define reg_tuner_data_167_160_pos 0
+#define reg_tuner_data_167_160_len 8
+#define reg_tuner_data_167_160_lsb 160
+#define    p_reg_tuner_data_175_168 0xF015
+#define reg_tuner_data_175_168_pos 0
+#define reg_tuner_data_175_168_len 8
+#define reg_tuner_data_175_168_lsb 168
+#define    p_reg_tuner_data_183_176 0xF016
+#define reg_tuner_data_183_176_pos 0
+#define reg_tuner_data_183_176_len 8
+#define reg_tuner_data_183_176_lsb 176
+#define    p_reg_tuner_data_191_184 0xF017
+#define reg_tuner_data_191_184_pos 0
+#define reg_tuner_data_191_184_len 8
+#define reg_tuner_data_191_184_lsb 184
+#define    p_reg_tuner_data_199_192 0xF018
+#define reg_tuner_data_199_192_pos 0
+#define reg_tuner_data_199_192_len 8
+#define reg_tuner_data_199_192_lsb 192
+#define    p_reg_tuner_data_207_200 0xF019
+#define reg_tuner_data_207_200_pos 0
+#define reg_tuner_data_207_200_len 8
+#define reg_tuner_data_207_200_lsb 200
+#define    p_reg_tuner_data_215_208 0xF01A
+#define reg_tuner_data_215_208_pos 0
+#define reg_tuner_data_215_208_len 8
+#define reg_tuner_data_215_208_lsb 208
+#define    p_reg_tuner_data_223_216 0xF01B
+#define reg_tuner_data_223_216_pos 0
+#define reg_tuner_data_223_216_len 8
+#define reg_tuner_data_223_216_lsb 216
+#define    p_reg_tuner_data_231_224 0xF01C
+#define reg_tuner_data_231_224_pos 0
+#define reg_tuner_data_231_224_len 8
+#define reg_tuner_data_231_224_lsb 224
+#define    p_reg_tuner_data_239_232 0xF01D
+#define reg_tuner_data_239_232_pos 0
+#define reg_tuner_data_239_232_len 8
+#define reg_tuner_data_239_232_lsb 232
+#define    p_reg_tuner_data_247_240 0xF01E
+#define reg_tuner_data_247_240_pos 0
+#define reg_tuner_data_247_240_len 8
+#define reg_tuner_data_247_240_lsb 240
+#define    p_reg_tuner_data_255_248 0xF01F
+#define reg_tuner_data_255_248_pos 0
+#define reg_tuner_data_255_248_len 8
+#define reg_tuner_data_255_248_lsb 248
+#define    p_reg_tuner_data_263_256 0xF020
+#define reg_tuner_data_263_256_pos 0
+#define reg_tuner_data_263_256_len 8
+#define reg_tuner_data_263_256_lsb 256
+#define    p_reg_tuner_data_271_264 0xF021
+#define reg_tuner_data_271_264_pos 0
+#define reg_tuner_data_271_264_len 8
+#define reg_tuner_data_271_264_lsb 264
+#define    p_reg_tuner_data_279_272 0xF022
+#define reg_tuner_data_279_272_pos 0
+#define reg_tuner_data_279_272_len 8
+#define reg_tuner_data_279_272_lsb 272
+#define    p_reg_tuner_data_287_280 0xF023
+#define reg_tuner_data_287_280_pos 0
+#define reg_tuner_data_287_280_len 8
+#define reg_tuner_data_287_280_lsb 280
+#define    p_reg_tuner_data_295_288 0xF024
+#define reg_tuner_data_295_288_pos 0
+#define reg_tuner_data_295_288_len 8
+#define reg_tuner_data_295_288_lsb 288
+#define    p_reg_tuner_data_303_296 0xF025
+#define reg_tuner_data_303_296_pos 0
+#define reg_tuner_data_303_296_len 8
+#define reg_tuner_data_303_296_lsb 296
+#define    p_reg_tuner_data_311_304 0xF026
+#define reg_tuner_data_311_304_pos 0
+#define reg_tuner_data_311_304_len 8
+#define reg_tuner_data_311_304_lsb 304
+#define    p_reg_tuner_data_319_312 0xF027
+#define reg_tuner_data_319_312_pos 0
+#define reg_tuner_data_319_312_len 8
+#define reg_tuner_data_319_312_lsb 312
+#define    p_reg_tuner_data_327_320 0xF028
+#define reg_tuner_data_327_320_pos 0
+#define reg_tuner_data_327_320_len 8
+#define reg_tuner_data_327_320_lsb 320
+#define    p_reg_tuner_data_335_328 0xF029
+#define reg_tuner_data_335_328_pos 0
+#define reg_tuner_data_335_328_len 8
+#define reg_tuner_data_335_328_lsb 328
+#define    p_reg_tuner_data_343_336 0xF02A
+#define reg_tuner_data_343_336_pos 0
+#define reg_tuner_data_343_336_len 8
+#define reg_tuner_data_343_336_lsb 336
+#define    p_reg_tuner_data_351_344 0xF02B
+#define reg_tuner_data_351_344_pos 0
+#define reg_tuner_data_351_344_len 8
+#define reg_tuner_data_351_344_lsb 344
+#define    p_reg_tuner_data_359_352 0xF02C
+#define reg_tuner_data_359_352_pos 0
+#define reg_tuner_data_359_352_len 8
+#define reg_tuner_data_359_352_lsb 352
+#define    p_reg_tuner_data_367_360 0xF02D
+#define reg_tuner_data_367_360_pos 0
+#define reg_tuner_data_367_360_len 8
+#define reg_tuner_data_367_360_lsb 360
+#define    p_reg_tuner_data_375_368 0xF02E
+#define reg_tuner_data_375_368_pos 0
+#define reg_tuner_data_375_368_len 8
+#define reg_tuner_data_375_368_lsb 368
+#define    p_reg_tuner_data_383_376 0xF02F
+#define reg_tuner_data_383_376_pos 0
+#define reg_tuner_data_383_376_len 8
+#define reg_tuner_data_383_376_lsb 376
+#define    p_reg_tuner_data_391_384 0xF030
+#define reg_tuner_data_391_384_pos 0
+#define reg_tuner_data_391_384_len 8
+#define reg_tuner_data_391_384_lsb 384
+#define    p_reg_tuner_data_399_392 0xF031
+#define reg_tuner_data_399_392_pos 0
+#define reg_tuner_data_399_392_len 8
+#define reg_tuner_data_399_392_lsb 392
+#define    p_reg_tuner_data_407_400 0xF032
+#define reg_tuner_data_407_400_pos 0
+#define reg_tuner_data_407_400_len 8
+#define reg_tuner_data_407_400_lsb 400
+#define    p_reg_tuner_data_415_408 0xF033
+#define reg_tuner_data_415_408_pos 0
+#define reg_tuner_data_415_408_len 8
+#define reg_tuner_data_415_408_lsb 408
+#define    p_reg_tuner_data_423_416 0xF034
+#define reg_tuner_data_423_416_pos 0
+#define reg_tuner_data_423_416_len 8
+#define reg_tuner_data_423_416_lsb 416
+#define    p_reg_tuner_data_431_424 0xF035
+#define reg_tuner_data_431_424_pos 0
+#define reg_tuner_data_431_424_len 8
+#define reg_tuner_data_431_424_lsb 424
+#define    p_reg_tuner_data_439_432 0xF036
+#define reg_tuner_data_439_432_pos 0
+#define reg_tuner_data_439_432_len 8
+#define reg_tuner_data_439_432_lsb 432
+#define    p_reg_tuner_data_447_440 0xF037
+#define reg_tuner_data_447_440_pos 0
+#define reg_tuner_data_447_440_len 8
+#define reg_tuner_data_447_440_lsb 440
+#define    p_reg_tuner_data_455_448 0xF038
+#define reg_tuner_data_455_448_pos 0
+#define reg_tuner_data_455_448_len 8
+#define reg_tuner_data_455_448_lsb 448
+#define    p_reg_tuner_data_463_456 0xF039
+#define reg_tuner_data_463_456_pos 0
+#define reg_tuner_data_463_456_len 8
+#define reg_tuner_data_463_456_lsb 456
+#define    p_reg_tuner_data_471_464 0xF03A
+#define reg_tuner_data_471_464_pos 0
+#define reg_tuner_data_471_464_len 8
+#define reg_tuner_data_471_464_lsb 464
+#define    p_reg_tuner_data_479_472 0xF03B
+#define reg_tuner_data_479_472_pos 0
+#define reg_tuner_data_479_472_len 8
+#define reg_tuner_data_479_472_lsb 472
+#define    p_reg_tuner_data_487_480 0xF03C
+#define reg_tuner_data_487_480_pos 0
+#define reg_tuner_data_487_480_len 8
+#define reg_tuner_data_487_480_lsb 480
+#define    p_reg_tuner_data_495_488 0xF03D
+#define reg_tuner_data_495_488_pos 0
+#define reg_tuner_data_495_488_len 8
+#define reg_tuner_data_495_488_lsb 488
+#define    p_reg_tuner_data_503_496 0xF03E
+#define reg_tuner_data_503_496_pos 0
+#define reg_tuner_data_503_496_len 8
+#define reg_tuner_data_503_496_lsb 496
+#define    p_reg_tuner_data_511_504 0xF03F
+#define reg_tuner_data_511_504_pos 0
+#define reg_tuner_data_511_504_len 8
+#define reg_tuner_data_511_504_lsb 504
+#define    p_reg_tuner_data_519_512 0xF040
+#define reg_tuner_data_519_512_pos 0
+#define reg_tuner_data_519_512_len 8
+#define reg_tuner_data_519_512_lsb 512
+#define    p_reg_tuner_data_527_520 0xF041
+#define reg_tuner_data_527_520_pos 0
+#define reg_tuner_data_527_520_len 8
+#define reg_tuner_data_527_520_lsb 520
+#define    p_reg_tuner_data_535_528 0xF042
+#define reg_tuner_data_535_528_pos 0
+#define reg_tuner_data_535_528_len 8
+#define reg_tuner_data_535_528_lsb 528
+#define    p_reg_tuner_data_543_536 0xF043
+#define reg_tuner_data_543_536_pos 0
+#define reg_tuner_data_543_536_len 8
+#define reg_tuner_data_543_536_lsb 536
+#define    p_reg_tuner_data_551_544 0xF044
+#define reg_tuner_data_551_544_pos 0
+#define reg_tuner_data_551_544_len 8
+#define reg_tuner_data_551_544_lsb 544
+#define    p_reg_tuner_data_559_552 0xF045
+#define reg_tuner_data_559_552_pos 0
+#define reg_tuner_data_559_552_len 8
+#define reg_tuner_data_559_552_lsb 552
+#define    p_reg_tuner_data_567_560 0xF046
+#define reg_tuner_data_567_560_pos 0
+#define reg_tuner_data_567_560_len 8
+#define reg_tuner_data_567_560_lsb 560
+#define    p_reg_tuner_data_575_568 0xF047
+#define reg_tuner_data_575_568_pos 0
+#define reg_tuner_data_575_568_len 8
+#define reg_tuner_data_575_568_lsb 568
+#define    p_reg_tuner_data_583_576 0xF048
+#define reg_tuner_data_583_576_pos 0
+#define reg_tuner_data_583_576_len 8
+#define reg_tuner_data_583_576_lsb 576
+#define    p_reg_tuner_data_591_584 0xF049
+#define reg_tuner_data_591_584_pos 0
+#define reg_tuner_data_591_584_len 8
+#define reg_tuner_data_591_584_lsb 584
+#define    p_reg_tuner_data_599_592 0xF04A
+#define reg_tuner_data_599_592_pos 0
+#define reg_tuner_data_599_592_len 8
+#define reg_tuner_data_599_592_lsb 592
+#define    p_reg_tuner_data_607_600 0xF04B
+#define reg_tuner_data_607_600_pos 0
+#define reg_tuner_data_607_600_len 8
+#define reg_tuner_data_607_600_lsb 600
+#define    p_reg_tuner_data_615_608 0xF04C
+#define reg_tuner_data_615_608_pos 0
+#define reg_tuner_data_615_608_len 8
+#define reg_tuner_data_615_608_lsb 608
+#define    p_reg_tuner_data_623_616 0xF04D
+#define reg_tuner_data_623_616_pos 0
+#define reg_tuner_data_623_616_len 8
+#define reg_tuner_data_623_616_lsb 616
+#define    p_reg_tuner_data_631_624 0xF04E
+#define reg_tuner_data_631_624_pos 0
+#define reg_tuner_data_631_624_len 8
+#define reg_tuner_data_631_624_lsb 624
+#define    p_reg_tuner_data_639_632 0xF04F
+#define reg_tuner_data_639_632_pos 0
+#define reg_tuner_data_639_632_len 8
+#define reg_tuner_data_639_632_lsb 632
+#define    p_reg_tuner_data_647_640 0xF050
+#define reg_tuner_data_647_640_pos 0
+#define reg_tuner_data_647_640_len 8
+#define reg_tuner_data_647_640_lsb 640
+#define    p_reg_tuner_data_655_648 0xF051
+#define reg_tuner_data_655_648_pos 0
+#define reg_tuner_data_655_648_len 8
+#define reg_tuner_data_655_648_lsb 648
+#define    p_reg_tuner_data_663_656 0xF052
+#define reg_tuner_data_663_656_pos 0
+#define reg_tuner_data_663_656_len 8
+#define reg_tuner_data_663_656_lsb 656
+#define    p_reg_tuner_data_671_664 0xF053
+#define reg_tuner_data_671_664_pos 0
+#define reg_tuner_data_671_664_len 8
+#define reg_tuner_data_671_664_lsb 664
+#define    p_reg_tuner_data_679_672 0xF054
+#define reg_tuner_data_679_672_pos 0
+#define reg_tuner_data_679_672_len 8
+#define reg_tuner_data_679_672_lsb 672
+#define    p_reg_tuner_data_687_680 0xF055
+#define reg_tuner_data_687_680_pos 0
+#define reg_tuner_data_687_680_len 8
+#define reg_tuner_data_687_680_lsb 680
+#define    p_reg_tuner_data_695_688 0xF056
+#define reg_tuner_data_695_688_pos 0
+#define reg_tuner_data_695_688_len 8
+#define reg_tuner_data_695_688_lsb 688
+#define    p_reg_tuner_data_703_696 0xF057
+#define reg_tuner_data_703_696_pos 0
+#define reg_tuner_data_703_696_len 8
+#define reg_tuner_data_703_696_lsb 696
+#define    p_reg_tuner_data_711_704 0xF058
+#define reg_tuner_data_711_704_pos 0
+#define reg_tuner_data_711_704_len 8
+#define reg_tuner_data_711_704_lsb 704
+#define    p_reg_tuner_data_719_712 0xF059
+#define reg_tuner_data_719_712_pos 0
+#define reg_tuner_data_719_712_len 8
+#define reg_tuner_data_719_712_lsb 712
+#define    p_reg_tuner_data_727_720 0xF05A
+#define reg_tuner_data_727_720_pos 0
+#define reg_tuner_data_727_720_len 8
+#define reg_tuner_data_727_720_lsb 720
+#define    p_reg_tuner_data_735_728 0xF05B
+#define reg_tuner_data_735_728_pos 0
+#define reg_tuner_data_735_728_len 8
+#define reg_tuner_data_735_728_lsb 728
+#define    p_reg_tuner_data_743_736 0xF05C
+#define reg_tuner_data_743_736_pos 0
+#define reg_tuner_data_743_736_len 8
+#define reg_tuner_data_743_736_lsb 736
+#define    p_reg_tuner_data_751_744 0xF05D
+#define reg_tuner_data_751_744_pos 0
+#define reg_tuner_data_751_744_len 8
+#define reg_tuner_data_751_744_lsb 744
+#define    p_reg_tuner_data_759_752 0xF05E
+#define reg_tuner_data_759_752_pos 0
+#define reg_tuner_data_759_752_len 8
+#define reg_tuner_data_759_752_lsb 752
+#define    p_reg_tuner_data_767_760 0xF05F
+#define reg_tuner_data_767_760_pos 0
+#define reg_tuner_data_767_760_len 8
+#define reg_tuner_data_767_760_lsb 760
+#define    p_reg_tuner_data_775_768 0xF060
+#define reg_tuner_data_775_768_pos 0
+#define reg_tuner_data_775_768_len 8
+#define reg_tuner_data_775_768_lsb 768
+#define    p_reg_tuner_data_783_776 0xF061
+#define reg_tuner_data_783_776_pos 0
+#define reg_tuner_data_783_776_len 8
+#define reg_tuner_data_783_776_lsb 776
+#define    p_reg_tuner_data_791_784 0xF062
+#define reg_tuner_data_791_784_pos 0
+#define reg_tuner_data_791_784_len 8
+#define reg_tuner_data_791_784_lsb 784
+#define    p_reg_tuner_data_799_792 0xF063
+#define reg_tuner_data_799_792_pos 0
+#define reg_tuner_data_799_792_len 8
+#define reg_tuner_data_799_792_lsb 792
+#define    p_reg_tuner_data_807_800 0xF064
+#define reg_tuner_data_807_800_pos 0
+#define reg_tuner_data_807_800_len 8
+#define reg_tuner_data_807_800_lsb 800
+#define    p_reg_tuner_data_815_808 0xF065
+#define reg_tuner_data_815_808_pos 0
+#define reg_tuner_data_815_808_len 8
+#define reg_tuner_data_815_808_lsb 808
+#define    p_reg_tuner_data_823_816 0xF066
+#define reg_tuner_data_823_816_pos 0
+#define reg_tuner_data_823_816_len 8
+#define reg_tuner_data_823_816_lsb 816
+#define    p_reg_tuner_data_831_824 0xF067
+#define reg_tuner_data_831_824_pos 0
+#define reg_tuner_data_831_824_len 8
+#define reg_tuner_data_831_824_lsb 824
+#define    p_reg_tuner_data_839_832 0xF068
+#define reg_tuner_data_839_832_pos 0
+#define reg_tuner_data_839_832_len 8
+#define reg_tuner_data_839_832_lsb 832
+#define    p_reg_tuner_data_847_840 0xF069
+#define reg_tuner_data_847_840_pos 0
+#define reg_tuner_data_847_840_len 8
+#define reg_tuner_data_847_840_lsb 840
+#define    p_reg_tuner_data_855_848 0xF06A
+#define reg_tuner_data_855_848_pos 0
+#define reg_tuner_data_855_848_len 8
+#define reg_tuner_data_855_848_lsb 848
+#define    p_reg_tuner_data_863_856 0xF06B
+#define reg_tuner_data_863_856_pos 0
+#define reg_tuner_data_863_856_len 8
+#define reg_tuner_data_863_856_lsb 856
+#define    p_reg_tuner_data_871_864 0xF06C
+#define reg_tuner_data_871_864_pos 0
+#define reg_tuner_data_871_864_len 8
+#define reg_tuner_data_871_864_lsb 864
+#define    p_reg_tuner_data_879_872 0xF06D
+#define reg_tuner_data_879_872_pos 0
+#define reg_tuner_data_879_872_len 8
+#define reg_tuner_data_879_872_lsb 872
+#define    p_reg_tuner_data_887_880 0xF06E
+#define reg_tuner_data_887_880_pos 0
+#define reg_tuner_data_887_880_len 8
+#define reg_tuner_data_887_880_lsb 880
+#define    p_reg_tuner_data_895_888 0xF06F
+#define reg_tuner_data_895_888_pos 0
+#define reg_tuner_data_895_888_len 8
+#define reg_tuner_data_895_888_lsb 888
+#define    p_reg_tuner_data_903_896 0xF070
+#define reg_tuner_data_903_896_pos 0
+#define reg_tuner_data_903_896_len 8
+#define reg_tuner_data_903_896_lsb 896
+#define    p_reg_tuner_data_911_904 0xF071
+#define reg_tuner_data_911_904_pos 0
+#define reg_tuner_data_911_904_len 8
+#define reg_tuner_data_911_904_lsb 904
+#define    p_reg_tuner_data_919_912 0xF072
+#define reg_tuner_data_919_912_pos 0
+#define reg_tuner_data_919_912_len 8
+#define reg_tuner_data_919_912_lsb 912
+#define    p_reg_tuner_data_927_920 0xF073
+#define reg_tuner_data_927_920_pos 0
+#define reg_tuner_data_927_920_len 8
+#define reg_tuner_data_927_920_lsb 920
+#define    p_reg_tuner_data_935_928 0xF074
+#define reg_tuner_data_935_928_pos 0
+#define reg_tuner_data_935_928_len 8
+#define reg_tuner_data_935_928_lsb 928
+#define    p_reg_tuner_data_943_936 0xF075
+#define reg_tuner_data_943_936_pos 0
+#define reg_tuner_data_943_936_len 8
+#define reg_tuner_data_943_936_lsb 936
+#define    p_reg_tuner_data_951_944 0xF076
+#define reg_tuner_data_951_944_pos 0
+#define reg_tuner_data_951_944_len 8
+#define reg_tuner_data_951_944_lsb 944
+#define    p_reg_tuner_data_959_952 0xF077
+#define reg_tuner_data_959_952_pos 0
+#define reg_tuner_data_959_952_len 8
+#define reg_tuner_data_959_952_lsb 952
+#define    p_reg_tuner_data_967_960 0xF078
+#define reg_tuner_data_967_960_pos 0
+#define reg_tuner_data_967_960_len 8
+#define reg_tuner_data_967_960_lsb 960
+#define    p_reg_tuner_data_975_968 0xF079
+#define reg_tuner_data_975_968_pos 0
+#define reg_tuner_data_975_968_len 8
+#define reg_tuner_data_975_968_lsb 968
+#define    p_reg_tuner_data_983_976 0xF07A
+#define reg_tuner_data_983_976_pos 0
+#define reg_tuner_data_983_976_len 8
+#define reg_tuner_data_983_976_lsb 976
+#define    p_reg_tuner_data_991_984 0xF07B
+#define reg_tuner_data_991_984_pos 0
+#define reg_tuner_data_991_984_len 8
+#define reg_tuner_data_991_984_lsb 984
+#define    p_reg_tuner_data_999_992 0xF07C
+#define reg_tuner_data_999_992_pos 0
+#define reg_tuner_data_999_992_len 8
+#define reg_tuner_data_999_992_lsb 992
+#define    p_reg_tuner_data_1007_1000   0xF07D
+#define reg_tuner_data_1007_1000_pos 0
+#define reg_tuner_data_1007_1000_len 8
+#define reg_tuner_data_1007_1000_lsb 1000
+#define    p_reg_tuner_data_1015_1008   0xF07E
+#define reg_tuner_data_1015_1008_pos 0
+#define reg_tuner_data_1015_1008_len 8
+#define reg_tuner_data_1015_1008_lsb 1008
+#define    p_reg_tuner_data_1023_1016   0xF07F
+#define reg_tuner_data_1023_1016_pos 0
+#define reg_tuner_data_1023_1016_len 8
+#define reg_tuner_data_1023_1016_lsb 1016
+#define    p_reg_tuner_data_1031_1024   0xF080
+#define reg_tuner_data_1031_1024_pos 0
+#define reg_tuner_data_1031_1024_len 8
+#define reg_tuner_data_1031_1024_lsb 1024
+#define    p_reg_tuner_data_1039_1032   0xF081
+#define reg_tuner_data_1039_1032_pos 0
+#define reg_tuner_data_1039_1032_len 8
+#define reg_tuner_data_1039_1032_lsb 1032
+#define    p_reg_tuner_data_1047_1040   0xF082
+#define reg_tuner_data_1047_1040_pos 0
+#define reg_tuner_data_1047_1040_len 8
+#define reg_tuner_data_1047_1040_lsb 1040
+#define    p_reg_tuner_data_1055_1048   0xF083
+#define reg_tuner_data_1055_1048_pos 0
+#define reg_tuner_data_1055_1048_len 8
+#define reg_tuner_data_1055_1048_lsb 1048
+#define    p_reg_tuner_data_1063_1056   0xF084
+#define reg_tuner_data_1063_1056_pos 0
+#define reg_tuner_data_1063_1056_len 8
+#define reg_tuner_data_1063_1056_lsb 1056
+#define    p_reg_tuner_data_1071_1064   0xF085
+#define reg_tuner_data_1071_1064_pos 0
+#define reg_tuner_data_1071_1064_len 8
+#define reg_tuner_data_1071_1064_lsb 1064
+#define    p_reg_tuner_data_1079_1072   0xF086
+#define reg_tuner_data_1079_1072_pos 0
+#define reg_tuner_data_1079_1072_len 8
+#define reg_tuner_data_1079_1072_lsb 1072
+#define    p_reg_tuner_data_1087_1080   0xF087
+#define reg_tuner_data_1087_1080_pos 0
+#define reg_tuner_data_1087_1080_len 8
+#define reg_tuner_data_1087_1080_lsb 1080
+#define    p_reg_tuner_data_1095_1088   0xF088
+#define reg_tuner_data_1095_1088_pos 0
+#define reg_tuner_data_1095_1088_len 8
+#define reg_tuner_data_1095_1088_lsb 1088
+#define    p_reg_tuner_data_1103_1096   0xF089
+#define reg_tuner_data_1103_1096_pos 0
+#define reg_tuner_data_1103_1096_len 8
+#define reg_tuner_data_1103_1096_lsb 1096
+#define    p_reg_tuner_data_1111_1104   0xF08A
+#define reg_tuner_data_1111_1104_pos 0
+#define reg_tuner_data_1111_1104_len 8
+#define reg_tuner_data_1111_1104_lsb 1104
+#define    p_reg_tuner_data_1119_1112   0xF08B
+#define reg_tuner_data_1119_1112_pos 0
+#define reg_tuner_data_1119_1112_len 8
+#define reg_tuner_data_1119_1112_lsb 1112
+#define    p_reg_tuner_data_1127_1120   0xF08C
+#define reg_tuner_data_1127_1120_pos 0
+#define reg_tuner_data_1127_1120_len 8
+#define reg_tuner_data_1127_1120_lsb 1120
+#define    p_reg_tuner_data_1135_1128   0xF08D
+#define reg_tuner_data_1135_1128_pos 0
+#define reg_tuner_data_1135_1128_len 8
+#define reg_tuner_data_1135_1128_lsb 1128
+#define    p_reg_tuner_data_1143_1136   0xF08E
+#define reg_tuner_data_1143_1136_pos 0
+#define reg_tuner_data_1143_1136_len 8
+#define reg_tuner_data_1143_1136_lsb 1136
+#define    p_reg_tuner_data_1151_1144   0xF08F
+#define reg_tuner_data_1151_1144_pos 0
+#define reg_tuner_data_1151_1144_len 8
+#define reg_tuner_data_1151_1144_lsb 1144
+#define    p_reg_tuner_data_1159_1152   0xF090
+#define reg_tuner_data_1159_1152_pos 0
+#define reg_tuner_data_1159_1152_len 8
+#define reg_tuner_data_1159_1152_lsb 1152
+#define    p_reg_tuner_data_1167_1160   0xF091
+#define reg_tuner_data_1167_1160_pos 0
+#define reg_tuner_data_1167_1160_len 8
+#define reg_tuner_data_1167_1160_lsb 1160
+#define    p_reg_tuner_data_1175_1168   0xF092
+#define reg_tuner_data_1175_1168_pos 0
+#define reg_tuner_data_1175_1168_len 8
+#define reg_tuner_data_1175_1168_lsb 1168
+#define    p_reg_tuner_data_1183_1176   0xF093
+#define reg_tuner_data_1183_1176_pos 0
+#define reg_tuner_data_1183_1176_len 8
+#define reg_tuner_data_1183_1176_lsb 1176
+#define    p_reg_tuner_data_1191_1184   0xF094
+#define reg_tuner_data_1191_1184_pos 0
+#define reg_tuner_data_1191_1184_len 8
+#define reg_tuner_data_1191_1184_lsb 1184
+#define    p_reg_tuner_data_1199_1192   0xF095
+#define reg_tuner_data_1199_1192_pos 0
+#define reg_tuner_data_1199_1192_len 8
+#define reg_tuner_data_1199_1192_lsb 1192
+#define    p_reg_tuner_data_1207_1200   0xF096
+#define reg_tuner_data_1207_1200_pos 0
+#define reg_tuner_data_1207_1200_len 8
+#define reg_tuner_data_1207_1200_lsb 1200
+#define    p_reg_tuner_data_1215_1208   0xF097
+#define reg_tuner_data_1215_1208_pos 0
+#define reg_tuner_data_1215_1208_len 8
+#define reg_tuner_data_1215_1208_lsb 1208
+#define    p_reg_tuner_data_1223_1216   0xF098
+#define reg_tuner_data_1223_1216_pos 0
+#define reg_tuner_data_1223_1216_len 8
+#define reg_tuner_data_1223_1216_lsb 1216
+#define    p_reg_tuner_data_1231_1224   0xF099
+#define reg_tuner_data_1231_1224_pos 0
+#define reg_tuner_data_1231_1224_len 8
+#define reg_tuner_data_1231_1224_lsb 1224
+#define    p_reg_tuner_data_1239_1232   0xF09A
+#define reg_tuner_data_1239_1232_pos 0
+#define reg_tuner_data_1239_1232_len 8
+#define reg_tuner_data_1239_1232_lsb 1232
+#define    p_reg_tuner_data_1247_1240   0xF09B
+#define reg_tuner_data_1247_1240_pos 0
+#define reg_tuner_data_1247_1240_len 8
+#define reg_tuner_data_1247_1240_lsb 1240
+#define    p_reg_tuner_data_1255_1248   0xF09C
+#define reg_tuner_data_1255_1248_pos 0
+#define reg_tuner_data_1255_1248_len 8
+#define reg_tuner_data_1255_1248_lsb 1248
+#define    p_reg_tuner_data_1263_1256   0xF09D
+#define reg_tuner_data_1263_1256_pos 0
+#define reg_tuner_data_1263_1256_len 8
+#define reg_tuner_data_1263_1256_lsb 1256
+#define    p_reg_tuner_data_1271_1264   0xF09E
+#define reg_tuner_data_1271_1264_pos 0
+#define reg_tuner_data_1271_1264_len 8
+#define reg_tuner_data_1271_1264_lsb 1264
+#define    p_reg_tuner_data_1279_1272   0xF09F
+#define reg_tuner_data_1279_1272_pos 0
+#define reg_tuner_data_1279_1272_len 8
+#define reg_tuner_data_1279_1272_lsb 1272
+#define    p_reg_tuner_data_1287_1280   0xF0A0
+#define reg_tuner_data_1287_1280_pos 0
+#define reg_tuner_data_1287_1280_len 8
+#define reg_tuner_data_1287_1280_lsb 1280
+#define    p_reg_tuner_data_1295_1288   0xF0A1
+#define reg_tuner_data_1295_1288_pos 0
+#define reg_tuner_data_1295_1288_len 8
+#define reg_tuner_data_1295_1288_lsb 1288
+#define    p_reg_tuner_data_1303_1296   0xF0A2
+#define reg_tuner_data_1303_1296_pos 0
+#define reg_tuner_data_1303_1296_len 8
+#define reg_tuner_data_1303_1296_lsb 1296
+#define    p_reg_tuner_data_1311_1304   0xF0A3
+#define reg_tuner_data_1311_1304_pos 0
+#define reg_tuner_data_1311_1304_len 8
+#define reg_tuner_data_1311_1304_lsb 1304
+#define    p_reg_tuner_data_1319_1312   0xF0A4
+#define reg_tuner_data_1319_1312_pos 0
+#define reg_tuner_data_1319_1312_len 8
+#define reg_tuner_data_1319_1312_lsb 1312
+#define    p_reg_tuner_data_1327_1320   0xF0A5
+#define reg_tuner_data_1327_1320_pos 0
+#define reg_tuner_data_1327_1320_len 8
+#define reg_tuner_data_1327_1320_lsb 1320
+#define    p_reg_tuner_data_1335_1328   0xF0A6
+#define reg_tuner_data_1335_1328_pos 0
+#define reg_tuner_data_1335_1328_len 8
+#define reg_tuner_data_1335_1328_lsb 1328
+#define    p_reg_tuner_data_1343_1336   0xF0A7
+#define reg_tuner_data_1343_1336_pos 0
+#define reg_tuner_data_1343_1336_len 8
+#define reg_tuner_data_1343_1336_lsb 1336
+#define    p_reg_tuner_data_1351_1344   0xF0A8
+#define reg_tuner_data_1351_1344_pos 0
+#define reg_tuner_data_1351_1344_len 8
+#define reg_tuner_data_1351_1344_lsb 1344
+#define    p_reg_tuner_data_1359_1352   0xF0A9
+#define reg_tuner_data_1359_1352_pos 0
+#define reg_tuner_data_1359_1352_len 8
+#define reg_tuner_data_1359_1352_lsb 1352
+#define    p_reg_tuner_data_1367_1360   0xF0AA
+#define reg_tuner_data_1367_1360_pos 0
+#define reg_tuner_data_1367_1360_len 8
+#define reg_tuner_data_1367_1360_lsb 1360
+#define    p_reg_tuner_data_1375_1368   0xF0AB
+#define reg_tuner_data_1375_1368_pos 0
+#define reg_tuner_data_1375_1368_len 8
+#define reg_tuner_data_1375_1368_lsb 1368
+#define    p_reg_tuner_data_1383_1376   0xF0AC
+#define reg_tuner_data_1383_1376_pos 0
+#define reg_tuner_data_1383_1376_len 8
+#define reg_tuner_data_1383_1376_lsb 1376
+#define    p_reg_tuner_data_1391_1384   0xF0AD
+#define reg_tuner_data_1391_1384_pos 0
+#define reg_tuner_data_1391_1384_len 8
+#define reg_tuner_data_1391_1384_lsb 1384
+#define    p_reg_tuner_data_1399_1392   0xF0AE
+#define reg_tuner_data_1399_1392_pos 0
+#define reg_tuner_data_1399_1392_len 8
+#define reg_tuner_data_1399_1392_lsb 1392
+#define    p_reg_tuner_data_1407_1400   0xF0AF
+#define reg_tuner_data_1407_1400_pos 0
+#define reg_tuner_data_1407_1400_len 8
+#define reg_tuner_data_1407_1400_lsb 1400
+#define    p_reg_tuner_data_1415_1408   0xF0B0
+#define reg_tuner_data_1415_1408_pos 0
+#define reg_tuner_data_1415_1408_len 8
+#define reg_tuner_data_1415_1408_lsb 1408
+#define    p_reg_tuner_data_1423_1416   0xF0B1
+#define reg_tuner_data_1423_1416_pos 0
+#define reg_tuner_data_1423_1416_len 8
+#define reg_tuner_data_1423_1416_lsb 1416
+#define    p_reg_tuner_data_1431_1424   0xF0B2
+#define reg_tuner_data_1431_1424_pos 0
+#define reg_tuner_data_1431_1424_len 8
+#define reg_tuner_data_1431_1424_lsb 1424
+#define    p_reg_tuner_data_1439_1432   0xF0B3
+#define reg_tuner_data_1439_1432_pos 0
+#define reg_tuner_data_1439_1432_len 8
+#define reg_tuner_data_1439_1432_lsb 1432
+#define    p_reg_tuner_data_1447_1440   0xF0B4
+#define reg_tuner_data_1447_1440_pos 0
+#define reg_tuner_data_1447_1440_len 8
+#define reg_tuner_data_1447_1440_lsb 1440
+#define    p_reg_tuner_data_1455_1448   0xF0B5
+#define reg_tuner_data_1455_1448_pos 0
+#define reg_tuner_data_1455_1448_len 8
+#define reg_tuner_data_1455_1448_lsb 1448
+#define    p_reg_tuner_data_1463_1456   0xF0B6
+#define reg_tuner_data_1463_1456_pos 0
+#define reg_tuner_data_1463_1456_len 8
+#define reg_tuner_data_1463_1456_lsb 1456
+#define    p_reg_tuner_data_1471_1464   0xF0B7
+#define reg_tuner_data_1471_1464_pos 0
+#define reg_tuner_data_1471_1464_len 8
+#define reg_tuner_data_1471_1464_lsb 1464
+#define    p_reg_tuner_data_1479_1472   0xF0B8
+#define reg_tuner_data_1479_1472_pos 0
+#define reg_tuner_data_1479_1472_len 8
+#define reg_tuner_data_1479_1472_lsb 1472
+#define    p_reg_tuner_data_1487_1480   0xF0B9
+#define reg_tuner_data_1487_1480_pos 0
+#define reg_tuner_data_1487_1480_len 8
+#define reg_tuner_data_1487_1480_lsb 1480
+#define    p_reg_tuner_data_1495_1488   0xF0BA
+#define reg_tuner_data_1495_1488_pos 0
+#define reg_tuner_data_1495_1488_len 8
+#define reg_tuner_data_1495_1488_lsb 1488
+#define    p_reg_tuner_data_1503_1496   0xF0BB
+#define reg_tuner_data_1503_1496_pos 0
+#define reg_tuner_data_1503_1496_len 8
+#define reg_tuner_data_1503_1496_lsb 1496
+#define    p_reg_tuner_data_1511_1504   0xF0BC
+#define reg_tuner_data_1511_1504_pos 0
+#define reg_tuner_data_1511_1504_len 8
+#define reg_tuner_data_1511_1504_lsb 1504
+#define    p_reg_tuner_data_1519_1512   0xF0BD
+#define reg_tuner_data_1519_1512_pos 0
+#define reg_tuner_data_1519_1512_len 8
+#define reg_tuner_data_1519_1512_lsb 1512
+#define    p_reg_tuner_data_1527_1520   0xF0BE
+#define reg_tuner_data_1527_1520_pos 0
+#define reg_tuner_data_1527_1520_len 8
+#define reg_tuner_data_1527_1520_lsb 1520
+#define    p_reg_tuner_data_1535_1528   0xF0BF
+#define reg_tuner_data_1535_1528_pos 0
+#define reg_tuner_data_1535_1528_len 8
+#define reg_tuner_data_1535_1528_lsb 1528
+#define    p_reg_tuner_data_1543_1536   0xF0C0
+#define reg_tuner_data_1543_1536_pos 0
+#define reg_tuner_data_1543_1536_len 8
+#define reg_tuner_data_1543_1536_lsb 1536
+#define    p_reg_tuner_data_1551_1544   0xF0C1
+#define reg_tuner_data_1551_1544_pos 0
+#define reg_tuner_data_1551_1544_len 8
+#define reg_tuner_data_1551_1544_lsb 1544
+#define    p_reg_tuner_data_1559_1552   0xF0C2
+#define reg_tuner_data_1559_1552_pos 0
+#define reg_tuner_data_1559_1552_len 8
+#define reg_tuner_data_1559_1552_lsb 1552
+#define    p_reg_tuner_data_1567_1560   0xF0C3
+#define reg_tuner_data_1567_1560_pos 0
+#define reg_tuner_data_1567_1560_len 8
+#define reg_tuner_data_1567_1560_lsb 1560
+#define    p_reg_tuner_data_1575_1568   0xF0C4
+#define reg_tuner_data_1575_1568_pos 0
+#define reg_tuner_data_1575_1568_len 8
+#define reg_tuner_data_1575_1568_lsb 1568
+#define    p_reg_tuner_data_1583_1576   0xF0C5
+#define reg_tuner_data_1583_1576_pos 0
+#define reg_tuner_data_1583_1576_len 8
+#define reg_tuner_data_1583_1576_lsb 1576
+#define    p_reg_tuner_data_1591_1584   0xF0C6
+#define reg_tuner_data_1591_1584_pos 0
+#define reg_tuner_data_1591_1584_len 8
+#define reg_tuner_data_1591_1584_lsb 1584
+#define    p_reg_tuner_data_1599_1592   0xF0C7
+#define reg_tuner_data_1599_1592_pos 0
+#define reg_tuner_data_1599_1592_len 8
+#define reg_tuner_data_1599_1592_lsb 1592
+#define    p_reg_tuner_data_1607_1600   0xF0C8
+#define reg_tuner_data_1607_1600_pos 0
+#define reg_tuner_data_1607_1600_len 8
+#define reg_tuner_data_1607_1600_lsb 1600
+#define    p_reg_tuner_data_1615_1608   0xF0C9
+#define reg_tuner_data_1615_1608_pos 0
+#define reg_tuner_data_1615_1608_len 8
+#define reg_tuner_data_1615_1608_lsb 1608
+#define    p_reg_tuner_data_1623_1616   0xF0CA
+#define reg_tuner_data_1623_1616_pos 0
+#define reg_tuner_data_1623_1616_len 8
+#define reg_tuner_data_1623_1616_lsb 1616
+#define    p_reg_tuner_data_1631_1624   0xF0CB
+#define reg_tuner_data_1631_1624_pos 0
+#define reg_tuner_data_1631_1624_len 8
+#define reg_tuner_data_1631_1624_lsb 1624
+#define    p_reg_tuner_data_1639_1632   0xF0CC
+#define reg_tuner_data_1639_1632_pos 0
+#define reg_tuner_data_1639_1632_len 8
+#define reg_tuner_data_1639_1632_lsb 1632
+#define    p_reg_tuner_data_1647_1640   0xF0CD
+#define reg_tuner_data_1647_1640_pos 0
+#define reg_tuner_data_1647_1640_len 8
+#define reg_tuner_data_1647_1640_lsb 1640
+#define    p_reg_tuner_data_1655_1648   0xF0CE
+#define reg_tuner_data_1655_1648_pos 0
+#define reg_tuner_data_1655_1648_len 8
+#define reg_tuner_data_1655_1648_lsb 1648
+#define    p_reg_tuner_data_1663_1656   0xF0CF
+#define reg_tuner_data_1663_1656_pos 0
+#define reg_tuner_data_1663_1656_len 8
+#define reg_tuner_data_1663_1656_lsb 1656
+#define    p_reg_tuner_data_1671_1664   0xF0D0
+#define reg_tuner_data_1671_1664_pos 0
+#define reg_tuner_data_1671_1664_len 8
+#define reg_tuner_data_1671_1664_lsb 1664
+#define    p_reg_tuner_data_1679_1672   0xF0D1
+#define reg_tuner_data_1679_1672_pos 0
+#define reg_tuner_data_1679_1672_len 8
+#define reg_tuner_data_1679_1672_lsb 1672
+#define    p_reg_tuner_data_1687_1680   0xF0D2
+#define reg_tuner_data_1687_1680_pos 0
+#define reg_tuner_data_1687_1680_len 8
+#define reg_tuner_data_1687_1680_lsb 1680
+#define    p_reg_tuner_data_1695_1688   0xF0D3
+#define reg_tuner_data_1695_1688_pos 0
+#define reg_tuner_data_1695_1688_len 8
+#define reg_tuner_data_1695_1688_lsb 1688
+#define    p_reg_tuner_data_1703_1696   0xF0D4
+#define reg_tuner_data_1703_1696_pos 0
+#define reg_tuner_data_1703_1696_len 8
+#define reg_tuner_data_1703_1696_lsb 1696
+#define    p_reg_tuner_data_1711_1704   0xF0D5
+#define reg_tuner_data_1711_1704_pos 0
+#define reg_tuner_data_1711_1704_len 8
+#define reg_tuner_data_1711_1704_lsb 1704
+#define    p_reg_tuner_data_1719_1712   0xF0D6
+#define reg_tuner_data_1719_1712_pos 0
+#define reg_tuner_data_1719_1712_len 8
+#define reg_tuner_data_1719_1712_lsb 1712
+#define    p_reg_tuner_data_1727_1720   0xF0D7
+#define reg_tuner_data_1727_1720_pos 0
+#define reg_tuner_data_1727_1720_len 8
+#define reg_tuner_data_1727_1720_lsb 1720
+#define    p_reg_tuner_data_1735_1728   0xF0D8
+#define reg_tuner_data_1735_1728_pos 0
+#define reg_tuner_data_1735_1728_len 8
+#define reg_tuner_data_1735_1728_lsb 1728
+#define    p_reg_tuner_data_1743_1736   0xF0D9
+#define reg_tuner_data_1743_1736_pos 0
+#define reg_tuner_data_1743_1736_len 8
+#define reg_tuner_data_1743_1736_lsb 1736
+#define    p_reg_tuner_data_1751_1744   0xF0DA
+#define reg_tuner_data_1751_1744_pos 0
+#define reg_tuner_data_1751_1744_len 8
+#define reg_tuner_data_1751_1744_lsb 1744
+#define    p_reg_tuner_data_1759_1752   0xF0DB
+#define reg_tuner_data_1759_1752_pos 0
+#define reg_tuner_data_1759_1752_len 8
+#define reg_tuner_data_1759_1752_lsb 1752
+#define    p_reg_tuner_data_1767_1760   0xF0DC
+#define reg_tuner_data_1767_1760_pos 0
+#define reg_tuner_data_1767_1760_len 8
+#define reg_tuner_data_1767_1760_lsb 1760
+#define    p_reg_tuner_data_1775_1768   0xF0DD
+#define reg_tuner_data_1775_1768_pos 0
+#define reg_tuner_data_1775_1768_len 8
+#define reg_tuner_data_1775_1768_lsb 1768
+#define    p_reg_tuner_data_1783_1776   0xF0DE
+#define reg_tuner_data_1783_1776_pos 0
+#define reg_tuner_data_1783_1776_len 8
+#define reg_tuner_data_1783_1776_lsb 1776
+#define    p_reg_tuner_data_1791_1784   0xF0DF
+#define reg_tuner_data_1791_1784_pos 0
+#define reg_tuner_data_1791_1784_len 8
+#define reg_tuner_data_1791_1784_lsb 1784
+#define    p_reg_tuner_data_1799_1792   0xF0E0
+#define reg_tuner_data_1799_1792_pos 0
+#define reg_tuner_data_1799_1792_len 8
+#define reg_tuner_data_1799_1792_lsb 1792
+#define    p_reg_tuner_data_1807_1800   0xF0E1
+#define reg_tuner_data_1807_1800_pos 0
+#define reg_tuner_data_1807_1800_len 8
+#define reg_tuner_data_1807_1800_lsb 1800
+#define    p_reg_tuner_data_1815_1808   0xF0E2
+#define reg_tuner_data_1815_1808_pos 0
+#define reg_tuner_data_1815_1808_len 8
+#define reg_tuner_data_1815_1808_lsb 1808
+#define    p_reg_tuner_data_1823_1816   0xF0E3
+#define reg_tuner_data_1823_1816_pos 0
+#define reg_tuner_data_1823_1816_len 8
+#define reg_tuner_data_1823_1816_lsb 1816
+#define    p_reg_tuner_data_1831_1824   0xF0E4
+#define reg_tuner_data_1831_1824_pos 0
+#define reg_tuner_data_1831_1824_len 8
+#define reg_tuner_data_1831_1824_lsb 1824
+#define    p_reg_tuner_data_1839_1832   0xF0E5
+#define reg_tuner_data_1839_1832_pos 0
+#define reg_tuner_data_1839_1832_len 8
+#define reg_tuner_data_1839_1832_lsb 1832
+#define    p_reg_tuner_data_1847_1840   0xF0E6
+#define reg_tuner_data_1847_1840_pos 0
+#define reg_tuner_data_1847_1840_len 8
+#define reg_tuner_data_1847_1840_lsb 1840
+#define    p_reg_tuner_data_1855_1848   0xF0E7
+#define reg_tuner_data_1855_1848_pos 0
+#define reg_tuner_data_1855_1848_len 8
+#define reg_tuner_data_1855_1848_lsb 1848
+#define    p_reg_tuner_data_1863_1856   0xF0E8
+#define reg_tuner_data_1863_1856_pos 0
+#define reg_tuner_data_1863_1856_len 8
+#define reg_tuner_data_1863_1856_lsb 1856
+#define    p_reg_tuner_data_1871_1864   0xF0E9
+#define reg_tuner_data_1871_1864_pos 0
+#define reg_tuner_data_1871_1864_len 8
+#define reg_tuner_data_1871_1864_lsb 1864
+#define    p_reg_tuner_data_1879_1872   0xF0EA
+#define reg_tuner_data_1879_1872_pos 0
+#define reg_tuner_data_1879_1872_len 8
+#define reg_tuner_data_1879_1872_lsb 1872
+#define    p_reg_tuner_data_1887_1880   0xF0EB
+#define reg_tuner_data_1887_1880_pos 0
+#define reg_tuner_data_1887_1880_len 8
+#define reg_tuner_data_1887_1880_lsb 1880
+#define    p_reg_tuner_data_1895_1888   0xF0EC
+#define reg_tuner_data_1895_1888_pos 0
+#define reg_tuner_data_1895_1888_len 8
+#define reg_tuner_data_1895_1888_lsb 1888
+#define    p_reg_tuner_data_1903_1896   0xF0ED
+#define reg_tuner_data_1903_1896_pos 0
+#define reg_tuner_data_1903_1896_len 8
+#define reg_tuner_data_1903_1896_lsb 1896
+#define    p_reg_tuner_data_1911_1904   0xF0EE
+#define reg_tuner_data_1911_1904_pos 0
+#define reg_tuner_data_1911_1904_len 8
+#define reg_tuner_data_1911_1904_lsb 1904
+#define    p_reg_tuner_data_1919_1912   0xF0EF
+#define reg_tuner_data_1919_1912_pos 0
+#define reg_tuner_data_1919_1912_len 8
+#define reg_tuner_data_1919_1912_lsb 1912
+#define    p_reg_tuner_data_1927_1920   0xF0F0
+#define reg_tuner_data_1927_1920_pos 0
+#define reg_tuner_data_1927_1920_len 8
+#define reg_tuner_data_1927_1920_lsb 1920
+#define    p_reg_tuner_data_1935_1928   0xF0F1
+#define reg_tuner_data_1935_1928_pos 0
+#define reg_tuner_data_1935_1928_len 8
+#define reg_tuner_data_1935_1928_lsb 1928
+#define    p_reg_tuner_data_1943_1936   0xF0F2
+#define reg_tuner_data_1943_1936_pos 0
+#define reg_tuner_data_1943_1936_len 8
+#define reg_tuner_data_1943_1936_lsb 1936
+#define    p_reg_tuner_data_1951_1944   0xF0F3
+#define reg_tuner_data_1951_1944_pos 0
+#define reg_tuner_data_1951_1944_len 8
+#define reg_tuner_data_1951_1944_lsb 1944
+#define    p_reg_tuner_data_1959_1952   0xF0F4
+#define reg_tuner_data_1959_1952_pos 0
+#define reg_tuner_data_1959_1952_len 8
+#define reg_tuner_data_1959_1952_lsb 1952
+#define    p_reg_tuner_data_1967_1960   0xF0F5
+#define reg_tuner_data_1967_1960_pos 0
+#define reg_tuner_data_1967_1960_len 8
+#define reg_tuner_data_1967_1960_lsb 1960
+#define    p_reg_tuner_data_1975_1968   0xF0F6
+#define reg_tuner_data_1975_1968_pos 0
+#define reg_tuner_data_1975_1968_len 8
+#define reg_tuner_data_1975_1968_lsb 1968
+#define    p_reg_tuner_data_1983_1976   0xF0F7
+#define reg_tuner_data_1983_1976_pos 0
+#define reg_tuner_data_1983_1976_len 8
+#define reg_tuner_data_1983_1976_lsb 1976
+#define    p_reg_tuner_data_1991_1984   0xF0F8
+#define reg_tuner_data_1991_1984_pos 0
+#define reg_tuner_data_1991_1984_len 8
+#define reg_tuner_data_1991_1984_lsb 1984
+#define    p_reg_tuner_data_1999_1992   0xF0F9
+#define reg_tuner_data_1999_1992_pos 0
+#define reg_tuner_data_1999_1992_len 8
+#define reg_tuner_data_1999_1992_lsb 1992
+#define    p_reg_tuner_data_2007_2000   0xF0FA
+#define reg_tuner_data_2007_2000_pos 0
+#define reg_tuner_data_2007_2000_len 8
+#define reg_tuner_data_2007_2000_lsb 2000
+#define    p_reg_tuner_data_2015_2008   0xF0FB
+#define reg_tuner_data_2015_2008_pos 0
+#define reg_tuner_data_2015_2008_len 8
+#define reg_tuner_data_2015_2008_lsb 2008
+#define    p_reg_tuner_data_2023_2016   0xF0FC
+#define reg_tuner_data_2023_2016_pos 0
+#define reg_tuner_data_2023_2016_len 8
+#define reg_tuner_data_2023_2016_lsb 2016
+#define    p_reg_tuner_data_2031_2024   0xF0FD
+#define reg_tuner_data_2031_2024_pos 0
+#define reg_tuner_data_2031_2024_len 8
+#define reg_tuner_data_2031_2024_lsb 2024
+#define    p_reg_tuner_data_2039_2032   0xF0FE
+#define reg_tuner_data_2039_2032_pos 0
+#define reg_tuner_data_2039_2032_len 8
+#define reg_tuner_data_2039_2032_lsb 2032
+#define    p_reg_tuner_data_2047_2040   0xF0FF
+#define reg_tuner_data_2047_2040_pos 0
+#define reg_tuner_data_2047_2040_len 8
+#define reg_tuner_data_2047_2040_lsb 2040
+#define    p_reg_tuner_master_rd_wr 0xF100
+#define reg_tuner_master_rd_wr_pos 0
+#define reg_tuner_master_rd_wr_len 1
+#define reg_tuner_master_rd_wr_lsb 0
+#define    p_reg_tuner_master_length    0xF101
+#define reg_tuner_master_length_pos 0
+#define reg_tuner_master_length_len 8
+#define reg_tuner_master_length_lsb 0
+#define    p_reg_tuner_cmd_exe  0xF102
+#define reg_tuner_cmd_exe_pos 0
+#define reg_tuner_cmd_exe_len 1
+#define reg_tuner_cmd_exe_lsb 0
+#define    p_reg_tuner_wdat_done    0xF102
+#define reg_tuner_wdat_done_pos 1
+#define reg_tuner_wdat_done_len 1
+#define reg_tuner_wdat_done_lsb 0
+#define    p_reg_tuner_wdat_fail    0xF102
+#define reg_tuner_wdat_fail_pos 2
+#define reg_tuner_wdat_fail_len 1
+#define reg_tuner_wdat_fail_lsb 0
+#define    p_reg_tuner_ofsm_i2cm_rdat_rdy   0xF102
+#define reg_tuner_ofsm_i2cm_rdat_rdy_pos 3
+#define reg_tuner_ofsm_i2cm_rdat_rdy_len 1
+#define reg_tuner_ofsm_i2cm_rdat_rdy_lsb 0
+#define    p_reg_tuner_current_state    0xF102
+#define reg_tuner_current_state_pos 4
+#define reg_tuner_current_state_len 3
+#define reg_tuner_current_state_lsb 0
+#define    p_reg_one_cycle_counter_tuner    0xF103
+#define reg_one_cycle_counter_tuner_pos 0
+#define reg_one_cycle_counter_tuner_len 8
+#define reg_one_cycle_counter_tuner_lsb 0
+#define    p_reg_msb_lsb    0xF104
+#define reg_msb_lsb_pos 0
+#define reg_msb_lsb_len 1
+#define reg_msb_lsb_lsb 0
+#define    p_reg_ofdm_rst   0xF104
+#define    p_reg_sel_thirdi2c   0xF104
+#define reg_sel_thirdi2c_pos 2
+#define reg_sel_thirdi2c_len 1
+#define reg_sel_thirdi2c_lsb 0
+#define    p_reg_sel_tuner  0xF104
+#define    p_reg_ofdm_rst_en    0xF104
+#define    p_reg_sdio_cccr_v    0xF140
+#define reg_sdio_cccr_v_pos 0
+#define reg_sdio_cccr_v_len 4
+#define reg_sdio_cccr_v_lsb 0
+#define    p_reg_sdio_sdio_v    0xF140
+#define reg_sdio_sdio_v_pos 4
+#define reg_sdio_sdio_v_len 4
+#define reg_sdio_sdio_v_lsb 0
+#define    p_reg_sdioc_sd_v 0xF141
+#define reg_sdioc_sd_v_pos 0
+#define reg_sdioc_sd_v_len 4
+#define reg_sdioc_sd_v_lsb 0
+#define    p_reg_sdioc_ior1 0xF143
+#define reg_sdioc_ior1_pos 1
+#define reg_sdioc_ior1_len 1
+#define reg_sdioc_ior1_lsb 0
+#define    p_reg_sdioc_int1 0xF145
+#define reg_sdioc_int1_pos 1
+#define reg_sdioc_int1_len 1
+#define reg_sdioc_int1_lsb 0
+#define    p_reg_sdioc_scsi 0xF147
+#define reg_sdioc_scsi_pos 6
+#define reg_sdioc_scsi_len 1
+#define reg_sdioc_scsi_lsb 0
+#define    p_reg_sdioc_sdc  0xF148
+#define reg_sdioc_sdc_pos 0
+#define reg_sdioc_sdc_len 1
+#define reg_sdioc_sdc_lsb 0
+#define    p_reg_sdioc_smb  0xF148
+#define reg_sdioc_smb_pos 1
+#define reg_sdioc_smb_len 1
+#define reg_sdioc_smb_lsb 0
+#define    p_reg_sdioc_srw  0xF148
+#define reg_sdioc_srw_pos 2
+#define reg_sdioc_srw_len 1
+#define reg_sdioc_srw_lsb 0
+#define    p_reg_sdioc_sbs  0xF148
+#define reg_sdioc_sbs_pos 3
+#define reg_sdioc_sbs_len 1
+#define reg_sdioc_sbs_lsb 0
+#define    p_reg_sdioc_s4mi 0xF148
+#define reg_sdioc_s4mi_pos 4
+#define reg_sdioc_s4mi_len 1
+#define reg_sdioc_s4mi_lsb 0
+#define    p_reg_sdioc_lsc  0xF148
+#define reg_sdioc_lsc_pos 6
+#define reg_sdioc_lsc_len 1
+#define reg_sdioc_lsc_lsb 0
+#define    p_reg_sdioc_4bls 0xF148
+#define reg_sdioc_4bls_pos 7
+#define reg_sdioc_4bls_len 1
+#define reg_sdioc_4bls_lsb 0
+#define    p_reg_sdioc_cis_7_0  0xF149
+#define reg_sdioc_cis_7_0_pos 0
+#define reg_sdioc_cis_7_0_len 8
+#define reg_sdioc_cis_7_0_lsb 0
+#define    p_reg_sdioc_cis_15_8 0xF14A
+#define reg_sdioc_cis_15_8_pos 0
+#define reg_sdioc_cis_15_8_len 8
+#define reg_sdioc_cis_15_8_lsb 8
+#define    p_reg_sdioc_cis_23_16    0xF14B
+#define reg_sdioc_cis_23_16_pos 0
+#define reg_sdioc_cis_23_16_len 8
+#define reg_sdioc_cis_23_16_lsb 16
+#define    p_reg_sdioc_fs   0xF14D
+#define reg_sdioc_fs_pos 0
+#define reg_sdioc_fs_len 4
+#define reg_sdioc_fs_lsb 0
+#define    p_reg_sdioc_df   0xF14D
+#define reg_sdioc_df_pos 7
+#define reg_sdioc_df_len 1
+#define reg_sdioc_df_lsb 0
+#define    p_reg_sdioc_ex1  0xF14E
+#define reg_sdioc_ex1_pos 1
+#define reg_sdioc_ex1_len 1
+#define reg_sdioc_ex1_lsb 0
+#define    p_reg_sdioc_rf1  0xF14F
+#define reg_sdioc_rf1_pos 1
+#define reg_sdioc_rf1_len 1
+#define reg_sdioc_rf1_lsb 0
+#define    p_reg_sdioc_smpc 0xF152
+#define reg_sdioc_smpc_pos 0
+#define reg_sdioc_smpc_len 1
+#define reg_sdioc_smpc_lsb 0
+#define    p_reg_sdioc_f1_code  0xF160
+#define reg_sdioc_f1_code_pos 0
+#define reg_sdioc_f1_code_len 4
+#define reg_sdioc_f1_code_lsb 0
+#define    p_reg_sdioc_scsa 0xF160
+#define reg_sdioc_scsa_pos 6
+#define reg_sdioc_scsa_len 1
+#define reg_sdioc_scsa_lsb 0
+#define    p_reg_sdioc_csa_en   0xF160
+#define reg_sdioc_csa_en_pos 7
+#define reg_sdioc_csa_en_len 1
+#define reg_sdioc_csa_en_lsb 0
+#define    p_reg_sdioc_f1_ext_code  0xF161
+#define reg_sdioc_f1_ext_code_pos 0
+#define reg_sdioc_f1_ext_code_len 8
+#define reg_sdioc_f1_ext_code_lsb 0
+#define    p_reg_sdioc_sps  0xF162
+#define reg_sdioc_sps_pos 0
+#define reg_sdioc_sps_len 1
+#define reg_sdioc_sps_lsb 0
+#define    p_reg_sdioc_func1_cis_ptr_7_0    0xF169
+#define reg_sdioc_func1_cis_ptr_7_0_pos 0
+#define reg_sdioc_func1_cis_ptr_7_0_len 8
+#define reg_sdioc_func1_cis_ptr_7_0_lsb 0
+#define    p_reg_sdioc_func1_cis_ptr_15_8   0xF16A
+#define reg_sdioc_func1_cis_ptr_15_8_pos 0
+#define reg_sdioc_func1_cis_ptr_15_8_len 8
+#define reg_sdioc_func1_cis_ptr_15_8_lsb 8
+#define    p_reg_sdioc_func1_cis_ptr_23_16  0xF16B
+#define reg_sdioc_func1_cis_ptr_23_16_pos 0
+#define reg_sdioc_func1_cis_ptr_23_16_len 8
+#define reg_sdioc_func1_cis_ptr_23_16_lsb 16
+#define    p_reg_sdio_FUNCID0_0 0xF180
+#define reg_sdio_FUNCID0_0_pos 0
+#define reg_sdio_FUNCID0_0_len 8
+#define reg_sdio_FUNCID0_0_lsb 0
+#define    p_reg_sdio_FUNCID0_1 0xF181
+#define reg_sdio_FUNCID0_1_pos 0
+#define reg_sdio_FUNCID0_1_len 8
+#define reg_sdio_FUNCID0_1_lsb 0
+#define    p_reg_sdio_FUNCID0_2 0xF182
+#define reg_sdio_FUNCID0_2_pos 0
+#define reg_sdio_FUNCID0_2_len 8
+#define reg_sdio_FUNCID0_2_lsb 0
+#define    p_reg_sdio_FUNCID0_3 0xF183
+#define reg_sdio_FUNCID0_3_pos 0
+#define reg_sdio_FUNCID0_3_len 8
+#define reg_sdio_FUNCID0_3_lsb 0
+#define    p_reg_sdio_MANFID0_0 0xF184
+#define reg_sdio_MANFID0_0_pos 0
+#define reg_sdio_MANFID0_0_len 8
+#define reg_sdio_MANFID0_0_lsb 0
+#define    p_reg_sdio_MANFID0_1 0xF185
+#define reg_sdio_MANFID0_1_pos 0
+#define reg_sdio_MANFID0_1_len 8
+#define reg_sdio_MANFID0_1_lsb 0
+#define    p_reg_sdio_MANFID0_2_7_0 0xF186
+#define reg_sdio_MANFID0_2_7_0_pos 0
+#define reg_sdio_MANFID0_2_7_0_len 8
+#define reg_sdio_MANFID0_2_7_0_lsb 0
+#define    p_reg_sdio_MANFID0_2_15_8    0xF187
+#define reg_sdio_MANFID0_2_15_8_pos 0
+#define reg_sdio_MANFID0_2_15_8_len 8
+#define reg_sdio_MANFID0_2_15_8_lsb 8
+#define    p_reg_sdio_MANFID0_4_7_0 0xF188
+#define reg_sdio_MANFID0_4_7_0_pos 0
+#define reg_sdio_MANFID0_4_7_0_len 8
+#define reg_sdio_MANFID0_4_7_0_lsb 0
+#define    p_reg_sdio_MANFID0_4_15_8    0xF189
+#define reg_sdio_MANFID0_4_15_8_pos 0
+#define reg_sdio_MANFID0_4_15_8_len 8
+#define reg_sdio_MANFID0_4_15_8_lsb 8
+#define    p_reg_sdio_FUNCE0_0  0xF18A
+#define reg_sdio_FUNCE0_0_pos 0
+#define reg_sdio_FUNCE0_0_len 8
+#define reg_sdio_FUNCE0_0_lsb 0
+#define    p_reg_sdio_FUNCE0_1  0xF18B
+#define reg_sdio_FUNCE0_1_pos 0
+#define reg_sdio_FUNCE0_1_len 8
+#define reg_sdio_FUNCE0_1_lsb 0
+#define    p_reg_sdio_FUNCE0_2  0xF18C
+#define reg_sdio_FUNCE0_2_pos 0
+#define reg_sdio_FUNCE0_2_len 8
+#define reg_sdio_FUNCE0_2_lsb 0
+#define    p_reg_sdio_FUNCE0_3_7_0  0xF18D
+#define reg_sdio_FUNCE0_3_7_0_pos 0
+#define reg_sdio_FUNCE0_3_7_0_len 8
+#define reg_sdio_FUNCE0_3_7_0_lsb 0
+#define    p_reg_sdio_FUNCE0_3_15_8 0xF18E
+#define reg_sdio_FUNCE0_3_15_8_pos 0
+#define reg_sdio_FUNCE0_3_15_8_len 8
+#define reg_sdio_FUNCE0_3_15_8_lsb 8
+#define    p_reg_sdio_FUNCE0_5  0xF18F
+#define reg_sdio_FUNCE0_5_pos 0
+#define reg_sdio_FUNCE0_5_len 8
+#define reg_sdio_FUNCE0_5_lsb 0
+#define    p_reg_sdio_VERS_10_0 0xF190
+#define reg_sdio_VERS_10_0_pos 0
+#define reg_sdio_VERS_10_0_len 8
+#define reg_sdio_VERS_10_0_lsb 0
+#define    p_reg_sdio_VERS_10_1 0xF191
+#define reg_sdio_VERS_10_1_pos 0
+#define reg_sdio_VERS_10_1_len 8
+#define reg_sdio_VERS_10_1_lsb 0
+#define    p_reg_sdio_VERS_10_2 0xF192
+#define reg_sdio_VERS_10_2_pos 0
+#define reg_sdio_VERS_10_2_len 8
+#define reg_sdio_VERS_10_2_lsb 0
+#define    p_reg_sdio_VERS_10_3 0xF193
+#define reg_sdio_VERS_10_3_pos 0
+#define reg_sdio_VERS_10_3_len 8
+#define reg_sdio_VERS_10_3_lsb 0
+#define    p_reg_sdio_VERS_10_4 0xF194
+#define reg_sdio_VERS_10_4_pos 0
+#define reg_sdio_VERS_10_4_len 8
+#define reg_sdio_VERS_10_4_lsb 0
+#define    p_reg_sdio_VERS_10_5 0xF195
+#define reg_sdio_VERS_10_5_pos 0
+#define reg_sdio_VERS_10_5_len 8
+#define reg_sdio_VERS_10_5_lsb 0
+#define    p_reg_sdio_VERS_10_6 0xF196
+#define reg_sdio_VERS_10_6_pos 0
+#define reg_sdio_VERS_10_6_len 8
+#define reg_sdio_VERS_10_6_lsb 0
+#define    p_reg_sdio_VERS_10_7 0xF197
+#define reg_sdio_VERS_10_7_pos 0
+#define reg_sdio_VERS_10_7_len 8
+#define reg_sdio_VERS_10_7_lsb 0
+#define    p_reg_sdio_VERS_10_8 0xF198
+#define reg_sdio_VERS_10_8_pos 0
+#define reg_sdio_VERS_10_8_len 8
+#define reg_sdio_VERS_10_8_lsb 0
+#define    p_reg_sdio_VERS_10_9 0xF199
+#define reg_sdio_VERS_10_9_pos 0
+#define reg_sdio_VERS_10_9_len 8
+#define reg_sdio_VERS_10_9_lsb 0
+#define    p_reg_sdio_VERS_10_A 0xF19A
+#define reg_sdio_VERS_10_A_pos 0
+#define reg_sdio_VERS_10_A_len 8
+#define reg_sdio_VERS_10_A_lsb 0
+#define    p_reg_sdio_VERS_10_B 0xF19B
+#define reg_sdio_VERS_10_B_pos 0
+#define reg_sdio_VERS_10_B_len 8
+#define reg_sdio_VERS_10_B_lsb 0
+#define    p_reg_sdio_VERS_10_C 0xF19C
+#define reg_sdio_VERS_10_C_pos 0
+#define reg_sdio_VERS_10_C_len 8
+#define reg_sdio_VERS_10_C_lsb 0
+#define    p_reg_sdio_VERS_10_D 0xF19D
+#define reg_sdio_VERS_10_D_pos 0
+#define reg_sdio_VERS_10_D_len 8
+#define reg_sdio_VERS_10_D_lsb 0
+#define    p_reg_sdio_VERS_10_E 0xF19E
+#define reg_sdio_VERS_10_E_pos 0
+#define reg_sdio_VERS_10_E_len 8
+#define reg_sdio_VERS_10_E_lsb 0
+#define    p_reg_sdio_VERS_10_F 0xF19F
+#define reg_sdio_VERS_10_F_pos 0
+#define reg_sdio_VERS_10_F_len 8
+#define reg_sdio_VERS_10_F_lsb 0
+#define    p_reg_sdio_VERS_10_10    0xF1A0
+#define reg_sdio_VERS_10_10_pos 0
+#define reg_sdio_VERS_10_10_len 8
+#define reg_sdio_VERS_10_10_lsb 0
+#define    p_reg_sdio_VERS_10_11    0xF1A1
+#define reg_sdio_VERS_10_11_pos 0
+#define reg_sdio_VERS_10_11_len 8
+#define reg_sdio_VERS_10_11_lsb 0
+#define    p_reg_sdio_VERS_10_12    0xF1A2
+#define reg_sdio_VERS_10_12_pos 0
+#define reg_sdio_VERS_10_12_len 8
+#define reg_sdio_VERS_10_12_lsb 0
+#define    p_reg_sdio_VERS_10_13    0xF1A3
+#define reg_sdio_VERS_10_13_pos 0
+#define reg_sdio_VERS_10_13_len 8
+#define reg_sdio_VERS_10_13_lsb 0
+#define    p_reg_sdio_VERS_10_14    0xF1A4
+#define reg_sdio_VERS_10_14_pos 0
+#define reg_sdio_VERS_10_14_len 8
+#define reg_sdio_VERS_10_14_lsb 0
+#define    p_reg_sdio_VERS_10_15    0xF1A5
+#define reg_sdio_VERS_10_15_pos 0
+#define reg_sdio_VERS_10_15_len 8
+#define reg_sdio_VERS_10_15_lsb 0
+#define    p_reg_sdio_VERS_10_16    0xF1A6
+#define reg_sdio_VERS_10_16_pos 0
+#define reg_sdio_VERS_10_16_len 8
+#define reg_sdio_VERS_10_16_lsb 0
+#define    p_reg_sdio_VERS_10_17    0xF1A7
+#define reg_sdio_VERS_10_17_pos 0
+#define reg_sdio_VERS_10_17_len 8
+#define reg_sdio_VERS_10_17_lsb 0
+#define    p_reg_sdio_VERS_10_18    0xF1A8
+#define reg_sdio_VERS_10_18_pos 0
+#define reg_sdio_VERS_10_18_len 8
+#define reg_sdio_VERS_10_18_lsb 0
+#define    p_reg_sdio_VERS_10_19    0xF1A9
+#define reg_sdio_VERS_10_19_pos 0
+#define reg_sdio_VERS_10_19_len 8
+#define reg_sdio_VERS_10_19_lsb 0
+#define    p_reg_sdio_VERS_10_1A    0xF1AA
+#define reg_sdio_VERS_10_1A_pos 0
+#define reg_sdio_VERS_10_1A_len 8
+#define reg_sdio_VERS_10_1A_lsb 0
+#define    p_reg_sdio_VERS_10_1B    0xF1AB
+#define reg_sdio_VERS_10_1B_pos 0
+#define reg_sdio_VERS_10_1B_len 8
+#define reg_sdio_VERS_10_1B_lsb 0
+#define    p_reg_sdio_VERS_10_1C    0xF1AC
+#define reg_sdio_VERS_10_1C_pos 0
+#define reg_sdio_VERS_10_1C_len 8
+#define reg_sdio_VERS_10_1C_lsb 0
+#define    p_reg_sdio_VERS_10_1D    0xF1AD
+#define reg_sdio_VERS_10_1D_pos 0
+#define reg_sdio_VERS_10_1D_len 8
+#define reg_sdio_VERS_10_1D_lsb 0
+#define    p_reg_sdio_VERS_10_1E    0xF1AE
+#define reg_sdio_VERS_10_1E_pos 0
+#define reg_sdio_VERS_10_1E_len 8
+#define reg_sdio_VERS_10_1E_lsb 0
+#define    p_reg_sdio_VERS_10_1F    0xF1AF
+#define reg_sdio_VERS_10_1F_pos 0
+#define reg_sdio_VERS_10_1F_len 8
+#define reg_sdio_VERS_10_1F_lsb 0
+#define    p_reg_sdio_VERS_10_20    0xF1B0
+#define reg_sdio_VERS_10_20_pos 0
+#define reg_sdio_VERS_10_20_len 8
+#define reg_sdio_VERS_10_20_lsb 0
+#define    p_reg_sdio_VERS_10_21    0xF1B1
+#define reg_sdio_VERS_10_21_pos 0
+#define reg_sdio_VERS_10_21_len 8
+#define reg_sdio_VERS_10_21_lsb 0
+#define    p_reg_sdio_VERS_10_22    0xF1B2
+#define reg_sdio_VERS_10_22_pos 0
+#define reg_sdio_VERS_10_22_len 8
+#define reg_sdio_VERS_10_22_lsb 0
+#define    p_reg_sdio_VERS_10_23    0xF1B3
+#define reg_sdio_VERS_10_23_pos 0
+#define reg_sdio_VERS_10_23_len 8
+#define reg_sdio_VERS_10_23_lsb 0
+#define    p_reg_sdio_VERS_10_24    0xF1B4
+#define reg_sdio_VERS_10_24_pos 0
+#define reg_sdio_VERS_10_24_len 8
+#define reg_sdio_VERS_10_24_lsb 0
+#define    p_reg_sdio_VERS_10_25    0xF1B5
+#define reg_sdio_VERS_10_25_pos 0
+#define reg_sdio_VERS_10_25_len 8
+#define reg_sdio_VERS_10_25_lsb 0
+#define    p_reg_sdio_VERS_10_26    0xF1B6
+#define reg_sdio_VERS_10_26_pos 0
+#define reg_sdio_VERS_10_26_len 8
+#define reg_sdio_VERS_10_26_lsb 0
+#define    p_reg_sdio_VERS_10_27    0xF1B7
+#define reg_sdio_VERS_10_27_pos 0
+#define reg_sdio_VERS_10_27_len 8
+#define reg_sdio_VERS_10_27_lsb 0
+#define    p_reg_sdio_END0  0xF1B8
+#define reg_sdio_END0_pos 0
+#define reg_sdio_END0_len 8
+#define reg_sdio_END0_lsb 0
+#define    p_reg_sdio_FUNCID1_0 0xF1C0
+#define reg_sdio_FUNCID1_0_pos 0
+#define reg_sdio_FUNCID1_0_len 8
+#define reg_sdio_FUNCID1_0_lsb 0
+#define    p_reg_sdio_FUNCID1_1 0xF1C1
+#define reg_sdio_FUNCID1_1_pos 0
+#define reg_sdio_FUNCID1_1_len 8
+#define reg_sdio_FUNCID1_1_lsb 0
+#define    p_reg_sdio_FUNCID1_2 0xF1C2
+#define reg_sdio_FUNCID1_2_pos 0
+#define reg_sdio_FUNCID1_2_len 8
+#define reg_sdio_FUNCID1_2_lsb 0
+#define    p_reg_sdio_FUNCID1_3 0xF1C3
+#define reg_sdio_FUNCID1_3_pos 0
+#define reg_sdio_FUNCID1_3_len 8
+#define reg_sdio_FUNCID1_3_lsb 0
+#define    p_reg_sdio_FUNCE1_0  0xF1C4
+#define reg_sdio_FUNCE1_0_pos 0
+#define reg_sdio_FUNCE1_0_len 8
+#define reg_sdio_FUNCE1_0_lsb 0
+#define    p_reg_sdio_FUNCE1_1  0xF1C5
+#define reg_sdio_FUNCE1_1_pos 0
+#define reg_sdio_FUNCE1_1_len 8
+#define reg_sdio_FUNCE1_1_lsb 0
+#define    p_reg_sdio_FUNCE1_2  0xF1C6
+#define reg_sdio_FUNCE1_2_pos 0
+#define reg_sdio_FUNCE1_2_len 8
+#define reg_sdio_FUNCE1_2_lsb 0
+#define    p_reg_sdio_FUNCE1_3  0xF1C7
+#define reg_sdio_FUNCE1_3_pos 0
+#define reg_sdio_FUNCE1_3_len 8
+#define reg_sdio_FUNCE1_3_lsb 0
+#define    p_reg_sdio_FUNCE1_4  0xF1C8
+#define reg_sdio_FUNCE1_4_pos 0
+#define reg_sdio_FUNCE1_4_len 8
+#define reg_sdio_FUNCE1_4_lsb 0
+#define    p_reg_sdio_FUNCE1_5_7_0  0xF1C9
+#define reg_sdio_FUNCE1_5_7_0_pos 0
+#define reg_sdio_FUNCE1_5_7_0_len 8
+#define reg_sdio_FUNCE1_5_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_5_15_8 0xF1CA
+#define reg_sdio_FUNCE1_5_15_8_pos 0
+#define reg_sdio_FUNCE1_5_15_8_len 8
+#define reg_sdio_FUNCE1_5_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_5_23_16    0xF1CB
+#define reg_sdio_FUNCE1_5_23_16_pos 0
+#define reg_sdio_FUNCE1_5_23_16_len 8
+#define reg_sdio_FUNCE1_5_23_16_lsb 16
+#define    p_reg_sdio_FUNCE1_5_31_24    0xF1CC
+#define reg_sdio_FUNCE1_5_31_24_pos 0
+#define reg_sdio_FUNCE1_5_31_24_len 8
+#define reg_sdio_FUNCE1_5_31_24_lsb 24
+#define    p_reg_sdio_FUNCE1_9_7_0  0xF1CD
+#define reg_sdio_FUNCE1_9_7_0_pos 0
+#define reg_sdio_FUNCE1_9_7_0_len 8
+#define reg_sdio_FUNCE1_9_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_9_15_8 0xF1CE
+#define reg_sdio_FUNCE1_9_15_8_pos 0
+#define reg_sdio_FUNCE1_9_15_8_len 8
+#define reg_sdio_FUNCE1_9_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_9_23_16    0xF1CF
+#define reg_sdio_FUNCE1_9_23_16_pos 0
+#define reg_sdio_FUNCE1_9_23_16_len 8
+#define reg_sdio_FUNCE1_9_23_16_lsb 16
+#define    p_reg_sdio_FUNCE1_9_31_24    0xF1D0
+#define reg_sdio_FUNCE1_9_31_24_pos 0
+#define reg_sdio_FUNCE1_9_31_24_len 8
+#define reg_sdio_FUNCE1_9_31_24_lsb 24
+#define    p_reg_sdio_FUNCE1_D  0xF1D1
+#define reg_sdio_FUNCE1_D_pos 0
+#define reg_sdio_FUNCE1_D_len 8
+#define reg_sdio_FUNCE1_D_lsb 0
+#define    p_reg_sdio_FUNCE1_E_7_0  0xF1D2
+#define reg_sdio_FUNCE1_E_7_0_pos 0
+#define reg_sdio_FUNCE1_E_7_0_len 8
+#define reg_sdio_FUNCE1_E_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_E_15_8 0xF1D3
+#define reg_sdio_FUNCE1_E_15_8_pos 0
+#define reg_sdio_FUNCE1_E_15_8_len 8
+#define reg_sdio_FUNCE1_E_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_10_7_0 0xF1D4
+#define reg_sdio_FUNCE1_10_7_0_pos 0
+#define reg_sdio_FUNCE1_10_7_0_len 8
+#define reg_sdio_FUNCE1_10_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_10_15_8    0xF1D5
+#define reg_sdio_FUNCE1_10_15_8_pos 0
+#define reg_sdio_FUNCE1_10_15_8_len 8
+#define reg_sdio_FUNCE1_10_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_10_23_16   0xF1D6
+#define reg_sdio_FUNCE1_10_23_16_pos 0
+#define reg_sdio_FUNCE1_10_23_16_len 8
+#define reg_sdio_FUNCE1_10_23_16_lsb 16
+#define    p_reg_sdio_FUNCE1_10_31_24   0xF1D7
+#define reg_sdio_FUNCE1_10_31_24_pos 0
+#define reg_sdio_FUNCE1_10_31_24_len 8
+#define reg_sdio_FUNCE1_10_31_24_lsb 24
+#define    p_reg_sdio_FUNCE1_14 0xF1D8
+#define reg_sdio_FUNCE1_14_pos 0
+#define reg_sdio_FUNCE1_14_len 8
+#define reg_sdio_FUNCE1_14_lsb 0
+#define    p_reg_sdio_FUNCE1_15 0xF1D9
+#define reg_sdio_FUNCE1_15_pos 0
+#define reg_sdio_FUNCE1_15_len 8
+#define reg_sdio_FUNCE1_15_lsb 0
+#define    p_reg_sdio_FUNCE1_16 0xF1DA
+#define reg_sdio_FUNCE1_16_pos 0
+#define reg_sdio_FUNCE1_16_len 8
+#define reg_sdio_FUNCE1_16_lsb 0
+#define    p_reg_sdio_FUNCE1_17 0xF1DB
+#define reg_sdio_FUNCE1_17_pos 0
+#define reg_sdio_FUNCE1_17_len 8
+#define reg_sdio_FUNCE1_17_lsb 0
+#define    p_reg_sdio_FUNCE1_18 0xF1DC
+#define reg_sdio_FUNCE1_18_pos 0
+#define reg_sdio_FUNCE1_18_len 8
+#define reg_sdio_FUNCE1_18_lsb 0
+#define    p_reg_sdio_FUNCE1_19 0xF1DD
+#define reg_sdio_FUNCE1_19_pos 0
+#define reg_sdio_FUNCE1_19_len 8
+#define reg_sdio_FUNCE1_19_lsb 0
+#define    p_reg_sdio_FUNCE1_1A_7_0 0xF1DE
+#define reg_sdio_FUNCE1_1A_7_0_pos 0
+#define reg_sdio_FUNCE1_1A_7_0_len 8
+#define reg_sdio_FUNCE1_1A_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_1A_15_8    0xF1DF
+#define reg_sdio_FUNCE1_1A_15_8_pos 0
+#define reg_sdio_FUNCE1_1A_15_8_len 8
+#define reg_sdio_FUNCE1_1A_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_1C_7_0 0xF1E0
+#define reg_sdio_FUNCE1_1C_7_0_pos 0
+#define reg_sdio_FUNCE1_1C_7_0_len 8
+#define reg_sdio_FUNCE1_1C_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_1C_15_8    0xF1E1
+#define reg_sdio_FUNCE1_1C_15_8_pos 0
+#define reg_sdio_FUNCE1_1C_15_8_len 8
+#define reg_sdio_FUNCE1_1C_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_1E_7_0 0xF1E2
+#define reg_sdio_FUNCE1_1E_7_0_pos 0
+#define reg_sdio_FUNCE1_1E_7_0_len 8
+#define reg_sdio_FUNCE1_1E_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_1E_15_8    0xF1E3
+#define reg_sdio_FUNCE1_1E_15_8_pos 0
+#define reg_sdio_FUNCE1_1E_15_8_len 8
+#define reg_sdio_FUNCE1_1E_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_20_7_0 0xF1E4
+#define reg_sdio_FUNCE1_20_7_0_pos 0
+#define reg_sdio_FUNCE1_20_7_0_len 8
+#define reg_sdio_FUNCE1_20_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_20_15_8    0xF1E5
+#define reg_sdio_FUNCE1_20_15_8_pos 0
+#define reg_sdio_FUNCE1_20_15_8_len 8
+#define reg_sdio_FUNCE1_20_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_22_7_0 0xF1E6
+#define reg_sdio_FUNCE1_22_7_0_pos 0
+#define reg_sdio_FUNCE1_22_7_0_len 8
+#define reg_sdio_FUNCE1_22_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_22_15_8    0xF1E7
+#define reg_sdio_FUNCE1_22_15_8_pos 0
+#define reg_sdio_FUNCE1_22_15_8_len 8
+#define reg_sdio_FUNCE1_22_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_24_7_0 0xF1E8
+#define reg_sdio_FUNCE1_24_7_0_pos 0
+#define reg_sdio_FUNCE1_24_7_0_len 8
+#define reg_sdio_FUNCE1_24_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_24_15_8    0xF1E9
+#define reg_sdio_FUNCE1_24_15_8_pos 0
+#define reg_sdio_FUNCE1_24_15_8_len 8
+#define reg_sdio_FUNCE1_24_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_26_7_0 0xF1EA
+#define reg_sdio_FUNCE1_26_7_0_pos 0
+#define reg_sdio_FUNCE1_26_7_0_len 8
+#define reg_sdio_FUNCE1_26_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_26_15_8    0xF1EB
+#define reg_sdio_FUNCE1_26_15_8_pos 0
+#define reg_sdio_FUNCE1_26_15_8_len 8
+#define reg_sdio_FUNCE1_26_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_28_7_0 0xF1EC
+#define reg_sdio_FUNCE1_28_7_0_pos 0
+#define reg_sdio_FUNCE1_28_7_0_len 8
+#define reg_sdio_FUNCE1_28_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_28_15_8    0xF1ED
+#define reg_sdio_FUNCE1_28_15_8_pos 0
+#define reg_sdio_FUNCE1_28_15_8_len 8
+#define reg_sdio_FUNCE1_28_15_8_lsb 8
+#define    p_reg_sdio_FUNCE1_2A_7_0 0xF1EE
+#define reg_sdio_FUNCE1_2A_7_0_pos 0
+#define reg_sdio_FUNCE1_2A_7_0_len 8
+#define reg_sdio_FUNCE1_2A_7_0_lsb 0
+#define    p_reg_sdio_FUNCE1_2A_15_8    0xF1EF
+#define reg_sdio_FUNCE1_2A_15_8_pos 0
+#define reg_sdio_FUNCE1_2A_15_8_len 8
+#define reg_sdio_FUNCE1_2A_15_8_lsb 8
+#define    p_reg_sdio_END1  0xF1F0
+#define reg_sdio_END1_pos 0
+#define reg_sdio_END1_len 8
+#define reg_sdio_END1_lsb 0
+#define    r_sdioc_tx_fifo_empty    0xF210
+#define sdioc_tx_fifo_empty_pos 0
+#define sdioc_tx_fifo_empty_len 1
+#define sdioc_tx_fifo_empty_lsb 0
+#define    p_reg_sdio_53ra  0xF210
+#define reg_sdio_53ra_pos 1
+#define reg_sdio_53ra_len 1
+#define reg_sdio_53ra_lsb 0
+#define    p_reg_sdioc_rd_wait_dly  0xF210
+#define reg_sdioc_rd_wait_dly_pos 4
+#define reg_sdioc_rd_wait_dly_len 2
+#define reg_sdioc_rd_wait_dly_lsb 0
+#define    p_reg_write_mbx_complete 0xF211
+#define reg_write_mbx_complete_pos 0
+#define reg_write_mbx_complete_len 1
+#define reg_write_mbx_complete_lsb 0
+#define    p_reg_sdioc_sw_err   0xF211
+#define reg_sdioc_sw_err_pos 1
+#define reg_sdioc_sw_err_len 1
+#define reg_sdioc_sw_err_lsb 0
+#define    p_reg_sdioc_tran_dat_dly 0xF211
+#define reg_sdioc_tran_dat_dly_pos 4
+#define reg_sdioc_tran_dat_dly_len 3
+#define reg_sdioc_tran_dat_dly_lsb 0
+#define    p_reg_sdioc_external_int_en  0xF212
+#define reg_sdioc_external_int_en_pos 1
+#define reg_sdioc_external_int_en_len 1
+#define reg_sdioc_external_int_en_lsb 0
+#define    r_reg_sdioc_external_int 0xF212
+#define reg_sdioc_external_int_pos 2
+#define reg_sdioc_external_int_len 1
+#define reg_sdioc_external_int_lsb 0
+#define    p_reg_auto_clrWB_en  0xF213
+#define reg_auto_clrWB_en_pos 0
+#define reg_auto_clrWB_en_len 1
+#define reg_auto_clrWB_en_lsb 0
+#define    p_reg_sdioc_crc_s_dly    0xF213
+#define reg_sdioc_crc_s_dly_pos 1
+#define reg_sdioc_crc_s_dly_len 1
+#define reg_sdioc_crc_s_dly_lsb 0
+#define    p_reg_sdioc_neg_out_sel  0xF213
+#define reg_sdioc_neg_out_sel_pos 2
+#define reg_sdioc_neg_out_sel_len 1
+#define reg_sdioc_neg_out_sel_lsb 0
+#define    p_reg_sdioc_tx_fifo_rst  0xF213
+#define reg_sdioc_tx_fifo_rst_pos 4
+#define reg_sdioc_tx_fifo_rst_len 1
+#define reg_sdioc_tx_fifo_rst_lsb 0
+#define    p_reg_sdioc_rx_fifo_rst  0xF213
+#define reg_sdioc_rx_fifo_rst_pos 5
+#define reg_sdioc_rx_fifo_rst_len 1
+#define reg_sdioc_rx_fifo_rst_lsb 0
+#define    p_reg_sdioc_auto_rst_sm_en   0xF213
+#define reg_sdioc_auto_rst_sm_en_pos 6
+#define reg_sdioc_auto_rst_sm_en_len 1
+#define reg_sdioc_auto_rst_sm_en_lsb 0
+#define    p_sdio_link_clr_Wbusy_en 0xF214
+#define sdio_link_clr_Wbusy_en_pos 0
+#define sdio_link_clr_Wbusy_en_len 1
+#define sdio_link_clr_Wbusy_en_lsb 0
+#define    p_sdio_link_clr_Wbusy    0xF214
+#define sdio_link_clr_Wbusy_pos 1
+#define sdio_link_clr_Wbusy_len 1
+#define sdio_link_clr_Wbusy_lsb 0
+#define    p_reg_sdioc_dbg_sel  0xF214
+#define reg_sdioc_dbg_sel_pos 4
+#define reg_sdioc_dbg_sel_len 4
+#define reg_sdioc_dbg_sel_lsb 0
+#define    p_reg_sdioc_skip_ocr 0xF215
+#define reg_sdioc_skip_ocr_pos 0
+#define reg_sdioc_skip_ocr_len 1
+#define reg_sdioc_skip_ocr_lsb 0
+#define    p_reg_sdioc_spi_ns   0xF215
+#define reg_sdioc_spi_ns_pos 1
+#define reg_sdioc_spi_ns_len 1
+#define reg_sdioc_spi_ns_lsb 0
+#define    r_sdio_spi_mode  0xF215
+#define sdio_spi_mode_pos 7
+#define sdio_spi_mode_len 1
+#define sdio_spi_mode_lsb 0
+#define    r_link_ofsm_mailbox_int  0xF402
+#define link_ofsm_mailbox_int_pos 4
+#define link_ofsm_mailbox_int_len 1
+#define link_ofsm_mailbox_int_lsb 0
+#define    r_link_ofsm_dvbt_int 0xF403
+#define link_ofsm_dvbt_int_pos 2
+#define link_ofsm_dvbt_int_len 1
+#define link_ofsm_dvbt_int_lsb 0
+#define    p_reg_dvbt_intsts    0xF404
+#define reg_dvbt_intsts_pos 2
+#define reg_dvbt_intsts_len 1
+#define reg_dvbt_intsts_lsb 0
+#define    p_reg_link_mailbox_int   0xF405
+#define reg_link_mailbox_int_pos 5
+#define reg_link_mailbox_int_len 1
+#define reg_link_mailbox_int_lsb 0
+#define    p_reg_mailbox_wptr_rst   0xF408
+#define reg_mailbox_wptr_rst_pos 0
+#define reg_mailbox_wptr_rst_len 1
+#define reg_mailbox_wptr_rst_lsb 0
+#define    p_reg_link_mailbox_wptr  0xF409
+#define reg_link_mailbox_wptr_pos 0
+#define reg_link_mailbox_wptr_len 8
+#define reg_link_mailbox_wptr_lsb 0
+#define    p_reg_link_mailbox_wend  0xF410
+#define reg_link_mailbox_wend_pos 0
+#define reg_link_mailbox_wend_len 1
+#define reg_link_mailbox_wend_lsb 0
+#define    p_reg_rd_data_sel    0xF411
+#define reg_rd_data_sel_pos 0
+#define reg_rd_data_sel_len 2
+#define reg_rd_data_sel_lsb 0
+#define    p_reg_fifo_rd_length_7_0 0xF412
+#define reg_fifo_rd_length_7_0_pos 0
+#define reg_fifo_rd_length_7_0_len 8
+#define reg_fifo_rd_length_7_0_lsb 0
+#define    p_reg_fifo_rd_length_15_8    0xF413
+#define reg_fifo_rd_length_15_8_pos 0
+#define reg_fifo_rd_length_15_8_len 8
+#define reg_fifo_rd_length_15_8_lsb 8
+#define    p_reg_fifo_rd_length_17_16   0xF414
+#define reg_fifo_rd_length_17_16_pos 0
+#define reg_fifo_rd_length_17_16_len 2
+#define reg_fifo_rd_length_17_16_lsb 16
+#define    p_reg_rst_fifo_rptr  0xF414
+#define reg_rst_fifo_rptr_pos 6
+#define reg_rst_fifo_rptr_len 1
+#define reg_rst_fifo_rptr_lsb 0
+#define    p_reg_force_sel  0xF414
+#define reg_force_sel_pos 7
+#define reg_force_sel_len 1
+#define reg_force_sel_lsb 0
+#define    p_reg_fifo_rptr_7_0  0xF415
+#define reg_fifo_rptr_7_0_pos 0
+#define reg_fifo_rptr_7_0_len 8
+#define reg_fifo_rptr_7_0_lsb 0
+#define    p_reg_fifo_rptr_15_8 0xF416
+#define reg_fifo_rptr_15_8_pos 0
+#define reg_fifo_rptr_15_8_len 8
+#define reg_fifo_rptr_15_8_lsb 8
+#define    p_reg_fifo_rptr_17_16    0xF417
+#define reg_fifo_rptr_17_16_pos 0
+#define reg_fifo_rptr_17_16_len 2
+#define reg_fifo_rptr_17_16_lsb 16
+#define    p_reg_max_package_size_7_0   0xF418
+#define reg_max_package_size_7_0_pos 0
+#define reg_max_package_size_7_0_len 8
+#define reg_max_package_size_7_0_lsb 0
+#define    p_reg_max_package_size_11_8  0xF419
+#define reg_max_package_size_11_8_pos 0
+#define reg_max_package_size_11_8_len 4
+#define reg_max_package_size_11_8_lsb 8
+#define    p_reg_dvbt_en    0xF41A
+#define reg_dvbt_en_pos 0
+#define reg_dvbt_en_len 1
+#define reg_dvbt_en_lsb 0
+#define    p_reg_dvbt_bufsize   0xF41A
+#define reg_dvbt_bufsize_pos 1
+#define reg_dvbt_bufsize_len 1
+#define reg_dvbt_bufsize_lsb 0
+#define    p_reg_dvbt_path  0xF41A
+#define reg_dvbt_path_pos 2
+#define reg_dvbt_path_len 1
+#define reg_dvbt_path_lsb 0
+#define    p_reg_dvbt_r5    0xF41A
+#define reg_dvbt_r5_pos 3
+#define reg_dvbt_r5_len 1
+#define reg_dvbt_r5_lsb 0
+#define    p_reg_mailbox_inten  0xF41E
+#define reg_mailbox_inten_pos 4
+#define reg_mailbox_inten_len 1
+#define reg_mailbox_inten_lsb 0
+#define    p_reg_dvbt_inten 0xF41F
+#define reg_dvbt_inten_pos 2
+#define reg_dvbt_inten_len 1
+#define reg_dvbt_inten_lsb 0
+#define    r_link_ofsm_ip_length_7_0    0xF447
+#define link_ofsm_ip_length_7_0_pos 0
+#define link_ofsm_ip_length_7_0_len 8
+#define link_ofsm_ip_length_7_0_lsb 0
+#define    r_link_ofsm_ip_length_11_8   0xF448
+#define link_ofsm_ip_length_11_8_pos 0
+#define link_ofsm_ip_length_11_8_len 4
+#define link_ofsm_ip_length_11_8_lsb 8
+#define    r_link_ofsm_ip_valid 0xF448
+#define link_ofsm_ip_valid_pos 7
+#define link_ofsm_ip_valid_len 1
+#define link_ofsm_ip_valid_lsb 0
+#define    p_reg_spi_master 0xF600
+#define reg_spi_master_pos 0
+#define reg_spi_master_len 1
+#define reg_spi_master_lsb 0
+#define    p_reg_spi_bit    0xF601
+#define reg_spi_bit_pos 0
+#define reg_spi_bit_len 2
+#define reg_spi_bit_lsb 0
+#define    p_reg_spi_cs 0xF602
+#define reg_spi_cs_pos 0
+#define reg_spi_cs_len 1
+#define reg_spi_cs_lsb 0
+#define    p_reg_spi_polarity   0xF602
+#define reg_spi_polarity_pos 1
+#define reg_spi_polarity_len 1
+#define reg_spi_polarity_lsb 0
+#define    p_reg_spi_phase  0xF602
+#define reg_spi_phase_pos 2
+#define reg_spi_phase_len 1
+#define reg_spi_phase_lsb 0
+#define    p_reg_spi_1st_byte   0xF603
+#define reg_spi_1st_byte_pos 0
+#define reg_spi_1st_byte_len 4
+#define reg_spi_1st_byte_lsb 0
+#define    p_reg_spi_clk_div    0xF603
+#define reg_spi_clk_div_pos 4
+#define reg_spi_clk_div_len 4
+#define reg_spi_clk_div_lsb 0
+#define    p_reg_spi_rst    0xF604
+#define reg_spi_rst_pos 0
+#define reg_spi_rst_len 1
+#define reg_spi_rst_lsb 0
+#define    r_reg_spi_tx_done    0xF604
+#define reg_spi_tx_done_pos 1
+#define reg_spi_tx_done_len 1
+#define reg_spi_tx_done_lsb 0
+#define    r_reg_spi_rx_done    0xF604
+#define reg_spi_rx_done_pos 2
+#define reg_spi_rx_done_len 1
+#define reg_spi_rx_done_lsb 0
+#define    p_reg_spi_dbg_sel    0xF604
+#define reg_spi_dbg_sel_pos 3
+#define reg_spi_dbg_sel_len 1
+#define reg_spi_dbg_sel_lsb 0
+#define    r_reg_spi_crc_err    0xF604
+#define reg_spi_crc_err_pos 4
+#define reg_spi_crc_err_len 4
+#define reg_spi_crc_err_lsb 0
+#define    r_link_ofsm_usb20_mode   0xF613
+#define link_ofsm_usb20_mode_pos 0
+#define link_ofsm_usb20_mode_len 1
+#define link_ofsm_usb20_mode_lsb 0
+#define    r_link_ofsm_strap_usb20_mode 0xF613
+#define link_ofsm_strap_usb20_mode_pos 1
+#define link_ofsm_strap_usb20_mode_len 1
+#define link_ofsm_strap_usb20_mode_lsb 0
+#define    p_reg_link_stick_mem_end_7_0 0xF618
+#define reg_link_stick_mem_end_7_0_pos 0
+#define reg_link_stick_mem_end_7_0_len 8
+#define reg_link_stick_mem_end_7_0_lsb 0
+#define    p_reg_link_stick_mem_end_15_8    0xF619
+#define reg_link_stick_mem_end_15_8_pos 0
+#define reg_link_stick_mem_end_15_8_len 8
+#define reg_link_stick_mem_end_15_8_lsb 8
+#define    p_reg_ofdm_auto_write_addr_l 0xF61A
+#define reg_ofdm_auto_write_addr_l_pos 0
+#define reg_ofdm_auto_write_addr_l_len 8
+#define reg_ofdm_auto_write_addr_l_lsb 0
+#define    p_reg_ofdm_auto_write_addr_h 0xF61B
+#define reg_ofdm_auto_write_addr_h_pos 0
+#define reg_ofdm_auto_write_addr_h_len 8
+#define reg_ofdm_auto_write_addr_h_lsb 0
+#define    p_reg_link_auto_write_addr_l 0xF61C
+#define reg_link_auto_write_addr_l_pos 0
+#define reg_link_auto_write_addr_l_len 8
+#define reg_link_auto_write_addr_l_lsb 0
+#define    p_reg_link_auto_write_addr_h 0xF61D
+#define reg_link_auto_write_addr_h_pos 0
+#define reg_link_auto_write_addr_h_len 8
+#define reg_link_auto_write_addr_h_lsb 0
+#define    p_reg_mailbox_auto_write_addr    0xF61E
+#define reg_mailbox_auto_write_addr_pos 0
+#define reg_mailbox_auto_write_addr_len 8
+#define reg_mailbox_auto_write_addr_lsb 0
+#define    p_reg_usbmem_auto_write_addr 0xF61F
+#define reg_usbmem_auto_write_addr_pos 0
+#define reg_usbmem_auto_write_addr_len 8
+#define reg_usbmem_auto_write_addr_lsb 0
+#define    p_reg_mailbox_auto_read_addr 0xF620
+#define reg_mailbox_auto_read_addr_pos 0
+#define reg_mailbox_auto_read_addr_len 8
+#define reg_mailbox_auto_read_addr_lsb 0
+#define    p_reg_usbmem_auto_read_addr  0xF621
+#define reg_usbmem_auto_read_addr_pos 0
+#define reg_usbmem_auto_read_addr_len 8
+#define reg_usbmem_auto_read_addr_lsb 0
+#define    p_reg_auto_write_ofdm    0xF622
+#define reg_auto_write_ofdm_pos 0
+#define reg_auto_write_ofdm_len 1
+#define reg_auto_write_ofdm_lsb 0
+#define    p_reg_auto_write_link    0xF622
+#define reg_auto_write_link_pos 1
+#define reg_auto_write_link_len 1
+#define reg_auto_write_link_lsb 0
+#define    p_reg_auto_write_mailbox 0xF622
+#define reg_auto_write_mailbox_pos 2
+#define reg_auto_write_mailbox_len 1
+#define reg_auto_write_mailbox_lsb 0
+#define    p_reg_auto_write_usbmem  0xF622
+#define reg_auto_write_usbmem_pos 3
+#define reg_auto_write_usbmem_len 1
+#define reg_auto_write_usbmem_lsb 0
+#define    p_reg_auto_write_i2cm    0xF622
+#define reg_auto_write_i2cm_pos 4
+#define reg_auto_write_i2cm_len 1
+#define reg_auto_write_i2cm_lsb 0
+#define    p_reg_auto_read_mailbox  0xF623
+#define reg_auto_read_mailbox_pos 0
+#define reg_auto_read_mailbox_len 1
+#define reg_auto_read_mailbox_lsb 0
+#define    p_reg_auto_read_rom  0xF623
+#define reg_auto_read_rom_pos 1
+#define reg_auto_read_rom_len 1
+#define reg_auto_read_rom_lsb 0
+#define    p_reg_auto_sum_l 0xF624
+#define reg_auto_sum_l_pos 0
+#define reg_auto_sum_l_len 8
+#define reg_auto_sum_l_lsb 0
+#define    p_reg_auto_sum_h 0xF625
+#define reg_auto_sum_h_pos 0
+#define reg_auto_sum_h_len 8
+#define reg_auto_sum_h_lsb 0
+#define    p_reg_auto_sum_to_h  0xF626
+#define reg_auto_sum_to_h_pos 0
+#define reg_auto_sum_to_h_len 1
+#define reg_auto_sum_to_h_lsb 0
+#define    p_reg_auto_sum_en    0xF627
+#define reg_auto_sum_en_pos 0
+#define reg_auto_sum_en_len 1
+#define reg_auto_sum_en_lsb 0
+#define    p_reg_rom_remap_begin_7_0    0xF628
+#define reg_rom_remap_begin_7_0_pos 0
+#define reg_rom_remap_begin_7_0_len 8
+#define reg_rom_remap_begin_7_0_lsb 0
+#define    p_reg_rom_remap_begin_15_8   0xF629
+#define reg_rom_remap_begin_15_8_pos 0
+#define reg_rom_remap_begin_15_8_len 8
+#define reg_rom_remap_begin_15_8_lsb 8
+#define    p_reg_rom_remap_end_7_0  0xF62A
+#define reg_rom_remap_end_7_0_pos 0
+#define reg_rom_remap_end_7_0_len 8
+#define reg_rom_remap_end_7_0_lsb 0
+#define    p_reg_rom_remap_end_15_8 0xF62B
+#define reg_rom_remap_end_15_8_pos 0
+#define reg_rom_remap_end_15_8_len 8
+#define reg_rom_remap_end_15_8_lsb 8
+#define    p_reg_rom_remap_delta_7_0    0xF62C
+#define reg_rom_remap_delta_7_0_pos 0
+#define reg_rom_remap_delta_7_0_len 8
+#define reg_rom_remap_delta_7_0_lsb 0
+#define    p_reg_rom_remap_delta_15_8   0xF62D
+#define reg_rom_remap_delta_15_8_pos 0
+#define reg_rom_remap_delta_15_8_len 8
+#define reg_rom_remap_delta_15_8_lsb 8
+#define    p_reg_rom_remap_en   0xF62E
+#define reg_rom_remap_en_pos 0
+#define reg_rom_remap_en_len 1
+#define reg_rom_remap_en_lsb 0
+#define    p_reg_rom_remap_ofdm 0xF62E
+#define reg_rom_remap_ofdm_pos 1
+#define reg_rom_remap_ofdm_len 1
+#define reg_rom_remap_ofdm_lsb 0
+#define    p_reg_link_cpu_reset 0xF62F
+#define reg_link_cpu_reset_pos 0
+#define reg_link_cpu_reset_len 1
+#define reg_link_cpu_reset_lsb 0
+#define    p_reg_i2cm_auto_write_addr   0xF630
+#define reg_i2cm_auto_write_addr_pos 0
+#define reg_i2cm_auto_write_addr_len 8
+#define reg_i2cm_auto_write_addr_lsb 0
+#define    p_reg_link_bank_float_en 0xF631
+#define reg_link_bank_float_en_pos 0
+#define reg_link_bank_float_en_len 1
+#define reg_link_bank_float_en_lsb 0
+#define    p_reg_link_bank_float_start  0xF632
+#define reg_link_bank_float_start_pos 0
+#define reg_link_bank_float_start_len 8
+#define reg_link_bank_float_start_lsb 0
+#define    p_reg_link_bank_float_stop   0xF633
+#define reg_link_bank_float_stop_pos 0
+#define reg_link_bank_float_stop_len 8
+#define reg_link_bank_float_stop_lsb 0
+#define    p_reg_rom_auto_read_addr_7_0 0xF638
+#define reg_rom_auto_read_addr_7_0_pos 0
+#define reg_rom_auto_read_addr_7_0_len 8
+#define reg_rom_auto_read_addr_7_0_lsb 0
+#define    p_reg_rom_auto_read_addr_15_8    0xF639
+#define reg_rom_auto_read_addr_15_8_pos 0
+#define reg_rom_auto_read_addr_15_8_len 8
+#define reg_rom_auto_read_addr_15_8_lsb 8
+#define    p_reg_link_ofsm_dummy_7_0    0xF640
+#define reg_link_ofsm_dummy_7_0_pos 0
+#define reg_link_ofsm_dummy_7_0_len 8
+#define reg_link_ofsm_dummy_7_0_lsb 0
+#define    p_reg_link_ofsm_dummy_15_8   0xF641
+#define reg_link_ofsm_dummy_15_8_pos 0
+#define reg_link_ofsm_dummy_15_8_len 8
+#define reg_link_ofsm_dummy_15_8_lsb 8
+#define    p_reg_link_ofsm_dummy_23_16  0xF642
+#define reg_link_ofsm_dummy_23_16_pos 0
+#define reg_link_ofsm_dummy_23_16_len 8
+#define reg_link_ofsm_dummy_23_16_lsb 16
+#define    p_reg_link_ofsm_dummy_31_24  0xF643
+#define reg_link_ofsm_dummy_31_24_pos 0
+#define reg_link_ofsm_dummy_31_24_len 8
+#define reg_link_ofsm_dummy_31_24_lsb 24
+#define    p_reg_link_ofsm_dummy_39_32  0xF644
+#define reg_link_ofsm_dummy_39_32_pos 0
+#define reg_link_ofsm_dummy_39_32_len 8
+#define reg_link_ofsm_dummy_39_32_lsb 32
+#define    p_reg_link_ofsm_dummy_47_40  0xF645
+#define reg_link_ofsm_dummy_47_40_pos 0
+#define reg_link_ofsm_dummy_47_40_len 8
+#define reg_link_ofsm_dummy_47_40_lsb 40
+#define    p_reg_link_ofsm_dummy_55_48  0xF646
+#define reg_link_ofsm_dummy_55_48_pos 0
+#define reg_link_ofsm_dummy_55_48_len 8
+#define reg_link_ofsm_dummy_55_48_lsb 48
+#define    p_reg_link_ofsm_dummy_63_56  0xF647
+#define reg_link_ofsm_dummy_63_56_pos 0
+#define reg_link_ofsm_dummy_63_56_len 8
+#define reg_link_ofsm_dummy_63_56_lsb 56
+#define    p_reg_link_ofsm_dummy_71_64  0xF648
+#define reg_link_ofsm_dummy_71_64_pos 0
+#define reg_link_ofsm_dummy_71_64_len 8
+#define reg_link_ofsm_dummy_71_64_lsb 64
+#define    p_reg_link_ofsm_dummy_79_72  0xF649
+#define reg_link_ofsm_dummy_79_72_pos 0
+#define reg_link_ofsm_dummy_79_72_len 8
+#define reg_link_ofsm_dummy_79_72_lsb 72
+#define    p_reg_sdio_mode  0xF66F
+#define reg_sdio_mode_pos 0
+#define reg_sdio_mode_len 1
+#define reg_sdio_mode_lsb 0
+#define    p_reg_lnk2ofdm_data_7_0  0xF6A0
+#define reg_lnk2ofdm_data_7_0_pos 0
+#define reg_lnk2ofdm_data_7_0_len 8
+#define reg_lnk2ofdm_data_7_0_lsb 0
+#define    p_reg_lnk2ofdm_data_15_8 0xF6A1
+#define reg_lnk2ofdm_data_15_8_pos 0
+#define reg_lnk2ofdm_data_15_8_len 8
+#define reg_lnk2ofdm_data_15_8_lsb 8
+#define    p_reg_lnk2ofdm_data_23_16    0xF6A2
+#define reg_lnk2ofdm_data_23_16_pos 0
+#define reg_lnk2ofdm_data_23_16_len 8
+#define reg_lnk2ofdm_data_23_16_lsb 16
+#define    p_reg_lnk2ofdm_data_31_24    0xF6A3
+#define reg_lnk2ofdm_data_31_24_pos 0
+#define reg_lnk2ofdm_data_31_24_len 8
+#define reg_lnk2ofdm_data_31_24_lsb 24
+#define    p_reg_lnk2ofdm_data_39_32    0xF6A4
+#define reg_lnk2ofdm_data_39_32_pos 0
+#define reg_lnk2ofdm_data_39_32_len 8
+#define reg_lnk2ofdm_data_39_32_lsb 32
+#define    p_reg_lnk2ofdm_data_47_40    0xF6A5
+#define reg_lnk2ofdm_data_47_40_pos 0
+#define reg_lnk2ofdm_data_47_40_len 8
+#define reg_lnk2ofdm_data_47_40_lsb 40
+#define    p_reg_lnk2ofdm_data_55_48    0xF6A6
+#define reg_lnk2ofdm_data_55_48_pos 0
+#define reg_lnk2ofdm_data_55_48_len 8
+#define reg_lnk2ofdm_data_55_48_lsb 48
+#define    p_reg_lnk2ofdm_data_63_56    0xF6A7
+#define reg_lnk2ofdm_data_63_56_pos 0
+#define reg_lnk2ofdm_data_63_56_len 8
+#define reg_lnk2ofdm_data_63_56_lsb 56
+#define    p_reg_ofdmtolnk_data_7_0 0xF6A8
+#define reg_ofdmtolnk_data_7_0_pos 0
+#define reg_ofdmtolnk_data_7_0_len 8
+#define reg_ofdmtolnk_data_7_0_lsb 0
+#define    p_reg_ofdmtolnk_data_15_8    0xF6A9
+#define reg_ofdmtolnk_data_15_8_pos 0
+#define reg_ofdmtolnk_data_15_8_len 8
+#define reg_ofdmtolnk_data_15_8_lsb 8
+#define    p_reg_ofdmtolnk_data_23_16   0xF6AA
+#define reg_ofdmtolnk_data_23_16_pos 0
+#define reg_ofdmtolnk_data_23_16_len 8
+#define reg_ofdmtolnk_data_23_16_lsb 16
+#define    p_reg_ofdmtolnk_data_31_24   0xF6AB
+#define reg_ofdmtolnk_data_31_24_pos 0
+#define reg_ofdmtolnk_data_31_24_len 8
+#define reg_ofdmtolnk_data_31_24_lsb 24
+#define    p_reg_ofdmtolnk_data_39_32   0xF6AC
+#define reg_ofdmtolnk_data_39_32_pos 0
+#define reg_ofdmtolnk_data_39_32_len 8
+#define reg_ofdmtolnk_data_39_32_lsb 32
+#define    p_reg_ofdmtolnk_data_47_40   0xF6AD
+#define reg_ofdmtolnk_data_47_40_pos 0
+#define reg_ofdmtolnk_data_47_40_len 8
+#define reg_ofdmtolnk_data_47_40_lsb 40
+#define    p_reg_ofdmtolnk_data_55_48   0xF6AE
+#define reg_ofdmtolnk_data_55_48_pos 0
+#define reg_ofdmtolnk_data_55_48_len 8
+#define reg_ofdmtolnk_data_55_48_lsb 48
+#define    p_reg_ofdmtolnk_data_63_56   0xF6AF
+#define reg_ofdmtolnk_data_63_56_pos 0
+#define reg_ofdmtolnk_data_63_56_len 8
+#define reg_ofdmtolnk_data_63_56_lsb 56
+#define    p_reg_mon51_flag 0xF6B0
+#define reg_mon51_flag_pos 0
+#define reg_mon51_flag_len 1
+#define reg_mon51_flag_lsb 0
+#define    p_reg_force_mon51    0xF6B1
+#define reg_force_mon51_pos 0
+#define reg_force_mon51_len 1
+#define reg_force_mon51_lsb 0
+#define    p_reg_which_cpu  0xF6B2
+#define reg_which_cpu_pos 0
+#define reg_which_cpu_len 1
+#define reg_which_cpu_lsb 0
+#define    p_reg_program_ofdm_code_ready    0xF6B3
+#define reg_program_ofdm_code_ready_pos 0
+#define reg_program_ofdm_code_ready_len 1
+#define reg_program_ofdm_code_ready_lsb 0
+#define    p_reg_link_wr_ofdm_en    0xF6B3
+#define reg_link_wr_ofdm_en_pos 1
+#define reg_link_wr_ofdm_en_len 1
+#define reg_link_wr_ofdm_en_lsb 0
+#define    p_reg_i2c_mode   0xF6B4
+#define reg_i2c_mode_pos 0
+#define reg_i2c_mode_len 1
+#define reg_i2c_mode_lsb 0
+#define    p_reg_sw_reset_sdio  0xF6B4
+#define reg_sw_reset_sdio_pos 1
+#define reg_sw_reset_sdio_len 1
+#define reg_sw_reset_sdio_lsb 0
+#define    p_reg_debug_mpefec_sel   0xF6B4
+#define reg_debug_mpefec_sel_pos 2
+#define reg_debug_mpefec_sel_len 1
+#define reg_debug_mpefec_sel_lsb 0
+#define    p_reg_lnk_dynamic_clk    0xF6B4
+#define reg_lnk_dynamic_clk_pos 3
+#define reg_lnk_dynamic_clk_len 1
+#define reg_lnk_dynamic_clk_lsb 0
+#define    p_reg_lnk_free_clk   0xF6B4
+#define reg_lnk_free_clk_pos 4
+#define reg_lnk_free_clk_len 1
+#define reg_lnk_free_clk_lsb 0
+#define    p_reg_i2c_sample_rate_up_en  0xF6B4
+#define reg_i2c_sample_rate_up_en_pos 5
+#define reg_i2c_sample_rate_up_en_len 1
+#define reg_i2c_sample_rate_up_en_lsb 0
+#define    p_reg_i2c_start_patch    0xF6B4
+#define reg_i2c_start_patch_pos 6
+#define reg_i2c_start_patch_len 1
+#define reg_i2c_start_patch_lsb 0
+#define    p_reg_link_i2cs_msb  0xF6B5
+#define reg_link_i2cs_msb_pos 1
+#define reg_link_i2cs_msb_len 1
+#define reg_link_i2cs_msb_lsb 0
+#define    p_reg_link_ofsm_dbg_en   0xF6B5
+#define reg_link_ofsm_dbg_en_pos 4
+#define reg_link_ofsm_dbg_en_len 1
+#define reg_link_ofsm_dbg_en_lsb 0
+#define    p_reg_link_i2c_dbg_sel   0xF6B5
+#define reg_link_i2c_dbg_sel_pos 5
+#define reg_link_i2c_dbg_sel_len 1
+#define reg_link_i2c_dbg_sel_lsb 0
+#define    p_reg_fast_slow_train    0xF6DD
+#define    p_reg_lnk2ofdm_int   0xF6DE
+#define reg_lnk2ofdm_int_pos 0
+#define reg_lnk2ofdm_int_len 1
+#define reg_lnk2ofdm_int_lsb 0
+#define    p_reg_ofdm2lnk_int   0xF6DF
+#define reg_ofdm2lnk_int_pos 0
+#define reg_ofdm2lnk_int_len 1
+#define reg_ofdm2lnk_int_lsb 0
+#define    p_reg_load_ofdm_reg  0xF6E4
+#define    p_link_ofsm_cmd_reg  0xF6EA
+#define link_ofsm_cmd_reg_pos 0
+#define link_ofsm_cmd_reg_len 8
+#define link_ofsm_cmd_reg_lsb 0
+#define    p_link_ofsm_addr_reg_h   0xF6EB
+#define link_ofsm_addr_reg_h_pos 0
+#define link_ofsm_addr_reg_h_len 8
+#define link_ofsm_addr_reg_h_lsb 0
+#define    p_link_ofsm_addr_reg_l   0xF6EC
+#define link_ofsm_addr_reg_l_pos 0
+#define link_ofsm_addr_reg_l_len 8
+#define link_ofsm_addr_reg_l_lsb 0
+#define    p_link_ofsm_data_reg_0   0xF6ED
+#define link_ofsm_data_reg_0_pos 0
+#define link_ofsm_data_reg_0_len 8
+#define link_ofsm_data_reg_0_lsb 0
+#define    p_link_ofsm_data_reg_1   0xF6EE
+#define link_ofsm_data_reg_1_pos 0
+#define link_ofsm_data_reg_1_len 8
+#define link_ofsm_data_reg_1_lsb 0
+#define    p_link_ofsm_data_reg_2   0xF6EF
+#define link_ofsm_data_reg_2_pos 0
+#define link_ofsm_data_reg_2_len 8
+#define link_ofsm_data_reg_2_lsb 0
+#define    p_link_ofsm_data_reg_3   0xF6F0
+#define link_ofsm_data_reg_3_pos 0
+#define link_ofsm_data_reg_3_len 8
+#define link_ofsm_data_reg_3_lsb 0
+#define    p_link_ofsm_data_reg_4   0xF6F1
+#define link_ofsm_data_reg_4_pos 0
+#define link_ofsm_data_reg_4_len 8
+#define link_ofsm_data_reg_4_lsb 0
+#define    p_link_ofsm_data_reg_5   0xF6F2
+#define link_ofsm_data_reg_5_pos 0
+#define link_ofsm_data_reg_5_len 8
+#define link_ofsm_data_reg_5_lsb 0
+#define    p_link_ofsm_data_reg_6   0xF6F3
+#define link_ofsm_data_reg_6_pos 0
+#define link_ofsm_data_reg_6_len 8
+#define link_ofsm_data_reg_6_lsb 0
+#define    p_link_ofsm_data_reg_7   0xF6F4
+#define link_ofsm_data_reg_7_pos 0
+#define link_ofsm_data_reg_7_len 8
+#define link_ofsm_data_reg_7_lsb 0
+#define    p_link_ofsm_data_reg_8   0xF6F5
+#define link_ofsm_data_reg_8_pos 0
+#define link_ofsm_data_reg_8_len 8
+#define link_ofsm_data_reg_8_lsb 0
+#define    p_link_ofsm_data_reg_9   0xF6F6
+#define link_ofsm_data_reg_9_pos 0
+#define link_ofsm_data_reg_9_len 8
+#define link_ofsm_data_reg_9_lsb 0
+#define    p_link_ofsm_data_reg_10  0xF6F7
+#define link_ofsm_data_reg_10_pos 0
+#define link_ofsm_data_reg_10_len 8
+#define link_ofsm_data_reg_10_lsb 0
+#define    p_link_ofsm_data_reg_11  0xF6F8
+#define link_ofsm_data_reg_11_pos 0
+#define link_ofsm_data_reg_11_len 8
+#define link_ofsm_data_reg_11_lsb 0
+#define    p_link_ofsm_data_reg_12  0xF6F9
+#define link_ofsm_data_reg_12_pos 0
+#define link_ofsm_data_reg_12_len 8
+#define link_ofsm_data_reg_12_lsb 0
+#define    p_link_ofsm_data_reg_13  0xF6FA
+#define link_ofsm_data_reg_13_pos 0
+#define link_ofsm_data_reg_13_len 8
+#define link_ofsm_data_reg_13_lsb 0
+#define    p_link_ofsm_data_reg_14  0xF6FB
+#define link_ofsm_data_reg_14_pos 0
+#define link_ofsm_data_reg_14_len 8
+#define link_ofsm_data_reg_14_lsb 0
+#define    p_link_ofsm_data_reg_15  0xF6FC
+#define link_ofsm_data_reg_15_pos 0
+#define link_ofsm_data_reg_15_len 8
+#define link_ofsm_data_reg_15_lsb 0
+#define    p_reg_debug_mux  0xF6FE
+#define reg_debug_mux_pos 3
+#define reg_debug_mux_len 1
+#define reg_debug_mux_lsb 0
+#define    p_reg_top_gpioon0    0xF6FF
+#define reg_top_gpioon0_pos 0
+#define reg_top_gpioon0_len 1
+#define reg_top_gpioon0_lsb 0
+#define    p_reg_p_dmb_phy_is_dvb   0xDC31
+#define reg_p_dmb_phy_is_dvb_pos 0
+#define reg_p_dmb_phy_is_dvb_len 1
+#define reg_p_dmb_phy_is_dvb_lsb 0
+#define    p_reg_p_dmb_xt_reset 0xDC32
+#define reg_p_dmb_xt_reset_pos 0
+#define reg_p_dmb_xt_reset_len 1
+#define reg_p_dmb_xt_reset_lsb 0
+#define    p_reg_p_dmb_sw_reset 0xDC33
+#define reg_p_dmb_sw_reset_pos 0
+#define reg_p_dmb_sw_reset_len 1
+#define reg_p_dmb_sw_reset_lsb 0
+
+#endif
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c
--- media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c	2012-02-27 10:48:36.988908938 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c	2012-02-15 05:45:37.000000000 +0100
@@ -1950,7 +1950,6 @@
 		status = GetDVBTLockStatus(state, pLockStatus);
 		break;
 	default:
-		status = 0;
 		break;
 	}
 error:
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c.orig media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c.orig
--- media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c.orig	2012-02-15 05:45:37.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/drxk_hard.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,6449 +0,0 @@
-/*
- * drxk_hard: DRX-K DVB-C/T demodulator driver
- *
- * Copyright (C) 2010-2011 Digital Devices GmbH
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 only, as published by the Free Software Foundation.
- *
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA
- * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/firmware.h>
-#include <linux/i2c.h>
-#include <asm/div64.h>
-
-#include "dvb_frontend.h"
-#include "drxk.h"
-#include "drxk_hard.h"
-
-static int PowerDownDVBT(struct drxk_state *state, bool setPowerMode);
-static int PowerDownQAM(struct drxk_state *state);
-static int SetDVBTStandard(struct drxk_state *state,
-			   enum OperationMode oMode);
-static int SetQAMStandard(struct drxk_state *state,
-			  enum OperationMode oMode);
-static int SetQAM(struct drxk_state *state, u16 IntermediateFreqkHz,
-		  s32 tunerFreqOffset);
-static int SetDVBTStandard(struct drxk_state *state,
-			   enum OperationMode oMode);
-static int DVBTStart(struct drxk_state *state);
-static int SetDVBT(struct drxk_state *state, u16 IntermediateFreqkHz,
-		   s32 tunerFreqOffset);
-static int GetQAMLockStatus(struct drxk_state *state, u32 *pLockStatus);
-static int GetDVBTLockStatus(struct drxk_state *state, u32 *pLockStatus);
-static int SwitchAntennaToQAM(struct drxk_state *state);
-static int SwitchAntennaToDVBT(struct drxk_state *state);
-
-static bool IsDVBT(struct drxk_state *state)
-{
-	return state->m_OperationMode == OM_DVBT;
-}
-
-static bool IsQAM(struct drxk_state *state)
-{
-	return state->m_OperationMode == OM_QAM_ITU_A ||
-	    state->m_OperationMode == OM_QAM_ITU_B ||
-	    state->m_OperationMode == OM_QAM_ITU_C;
-}
-
-bool IsA1WithPatchCode(struct drxk_state *state)
-{
-	return state->m_DRXK_A1_PATCH_CODE;
-}
-
-bool IsA1WithRomCode(struct drxk_state *state)
-{
-	return state->m_DRXK_A1_ROM_CODE;
-}
-
-#define NOA1ROM 0
-
-#define DRXDAP_FASI_SHORT_FORMAT(addr) (((addr) & 0xFC30FF80) == 0)
-#define DRXDAP_FASI_LONG_FORMAT(addr)  (((addr) & 0xFC30FF80) != 0)
-
-#define DEFAULT_MER_83  165
-#define DEFAULT_MER_93  250
-
-#ifndef DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH
-#define DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH (0x02)
-#endif
-
-#ifndef DRXK_MPEG_PARALLEL_OUTPUT_PIN_DRIVE_STRENGTH
-#define DRXK_MPEG_PARALLEL_OUTPUT_PIN_DRIVE_STRENGTH (0x03)
-#endif
-
-#define DEFAULT_DRXK_MPEG_LOCK_TIMEOUT 700
-#define DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT 500
-
-#ifndef DRXK_KI_RAGC_ATV
-#define DRXK_KI_RAGC_ATV   4
-#endif
-#ifndef DRXK_KI_IAGC_ATV
-#define DRXK_KI_IAGC_ATV   6
-#endif
-#ifndef DRXK_KI_DAGC_ATV
-#define DRXK_KI_DAGC_ATV   7
-#endif
-
-#ifndef DRXK_KI_RAGC_QAM
-#define DRXK_KI_RAGC_QAM   3
-#endif
-#ifndef DRXK_KI_IAGC_QAM
-#define DRXK_KI_IAGC_QAM   4
-#endif
-#ifndef DRXK_KI_DAGC_QAM
-#define DRXK_KI_DAGC_QAM   7
-#endif
-#ifndef DRXK_KI_RAGC_DVBT
-#define DRXK_KI_RAGC_DVBT  (IsA1WithPatchCode(state) ? 3 : 2)
-#endif
-#ifndef DRXK_KI_IAGC_DVBT
-#define DRXK_KI_IAGC_DVBT  (IsA1WithPatchCode(state) ? 4 : 2)
-#endif
-#ifndef DRXK_KI_DAGC_DVBT
-#define DRXK_KI_DAGC_DVBT  (IsA1WithPatchCode(state) ? 10 : 7)
-#endif
-
-#ifndef DRXK_AGC_DAC_OFFSET
-#define DRXK_AGC_DAC_OFFSET (0x800)
-#endif
-
-#ifndef DRXK_BANDWIDTH_8MHZ_IN_HZ
-#define DRXK_BANDWIDTH_8MHZ_IN_HZ  (0x8B8249L)
-#endif
-
-#ifndef DRXK_BANDWIDTH_7MHZ_IN_HZ
-#define DRXK_BANDWIDTH_7MHZ_IN_HZ  (0x7A1200L)
-#endif
-
-#ifndef DRXK_BANDWIDTH_6MHZ_IN_HZ
-#define DRXK_BANDWIDTH_6MHZ_IN_HZ  (0x68A1B6L)
-#endif
-
-#ifndef DRXK_QAM_SYMBOLRATE_MAX
-#define DRXK_QAM_SYMBOLRATE_MAX         (7233000)
-#endif
-
-#define DRXK_BL_ROM_OFFSET_TAPS_DVBT    56
-#define DRXK_BL_ROM_OFFSET_TAPS_ITU_A   64
-#define DRXK_BL_ROM_OFFSET_TAPS_ITU_C   0x5FE0
-#define DRXK_BL_ROM_OFFSET_TAPS_BG      24
-#define DRXK_BL_ROM_OFFSET_TAPS_DKILLP  32
-#define DRXK_BL_ROM_OFFSET_TAPS_NTSC    40
-#define DRXK_BL_ROM_OFFSET_TAPS_FM      48
-#define DRXK_BL_ROM_OFFSET_UCODE        0
-
-#define DRXK_BLC_TIMEOUT                100
-
-#define DRXK_BLCC_NR_ELEMENTS_TAPS      2
-#define DRXK_BLCC_NR_ELEMENTS_UCODE     6
-
-#define DRXK_BLDC_NR_ELEMENTS_TAPS      28
-
-#ifndef DRXK_OFDM_NE_NOTCH_WIDTH
-#define DRXK_OFDM_NE_NOTCH_WIDTH             (4)
-#endif
-
-#define DRXK_QAM_SL_SIG_POWER_QAM16       (40960)
-#define DRXK_QAM_SL_SIG_POWER_QAM32       (20480)
-#define DRXK_QAM_SL_SIG_POWER_QAM64       (43008)
-#define DRXK_QAM_SL_SIG_POWER_QAM128      (20992)
-#define DRXK_QAM_SL_SIG_POWER_QAM256      (43520)
-
-static unsigned int debug;
-module_param(debug, int, 0644);
-MODULE_PARM_DESC(debug, "enable debug messages");
-
-#define dprintk(level, fmt, arg...) do {			\
-if (debug >= level)						\
-	printk(KERN_DEBUG "drxk: %s" fmt, __func__, ## arg);	\
-} while (0)
-
-
-static inline u32 MulDiv32(u32 a, u32 b, u32 c)
-{
-	u64 tmp64;
-
-	tmp64 = (u64) a * (u64) b;
-	do_div(tmp64, c);
-
-	return (u32) tmp64;
-}
-
-inline u32 Frac28a(u32 a, u32 c)
-{
-	int i = 0;
-	u32 Q1 = 0;
-	u32 R0 = 0;
-
-	R0 = (a % c) << 4;	/* 32-28 == 4 shifts possible at max */
-	Q1 = a / c;		/* integer part, only the 4 least significant bits
-				   will be visible in the result */
-
-	/* division using radix 16, 7 nibbles in the result */
-	for (i = 0; i < 7; i++) {
-		Q1 = (Q1 << 4) | (R0 / c);
-		R0 = (R0 % c) << 4;
-	}
-	/* rounding */
-	if ((R0 >> 3) >= c)
-		Q1++;
-
-	return Q1;
-}
-
-static u32 Log10Times100(u32 x)
-{
-	static const u8 scale = 15;
-	static const u8 indexWidth = 5;
-	u8 i = 0;
-	u32 y = 0;
-	u32 d = 0;
-	u32 k = 0;
-	u32 r = 0;
-	/*
-	   log2lut[n] = (1<<scale) * 200 * log2(1.0 + ((1.0/(1<<INDEXWIDTH)) * n))
-	   0 <= n < ((1<<INDEXWIDTH)+1)
-	 */
-
-	static const u32 log2lut[] = {
-		0,		/* 0.000000 */
-		290941,		/* 290941.300628 */
-		573196,		/* 573196.476418 */
-		847269,		/* 847269.179851 */
-		1113620,	/* 1113620.489452 */
-		1372674,	/* 1372673.576986 */
-		1624818,	/* 1624817.752104 */
-		1870412,	/* 1870411.981536 */
-		2109788,	/* 2109787.962654 */
-		2343253,	/* 2343252.817465 */
-		2571091,	/* 2571091.461923 */
-		2793569,	/* 2793568.696416 */
-		3010931,	/* 3010931.055901 */
-		3223408,	/* 3223408.452106 */
-		3431216,	/* 3431215.635215 */
-		3634553,	/* 3634553.498355 */
-		3833610,	/* 3833610.244726 */
-		4028562,	/* 4028562.434393 */
-		4219576,	/* 4219575.925308 */
-		4406807,	/* 4406806.721144 */
-		4590402,	/* 4590401.736809 */
-		4770499,	/* 4770499.491025 */
-		4947231,	/* 4947230.734179 */
-		5120719,	/* 5120719.018555 */
-		5291081,	/* 5291081.217197 */
-		5458428,	/* 5458427.996830 */
-		5622864,	/* 5622864.249668 */
-		5784489,	/* 5784489.488298 */
-		5943398,	/* 5943398.207380 */
-		6099680,	/* 6099680.215452 */
-		6253421,	/* 6253420.939751 */
-		6404702,	/* 6404701.706649 */
-		6553600,	/* 6553600.000000 */
-	};
-
-
-	if (x == 0)
-		return 0;
-
-	/* Scale x (normalize) */
-	/* computing y in log(x/y) = log(x) - log(y) */
-	if ((x & ((0xffffffff) << (scale + 1))) == 0) {
-		for (k = scale; k > 0; k--) {
-			if (x & (((u32) 1) << scale))
-				break;
-			x <<= 1;
-		}
-	} else {
-		for (k = scale; k < 31; k++) {
-			if ((x & (((u32) (-1)) << (scale + 1))) == 0)
-				break;
-			x >>= 1;
-		}
-	}
-	/*
-	   Now x has binary point between bit[scale] and bit[scale-1]
-	   and 1.0 <= x < 2.0 */
-
-	/* correction for divison: log(x) = log(x/y)+log(y) */
-	y = k * ((((u32) 1) << scale) * 200);
-
-	/* remove integer part */
-	x &= ((((u32) 1) << scale) - 1);
-	/* get index */
-	i = (u8) (x >> (scale - indexWidth));
-	/* compute delta (x - a) */
-	d = x & ((((u32) 1) << (scale - indexWidth)) - 1);
-	/* compute log, multiplication (d* (..)) must be within range ! */
-	y += log2lut[i] +
-	    ((d * (log2lut[i + 1] - log2lut[i])) >> (scale - indexWidth));
-	/* Conver to log10() */
-	y /= 108853;		/* (log2(10) << scale) */
-	r = (y >> 1);
-	/* rounding */
-	if (y & ((u32) 1))
-		r++;
-	return r;
-}
-
-/****************************************************************************/
-/* I2C **********************************************************************/
-/****************************************************************************/
-
-static int i2c_read1(struct i2c_adapter *adapter, u8 adr, u8 *val)
-{
-	struct i2c_msg msgs[1] = { {.addr = adr, .flags = I2C_M_RD,
-				    .buf = val, .len = 1}
-	};
-
-	return i2c_transfer(adapter, msgs, 1);
-}
-
-static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
-{
-	int status;
-	struct i2c_msg msg = {
-	    .addr = adr, .flags = 0, .buf = data, .len = len };
-
-	dprintk(3, ":");
-	if (debug > 2) {
-		int i;
-		for (i = 0; i < len; i++)
-			printk(KERN_CONT " %02x", data[i]);
-		printk(KERN_CONT "\n");
-	}
-	status = i2c_transfer(adap, &msg, 1);
-	if (status >= 0 && status != 1)
-		status = -EIO;
-
-	if (status < 0)
-		printk(KERN_ERR "drxk: i2c write error at addr 0x%02x\n", adr);
-
-	return status;
-}
-
-static int i2c_read(struct i2c_adapter *adap,
-		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
-{
-	int status;
-	struct i2c_msg msgs[2] = {
-		{.addr = adr, .flags = 0,
-				    .buf = msg, .len = len},
-		{.addr = adr, .flags = I2C_M_RD,
-		 .buf = answ, .len = alen}
-	};
-
-	status = i2c_transfer(adap, msgs, 2);
-	if (status != 2) {
-		if (debug > 2)
-			printk(KERN_CONT ": ERROR!\n");
-		if (status >= 0)
-			status = -EIO;
-
-		printk(KERN_ERR "drxk: i2c read error at addr 0x%02x\n", adr);
-		return status;
-	}
-	if (debug > 2) {
-		int i;
-		dprintk(2, ": read from");
-		for (i = 0; i < len; i++)
-			printk(KERN_CONT " %02x", msg[i]);
-		printk(KERN_CONT ", value = ");
-		for (i = 0; i < alen; i++)
-			printk(KERN_CONT " %02x", answ[i]);
-		printk(KERN_CONT "\n");
-	}
-	return 0;
-}
-
-static int read16_flags(struct drxk_state *state, u32 reg, u16 *data, u8 flags)
-{
-	int status;
-	u8 adr = state->demod_address, mm1[4], mm2[2], len;
-
-	if (state->single_master)
-		flags |= 0xC0;
-
-	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
-		mm1[0] = (((reg << 1) & 0xFF) | 0x01);
-		mm1[1] = ((reg >> 16) & 0xFF);
-		mm1[2] = ((reg >> 24) & 0xFF) | flags;
-		mm1[3] = ((reg >> 7) & 0xFF);
-		len = 4;
-	} else {
-		mm1[0] = ((reg << 1) & 0xFF);
-		mm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
-		len = 2;
-	}
-	dprintk(2, "(0x%08x, 0x%02x)\n", reg, flags);
-	status = i2c_read(state->i2c, adr, mm1, len, mm2, 2);
-	if (status < 0)
-		return status;
-	if (data)
-		*data = mm2[0] | (mm2[1] << 8);
-
-	return 0;
-}
-
-static int read16(struct drxk_state *state, u32 reg, u16 *data)
-{
-	return read16_flags(state, reg, data, 0);
-}
-
-static int read32_flags(struct drxk_state *state, u32 reg, u32 *data, u8 flags)
-{
-	int status;
-	u8 adr = state->demod_address, mm1[4], mm2[4], len;
-
-	if (state->single_master)
-		flags |= 0xC0;
-
-	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
-		mm1[0] = (((reg << 1) & 0xFF) | 0x01);
-		mm1[1] = ((reg >> 16) & 0xFF);
-		mm1[2] = ((reg >> 24) & 0xFF) | flags;
-		mm1[3] = ((reg >> 7) & 0xFF);
-		len = 4;
-	} else {
-		mm1[0] = ((reg << 1) & 0xFF);
-		mm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
-		len = 2;
-	}
-	dprintk(2, "(0x%08x, 0x%02x)\n", reg, flags);
-	status = i2c_read(state->i2c, adr, mm1, len, mm2, 4);
-	if (status < 0)
-		return status;
-	if (data)
-		*data = mm2[0] | (mm2[1] << 8) |
-		    (mm2[2] << 16) | (mm2[3] << 24);
-
-	return 0;
-}
-
-static int read32(struct drxk_state *state, u32 reg, u32 *data)
-{
-	return read32_flags(state, reg, data, 0);
-}
-
-static int write16_flags(struct drxk_state *state, u32 reg, u16 data, u8 flags)
-{
-	u8 adr = state->demod_address, mm[6], len;
-
-	if (state->single_master)
-		flags |= 0xC0;
-	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
-		mm[0] = (((reg << 1) & 0xFF) | 0x01);
-		mm[1] = ((reg >> 16) & 0xFF);
-		mm[2] = ((reg >> 24) & 0xFF) | flags;
-		mm[3] = ((reg >> 7) & 0xFF);
-		len = 4;
-	} else {
-		mm[0] = ((reg << 1) & 0xFF);
-		mm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
-		len = 2;
-	}
-	mm[len] = data & 0xff;
-	mm[len + 1] = (data >> 8) & 0xff;
-
-	dprintk(2, "(0x%08x, 0x%04x, 0x%02x)\n", reg, data, flags);
-	return i2c_write(state->i2c, adr, mm, len + 2);
-}
-
-static int write16(struct drxk_state *state, u32 reg, u16 data)
-{
-	return write16_flags(state, reg, data, 0);
-}
-
-static int write32_flags(struct drxk_state *state, u32 reg, u32 data, u8 flags)
-{
-	u8 adr = state->demod_address, mm[8], len;
-
-	if (state->single_master)
-		flags |= 0xC0;
-	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
-		mm[0] = (((reg << 1) & 0xFF) | 0x01);
-		mm[1] = ((reg >> 16) & 0xFF);
-		mm[2] = ((reg >> 24) & 0xFF) | flags;
-		mm[3] = ((reg >> 7) & 0xFF);
-		len = 4;
-	} else {
-		mm[0] = ((reg << 1) & 0xFF);
-		mm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
-		len = 2;
-	}
-	mm[len] = data & 0xff;
-	mm[len + 1] = (data >> 8) & 0xff;
-	mm[len + 2] = (data >> 16) & 0xff;
-	mm[len + 3] = (data >> 24) & 0xff;
-	dprintk(2, "(0x%08x, 0x%08x, 0x%02x)\n", reg, data, flags);
-
-	return i2c_write(state->i2c, adr, mm, len + 4);
-}
-
-static int write32(struct drxk_state *state, u32 reg, u32 data)
-{
-	return write32_flags(state, reg, data, 0);
-}
-
-static int write_block(struct drxk_state *state, u32 Address,
-		      const int BlockSize, const u8 pBlock[])
-{
-	int status = 0, BlkSize = BlockSize;
-	u8 Flags = 0;
-
-	if (state->single_master)
-		Flags |= 0xC0;
-
-	while (BlkSize > 0) {
-		int Chunk = BlkSize > state->m_ChunkSize ?
-		    state->m_ChunkSize : BlkSize;
-		u8 *AdrBuf = &state->Chunk[0];
-		u32 AdrLength = 0;
-
-		if (DRXDAP_FASI_LONG_FORMAT(Address) || (Flags != 0)) {
-			AdrBuf[0] = (((Address << 1) & 0xFF) | 0x01);
-			AdrBuf[1] = ((Address >> 16) & 0xFF);
-			AdrBuf[2] = ((Address >> 24) & 0xFF);
-			AdrBuf[3] = ((Address >> 7) & 0xFF);
-			AdrBuf[2] |= Flags;
-			AdrLength = 4;
-			if (Chunk == state->m_ChunkSize)
-				Chunk -= 2;
-		} else {
-			AdrBuf[0] = ((Address << 1) & 0xFF);
-			AdrBuf[1] = (((Address >> 16) & 0x0F) |
-				     ((Address >> 18) & 0xF0));
-			AdrLength = 2;
-		}
-		memcpy(&state->Chunk[AdrLength], pBlock, Chunk);
-		dprintk(2, "(0x%08x, 0x%02x)\n", Address, Flags);
-		if (debug > 1) {
-			int i;
-			if (pBlock)
-				for (i = 0; i < Chunk; i++)
-					printk(KERN_CONT " %02x", pBlock[i]);
-			printk(KERN_CONT "\n");
-		}
-		status = i2c_write(state->i2c, state->demod_address,
-				   &state->Chunk[0], Chunk + AdrLength);
-		if (status < 0) {
-			printk(KERN_ERR "drxk: %s: i2c write error at addr 0x%02x\n",
-			       __func__, Address);
-			break;
-		}
-		pBlock += Chunk;
-		Address += (Chunk >> 1);
-		BlkSize -= Chunk;
-	}
-	return status;
-}
-
-#ifndef DRXK_MAX_RETRIES_POWERUP
-#define DRXK_MAX_RETRIES_POWERUP 20
-#endif
-
-int PowerUpDevice(struct drxk_state *state)
-{
-	int status;
-	u8 data = 0;
-	u16 retryCount = 0;
-
-	dprintk(1, "\n");
-
-	status = i2c_read1(state->i2c, state->demod_address, &data);
-	if (status < 0) {
-		do {
-			data = 0;
-			status = i2c_write(state->i2c, state->demod_address,
-					   &data, 1);
-			msleep(10);
-			retryCount++;
-			if (status < 0)
-				continue;
-			status = i2c_read1(state->i2c, state->demod_address,
-					   &data);
-		} while (status < 0 &&
-			 (retryCount < DRXK_MAX_RETRIES_POWERUP));
-		if (status < 0 && retryCount >= DRXK_MAX_RETRIES_POWERUP)
-			goto error;
-	}
-
-	/* Make sure all clk domains are active */
-	status = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_NONE);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
-	if (status < 0)
-		goto error;
-	/* Enable pll lock tests */
-	status = write16(state, SIO_CC_PLL_LOCK__A, 1);
-	if (status < 0)
-		goto error;
-
-	state->m_currentPowerMode = DRX_POWER_UP;
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-
-static int init_state(struct drxk_state *state)
-{
-	/*
-	 * FIXME: most (all?) of the values bellow should be moved into
-	 * struct drxk_config, as they are probably board-specific
-	 */
-	u32 ulVSBIfAgcMode = DRXK_AGC_CTRL_AUTO;
-	u32 ulVSBIfAgcOutputLevel = 0;
-	u32 ulVSBIfAgcMinLevel = 0;
-	u32 ulVSBIfAgcMaxLevel = 0x7FFF;
-	u32 ulVSBIfAgcSpeed = 3;
-
-	u32 ulVSBRfAgcMode = DRXK_AGC_CTRL_AUTO;
-	u32 ulVSBRfAgcOutputLevel = 0;
-	u32 ulVSBRfAgcMinLevel = 0;
-	u32 ulVSBRfAgcMaxLevel = 0x7FFF;
-	u32 ulVSBRfAgcSpeed = 3;
-	u32 ulVSBRfAgcTop = 9500;
-	u32 ulVSBRfAgcCutOffCurrent = 4000;
-
-	u32 ulATVIfAgcMode = DRXK_AGC_CTRL_AUTO;
-	u32 ulATVIfAgcOutputLevel = 0;
-	u32 ulATVIfAgcMinLevel = 0;
-	u32 ulATVIfAgcMaxLevel = 0;
-	u32 ulATVIfAgcSpeed = 3;
-
-	u32 ulATVRfAgcMode = DRXK_AGC_CTRL_OFF;
-	u32 ulATVRfAgcOutputLevel = 0;
-	u32 ulATVRfAgcMinLevel = 0;
-	u32 ulATVRfAgcMaxLevel = 0;
-	u32 ulATVRfAgcTop = 9500;
-	u32 ulATVRfAgcCutOffCurrent = 4000;
-	u32 ulATVRfAgcSpeed = 3;
-
-	u32 ulQual83 = DEFAULT_MER_83;
-	u32 ulQual93 = DEFAULT_MER_93;
-
-	u32 ulMpegLockTimeOut = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;
-	u32 ulDemodLockTimeOut = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;
-
-	/* io_pad_cfg register (8 bit reg.) MSB bit is 1 (default value) */
-	/* io_pad_cfg_mode output mode is drive always */
-	/* io_pad_cfg_drive is set to power 2 (23 mA) */
-	u32 ulGPIOCfg = 0x0113;
-	u32 ulInvertTSClock = 0;
-	u32 ulTSDataStrength = DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH;
-	u32 ulDVBTBitrate = 50000000;
-	u32 ulDVBCBitrate = DRXK_QAM_SYMBOLRATE_MAX * 8;
-
-	u32 ulInsertRSByte = 0;
-
-	u32 ulRfMirror = 1;
-	u32 ulPowerDown = 0;
-
-	dprintk(1, "\n");
-
-	state->m_hasLNA = false;
-	state->m_hasDVBT = false;
-	state->m_hasDVBC = false;
-	state->m_hasATV = false;
-	state->m_hasOOB = false;
-	state->m_hasAudio = false;
-
-	if (!state->m_ChunkSize)
-		state->m_ChunkSize = 124;
-
-	state->m_oscClockFreq = 0;
-	state->m_smartAntInverted = false;
-	state->m_bPDownOpenBridge = false;
-
-	/* real system clock frequency in kHz */
-	state->m_sysClockFreq = 151875;
-	/* Timing div, 250ns/Psys */
-	/* Timing div, = (delay (nano seconds) * sysclk (kHz))/ 1000 */
-	state->m_HICfgTimingDiv = ((state->m_sysClockFreq / 1000) *
-				   HI_I2C_DELAY) / 1000;
-	/* Clipping */
-	if (state->m_HICfgTimingDiv > SIO_HI_RA_RAM_PAR_2_CFG_DIV__M)
-		state->m_HICfgTimingDiv = SIO_HI_RA_RAM_PAR_2_CFG_DIV__M;
-	state->m_HICfgWakeUpKey = (state->demod_address << 1);
-	/* port/bridge/power down ctrl */
-	state->m_HICfgCtrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;
-
-	state->m_bPowerDown = (ulPowerDown != 0);
-
-	state->m_DRXK_A1_PATCH_CODE = false;
-	state->m_DRXK_A1_ROM_CODE = false;
-	state->m_DRXK_A2_ROM_CODE = false;
-	state->m_DRXK_A3_ROM_CODE = false;
-	state->m_DRXK_A2_PATCH_CODE = false;
-	state->m_DRXK_A3_PATCH_CODE = false;
-
-	/* Init AGC and PGA parameters */
-	/* VSB IF */
-	state->m_vsbIfAgcCfg.ctrlMode = (ulVSBIfAgcMode);
-	state->m_vsbIfAgcCfg.outputLevel = (ulVSBIfAgcOutputLevel);
-	state->m_vsbIfAgcCfg.minOutputLevel = (ulVSBIfAgcMinLevel);
-	state->m_vsbIfAgcCfg.maxOutputLevel = (ulVSBIfAgcMaxLevel);
-	state->m_vsbIfAgcCfg.speed = (ulVSBIfAgcSpeed);
-	state->m_vsbPgaCfg = 140;
-
-	/* VSB RF */
-	state->m_vsbRfAgcCfg.ctrlMode = (ulVSBRfAgcMode);
-	state->m_vsbRfAgcCfg.outputLevel = (ulVSBRfAgcOutputLevel);
-	state->m_vsbRfAgcCfg.minOutputLevel = (ulVSBRfAgcMinLevel);
-	state->m_vsbRfAgcCfg.maxOutputLevel = (ulVSBRfAgcMaxLevel);
-	state->m_vsbRfAgcCfg.speed = (ulVSBRfAgcSpeed);
-	state->m_vsbRfAgcCfg.top = (ulVSBRfAgcTop);
-	state->m_vsbRfAgcCfg.cutOffCurrent = (ulVSBRfAgcCutOffCurrent);
-	state->m_vsbPreSawCfg.reference = 0x07;
-	state->m_vsbPreSawCfg.usePreSaw = true;
-
-	state->m_Quality83percent = DEFAULT_MER_83;
-	state->m_Quality93percent = DEFAULT_MER_93;
-	if (ulQual93 <= 500 && ulQual83 < ulQual93) {
-		state->m_Quality83percent = ulQual83;
-		state->m_Quality93percent = ulQual93;
-	}
-
-	/* ATV IF */
-	state->m_atvIfAgcCfg.ctrlMode = (ulATVIfAgcMode);
-	state->m_atvIfAgcCfg.outputLevel = (ulATVIfAgcOutputLevel);
-	state->m_atvIfAgcCfg.minOutputLevel = (ulATVIfAgcMinLevel);
-	state->m_atvIfAgcCfg.maxOutputLevel = (ulATVIfAgcMaxLevel);
-	state->m_atvIfAgcCfg.speed = (ulATVIfAgcSpeed);
-
-	/* ATV RF */
-	state->m_atvRfAgcCfg.ctrlMode = (ulATVRfAgcMode);
-	state->m_atvRfAgcCfg.outputLevel = (ulATVRfAgcOutputLevel);
-	state->m_atvRfAgcCfg.minOutputLevel = (ulATVRfAgcMinLevel);
-	state->m_atvRfAgcCfg.maxOutputLevel = (ulATVRfAgcMaxLevel);
-	state->m_atvRfAgcCfg.speed = (ulATVRfAgcSpeed);
-	state->m_atvRfAgcCfg.top = (ulATVRfAgcTop);
-	state->m_atvRfAgcCfg.cutOffCurrent = (ulATVRfAgcCutOffCurrent);
-	state->m_atvPreSawCfg.reference = 0x04;
-	state->m_atvPreSawCfg.usePreSaw = true;
-
-
-	/* DVBT RF */
-	state->m_dvbtRfAgcCfg.ctrlMode = DRXK_AGC_CTRL_OFF;
-	state->m_dvbtRfAgcCfg.outputLevel = 0;
-	state->m_dvbtRfAgcCfg.minOutputLevel = 0;
-	state->m_dvbtRfAgcCfg.maxOutputLevel = 0xFFFF;
-	state->m_dvbtRfAgcCfg.top = 0x2100;
-	state->m_dvbtRfAgcCfg.cutOffCurrent = 4000;
-	state->m_dvbtRfAgcCfg.speed = 1;
-
-
-	/* DVBT IF */
-	state->m_dvbtIfAgcCfg.ctrlMode = DRXK_AGC_CTRL_AUTO;
-	state->m_dvbtIfAgcCfg.outputLevel = 0;
-	state->m_dvbtIfAgcCfg.minOutputLevel = 0;
-	state->m_dvbtIfAgcCfg.maxOutputLevel = 9000;
-	state->m_dvbtIfAgcCfg.top = 13424;
-	state->m_dvbtIfAgcCfg.cutOffCurrent = 0;
-	state->m_dvbtIfAgcCfg.speed = 3;
-	state->m_dvbtIfAgcCfg.FastClipCtrlDelay = 30;
-	state->m_dvbtIfAgcCfg.IngainTgtMax = 30000;
-	/* state->m_dvbtPgaCfg = 140; */
-
-	state->m_dvbtPreSawCfg.reference = 4;
-	state->m_dvbtPreSawCfg.usePreSaw = false;
-
-	/* QAM RF */
-	state->m_qamRfAgcCfg.ctrlMode = DRXK_AGC_CTRL_OFF;
-	state->m_qamRfAgcCfg.outputLevel = 0;
-	state->m_qamRfAgcCfg.minOutputLevel = 6023;
-	state->m_qamRfAgcCfg.maxOutputLevel = 27000;
-	state->m_qamRfAgcCfg.top = 0x2380;
-	state->m_qamRfAgcCfg.cutOffCurrent = 4000;
-	state->m_qamRfAgcCfg.speed = 3;
-
-	/* QAM IF */
-	state->m_qamIfAgcCfg.ctrlMode = DRXK_AGC_CTRL_AUTO;
-	state->m_qamIfAgcCfg.outputLevel = 0;
-	state->m_qamIfAgcCfg.minOutputLevel = 0;
-	state->m_qamIfAgcCfg.maxOutputLevel = 9000;
-	state->m_qamIfAgcCfg.top = 0x0511;
-	state->m_qamIfAgcCfg.cutOffCurrent = 0;
-	state->m_qamIfAgcCfg.speed = 3;
-	state->m_qamIfAgcCfg.IngainTgtMax = 5119;
-	state->m_qamIfAgcCfg.FastClipCtrlDelay = 50;
-
-	state->m_qamPgaCfg = 140;
-	state->m_qamPreSawCfg.reference = 4;
-	state->m_qamPreSawCfg.usePreSaw = false;
-
-	state->m_OperationMode = OM_NONE;
-	state->m_DrxkState = DRXK_UNINITIALIZED;
-
-	/* MPEG output configuration */
-	state->m_enableMPEGOutput = true;	/* If TRUE; enable MPEG ouput */
-	state->m_insertRSByte = false;	/* If TRUE; insert RS byte */
-	state->m_invertDATA = false;	/* If TRUE; invert DATA signals */
-	state->m_invertERR = false;	/* If TRUE; invert ERR signal */
-	state->m_invertSTR = false;	/* If TRUE; invert STR signals */
-	state->m_invertVAL = false;	/* If TRUE; invert VAL signals */
-	state->m_invertCLK = (ulInvertTSClock != 0);	/* If TRUE; invert CLK signals */
-
-	/* If TRUE; static MPEG clockrate will be used;
-	   otherwise clockrate will adapt to the bitrate of the TS */
-
-	state->m_DVBTBitrate = ulDVBTBitrate;
-	state->m_DVBCBitrate = ulDVBCBitrate;
-
-	state->m_TSDataStrength = (ulTSDataStrength & 0x07);
-
-	/* Maximum bitrate in b/s in case static clockrate is selected */
-	state->m_mpegTsStaticBitrate = 19392658;
-	state->m_disableTEIhandling = false;
-
-	if (ulInsertRSByte)
-		state->m_insertRSByte = true;
-
-	state->m_MpegLockTimeOut = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;
-	if (ulMpegLockTimeOut < 10000)
-		state->m_MpegLockTimeOut = ulMpegLockTimeOut;
-	state->m_DemodLockTimeOut = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;
-	if (ulDemodLockTimeOut < 10000)
-		state->m_DemodLockTimeOut = ulDemodLockTimeOut;
-
-	/* QAM defaults */
-	state->m_Constellation = DRX_CONSTELLATION_AUTO;
-	state->m_qamInterleaveMode = DRXK_QAM_I12_J17;
-	state->m_fecRsPlen = 204 * 8;	/* fecRsPlen  annex A */
-	state->m_fecRsPrescale = 1;
-
-	state->m_sqiSpeed = DRXK_DVBT_SQI_SPEED_MEDIUM;
-	state->m_agcFastClipCtrlDelay = 0;
-
-	state->m_GPIOCfg = (ulGPIOCfg);
-
-	state->m_bPowerDown = false;
-	state->m_currentPowerMode = DRX_POWER_DOWN;
-
-	state->m_rfmirror = (ulRfMirror == 0);
-	state->m_IfAgcPol = false;
-	return 0;
-}
-
-static int DRXX_Open(struct drxk_state *state)
-{
-	int status = 0;
-	u32 jtag = 0;
-	u16 bid = 0;
-	u16 key = 0;
-
-	dprintk(1, "\n");
-	/* stop lock indicator process */
-	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
-	if (status < 0)
-		goto error;
-	/* Check device id */
-	status = read16(state, SIO_TOP_COMM_KEY__A, &key);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);
-	if (status < 0)
-		goto error;
-	status = read32(state, SIO_TOP_JTAGID_LO__A, &jtag);
-	if (status < 0)
-		goto error;
-	status = read16(state, SIO_PDR_UIO_IN_HI__A, &bid);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_TOP_COMM_KEY__A, key);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int GetDeviceCapabilities(struct drxk_state *state)
-{
-	u16 sioPdrOhwCfg = 0;
-	u32 sioTopJtagidLo = 0;
-	int status;
-	const char *spin = "";
-
-	dprintk(1, "\n");
-
-	/* driver 0.9.0 */
-	/* stop lock indicator process */
-	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_TOP_COMM_KEY__A, 0xFABA);
-	if (status < 0)
-		goto error;
-	status = read16(state, SIO_PDR_OHW_CFG__A, &sioPdrOhwCfg);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);
-	if (status < 0)
-		goto error;
-
-	switch ((sioPdrOhwCfg & SIO_PDR_OHW_CFG_FREF_SEL__M)) {
-	case 0:
-		/* ignore (bypass ?) */
-		break;
-	case 1:
-		/* 27 MHz */
-		state->m_oscClockFreq = 27000;
-		break;
-	case 2:
-		/* 20.25 MHz */
-		state->m_oscClockFreq = 20250;
-		break;
-	case 3:
-		/* 4 MHz */
-		state->m_oscClockFreq = 20250;
-		break;
-	default:
-		printk(KERN_ERR "drxk: Clock Frequency is unkonwn\n");
-		return -EINVAL;
-	}
-	/*
-		Determine device capabilities
-		Based on pinning v14
-		*/
-	status = read32(state, SIO_TOP_JTAGID_LO__A, &sioTopJtagidLo);
-	if (status < 0)
-		goto error;
-
-printk(KERN_ERR "drxk: status = 0x%08x\n", sioTopJtagidLo);
-
-	/* driver 0.9.0 */
-	switch ((sioTopJtagidLo >> 29) & 0xF) {
-	case 0:
-		state->m_deviceSpin = DRXK_SPIN_A1;
-		spin = "A1";
-		break;
-	case 2:
-		state->m_deviceSpin = DRXK_SPIN_A2;
-		spin = "A2";
-		break;
-	case 3:
-		state->m_deviceSpin = DRXK_SPIN_A3;
-		spin = "A3";
-		break;
-	default:
-		state->m_deviceSpin = DRXK_SPIN_UNKNOWN;
-		status = -EINVAL;
-		printk(KERN_ERR "drxk: Spin %d unknown\n",
-		       (sioTopJtagidLo >> 29) & 0xF);
-		goto error2;
-	}
-	switch ((sioTopJtagidLo >> 12) & 0xFF) {
-	case 0x13:
-		/* typeId = DRX3913K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = false;
-		state->m_hasAudio = false;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = true;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = false;
-		state->m_hasGPIO1 = false;
-		state->m_hasIRQN = false;
-		break;
-	case 0x15:
-		/* typeId = DRX3915K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = false;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = false;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	case 0x16:
-		/* typeId = DRX3916K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = false;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = false;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	case 0x18:
-		/* typeId = DRX3918K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = true;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = false;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	case 0x21:
-		/* typeId = DRX3921K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = true;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = true;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	case 0x23:
-		/* typeId = DRX3923K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = true;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = true;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	case 0x25:
-		/* typeId = DRX3925K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = true;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = true;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	case 0x26:
-		/* typeId = DRX3926K_TYPE_ID */
-		state->m_hasLNA = false;
-		state->m_hasOOB = false;
-		state->m_hasATV = true;
-		state->m_hasAudio = false;
-		state->m_hasDVBT = true;
-		state->m_hasDVBC = true;
-		state->m_hasSAWSW = true;
-		state->m_hasGPIO2 = true;
-		state->m_hasGPIO1 = true;
-		state->m_hasIRQN = false;
-		break;
-	default:
-		printk(KERN_ERR "drxk: DeviceID 0x%02x not supported\n",
-			((sioTopJtagidLo >> 12) & 0xFF));
-		status = -EINVAL;
-		goto error2;
-	}
-
-	printk(KERN_INFO
-	       "drxk: detected a drx-39%02xk, spin %s, xtal %d.%03d MHz\n",
-	       ((sioTopJtagidLo >> 12) & 0xFF), spin,
-	       state->m_oscClockFreq / 1000,
-	       state->m_oscClockFreq % 1000);
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-error2:
-	return status;
-}
-
-static int HI_Command(struct drxk_state *state, u16 cmd, u16 *pResult)
-{
-	int status;
-	bool powerdown_cmd;
-
-	dprintk(1, "\n");
-
-	/* Write command */
-	status = write16(state, SIO_HI_RA_RAM_CMD__A, cmd);
-	if (status < 0)
-		goto error;
-	if (cmd == SIO_HI_RA_RAM_CMD_RESET)
-		msleep(1);
-
-	powerdown_cmd =
-	    (bool) ((cmd == SIO_HI_RA_RAM_CMD_CONFIG) &&
-		    ((state->m_HICfgCtrl) &
-		     SIO_HI_RA_RAM_PAR_5_CFG_SLEEP__M) ==
-		    SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ);
-	if (powerdown_cmd == false) {
-		/* Wait until command rdy */
-		u32 retryCount = 0;
-		u16 waitCmd;
-
-		do {
-			msleep(1);
-			retryCount += 1;
-			status = read16(state, SIO_HI_RA_RAM_CMD__A,
-					  &waitCmd);
-		} while ((status < 0) && (retryCount < DRXK_MAX_RETRIES)
-			 && (waitCmd != 0));
-		if (status < 0)
-			goto error;
-		status = read16(state, SIO_HI_RA_RAM_RES__A, pResult);
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int HI_CfgCommand(struct drxk_state *state)
-{
-	int status;
-
-	dprintk(1, "\n");
-
-	mutex_lock(&state->mutex);
-
-	status = write16(state, SIO_HI_RA_RAM_PAR_6__A, state->m_HICfgTimeout);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_HI_RA_RAM_PAR_5__A, state->m_HICfgCtrl);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_HI_RA_RAM_PAR_4__A, state->m_HICfgWakeUpKey);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_HI_RA_RAM_PAR_3__A, state->m_HICfgBridgeDelay);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_HI_RA_RAM_PAR_2__A, state->m_HICfgTimingDiv);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_HI_RA_RAM_PAR_1__A, SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);
-	if (status < 0)
-		goto error;
-	status = HI_Command(state, SIO_HI_RA_RAM_CMD_CONFIG, 0);
-	if (status < 0)
-		goto error;
-
-	state->m_HICfgCtrl &= ~SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;
-error:
-	mutex_unlock(&state->mutex);
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int InitHI(struct drxk_state *state)
-{
-	dprintk(1, "\n");
-
-	state->m_HICfgWakeUpKey = (state->demod_address << 1);
-	state->m_HICfgTimeout = 0x96FF;
-	/* port/bridge/power down ctrl */
-	state->m_HICfgCtrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;
-
-	return HI_CfgCommand(state);
-}
-
-static int MPEGTSConfigurePins(struct drxk_state *state, bool mpegEnable)
-{
-	int status = -1;
-	u16 sioPdrMclkCfg = 0;
-	u16 sioPdrMdxCfg = 0;
-	u16 err_cfg = 0;
-
-	dprintk(1, ": mpeg %s, %s mode\n",
-		mpegEnable ? "enable" : "disable",
-		state->m_enableParallel ? "parallel" : "serial");
-
-	/* stop lock indicator process */
-	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
-	if (status < 0)
-		goto error;
-
-	/*  MPEG TS pad configuration */
-	status = write16(state, SIO_TOP_COMM_KEY__A, 0xFABA);
-	if (status < 0)
-		goto error;
-
-	if (mpegEnable == false) {
-		/*  Set MPEG TS pads to inputmode */
-		status = write16(state, SIO_PDR_MSTRT_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MERR_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MCLK_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MVAL_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD0_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);
-		if (status < 0)
-			goto error;
-	} else {
-		/* Enable MPEG output */
-		sioPdrMdxCfg =
-			((state->m_TSDataStrength <<
-			SIO_PDR_MD0_CFG_DRIVE__B) | 0x0003);
-		sioPdrMclkCfg = ((state->m_TSClockkStrength <<
-					SIO_PDR_MCLK_CFG_DRIVE__B) |
-					0x0003);
-
-		status = write16(state, SIO_PDR_MSTRT_CFG__A, sioPdrMdxCfg);
-		if (status < 0)
-			goto error;
-
-		if (state->enable_merr_cfg)
-			err_cfg = sioPdrMdxCfg;
-
-		status = write16(state, SIO_PDR_MERR_CFG__A, err_cfg);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MVAL_CFG__A, err_cfg);
-		if (status < 0)
-			goto error;
-
-		if (state->m_enableParallel == true) {
-			/* paralel -> enable MD1 to MD7 */
-			status = write16(state, SIO_PDR_MD1_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD2_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD3_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD4_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD5_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD6_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD7_CFG__A, sioPdrMdxCfg);
-			if (status < 0)
-				goto error;
-		} else {
-			sioPdrMdxCfg = ((state->m_TSDataStrength <<
-						SIO_PDR_MD0_CFG_DRIVE__B)
-					| 0x0003);
-			/* serial -> disable MD1 to MD7 */
-			status = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-			status = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);
-			if (status < 0)
-				goto error;
-		}
-		status = write16(state, SIO_PDR_MCLK_CFG__A, sioPdrMclkCfg);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_PDR_MD0_CFG__A, sioPdrMdxCfg);
-		if (status < 0)
-			goto error;
-	}
-	/*  Enable MB output over MPEG pads and ctl input */
-	status = write16(state, SIO_PDR_MON_CFG__A, 0x0000);
-	if (status < 0)
-		goto error;
-	/*  Write nomagic word to enable pdr reg write */
-	status = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int MPEGTSDisable(struct drxk_state *state)
-{
-	dprintk(1, "\n");
-
-	return MPEGTSConfigurePins(state, false);
-}
-
-static int BLChainCmd(struct drxk_state *state,
-		      u16 romOffset, u16 nrOfElements, u32 timeOut)
-{
-	u16 blStatus = 0;
-	int status;
-	unsigned long end;
-
-	dprintk(1, "\n");
-	mutex_lock(&state->mutex);
-	status = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_CHAIN);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_CHAIN_ADDR__A, romOffset);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_CHAIN_LEN__A, nrOfElements);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);
-	if (status < 0)
-		goto error;
-
-	end = jiffies + msecs_to_jiffies(timeOut);
-	do {
-		msleep(1);
-		status = read16(state, SIO_BL_STATUS__A, &blStatus);
-		if (status < 0)
-			goto error;
-	} while ((blStatus == 0x1) &&
-			((time_is_after_jiffies(end))));
-
-	if (blStatus == 0x1) {
-		printk(KERN_ERR "drxk: SIO not ready\n");
-		status = -EINVAL;
-		goto error2;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-error2:
-	mutex_unlock(&state->mutex);
-	return status;
-}
-
-
-static int DownloadMicrocode(struct drxk_state *state,
-			     const u8 pMCImage[], u32 Length)
-{
-	const u8 *pSrc = pMCImage;
-	u16 Flags;
-	u16 Drain;
-	u32 Address;
-	u16 nBlocks;
-	u16 BlockSize;
-	u16 BlockCRC;
-	u32 offset = 0;
-	u32 i;
-	int status = 0;
-
-	dprintk(1, "\n");
-
-	/* down the drain (we don care about MAGIC_WORD) */
-	Drain = (pSrc[0] << 8) | pSrc[1];
-	pSrc += sizeof(u16);
-	offset += sizeof(u16);
-	nBlocks = (pSrc[0] << 8) | pSrc[1];
-	pSrc += sizeof(u16);
-	offset += sizeof(u16);
-
-	for (i = 0; i < nBlocks; i += 1) {
-		Address = (pSrc[0] << 24) | (pSrc[1] << 16) |
-		    (pSrc[2] << 8) | pSrc[3];
-		pSrc += sizeof(u32);
-		offset += sizeof(u32);
-
-		BlockSize = ((pSrc[0] << 8) | pSrc[1]) * sizeof(u16);
-		pSrc += sizeof(u16);
-		offset += sizeof(u16);
-
-		Flags = (pSrc[0] << 8) | pSrc[1];
-		pSrc += sizeof(u16);
-		offset += sizeof(u16);
-
-		BlockCRC = (pSrc[0] << 8) | pSrc[1];
-		pSrc += sizeof(u16);
-		offset += sizeof(u16);
-
-		if (offset + BlockSize > Length) {
-			printk(KERN_ERR "drxk: Firmware is corrupted.\n");
-			return -EINVAL;
-		}
-
-		status = write_block(state, Address, BlockSize, pSrc);
-		if (status < 0) {
-			printk(KERN_ERR "drxk: Error %d while loading firmware\n", status);
-			break;
-		}
-		pSrc += BlockSize;
-		offset += BlockSize;
-	}
-	return status;
-}
-
-static int DVBTEnableOFDMTokenRing(struct drxk_state *state, bool enable)
-{
-	int status;
-	u16 data = 0;
-	u16 desiredCtrl = SIO_OFDM_SH_OFDM_RING_ENABLE_ON;
-	u16 desiredStatus = SIO_OFDM_SH_OFDM_RING_STATUS_ENABLED;
-	unsigned long end;
-
-	dprintk(1, "\n");
-
-	if (enable == false) {
-		desiredCtrl = SIO_OFDM_SH_OFDM_RING_ENABLE_OFF;
-		desiredStatus = SIO_OFDM_SH_OFDM_RING_STATUS_DOWN;
-	}
-
-	status = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);
-	if (status >= 0 && data == desiredStatus) {
-		/* tokenring already has correct status */
-		return status;
-	}
-	/* Disable/enable dvbt tokenring bridge   */
-	status = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, desiredCtrl);
-
-	end = jiffies + msecs_to_jiffies(DRXK_OFDM_TR_SHUTDOWN_TIMEOUT);
-	do {
-		status = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);
-		if ((status >= 0 && data == desiredStatus) || time_is_after_jiffies(end))
-			break;
-		msleep(1);
-	} while (1);
-	if (data != desiredStatus) {
-		printk(KERN_ERR "drxk: SIO not ready\n");
-		return -EINVAL;
-	}
-	return status;
-}
-
-static int MPEGTSStop(struct drxk_state *state)
-{
-	int status = 0;
-	u16 fecOcSncMode = 0;
-	u16 fecOcIprMode = 0;
-
-	dprintk(1, "\n");
-
-	/* Gracefull shutdown (byte boundaries) */
-	status = read16(state, FEC_OC_SNC_MODE__A, &fecOcSncMode);
-	if (status < 0)
-		goto error;
-	fecOcSncMode |= FEC_OC_SNC_MODE_SHUTDOWN__M;
-	status = write16(state, FEC_OC_SNC_MODE__A, fecOcSncMode);
-	if (status < 0)
-		goto error;
-
-	/* Suppress MCLK during absence of data */
-	status = read16(state, FEC_OC_IPR_MODE__A, &fecOcIprMode);
-	if (status < 0)
-		goto error;
-	fecOcIprMode |= FEC_OC_IPR_MODE_MCLK_DIS_DAT_ABS__M;
-	status = write16(state, FEC_OC_IPR_MODE__A, fecOcIprMode);
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int scu_command(struct drxk_state *state,
-		       u16 cmd, u8 parameterLen,
-		       u16 *parameter, u8 resultLen, u16 *result)
-{
-#if (SCU_RAM_PARAM_0__A - SCU_RAM_PARAM_15__A) != 15
-#error DRXK register mapping no longer compatible with this routine!
-#endif
-	u16 curCmd = 0;
-	int status = -EINVAL;
-	unsigned long end;
-	u8 buffer[34];
-	int cnt = 0, ii;
-	const char *p;
-	char errname[30];
-
-	dprintk(1, "\n");
-
-	if ((cmd == 0) || ((parameterLen > 0) && (parameter == NULL)) ||
-	    ((resultLen > 0) && (result == NULL)))
-		goto error;
-
-	mutex_lock(&state->mutex);
-
-	/* assume that the command register is ready
-		since it is checked afterwards */
-	for (ii = parameterLen - 1; ii >= 0; ii -= 1) {
-		buffer[cnt++] = (parameter[ii] & 0xFF);
-		buffer[cnt++] = ((parameter[ii] >> 8) & 0xFF);
-	}
-	buffer[cnt++] = (cmd & 0xFF);
-	buffer[cnt++] = ((cmd >> 8) & 0xFF);
-
-	write_block(state, SCU_RAM_PARAM_0__A -
-			(parameterLen - 1), cnt, buffer);
-	/* Wait until SCU has processed command */
-	end = jiffies + msecs_to_jiffies(DRXK_MAX_WAITTIME);
-	do {
-		msleep(1);
-		status = read16(state, SCU_RAM_COMMAND__A, &curCmd);
-		if (status < 0)
-			goto error;
-	} while (!(curCmd == DRX_SCU_READY) && (time_is_after_jiffies(end)));
-	if (curCmd != DRX_SCU_READY) {
-		printk(KERN_ERR "drxk: SCU not ready\n");
-		status = -EIO;
-		goto error2;
-	}
-	/* read results */
-	if ((resultLen > 0) && (result != NULL)) {
-		s16 err;
-		int ii;
-
-		for (ii = resultLen - 1; ii >= 0; ii -= 1) {
-			status = read16(state, SCU_RAM_PARAM_0__A - ii, &result[ii]);
-			if (status < 0)
-				goto error;
-		}
-
-		/* Check if an error was reported by SCU */
-		err = (s16)result[0];
-		if (err >= 0)
-			goto error;
-
-		/* check for the known error codes */
-		switch (err) {
-		case SCU_RESULT_UNKCMD:
-			p = "SCU_RESULT_UNKCMD";
-			break;
-		case SCU_RESULT_UNKSTD:
-			p = "SCU_RESULT_UNKSTD";
-			break;
-		case SCU_RESULT_SIZE:
-			p = "SCU_RESULT_SIZE";
-			break;
-		case SCU_RESULT_INVPAR:
-			p = "SCU_RESULT_INVPAR";
-			break;
-		default: /* Other negative values are errors */
-			sprintf(errname, "ERROR: %d\n", err);
-			p = errname;
-		}
-		printk(KERN_ERR "drxk: %s while sending cmd 0x%04x with params:", p, cmd);
-		print_hex_dump_bytes("drxk: ", DUMP_PREFIX_NONE, buffer, cnt);
-		status = -EINVAL;
-		goto error2;
-	}
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-error2:
-	mutex_unlock(&state->mutex);
-	return status;
-}
-
-static int SetIqmAf(struct drxk_state *state, bool active)
-{
-	u16 data = 0;
-	int status;
-
-	dprintk(1, "\n");
-
-	/* Configure IQM */
-	status = read16(state, IQM_AF_STDBY__A, &data);
-	if (status < 0)
-		goto error;
-
-	if (!active) {
-		data |= (IQM_AF_STDBY_STDBY_ADC_STANDBY
-				| IQM_AF_STDBY_STDBY_AMP_STANDBY
-				| IQM_AF_STDBY_STDBY_PD_STANDBY
-				| IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY
-				| IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY);
-	} else {
-		data &= ((~IQM_AF_STDBY_STDBY_ADC_STANDBY)
-				& (~IQM_AF_STDBY_STDBY_AMP_STANDBY)
-				& (~IQM_AF_STDBY_STDBY_PD_STANDBY)
-				& (~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY)
-				& (~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY)
-			);
-	}
-	status = write16(state, IQM_AF_STDBY__A, data);
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int CtrlPowerMode(struct drxk_state *state, enum DRXPowerMode *mode)
-{
-	int status = 0;
-	u16 sioCcPwdMode = 0;
-
-	dprintk(1, "\n");
-
-	/* Check arguments */
-	if (mode == NULL)
-		return -EINVAL;
-
-	switch (*mode) {
-	case DRX_POWER_UP:
-		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_NONE;
-		break;
-	case DRXK_POWER_DOWN_OFDM:
-		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_OFDM;
-		break;
-	case DRXK_POWER_DOWN_CORE:
-		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_CLOCK;
-		break;
-	case DRXK_POWER_DOWN_PLL:
-		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_PLL;
-		break;
-	case DRX_POWER_DOWN:
-		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_OSC;
-		break;
-	default:
-		/* Unknow sleep mode */
-		return -EINVAL;
-	}
-
-	/* If already in requested power mode, do nothing */
-	if (state->m_currentPowerMode == *mode)
-		return 0;
-
-	/* For next steps make sure to start from DRX_POWER_UP mode */
-	if (state->m_currentPowerMode != DRX_POWER_UP) {
-		status = PowerUpDevice(state);
-		if (status < 0)
-			goto error;
-		status = DVBTEnableOFDMTokenRing(state, true);
-		if (status < 0)
-			goto error;
-	}
-
-	if (*mode == DRX_POWER_UP) {
-		/* Restore analog & pin configuartion */
-	} else {
-		/* Power down to requested mode */
-		/* Backup some register settings */
-		/* Set pins with possible pull-ups connected
-		   to them in input mode */
-		/* Analog power down */
-		/* ADC power down */
-		/* Power down device */
-		/* stop all comm_exec */
-		/* Stop and power down previous standard */
-		switch (state->m_OperationMode) {
-		case OM_DVBT:
-			status = MPEGTSStop(state);
-			if (status < 0)
-				goto error;
-			status = PowerDownDVBT(state, false);
-			if (status < 0)
-				goto error;
-			break;
-		case OM_QAM_ITU_A:
-		case OM_QAM_ITU_C:
-			status = MPEGTSStop(state);
-			if (status < 0)
-				goto error;
-			status = PowerDownQAM(state);
-			if (status < 0)
-				goto error;
-			break;
-		default:
-			break;
-		}
-		status = DVBTEnableOFDMTokenRing(state, false);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_CC_PWD_MODE__A, sioCcPwdMode);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
-		if (status < 0)
-			goto error;
-
-		if (*mode != DRXK_POWER_DOWN_OFDM) {
-			state->m_HICfgCtrl |=
-				SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;
-			status = HI_CfgCommand(state);
-			if (status < 0)
-				goto error;
-		}
-	}
-	state->m_currentPowerMode = *mode;
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int PowerDownDVBT(struct drxk_state *state, bool setPowerMode)
-{
-	enum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;
-	u16 cmdResult = 0;
-	u16 data = 0;
-	int status;
-
-	dprintk(1, "\n");
-
-	status = read16(state, SCU_COMM_EXEC__A, &data);
-	if (status < 0)
-		goto error;
-	if (data == SCU_COMM_EXEC_ACTIVE) {
-		/* Send OFDM stop command */
-		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);
-		if (status < 0)
-			goto error;
-		/* Send OFDM reset command */
-		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);
-		if (status < 0)
-			goto error;
-	}
-
-	/* Reset datapath for OFDM, processors first */
-	status = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);
-	if (status < 0)
-		goto error;
-
-	/* powerdown AFE                   */
-	status = SetIqmAf(state, false);
-	if (status < 0)
-		goto error;
-
-	/* powerdown to OFDM mode          */
-	if (setPowerMode) {
-		status = CtrlPowerMode(state, &powerMode);
-		if (status < 0)
-			goto error;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SetOperationMode(struct drxk_state *state,
-			    enum OperationMode oMode)
-{
-	int status = 0;
-
-	dprintk(1, "\n");
-	/*
-	   Stop and power down previous standard
-	   TODO investigate total power down instead of partial
-	   power down depending on "previous" standard.
-	 */
-
-	/* disable HW lock indicator */
-	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
-	if (status < 0)
-		goto error;
-
-	/* Device is already at the required mode */
-	if (state->m_OperationMode == oMode)
-		return 0;
-
-	switch (state->m_OperationMode) {
-		/* OM_NONE was added for start up */
-	case OM_NONE:
-		break;
-	case OM_DVBT:
-		status = MPEGTSStop(state);
-		if (status < 0)
-			goto error;
-		status = PowerDownDVBT(state, true);
-		if (status < 0)
-			goto error;
-		state->m_OperationMode = OM_NONE;
-		break;
-	case OM_QAM_ITU_A:	/* fallthrough */
-	case OM_QAM_ITU_C:
-		status = MPEGTSStop(state);
-		if (status < 0)
-			goto error;
-		status = PowerDownQAM(state);
-		if (status < 0)
-			goto error;
-		state->m_OperationMode = OM_NONE;
-		break;
-	case OM_QAM_ITU_B:
-	default:
-		status = -EINVAL;
-		goto error;
-	}
-
-	/*
-		Power up new standard
-		*/
-	switch (oMode) {
-	case OM_DVBT:
-		dprintk(1, ": DVB-T\n");
-		state->m_OperationMode = oMode;
-		status = SetDVBTStandard(state, oMode);
-		if (status < 0)
-			goto error;
-		break;
-	case OM_QAM_ITU_A:	/* fallthrough */
-	case OM_QAM_ITU_C:
-		dprintk(1, ": DVB-C Annex %c\n",
-			(state->m_OperationMode == OM_QAM_ITU_A) ? 'A' : 'C');
-		state->m_OperationMode = oMode;
-		status = SetQAMStandard(state, oMode);
-		if (status < 0)
-			goto error;
-		break;
-	case OM_QAM_ITU_B:
-	default:
-		status = -EINVAL;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int Start(struct drxk_state *state, s32 offsetFreq,
-		 s32 IntermediateFrequency)
-{
-	int status = -EINVAL;
-
-	u16 IFreqkHz;
-	s32 OffsetkHz = offsetFreq / 1000;
-
-	dprintk(1, "\n");
-	if (state->m_DrxkState != DRXK_STOPPED &&
-		state->m_DrxkState != DRXK_DTV_STARTED)
-		goto error;
-
-	state->m_bMirrorFreqSpect = (state->props.inversion == INVERSION_ON);
-
-	if (IntermediateFrequency < 0) {
-		state->m_bMirrorFreqSpect = !state->m_bMirrorFreqSpect;
-		IntermediateFrequency = -IntermediateFrequency;
-	}
-
-	switch (state->m_OperationMode) {
-	case OM_QAM_ITU_A:
-	case OM_QAM_ITU_C:
-		IFreqkHz = (IntermediateFrequency / 1000);
-		status = SetQAM(state, IFreqkHz, OffsetkHz);
-		if (status < 0)
-			goto error;
-		state->m_DrxkState = DRXK_DTV_STARTED;
-		break;
-	case OM_DVBT:
-		IFreqkHz = (IntermediateFrequency / 1000);
-		status = MPEGTSStop(state);
-		if (status < 0)
-			goto error;
-		status = SetDVBT(state, IFreqkHz, OffsetkHz);
-		if (status < 0)
-			goto error;
-		status = DVBTStart(state);
-		if (status < 0)
-			goto error;
-		state->m_DrxkState = DRXK_DTV_STARTED;
-		break;
-	default:
-		break;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int ShutDown(struct drxk_state *state)
-{
-	dprintk(1, "\n");
-
-	MPEGTSStop(state);
-	return 0;
-}
-
-static int GetLockStatus(struct drxk_state *state, u32 *pLockStatus,
-			 u32 Time)
-{
-	int status = -EINVAL;
-
-	dprintk(1, "\n");
-
-	if (pLockStatus == NULL)
-		goto error;
-
-	*pLockStatus = NOT_LOCKED;
-
-	/* define the SCU command code */
-	switch (state->m_OperationMode) {
-	case OM_QAM_ITU_A:
-	case OM_QAM_ITU_B:
-	case OM_QAM_ITU_C:
-		status = GetQAMLockStatus(state, pLockStatus);
-		break;
-	case OM_DVBT:
-		status = GetDVBTLockStatus(state, pLockStatus);
-		break;
-	default:
-		break;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int MPEGTSStart(struct drxk_state *state)
-{
-	int status;
-
-	u16 fecOcSncMode = 0;
-
-	/* Allow OC to sync again */
-	status = read16(state, FEC_OC_SNC_MODE__A, &fecOcSncMode);
-	if (status < 0)
-		goto error;
-	fecOcSncMode &= ~FEC_OC_SNC_MODE_SHUTDOWN__M;
-	status = write16(state, FEC_OC_SNC_MODE__A, fecOcSncMode);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_SNC_UNLOCK__A, 1);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int MPEGTSDtoInit(struct drxk_state *state)
-{
-	int status;
-
-	dprintk(1, "\n");
-
-	/* Rate integration settings */
-	status = write16(state, FEC_OC_RCN_CTL_STEP_LO__A, 0x0000);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_RCN_CTL_STEP_HI__A, 0x000C);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_RCN_GAIN__A, 0x000A);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_AVR_PARM_A__A, 0x0008);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_AVR_PARM_B__A, 0x0006);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_TMD_HI_MARGIN__A, 0x0680);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_TMD_LO_MARGIN__A, 0x0080);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_TMD_COUNT__A, 0x03F4);
-	if (status < 0)
-		goto error;
-
-	/* Additional configuration */
-	status = write16(state, FEC_OC_OCR_INVERT__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_SNC_LWM__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_SNC_HWM__A, 12);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int MPEGTSDtoSetup(struct drxk_state *state,
-			  enum OperationMode oMode)
-{
-	int status;
-
-	u16 fecOcRegMode = 0;	/* FEC_OC_MODE       register value */
-	u16 fecOcRegIprMode = 0;	/* FEC_OC_IPR_MODE   register value */
-	u16 fecOcDtoMode = 0;	/* FEC_OC_IPR_INVERT register value */
-	u16 fecOcFctMode = 0;	/* FEC_OC_IPR_INVERT register value */
-	u16 fecOcDtoPeriod = 2;	/* FEC_OC_IPR_INVERT register value */
-	u16 fecOcDtoBurstLen = 188;	/* FEC_OC_IPR_INVERT register value */
-	u32 fecOcRcnCtlRate = 0;	/* FEC_OC_IPR_INVERT register value */
-	u16 fecOcTmdMode = 0;
-	u16 fecOcTmdIntUpdRate = 0;
-	u32 maxBitRate = 0;
-	bool staticCLK = false;
-
-	dprintk(1, "\n");
-
-	/* Check insertion of the Reed-Solomon parity bytes */
-	status = read16(state, FEC_OC_MODE__A, &fecOcRegMode);
-	if (status < 0)
-		goto error;
-	status = read16(state, FEC_OC_IPR_MODE__A, &fecOcRegIprMode);
-	if (status < 0)
-		goto error;
-	fecOcRegMode &= (~FEC_OC_MODE_PARITY__M);
-	fecOcRegIprMode &= (~FEC_OC_IPR_MODE_MVAL_DIS_PAR__M);
-	if (state->m_insertRSByte == true) {
-		/* enable parity symbol forward */
-		fecOcRegMode |= FEC_OC_MODE_PARITY__M;
-		/* MVAL disable during parity bytes */
-		fecOcRegIprMode |= FEC_OC_IPR_MODE_MVAL_DIS_PAR__M;
-		/* TS burst length to 204 */
-		fecOcDtoBurstLen = 204;
-	}
-
-	/* Check serial or parrallel output */
-	fecOcRegIprMode &= (~(FEC_OC_IPR_MODE_SERIAL__M));
-	if (state->m_enableParallel == false) {
-		/* MPEG data output is serial -> set ipr_mode[0] */
-		fecOcRegIprMode |= FEC_OC_IPR_MODE_SERIAL__M;
-	}
-
-	switch (oMode) {
-	case OM_DVBT:
-		maxBitRate = state->m_DVBTBitrate;
-		fecOcTmdMode = 3;
-		fecOcRcnCtlRate = 0xC00000;
-		staticCLK = state->m_DVBTStaticCLK;
-		break;
-	case OM_QAM_ITU_A:	/* fallthrough */
-	case OM_QAM_ITU_C:
-		fecOcTmdMode = 0x0004;
-		fecOcRcnCtlRate = 0xD2B4EE;	/* good for >63 Mb/s */
-		maxBitRate = state->m_DVBCBitrate;
-		staticCLK = state->m_DVBCStaticCLK;
-		break;
-	default:
-		status = -EINVAL;
-	}		/* switch (standard) */
-	if (status < 0)
-		goto error;
-
-	/* Configure DTO's */
-	if (staticCLK) {
-		u32 bitRate = 0;
-
-		/* Rational DTO for MCLK source (static MCLK rate),
-			Dynamic DTO for optimal grouping
-			(avoid intra-packet gaps),
-			DTO offset enable to sync TS burst with MSTRT */
-		fecOcDtoMode = (FEC_OC_DTO_MODE_DYNAMIC__M |
-				FEC_OC_DTO_MODE_OFFSET_ENABLE__M);
-		fecOcFctMode = (FEC_OC_FCT_MODE_RAT_ENA__M |
-				FEC_OC_FCT_MODE_VIRT_ENA__M);
-
-		/* Check user defined bitrate */
-		bitRate = maxBitRate;
-		if (bitRate > 75900000UL) {	/* max is 75.9 Mb/s */
-			bitRate = 75900000UL;
-		}
-		/* Rational DTO period:
-			dto_period = (Fsys / bitrate) - 2
-
-			Result should be floored,
-			to make sure >= requested bitrate
-			*/
-		fecOcDtoPeriod = (u16) (((state->m_sysClockFreq)
-						* 1000) / bitRate);
-		if (fecOcDtoPeriod <= 2)
-			fecOcDtoPeriod = 0;
-		else
-			fecOcDtoPeriod -= 2;
-		fecOcTmdIntUpdRate = 8;
-	} else {
-		/* (commonAttr->staticCLK == false) => dynamic mode */
-		fecOcDtoMode = FEC_OC_DTO_MODE_DYNAMIC__M;
-		fecOcFctMode = FEC_OC_FCT_MODE__PRE;
-		fecOcTmdIntUpdRate = 5;
-	}
-
-	/* Write appropriate registers with requested configuration */
-	status = write16(state, FEC_OC_DTO_BURST_LEN__A, fecOcDtoBurstLen);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_DTO_PERIOD__A, fecOcDtoPeriod);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_DTO_MODE__A, fecOcDtoMode);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_FCT_MODE__A, fecOcFctMode);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_MODE__A, fecOcRegMode);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_IPR_MODE__A, fecOcRegIprMode);
-	if (status < 0)
-		goto error;
-
-	/* Rate integration settings */
-	status = write32(state, FEC_OC_RCN_CTL_RATE_LO__A, fecOcRcnCtlRate);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_TMD_INT_UPD_RATE__A, fecOcTmdIntUpdRate);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_TMD_MODE__A, fecOcTmdMode);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int MPEGTSConfigurePolarity(struct drxk_state *state)
-{
-	u16 fecOcRegIprInvert = 0;
-
-	/* Data mask for the output data byte */
-	u16 InvertDataMask =
-	    FEC_OC_IPR_INVERT_MD7__M | FEC_OC_IPR_INVERT_MD6__M |
-	    FEC_OC_IPR_INVERT_MD5__M | FEC_OC_IPR_INVERT_MD4__M |
-	    FEC_OC_IPR_INVERT_MD3__M | FEC_OC_IPR_INVERT_MD2__M |
-	    FEC_OC_IPR_INVERT_MD1__M | FEC_OC_IPR_INVERT_MD0__M;
-
-	dprintk(1, "\n");
-
-	/* Control selective inversion of output bits */
-	fecOcRegIprInvert &= (~(InvertDataMask));
-	if (state->m_invertDATA == true)
-		fecOcRegIprInvert |= InvertDataMask;
-	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MERR__M));
-	if (state->m_invertERR == true)
-		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MERR__M;
-	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MSTRT__M));
-	if (state->m_invertSTR == true)
-		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MSTRT__M;
-	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MVAL__M));
-	if (state->m_invertVAL == true)
-		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MVAL__M;
-	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MCLK__M));
-	if (state->m_invertCLK == true)
-		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MCLK__M;
-
-	return write16(state, FEC_OC_IPR_INVERT__A, fecOcRegIprInvert);
-}
-
-#define   SCU_RAM_AGC_KI_INV_RF_POL__M 0x4000
-
-static int SetAgcRf(struct drxk_state *state,
-		    struct SCfgAgc *pAgcCfg, bool isDTV)
-{
-	int status = -EINVAL;
-	u16 data = 0;
-	struct SCfgAgc *pIfAgcSettings;
-
-	dprintk(1, "\n");
-
-	if (pAgcCfg == NULL)
-		goto error;
-
-	switch (pAgcCfg->ctrlMode) {
-	case DRXK_AGC_CTRL_AUTO:
-		/* Enable RF AGC DAC */
-		status = read16(state, IQM_AF_STDBY__A, &data);
-		if (status < 0)
-			goto error;
-		data &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;
-		status = write16(state, IQM_AF_STDBY__A, data);
-		if (status < 0)
-			goto error;
-		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
-		if (status < 0)
-			goto error;
-
-		/* Enable SCU RF AGC loop */
-		data &= ~SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;
-
-		/* Polarity */
-		if (state->m_RfAgcPol)
-			data |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
-		else
-			data &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
-		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
-		if (status < 0)
-			goto error;
-
-		/* Set speed (using complementary reduction value) */
-		status = read16(state, SCU_RAM_AGC_KI_RED__A, &data);
-		if (status < 0)
-			goto error;
-
-		data &= ~SCU_RAM_AGC_KI_RED_RAGC_RED__M;
-		data |= (~(pAgcCfg->speed <<
-				SCU_RAM_AGC_KI_RED_RAGC_RED__B)
-				& SCU_RAM_AGC_KI_RED_RAGC_RED__M);
-
-		status = write16(state, SCU_RAM_AGC_KI_RED__A, data);
-		if (status < 0)
-			goto error;
-
-		if (IsDVBT(state))
-			pIfAgcSettings = &state->m_dvbtIfAgcCfg;
-		else if (IsQAM(state))
-			pIfAgcSettings = &state->m_qamIfAgcCfg;
-		else
-			pIfAgcSettings = &state->m_atvIfAgcCfg;
-		if (pIfAgcSettings == NULL) {
-			status = -EINVAL;
-			goto error;
-		}
-
-		/* Set TOP, only if IF-AGC is in AUTO mode */
-		if (pIfAgcSettings->ctrlMode == DRXK_AGC_CTRL_AUTO)
-			status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pAgcCfg->top);
-			if (status < 0)
-				goto error;
-
-		/* Cut-Off current */
-		status = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, pAgcCfg->cutOffCurrent);
-		if (status < 0)
-			goto error;
-
-		/* Max. output level */
-		status = write16(state, SCU_RAM_AGC_RF_MAX__A, pAgcCfg->maxOutputLevel);
-		if (status < 0)
-			goto error;
-
-		break;
-
-	case DRXK_AGC_CTRL_USER:
-		/* Enable RF AGC DAC */
-		status = read16(state, IQM_AF_STDBY__A, &data);
-		if (status < 0)
-			goto error;
-		data &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;
-		status = write16(state, IQM_AF_STDBY__A, data);
-		if (status < 0)
-			goto error;
-
-		/* Disable SCU RF AGC loop */
-		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
-		if (status < 0)
-			goto error;
-		data |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;
-		if (state->m_RfAgcPol)
-			data |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
-		else
-			data &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
-		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
-		if (status < 0)
-			goto error;
-
-		/* SCU c.o.c. to 0, enabling full control range */
-		status = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, 0);
-		if (status < 0)
-			goto error;
-
-		/* Write value to output pin */
-		status = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, pAgcCfg->outputLevel);
-		if (status < 0)
-			goto error;
-		break;
-
-	case DRXK_AGC_CTRL_OFF:
-		/* Disable RF AGC DAC */
-		status = read16(state, IQM_AF_STDBY__A, &data);
-		if (status < 0)
-			goto error;
-		data |= IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;
-		status = write16(state, IQM_AF_STDBY__A, data);
-		if (status < 0)
-			goto error;
-
-		/* Disable SCU RF AGC loop */
-		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
-		if (status < 0)
-			goto error;
-		data |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;
-		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
-		if (status < 0)
-			goto error;
-		break;
-
-	default:
-		status = -EINVAL;
-
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-#define SCU_RAM_AGC_KI_INV_IF_POL__M 0x2000
-
-static int SetAgcIf(struct drxk_state *state,
-		    struct SCfgAgc *pAgcCfg, bool isDTV)
-{
-	u16 data = 0;
-	int status = 0;
-	struct SCfgAgc *pRfAgcSettings;
-
-	dprintk(1, "\n");
-
-	switch (pAgcCfg->ctrlMode) {
-	case DRXK_AGC_CTRL_AUTO:
-
-		/* Enable IF AGC DAC */
-		status = read16(state, IQM_AF_STDBY__A, &data);
-		if (status < 0)
-			goto error;
-		data &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;
-		status = write16(state, IQM_AF_STDBY__A, data);
-		if (status < 0)
-			goto error;
-
-		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
-		if (status < 0)
-			goto error;
-
-		/* Enable SCU IF AGC loop */
-		data &= ~SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;
-
-		/* Polarity */
-		if (state->m_IfAgcPol)
-			data |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
-		else
-			data &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
-		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
-		if (status < 0)
-			goto error;
-
-		/* Set speed (using complementary reduction value) */
-		status = read16(state, SCU_RAM_AGC_KI_RED__A, &data);
-		if (status < 0)
-			goto error;
-		data &= ~SCU_RAM_AGC_KI_RED_IAGC_RED__M;
-		data |= (~(pAgcCfg->speed <<
-				SCU_RAM_AGC_KI_RED_IAGC_RED__B)
-				& SCU_RAM_AGC_KI_RED_IAGC_RED__M);
-
-		status = write16(state, SCU_RAM_AGC_KI_RED__A, data);
-		if (status < 0)
-			goto error;
-
-		if (IsQAM(state))
-			pRfAgcSettings = &state->m_qamRfAgcCfg;
-		else
-			pRfAgcSettings = &state->m_atvRfAgcCfg;
-		if (pRfAgcSettings == NULL)
-			return -1;
-		/* Restore TOP */
-		status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pRfAgcSettings->top);
-		if (status < 0)
-			goto error;
-		break;
-
-	case DRXK_AGC_CTRL_USER:
-
-		/* Enable IF AGC DAC */
-		status = read16(state, IQM_AF_STDBY__A, &data);
-		if (status < 0)
-			goto error;
-		data &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;
-		status = write16(state, IQM_AF_STDBY__A, data);
-		if (status < 0)
-			goto error;
-
-		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
-		if (status < 0)
-			goto error;
-
-		/* Disable SCU IF AGC loop */
-		data |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;
-
-		/* Polarity */
-		if (state->m_IfAgcPol)
-			data |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
-		else
-			data &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
-		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
-		if (status < 0)
-			goto error;
-
-		/* Write value to output pin */
-		status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pAgcCfg->outputLevel);
-		if (status < 0)
-			goto error;
-		break;
-
-	case DRXK_AGC_CTRL_OFF:
-
-		/* Disable If AGC DAC */
-		status = read16(state, IQM_AF_STDBY__A, &data);
-		if (status < 0)
-			goto error;
-		data |= IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;
-		status = write16(state, IQM_AF_STDBY__A, data);
-		if (status < 0)
-			goto error;
-
-		/* Disable SCU IF AGC loop */
-		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
-		if (status < 0)
-			goto error;
-		data |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;
-		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
-		if (status < 0)
-			goto error;
-		break;
-	}		/* switch (agcSettingsIf->ctrlMode) */
-
-	/* always set the top to support
-		configurations without if-loop */
-	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, pAgcCfg->top);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int ReadIFAgc(struct drxk_state *state, u32 *pValue)
-{
-	u16 agcDacLvl;
-	int status;
-	u16 Level = 0;
-
-	dprintk(1, "\n");
-
-	status = read16(state, IQM_AF_AGC_IF__A, &agcDacLvl);
-	if (status < 0) {
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-		return status;
-	}
-
-	*pValue = 0;
-
-	if (agcDacLvl > DRXK_AGC_DAC_OFFSET)
-		Level = agcDacLvl - DRXK_AGC_DAC_OFFSET;
-	if (Level < 14000)
-		*pValue = (14000 - Level) / 4;
-	else
-		*pValue = 0;
-
-	return status;
-}
-
-static int GetQAMSignalToNoise(struct drxk_state *state,
-			       s32 *pSignalToNoise)
-{
-	int status = 0;
-	u16 qamSlErrPower = 0;	/* accum. error between
-					raw and sliced symbols */
-	u32 qamSlSigPower = 0;	/* used for MER, depends of
-					QAM modulation */
-	u32 qamSlMer = 0;	/* QAM MER */
-
-	dprintk(1, "\n");
-
-	/* MER calculation */
-
-	/* get the register value needed for MER */
-	status = read16(state, QAM_SL_ERR_POWER__A, &qamSlErrPower);
-	if (status < 0) {
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-		return -EINVAL;
-	}
-
-	switch (state->props.modulation) {
-	case QAM_16:
-		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM16 << 2;
-		break;
-	case QAM_32:
-		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM32 << 2;
-		break;
-	case QAM_64:
-		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM64 << 2;
-		break;
-	case QAM_128:
-		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM128 << 2;
-		break;
-	default:
-	case QAM_256:
-		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM256 << 2;
-		break;
-	}
-
-	if (qamSlErrPower > 0) {
-		qamSlMer = Log10Times100(qamSlSigPower) -
-			Log10Times100((u32) qamSlErrPower);
-	}
-	*pSignalToNoise = qamSlMer;
-
-	return status;
-}
-
-static int GetDVBTSignalToNoise(struct drxk_state *state,
-				s32 *pSignalToNoise)
-{
-	int status;
-	u16 regData = 0;
-	u32 EqRegTdSqrErrI = 0;
-	u32 EqRegTdSqrErrQ = 0;
-	u16 EqRegTdSqrErrExp = 0;
-	u16 EqRegTdTpsPwrOfs = 0;
-	u16 EqRegTdReqSmbCnt = 0;
-	u32 tpsCnt = 0;
-	u32 SqrErrIQ = 0;
-	u32 a = 0;
-	u32 b = 0;
-	u32 c = 0;
-	u32 iMER = 0;
-	u16 transmissionParams = 0;
-
-	dprintk(1, "\n");
-
-	status = read16(state, OFDM_EQ_TOP_TD_TPS_PWR_OFS__A, &EqRegTdTpsPwrOfs);
-	if (status < 0)
-		goto error;
-	status = read16(state, OFDM_EQ_TOP_TD_REQ_SMB_CNT__A, &EqRegTdReqSmbCnt);
-	if (status < 0)
-		goto error;
-	status = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_EXP__A, &EqRegTdSqrErrExp);
-	if (status < 0)
-		goto error;
-	status = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_I__A, &regData);
-	if (status < 0)
-		goto error;
-	/* Extend SQR_ERR_I operational range */
-	EqRegTdSqrErrI = (u32) regData;
-	if ((EqRegTdSqrErrExp > 11) &&
-		(EqRegTdSqrErrI < 0x00000FFFUL)) {
-		EqRegTdSqrErrI += 0x00010000UL;
-	}
-	status = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_Q__A, &regData);
-	if (status < 0)
-		goto error;
-	/* Extend SQR_ERR_Q operational range */
-	EqRegTdSqrErrQ = (u32) regData;
-	if ((EqRegTdSqrErrExp > 11) &&
-		(EqRegTdSqrErrQ < 0x00000FFFUL))
-		EqRegTdSqrErrQ += 0x00010000UL;
-
-	status = read16(state, OFDM_SC_RA_RAM_OP_PARAM__A, &transmissionParams);
-	if (status < 0)
-		goto error;
-
-	/* Check input data for MER */
-
-	/* MER calculation (in 0.1 dB) without math.h */
-	if ((EqRegTdTpsPwrOfs == 0) || (EqRegTdReqSmbCnt == 0))
-		iMER = 0;
-	else if ((EqRegTdSqrErrI + EqRegTdSqrErrQ) == 0) {
-		/* No error at all, this must be the HW reset value
-			* Apparently no first measurement yet
-			* Set MER to 0.0 */
-		iMER = 0;
-	} else {
-		SqrErrIQ = (EqRegTdSqrErrI + EqRegTdSqrErrQ) <<
-			EqRegTdSqrErrExp;
-		if ((transmissionParams &
-			OFDM_SC_RA_RAM_OP_PARAM_MODE__M)
-			== OFDM_SC_RA_RAM_OP_PARAM_MODE_2K)
-			tpsCnt = 17;
-		else
-			tpsCnt = 68;
-
-		/* IMER = 100 * log10 (x)
-			where x = (EqRegTdTpsPwrOfs^2 *
-			EqRegTdReqSmbCnt * tpsCnt)/SqrErrIQ
-
-			=> IMER = a + b -c
-			where a = 100 * log10 (EqRegTdTpsPwrOfs^2)
-			b = 100 * log10 (EqRegTdReqSmbCnt * tpsCnt)
-			c = 100 * log10 (SqrErrIQ)
-			*/
-
-		/* log(x) x = 9bits * 9bits->18 bits  */
-		a = Log10Times100(EqRegTdTpsPwrOfs *
-					EqRegTdTpsPwrOfs);
-		/* log(x) x = 16bits * 7bits->23 bits  */
-		b = Log10Times100(EqRegTdReqSmbCnt * tpsCnt);
-		/* log(x) x = (16bits + 16bits) << 15 ->32 bits  */
-		c = Log10Times100(SqrErrIQ);
-
-		iMER = a + b;
-		/* No negative MER, clip to zero */
-		if (iMER > c)
-			iMER -= c;
-		else
-			iMER = 0;
-	}
-	*pSignalToNoise = iMER;
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int GetSignalToNoise(struct drxk_state *state, s32 *pSignalToNoise)
-{
-	dprintk(1, "\n");
-
-	*pSignalToNoise = 0;
-	switch (state->m_OperationMode) {
-	case OM_DVBT:
-		return GetDVBTSignalToNoise(state, pSignalToNoise);
-	case OM_QAM_ITU_A:
-	case OM_QAM_ITU_C:
-		return GetQAMSignalToNoise(state, pSignalToNoise);
-	default:
-		break;
-	}
-	return 0;
-}
-
-#if 0
-static int GetDVBTQuality(struct drxk_state *state, s32 *pQuality)
-{
-	/* SNR Values for quasi errorfree reception rom Nordig 2.2 */
-	int status = 0;
-
-	dprintk(1, "\n");
-
-	static s32 QE_SN[] = {
-		51,		/* QPSK 1/2 */
-		69,		/* QPSK 2/3 */
-		79,		/* QPSK 3/4 */
-		89,		/* QPSK 5/6 */
-		97,		/* QPSK 7/8 */
-		108,		/* 16-QAM 1/2 */
-		131,		/* 16-QAM 2/3 */
-		146,		/* 16-QAM 3/4 */
-		156,		/* 16-QAM 5/6 */
-		160,		/* 16-QAM 7/8 */
-		165,		/* 64-QAM 1/2 */
-		187,		/* 64-QAM 2/3 */
-		202,		/* 64-QAM 3/4 */
-		216,		/* 64-QAM 5/6 */
-		225,		/* 64-QAM 7/8 */
-	};
-
-	*pQuality = 0;
-
-	do {
-		s32 SignalToNoise = 0;
-		u16 Constellation = 0;
-		u16 CodeRate = 0;
-		u32 SignalToNoiseRel;
-		u32 BERQuality;
-
-		status = GetDVBTSignalToNoise(state, &SignalToNoise);
-		if (status < 0)
-			break;
-		status = read16(state, OFDM_EQ_TOP_TD_TPS_CONST__A, &Constellation);
-		if (status < 0)
-			break;
-		Constellation &= OFDM_EQ_TOP_TD_TPS_CONST__M;
-
-		status = read16(state, OFDM_EQ_TOP_TD_TPS_CODE_HP__A, &CodeRate);
-		if (status < 0)
-			break;
-		CodeRate &= OFDM_EQ_TOP_TD_TPS_CODE_HP__M;
-
-		if (Constellation > OFDM_EQ_TOP_TD_TPS_CONST_64QAM ||
-		    CodeRate > OFDM_EQ_TOP_TD_TPS_CODE_LP_7_8)
-			break;
-		SignalToNoiseRel = SignalToNoise -
-		    QE_SN[Constellation * 5 + CodeRate];
-		BERQuality = 100;
-
-		if (SignalToNoiseRel < -70)
-			*pQuality = 0;
-		else if (SignalToNoiseRel < 30)
-			*pQuality = ((SignalToNoiseRel + 70) *
-				     BERQuality) / 100;
-		else
-			*pQuality = BERQuality;
-	} while (0);
-	return 0;
-};
-
-static int GetDVBCQuality(struct drxk_state *state, s32 *pQuality)
-{
-	int status = 0;
-	*pQuality = 0;
-
-	dprintk(1, "\n");
-
-	do {
-		u32 SignalToNoise = 0;
-		u32 BERQuality = 100;
-		u32 SignalToNoiseRel = 0;
-
-		status = GetQAMSignalToNoise(state, &SignalToNoise);
-		if (status < 0)
-			break;
-
-		switch (state->props.modulation) {
-		case QAM_16:
-			SignalToNoiseRel = SignalToNoise - 200;
-			break;
-		case QAM_32:
-			SignalToNoiseRel = SignalToNoise - 230;
-			break;	/* Not in NorDig */
-		case QAM_64:
-			SignalToNoiseRel = SignalToNoise - 260;
-			break;
-		case QAM_128:
-			SignalToNoiseRel = SignalToNoise - 290;
-			break;
-		default:
-		case QAM_256:
-			SignalToNoiseRel = SignalToNoise - 320;
-			break;
-		}
-
-		if (SignalToNoiseRel < -70)
-			*pQuality = 0;
-		else if (SignalToNoiseRel < 30)
-			*pQuality = ((SignalToNoiseRel + 70) *
-				     BERQuality) / 100;
-		else
-			*pQuality = BERQuality;
-	} while (0);
-
-	return status;
-}
-
-static int GetQuality(struct drxk_state *state, s32 *pQuality)
-{
-	dprintk(1, "\n");
-
-	switch (state->m_OperationMode) {
-	case OM_DVBT:
-		return GetDVBTQuality(state, pQuality);
-	case OM_QAM_ITU_A:
-		return GetDVBCQuality(state, pQuality);
-	default:
-		break;
-	}
-
-	return 0;
-}
-#endif
-
-/* Free data ram in SIO HI */
-#define SIO_HI_RA_RAM_USR_BEGIN__A 0x420040
-#define SIO_HI_RA_RAM_USR_END__A   0x420060
-
-#define DRXK_HI_ATOMIC_BUF_START (SIO_HI_RA_RAM_USR_BEGIN__A)
-#define DRXK_HI_ATOMIC_BUF_END   (SIO_HI_RA_RAM_USR_BEGIN__A + 7)
-#define DRXK_HI_ATOMIC_READ      SIO_HI_RA_RAM_PAR_3_ACP_RW_READ
-#define DRXK_HI_ATOMIC_WRITE     SIO_HI_RA_RAM_PAR_3_ACP_RW_WRITE
-
-#define DRXDAP_FASI_ADDR2BLOCK(addr)  (((addr) >> 22) & 0x3F)
-#define DRXDAP_FASI_ADDR2BANK(addr)   (((addr) >> 16) & 0x3F)
-#define DRXDAP_FASI_ADDR2OFFSET(addr) ((addr) & 0x7FFF)
-
-static int ConfigureI2CBridge(struct drxk_state *state, bool bEnableBridge)
-{
-	int status = -EINVAL;
-
-	dprintk(1, "\n");
-
-	if (state->m_DrxkState == DRXK_UNINITIALIZED)
-		goto error;
-	if (state->m_DrxkState == DRXK_POWERED_DOWN)
-		goto error;
-
-	if (state->no_i2c_bridge)
-		return 0;
-
-	status = write16(state, SIO_HI_RA_RAM_PAR_1__A, SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);
-	if (status < 0)
-		goto error;
-	if (bEnableBridge) {
-		status = write16(state, SIO_HI_RA_RAM_PAR_2__A, SIO_HI_RA_RAM_PAR_2_BRD_CFG_CLOSED);
-		if (status < 0)
-			goto error;
-	} else {
-		status = write16(state, SIO_HI_RA_RAM_PAR_2__A, SIO_HI_RA_RAM_PAR_2_BRD_CFG_OPEN);
-		if (status < 0)
-			goto error;
-	}
-
-	status = HI_Command(state, SIO_HI_RA_RAM_CMD_BRDCTRL, 0);
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SetPreSaw(struct drxk_state *state,
-		     struct SCfgPreSaw *pPreSawCfg)
-{
-	int status = -EINVAL;
-
-	dprintk(1, "\n");
-
-	if ((pPreSawCfg == NULL)
-	    || (pPreSawCfg->reference > IQM_AF_PDREF__M))
-		goto error;
-
-	status = write16(state, IQM_AF_PDREF__A, pPreSawCfg->reference);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int BLDirectCmd(struct drxk_state *state, u32 targetAddr,
-		       u16 romOffset, u16 nrOfElements, u32 timeOut)
-{
-	u16 blStatus = 0;
-	u16 offset = (u16) ((targetAddr >> 0) & 0x00FFFF);
-	u16 blockbank = (u16) ((targetAddr >> 16) & 0x000FFF);
-	int status;
-	unsigned long end;
-
-	dprintk(1, "\n");
-
-	mutex_lock(&state->mutex);
-	status = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_DIRECT);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_TGT_HDR__A, blockbank);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_TGT_ADDR__A, offset);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_SRC_ADDR__A, romOffset);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_SRC_LEN__A, nrOfElements);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);
-	if (status < 0)
-		goto error;
-
-	end = jiffies + msecs_to_jiffies(timeOut);
-	do {
-		status = read16(state, SIO_BL_STATUS__A, &blStatus);
-		if (status < 0)
-			goto error;
-	} while ((blStatus == 0x1) && time_is_after_jiffies(end));
-	if (blStatus == 0x1) {
-		printk(KERN_ERR "drxk: SIO not ready\n");
-		status = -EINVAL;
-		goto error2;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-error2:
-	mutex_unlock(&state->mutex);
-	return status;
-
-}
-
-static int ADCSyncMeasurement(struct drxk_state *state, u16 *count)
-{
-	u16 data = 0;
-	int status;
-
-	dprintk(1, "\n");
-
-	/* Start measurement */
-	status = write16(state, IQM_AF_COMM_EXEC__A, IQM_AF_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_START_LOCK__A, 1);
-	if (status < 0)
-		goto error;
-
-	*count = 0;
-	status = read16(state, IQM_AF_PHASE0__A, &data);
-	if (status < 0)
-		goto error;
-	if (data == 127)
-		*count = *count + 1;
-	status = read16(state, IQM_AF_PHASE1__A, &data);
-	if (status < 0)
-		goto error;
-	if (data == 127)
-		*count = *count + 1;
-	status = read16(state, IQM_AF_PHASE2__A, &data);
-	if (status < 0)
-		goto error;
-	if (data == 127)
-		*count = *count + 1;
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int ADCSynchronization(struct drxk_state *state)
-{
-	u16 count = 0;
-	int status;
-
-	dprintk(1, "\n");
-
-	status = ADCSyncMeasurement(state, &count);
-	if (status < 0)
-		goto error;
-
-	if (count == 1) {
-		/* Try sampling on a diffrent edge */
-		u16 clkNeg = 0;
-
-		status = read16(state, IQM_AF_CLKNEG__A, &clkNeg);
-		if (status < 0)
-			goto error;
-		if ((clkNeg | IQM_AF_CLKNEG_CLKNEGDATA__M) ==
-			IQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS) {
-			clkNeg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));
-			clkNeg |=
-				IQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_NEG;
-		} else {
-			clkNeg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));
-			clkNeg |=
-				IQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS;
-		}
-		status = write16(state, IQM_AF_CLKNEG__A, clkNeg);
-		if (status < 0)
-			goto error;
-		status = ADCSyncMeasurement(state, &count);
-		if (status < 0)
-			goto error;
-	}
-
-	if (count < 2)
-		status = -EINVAL;
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SetFrequencyShifter(struct drxk_state *state,
-			       u16 intermediateFreqkHz,
-			       s32 tunerFreqOffset, bool isDTV)
-{
-	bool selectPosImage = false;
-	u32 rfFreqResidual = tunerFreqOffset;
-	u32 fmFrequencyShift = 0;
-	bool tunerMirror = !state->m_bMirrorFreqSpect;
-	u32 adcFreq;
-	bool adcFlip;
-	int status;
-	u32 ifFreqActual;
-	u32 samplingFrequency = (u32) (state->m_sysClockFreq / 3);
-	u32 frequencyShift;
-	bool imageToSelect;
-
-	dprintk(1, "\n");
-
-	/*
-	   Program frequency shifter
-	   No need to account for mirroring on RF
-	 */
-	if (isDTV) {
-		if ((state->m_OperationMode == OM_QAM_ITU_A) ||
-		    (state->m_OperationMode == OM_QAM_ITU_C) ||
-		    (state->m_OperationMode == OM_DVBT))
-			selectPosImage = true;
-		else
-			selectPosImage = false;
-	}
-	if (tunerMirror)
-		/* tuner doesn't mirror */
-		ifFreqActual = intermediateFreqkHz +
-		    rfFreqResidual + fmFrequencyShift;
-	else
-		/* tuner mirrors */
-		ifFreqActual = intermediateFreqkHz -
-		    rfFreqResidual - fmFrequencyShift;
-	if (ifFreqActual > samplingFrequency / 2) {
-		/* adc mirrors */
-		adcFreq = samplingFrequency - ifFreqActual;
-		adcFlip = true;
-	} else {
-		/* adc doesn't mirror */
-		adcFreq = ifFreqActual;
-		adcFlip = false;
-	}
-
-	frequencyShift = adcFreq;
-	imageToSelect = state->m_rfmirror ^ tunerMirror ^
-	    adcFlip ^ selectPosImage;
-	state->m_IqmFsRateOfs =
-	    Frac28a((frequencyShift), samplingFrequency);
-
-	if (imageToSelect)
-		state->m_IqmFsRateOfs = ~state->m_IqmFsRateOfs + 1;
-
-	/* Program frequency shifter with tuner offset compensation */
-	/* frequencyShift += tunerFreqOffset; TODO */
-	status = write32(state, IQM_FS_RATE_OFS_LO__A,
-			 state->m_IqmFsRateOfs);
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int InitAGC(struct drxk_state *state, bool isDTV)
-{
-	u16 ingainTgt = 0;
-	u16 ingainTgtMin = 0;
-	u16 ingainTgtMax = 0;
-	u16 clpCyclen = 0;
-	u16 clpSumMin = 0;
-	u16 clpDirTo = 0;
-	u16 snsSumMin = 0;
-	u16 snsSumMax = 0;
-	u16 clpSumMax = 0;
-	u16 snsDirTo = 0;
-	u16 kiInnergainMin = 0;
-	u16 ifIaccuHiTgt = 0;
-	u16 ifIaccuHiTgtMin = 0;
-	u16 ifIaccuHiTgtMax = 0;
-	u16 data = 0;
-	u16 fastClpCtrlDelay = 0;
-	u16 clpCtrlMode = 0;
-	int status = 0;
-
-	dprintk(1, "\n");
-
-	/* Common settings */
-	snsSumMax = 1023;
-	ifIaccuHiTgtMin = 2047;
-	clpCyclen = 500;
-	clpSumMax = 1023;
-
-	/* AGCInit() not available for DVBT; init done in microcode */
-	if (!IsQAM(state)) {
-		printk(KERN_ERR "drxk: %s: mode %d is not DVB-C\n", __func__, state->m_OperationMode);
-		return -EINVAL;
-	}
-
-	/* FIXME: Analog TV AGC require different settings */
-
-	/* Standard specific settings */
-	clpSumMin = 8;
-	clpDirTo = (u16) -9;
-	clpCtrlMode = 0;
-	snsSumMin = 8;
-	snsDirTo = (u16) -9;
-	kiInnergainMin = (u16) -1030;
-	ifIaccuHiTgtMax = 0x2380;
-	ifIaccuHiTgt = 0x2380;
-	ingainTgtMin = 0x0511;
-	ingainTgt = 0x0511;
-	ingainTgtMax = 5119;
-	fastClpCtrlDelay = state->m_qamIfAgcCfg.FastClipCtrlDelay;
-
-	status = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A, fastClpCtrlDelay);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_AGC_CLP_CTRL_MODE__A, clpCtrlMode);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_INGAIN_TGT__A, ingainTgt);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, ingainTgtMin);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, ingainTgtMax);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MIN__A, ifIaccuHiTgtMin);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, ifIaccuHiTgtMax);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_IF_IACCU_LO__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_RF_IACCU_LO__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_SUM_MAX__A, clpSumMax);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_SUM_MAX__A, snsSumMax);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_AGC_KI_INNERGAIN_MIN__A, kiInnergainMin);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT__A, ifIaccuHiTgt);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_CYCLEN__A, clpCyclen);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MAX__A, 1023);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MIN__A, (u16) -1023);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_FAST_SNS_CTRL_DELAY__A, 50);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_AGC_KI_MAXMINGAIN_TH__A, 20);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_SUM_MIN__A, clpSumMin);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_SUM_MIN__A, snsSumMin);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_DIR_TO__A, clpDirTo);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_DIR_TO__A, snsDirTo);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_KI_MINGAIN__A, 0x7fff);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_KI_MAXGAIN__A, 0x0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_KI_MIN__A, 0x0117);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_KI_MAX__A, 0x0657);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_SUM__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_CYCCNT__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_DIR_WD__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_CLP_DIR_STP__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_SUM__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_CYCCNT__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_DIR_WD__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_DIR_STP__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_SNS_CYCLEN__A, 500);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_KI_CYCLEN__A, 500);
-	if (status < 0)
-		goto error;
-
-	/* Initialize inner-loop KI gain factors */
-	status = read16(state, SCU_RAM_AGC_KI__A, &data);
-	if (status < 0)
-		goto error;
-
-	data = 0x0657;
-	data &= ~SCU_RAM_AGC_KI_RF__M;
-	data |= (DRXK_KI_RAGC_QAM << SCU_RAM_AGC_KI_RF__B);
-	data &= ~SCU_RAM_AGC_KI_IF__M;
-	data |= (DRXK_KI_IAGC_QAM << SCU_RAM_AGC_KI_IF__B);
-
-	status = write16(state, SCU_RAM_AGC_KI__A, data);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int DVBTQAMGetAccPktErr(struct drxk_state *state, u16 *packetErr)
-{
-	int status;
-
-	dprintk(1, "\n");
-	if (packetErr == NULL)
-		status = write16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, 0);
-	else
-		status = read16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, packetErr);
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int DVBTScCommand(struct drxk_state *state,
-			 u16 cmd, u16 subcmd,
-			 u16 param0, u16 param1, u16 param2,
-			 u16 param3, u16 param4)
-{
-	u16 curCmd = 0;
-	u16 errCode = 0;
-	u16 retryCnt = 0;
-	u16 scExec = 0;
-	int status;
-
-	dprintk(1, "\n");
-	status = read16(state, OFDM_SC_COMM_EXEC__A, &scExec);
-	if (scExec != 1) {
-		/* SC is not running */
-		status = -EINVAL;
-	}
-	if (status < 0)
-		goto error;
-
-	/* Wait until sc is ready to receive command */
-	retryCnt = 0;
-	do {
-		msleep(1);
-		status = read16(state, OFDM_SC_RA_RAM_CMD__A, &curCmd);
-		retryCnt++;
-	} while ((curCmd != 0) && (retryCnt < DRXK_MAX_RETRIES));
-	if (retryCnt >= DRXK_MAX_RETRIES && (status < 0))
-		goto error;
-
-	/* Write sub-command */
-	switch (cmd) {
-		/* All commands using sub-cmd */
-	case OFDM_SC_RA_RAM_CMD_PROC_START:
-	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
-	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
-		status = write16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, subcmd);
-		if (status < 0)
-			goto error;
-		break;
-	default:
-		/* Do nothing */
-		break;
-	}
-
-	/* Write needed parameters and the command */
-	switch (cmd) {
-		/* All commands using 5 parameters */
-		/* All commands using 4 parameters */
-		/* All commands using 3 parameters */
-		/* All commands using 2 parameters */
-	case OFDM_SC_RA_RAM_CMD_PROC_START:
-	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
-	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
-		status = write16(state, OFDM_SC_RA_RAM_PARAM1__A, param1);
-		/* All commands using 1 parameters */
-	case OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:
-	case OFDM_SC_RA_RAM_CMD_USER_IO:
-		status = write16(state, OFDM_SC_RA_RAM_PARAM0__A, param0);
-		/* All commands using 0 parameters */
-	case OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:
-	case OFDM_SC_RA_RAM_CMD_NULL:
-		/* Write command */
-		status = write16(state, OFDM_SC_RA_RAM_CMD__A, cmd);
-		break;
-	default:
-		/* Unknown command */
-		status = -EINVAL;
-	}
-	if (status < 0)
-		goto error;
-
-	/* Wait until sc is ready processing command */
-	retryCnt = 0;
-	do {
-		msleep(1);
-		status = read16(state, OFDM_SC_RA_RAM_CMD__A, &curCmd);
-		retryCnt++;
-	} while ((curCmd != 0) && (retryCnt < DRXK_MAX_RETRIES));
-	if (retryCnt >= DRXK_MAX_RETRIES && (status < 0))
-		goto error;
-
-	/* Check for illegal cmd */
-	status = read16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, &errCode);
-	if (errCode == 0xFFFF) {
-		/* illegal command */
-		status = -EINVAL;
-	}
-	if (status < 0)
-		goto error;
-
-	/* Retreive results parameters from SC */
-	switch (cmd) {
-		/* All commands yielding 5 results */
-		/* All commands yielding 4 results */
-		/* All commands yielding 3 results */
-		/* All commands yielding 2 results */
-		/* All commands yielding 1 result */
-	case OFDM_SC_RA_RAM_CMD_USER_IO:
-	case OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:
-		status = read16(state, OFDM_SC_RA_RAM_PARAM0__A, &(param0));
-		/* All commands yielding 0 results */
-	case OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:
-	case OFDM_SC_RA_RAM_CMD_SET_TIMER:
-	case OFDM_SC_RA_RAM_CMD_PROC_START:
-	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
-	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
-	case OFDM_SC_RA_RAM_CMD_NULL:
-		break;
-	default:
-		/* Unknown command */
-		status = -EINVAL;
-		break;
-	}			/* switch (cmd->cmd) */
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int PowerUpDVBT(struct drxk_state *state)
-{
-	enum DRXPowerMode powerMode = DRX_POWER_UP;
-	int status;
-
-	dprintk(1, "\n");
-	status = CtrlPowerMode(state, &powerMode);
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int DVBTCtrlSetIncEnable(struct drxk_state *state, bool *enabled)
-{
-	int status;
-
-	dprintk(1, "\n");
-	if (*enabled == true)
-		status = write16(state, IQM_CF_BYPASSDET__A, 0);
-	else
-		status = write16(state, IQM_CF_BYPASSDET__A, 1);
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-#define DEFAULT_FR_THRES_8K     4000
-static int DVBTCtrlSetFrEnable(struct drxk_state *state, bool *enabled)
-{
-
-	int status;
-
-	dprintk(1, "\n");
-	if (*enabled == true) {
-		/* write mask to 1 */
-		status = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A,
-				   DEFAULT_FR_THRES_8K);
-	} else {
-		/* write mask to 0 */
-		status = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A, 0);
-	}
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int DVBTCtrlSetEchoThreshold(struct drxk_state *state,
-				    struct DRXKCfgDvbtEchoThres_t *echoThres)
-{
-	u16 data = 0;
-	int status;
-
-	dprintk(1, "\n");
-	status = read16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, &data);
-	if (status < 0)
-		goto error;
-
-	switch (echoThres->fftMode) {
-	case DRX_FFTMODE_2K:
-		data &= ~OFDM_SC_RA_RAM_ECHO_THRES_2K__M;
-		data |= ((echoThres->threshold <<
-			OFDM_SC_RA_RAM_ECHO_THRES_2K__B)
-			& (OFDM_SC_RA_RAM_ECHO_THRES_2K__M));
-		break;
-	case DRX_FFTMODE_8K:
-		data &= ~OFDM_SC_RA_RAM_ECHO_THRES_8K__M;
-		data |= ((echoThres->threshold <<
-			OFDM_SC_RA_RAM_ECHO_THRES_8K__B)
-			& (OFDM_SC_RA_RAM_ECHO_THRES_8K__M));
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	status = write16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, data);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int DVBTCtrlSetSqiSpeed(struct drxk_state *state,
-			       enum DRXKCfgDvbtSqiSpeed *speed)
-{
-	int status = -EINVAL;
-
-	dprintk(1, "\n");
-
-	switch (*speed) {
-	case DRXK_DVBT_SQI_SPEED_FAST:
-	case DRXK_DVBT_SQI_SPEED_MEDIUM:
-	case DRXK_DVBT_SQI_SPEED_SLOW:
-		break;
-	default:
-		goto error;
-	}
-	status = write16(state, SCU_RAM_FEC_PRE_RS_BER_FILTER_SH__A,
-			   (u16) *speed);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief Activate DVBT specific presets
-* \param demod instance of demodulator.
-* \return DRXStatus_t.
-*
-* Called in DVBTSetStandard
-*
-*/
-static int DVBTActivatePresets(struct drxk_state *state)
-{
-	int status;
-	bool setincenable = false;
-	bool setfrenable = true;
-
-	struct DRXKCfgDvbtEchoThres_t echoThres2k = { 0, DRX_FFTMODE_2K };
-	struct DRXKCfgDvbtEchoThres_t echoThres8k = { 0, DRX_FFTMODE_8K };
-
-	dprintk(1, "\n");
-	status = DVBTCtrlSetIncEnable(state, &setincenable);
-	if (status < 0)
-		goto error;
-	status = DVBTCtrlSetFrEnable(state, &setfrenable);
-	if (status < 0)
-		goto error;
-	status = DVBTCtrlSetEchoThreshold(state, &echoThres2k);
-	if (status < 0)
-		goto error;
-	status = DVBTCtrlSetEchoThreshold(state, &echoThres8k);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, state->m_dvbtIfAgcCfg.IngainTgtMax);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief Initialize channelswitch-independent settings for DVBT.
-* \param demod instance of demodulator.
-* \return DRXStatus_t.
-*
-* For ROM code channel filter taps are loaded from the bootloader. For microcode
-* the DVB-T taps from the drxk_filters.h are used.
-*/
-static int SetDVBTStandard(struct drxk_state *state,
-			   enum OperationMode oMode)
-{
-	u16 cmdResult = 0;
-	u16 data = 0;
-	int status;
-
-	dprintk(1, "\n");
-
-	PowerUpDVBT(state);
-	/* added antenna switch */
-	SwitchAntennaToDVBT(state);
-	/* send OFDM reset command */
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);
-	if (status < 0)
-		goto error;
-
-	/* send OFDM setenv command */
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV, 0, NULL, 1, &cmdResult);
-	if (status < 0)
-		goto error;
-
-	/* reset datapath for OFDM, processors first */
-	status = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);
-	if (status < 0)
-		goto error;
-
-	/* IQM setup */
-	/* synchronize on ofdstate->m_festart */
-	status = write16(state, IQM_AF_UPD_SEL__A, 1);
-	if (status < 0)
-		goto error;
-	/* window size for clipping ADC detection */
-	status = write16(state, IQM_AF_CLP_LEN__A, 0);
-	if (status < 0)
-		goto error;
-	/* window size for for sense pre-SAW detection */
-	status = write16(state, IQM_AF_SNS_LEN__A, 0);
-	if (status < 0)
-		goto error;
-	/* sense threshold for sense pre-SAW detection */
-	status = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);
-	if (status < 0)
-		goto error;
-	status = SetIqmAf(state, true);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, IQM_AF_AGC_RF__A, 0);
-	if (status < 0)
-		goto error;
-
-	/* Impulse noise cruncher setup */
-	status = write16(state, IQM_AF_INC_LCT__A, 0);	/* crunch in IQM_CF */
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_DET_LCT__A, 0);	/* detect in IQM_CF */
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_WND_LEN__A, 3);	/* peak detector window length */
-	if (status < 0)
-		goto error;
-
-	status = write16(state, IQM_RC_STRETCH__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_OUT_ENA__A, 0x4);	/* enable output 2 */
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_DS_ENA__A, 0x4);	/* decimate output 2 */
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_SCALE__A, 1600);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_SCALE_SH__A, 0);
-	if (status < 0)
-		goto error;
-
-	/* virtual clipping threshold for clipping ADC detection */
-	status = write16(state, IQM_AF_CLP_TH__A, 448);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_DATATH__A, 495);	/* crunching threshold */
-	if (status < 0)
-		goto error;
-
-	status = BLChainCmd(state, DRXK_BL_ROM_OFFSET_TAPS_DVBT, DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, IQM_CF_PKDTH__A, 2);	/* peak detector threshold */
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_POW_MEAS_LEN__A, 2);
-	if (status < 0)
-		goto error;
-	/* enable power measurement interrupt */
-	status = write16(state, IQM_CF_COMM_INT_MSK__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);
-	if (status < 0)
-		goto error;
-
-	/* IQM will not be reset from here, sync ADC and update/init AGC */
-	status = ADCSynchronization(state);
-	if (status < 0)
-		goto error;
-	status = SetPreSaw(state, &state->m_dvbtPreSawCfg);
-	if (status < 0)
-		goto error;
-
-	/* Halt SCU to enable safe non-atomic accesses */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
-	if (status < 0)
-		goto error;
-
-	status = SetAgcRf(state, &state->m_dvbtRfAgcCfg, true);
-	if (status < 0)
-		goto error;
-	status = SetAgcIf(state, &state->m_dvbtIfAgcCfg, true);
-	if (status < 0)
-		goto error;
-
-	/* Set Noise Estimation notch width and enable DC fix */
-	status = read16(state, OFDM_SC_RA_RAM_CONFIG__A, &data);
-	if (status < 0)
-		goto error;
-	data |= OFDM_SC_RA_RAM_CONFIG_NE_FIX_ENABLE__M;
-	status = write16(state, OFDM_SC_RA_RAM_CONFIG__A, data);
-	if (status < 0)
-		goto error;
-
-	/* Activate SCU to enable SCU commands */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-
-	if (!state->m_DRXK_A3_ROM_CODE) {
-		/* AGCInit() is not done for DVBT, so set agcFastClipCtrlDelay  */
-		status = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A, state->m_dvbtIfAgcCfg.FastClipCtrlDelay);
-		if (status < 0)
-			goto error;
-	}
-
-	/* OFDM_SC setup */
-#ifdef COMPILE_FOR_NONRT
-	status = write16(state, OFDM_SC_RA_RAM_BE_OPT_DELAY__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, OFDM_SC_RA_RAM_BE_OPT_INIT_DELAY__A, 2);
-	if (status < 0)
-		goto error;
-#endif
-
-	/* FEC setup */
-	status = write16(state, FEC_DI_INPUT_CTL__A, 1);	/* OFDM input */
-	if (status < 0)
-		goto error;
-
-
-#ifdef COMPILE_FOR_NONRT
-	status = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x400);
-	if (status < 0)
-		goto error;
-#else
-	status = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x1000);
-	if (status < 0)
-		goto error;
-#endif
-	status = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, 0x0001);
-	if (status < 0)
-		goto error;
-
-	/* Setup MPEG bus */
-	status = MPEGTSDtoSetup(state, OM_DVBT);
-	if (status < 0)
-		goto error;
-	/* Set DVBT Presets */
-	status = DVBTActivatePresets(state);
-	if (status < 0)
-		goto error;
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-/**
-* \brief Start dvbt demodulating for channel.
-* \param demod instance of demodulator.
-* \return DRXStatus_t.
-*/
-static int DVBTStart(struct drxk_state *state)
-{
-	u16 param1;
-	int status;
-	/* DRXKOfdmScCmd_t scCmd; */
-
-	dprintk(1, "\n");
-	/* Start correct processes to get in lock */
-	/* DRXK: OFDM_SC_RA_RAM_PROC_LOCKTRACK is no longer in mapfile! */
-	param1 = OFDM_SC_RA_RAM_LOCKTRACK_MIN;
-	status = DVBTScCommand(state, OFDM_SC_RA_RAM_CMD_PROC_START, 0, OFDM_SC_RA_RAM_SW_EVENT_RUN_NMASK__M, param1, 0, 0, 0);
-	if (status < 0)
-		goto error;
-	/* Start FEC OC */
-	status = MPEGTSStart(state);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-
-/*============================================================================*/
-
-/**
-* \brief Set up dvbt demodulator for channel.
-* \param demod instance of demodulator.
-* \return DRXStatus_t.
-* // original DVBTSetChannel()
-*/
-static int SetDVBT(struct drxk_state *state, u16 IntermediateFreqkHz,
-		   s32 tunerFreqOffset)
-{
-	u16 cmdResult = 0;
-	u16 transmissionParams = 0;
-	u16 operationMode = 0;
-	u32 iqmRcRateOfs = 0;
-	u32 bandwidth = 0;
-	u16 param1;
-	int status;
-
-	dprintk(1, "IF =%d, TFO = %d\n", IntermediateFreqkHz, tunerFreqOffset);
-
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);
-	if (status < 0)
-		goto error;
-
-	/* Halt SCU to enable safe non-atomic accesses */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
-	if (status < 0)
-		goto error;
-
-	/* Stop processors */
-	status = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-
-	/* Mandatory fix, always stop CP, required to set spl offset back to
-		hardware default (is set to 0 by ucode during pilot detection */
-	status = write16(state, OFDM_CP_COMM_EXEC__A, OFDM_CP_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-
-	/*== Write channel settings to device =====================================*/
-
-	/* mode */
-	switch (state->props.transmission_mode) {
-	case TRANSMISSION_MODE_AUTO:
-	default:
-		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_MODE__M;
-		/* fall through , try first guess DRX_FFTMODE_8K */
-	case TRANSMISSION_MODE_8K:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_MODE_8K;
-		break;
-	case TRANSMISSION_MODE_2K:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_MODE_2K;
-		break;
-	}
-
-	/* guard */
-	switch (state->props.guard_interval) {
-	default:
-	case GUARD_INTERVAL_AUTO:
-		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_GUARD__M;
-		/* fall through , try first guess DRX_GUARD_1DIV4 */
-	case GUARD_INTERVAL_1_4:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_4;
-		break;
-	case GUARD_INTERVAL_1_32:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_32;
-		break;
-	case GUARD_INTERVAL_1_16:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_16;
-		break;
-	case GUARD_INTERVAL_1_8:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_8;
-		break;
-	}
-
-	/* hierarchy */
-	switch (state->props.hierarchy) {
-	case HIERARCHY_AUTO:
-	case HIERARCHY_NONE:
-	default:
-		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_HIER__M;
-		/* fall through , try first guess SC_RA_RAM_OP_PARAM_HIER_NO */
-		/* transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_NO; */
-		/* break; */
-	case HIERARCHY_1:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A1;
-		break;
-	case HIERARCHY_2:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A2;
-		break;
-	case HIERARCHY_4:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A4;
-		break;
-	}
-
-
-	/* modulation */
-	switch (state->props.modulation) {
-	case QAM_AUTO:
-	default:
-		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_CONST__M;
-		/* fall through , try first guess DRX_CONSTELLATION_QAM64 */
-	case QAM_64:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM64;
-		break;
-	case QPSK:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QPSK;
-		break;
-	case QAM_16:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM16;
-		break;
-	}
-#if 0
-	/* No hierachical channels support in BDA */
-	/* Priority (only for hierarchical channels) */
-	switch (channel->priority) {
-	case DRX_PRIORITY_LOW:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_LO;
-		WR16(devAddr, OFDM_EC_SB_PRIOR__A,
-			OFDM_EC_SB_PRIOR_LO);
-		break;
-	case DRX_PRIORITY_HIGH:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;
-		WR16(devAddr, OFDM_EC_SB_PRIOR__A,
-			OFDM_EC_SB_PRIOR_HI));
-		break;
-	case DRX_PRIORITY_UNKNOWN:	/* fall through */
-	default:
-		status = -EINVAL;
-		goto error;
-	}
-#else
-	/* Set Priorty high */
-	transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;
-	status = write16(state, OFDM_EC_SB_PRIOR__A, OFDM_EC_SB_PRIOR_HI);
-	if (status < 0)
-		goto error;
-#endif
-
-	/* coderate */
-	switch (state->props.code_rate_HP) {
-	case FEC_AUTO:
-	default:
-		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_RATE__M;
-		/* fall through , try first guess DRX_CODERATE_2DIV3 */
-	case FEC_2_3:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_2_3;
-		break;
-	case FEC_1_2:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_1_2;
-		break;
-	case FEC_3_4:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_3_4;
-		break;
-	case FEC_5_6:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_5_6;
-		break;
-	case FEC_7_8:
-		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_7_8;
-		break;
-	}
-
-	/* SAW filter selection: normaly not necesarry, but if wanted
-		the application can select a SAW filter via the driver by using UIOs */
-	/* First determine real bandwidth (Hz) */
-	/* Also set delay for impulse noise cruncher */
-	/* Also set parameters for EC_OC fix, note EC_OC_REG_TMD_HIL_MAR is changed
-		by SC for fix for some 8K,1/8 guard but is restored by InitEC and ResetEC
-		functions */
-	switch (state->props.bandwidth_hz) {
-	case 0:
-		state->props.bandwidth_hz = 8000000;
-		/* fall though */
-	case 8000000:
-		bandwidth = DRXK_BANDWIDTH_8MHZ_IN_HZ;
-		status = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 3052);
-		if (status < 0)
-			goto error;
-		/* cochannel protection for PAL 8 MHz */
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 7);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 7);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 7);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);
-		if (status < 0)
-			goto error;
-		break;
-	case 7000000:
-		bandwidth = DRXK_BANDWIDTH_7MHZ_IN_HZ;
-		status = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 3491);
-		if (status < 0)
-			goto error;
-		/* cochannel protection for PAL 7 MHz */
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 8);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 8);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 4);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);
-		if (status < 0)
-			goto error;
-		break;
-	case 6000000:
-		bandwidth = DRXK_BANDWIDTH_6MHZ_IN_HZ;
-		status = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 4073);
-		if (status < 0)
-			goto error;
-		/* cochannel protection for NTSC 6 MHz */
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 19);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 19);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 14);
-		if (status < 0)
-			goto error;
-		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);
-		if (status < 0)
-			goto error;
-		break;
-	default:
-		status = -EINVAL;
-		goto error;
-	}
-
-	if (iqmRcRateOfs == 0) {
-		/* Now compute IQM_RC_RATE_OFS
-			(((SysFreq/BandWidth)/2)/2) -1) * 2^23)
-			=>
-			((SysFreq / BandWidth) * (2^21)) - (2^23)
-			*/
-		/* (SysFreq / BandWidth) * (2^28)  */
-		/* assert (MAX(sysClk)/MIN(bandwidth) < 16)
-			=> assert(MAX(sysClk) < 16*MIN(bandwidth))
-			=> assert(109714272 > 48000000) = true so Frac 28 can be used  */
-		iqmRcRateOfs = Frac28a((u32)
-					((state->m_sysClockFreq *
-						1000) / 3), bandwidth);
-		/* (SysFreq / BandWidth) * (2^21), rounding before truncating  */
-		if ((iqmRcRateOfs & 0x7fL) >= 0x40)
-			iqmRcRateOfs += 0x80L;
-		iqmRcRateOfs = iqmRcRateOfs >> 7;
-		/* ((SysFreq / BandWidth) * (2^21)) - (2^23)  */
-		iqmRcRateOfs = iqmRcRateOfs - (1 << 23);
-	}
-
-	iqmRcRateOfs &=
-		((((u32) IQM_RC_RATE_OFS_HI__M) <<
-		IQM_RC_RATE_OFS_LO__W) | IQM_RC_RATE_OFS_LO__M);
-	status = write32(state, IQM_RC_RATE_OFS_LO__A, iqmRcRateOfs);
-	if (status < 0)
-		goto error;
-
-	/* Bandwidth setting done */
-
-#if 0
-	status = DVBTSetFrequencyShift(demod, channel, tunerOffset);
-	if (status < 0)
-		goto error;
-#endif
-	status = SetFrequencyShifter(state, IntermediateFreqkHz, tunerFreqOffset, true);
-	if (status < 0)
-		goto error;
-
-	/*== Start SC, write channel settings to SC ===============================*/
-
-	/* Activate SCU to enable SCU commands */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-
-	/* Enable SC after setting all other parameters */
-	status = write16(state, OFDM_SC_COMM_STATE__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, OFDM_SC_COMM_EXEC__A, 1);
-	if (status < 0)
-		goto error;
-
-
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_START, 0, NULL, 1, &cmdResult);
-	if (status < 0)
-		goto error;
-
-	/* Write SC parameter registers, set all AUTO flags in operation mode */
-	param1 = (OFDM_SC_RA_RAM_OP_AUTO_MODE__M |
-			OFDM_SC_RA_RAM_OP_AUTO_GUARD__M |
-			OFDM_SC_RA_RAM_OP_AUTO_CONST__M |
-			OFDM_SC_RA_RAM_OP_AUTO_HIER__M |
-			OFDM_SC_RA_RAM_OP_AUTO_RATE__M);
-	status = DVBTScCommand(state, OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM,
-				0, transmissionParams, param1, 0, 0, 0);
-	if (status < 0)
-		goto error;
-
-	if (!state->m_DRXK_A3_ROM_CODE)
-		status = DVBTCtrlSetSqiSpeed(state, &state->m_sqiSpeed);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-
-/*============================================================================*/
-
-/**
-* \brief Retreive lock status .
-* \param demod    Pointer to demodulator instance.
-* \param lockStat Pointer to lock status structure.
-* \return DRXStatus_t.
-*
-*/
-static int GetDVBTLockStatus(struct drxk_state *state, u32 *pLockStatus)
-{
-	int status;
-	const u16 mpeg_lock_mask = (OFDM_SC_RA_RAM_LOCK_MPEG__M |
-				    OFDM_SC_RA_RAM_LOCK_FEC__M);
-	const u16 fec_lock_mask = (OFDM_SC_RA_RAM_LOCK_FEC__M);
-	const u16 demod_lock_mask = OFDM_SC_RA_RAM_LOCK_DEMOD__M;
-
-	u16 ScRaRamLock = 0;
-	u16 ScCommExec = 0;
-
-	dprintk(1, "\n");
-
-	*pLockStatus = NOT_LOCKED;
-	/* driver 0.9.0 */
-	/* Check if SC is running */
-	status = read16(state, OFDM_SC_COMM_EXEC__A, &ScCommExec);
-	if (status < 0)
-		goto end;
-	if (ScCommExec == OFDM_SC_COMM_EXEC_STOP)
-		goto end;
-
-	status = read16(state, OFDM_SC_RA_RAM_LOCK__A, &ScRaRamLock);
-	if (status < 0)
-		goto end;
-
-	if ((ScRaRamLock & mpeg_lock_mask) == mpeg_lock_mask)
-		*pLockStatus = MPEG_LOCK;
-	else if ((ScRaRamLock & fec_lock_mask) == fec_lock_mask)
-		*pLockStatus = FEC_LOCK;
-	else if ((ScRaRamLock & demod_lock_mask) == demod_lock_mask)
-		*pLockStatus = DEMOD_LOCK;
-	else if (ScRaRamLock & OFDM_SC_RA_RAM_LOCK_NODVBT__M)
-		*pLockStatus = NEVER_LOCK;
-end:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int PowerUpQAM(struct drxk_state *state)
-{
-	enum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;
-	int status;
-
-	dprintk(1, "\n");
-	status = CtrlPowerMode(state, &powerMode);
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-
-/** Power Down QAM */
-static int PowerDownQAM(struct drxk_state *state)
-{
-	u16 data = 0;
-	u16 cmdResult;
-	int status = 0;
-
-	dprintk(1, "\n");
-	status = read16(state, SCU_COMM_EXEC__A, &data);
-	if (status < 0)
-		goto error;
-	if (data == SCU_COMM_EXEC_ACTIVE) {
-		/*
-			STOP demodulator
-			QAM and HW blocks
-			*/
-		/* stop all comstate->m_exec */
-		status = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);
-		if (status < 0)
-			goto error;
-		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);
-		if (status < 0)
-			goto error;
-	}
-	/* powerdown AFE                   */
-	status = SetIqmAf(state, false);
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief Setup of the QAM Measurement intervals for signal quality
-* \param demod instance of demod.
-* \param modulation current modulation.
-* \return DRXStatus_t.
-*
-*  NOTE:
-*  Take into account that for certain settings the errorcounters can overflow.
-*  The implementation does not check this.
-*
-*/
-static int SetQAMMeasurement(struct drxk_state *state,
-			     enum EDrxkConstellation modulation,
-			     u32 symbolRate)
-{
-	u32 fecBitsDesired = 0;	/* BER accounting period */
-	u32 fecRsPeriodTotal = 0;	/* Total period */
-	u16 fecRsPrescale = 0;	/* ReedSolomon Measurement Prescale */
-	u16 fecRsPeriod = 0;	/* Value for corresponding I2C register */
-	int status = 0;
-
-	dprintk(1, "\n");
-
-	fecRsPrescale = 1;
-	/* fecBitsDesired = symbolRate [kHz] *
-		FrameLenght [ms] *
-		(modulation + 1) *
-		SyncLoss (== 1) *
-		ViterbiLoss (==1)
-		*/
-	switch (modulation) {
-	case DRX_CONSTELLATION_QAM16:
-		fecBitsDesired = 4 * symbolRate;
-		break;
-	case DRX_CONSTELLATION_QAM32:
-		fecBitsDesired = 5 * symbolRate;
-		break;
-	case DRX_CONSTELLATION_QAM64:
-		fecBitsDesired = 6 * symbolRate;
-		break;
-	case DRX_CONSTELLATION_QAM128:
-		fecBitsDesired = 7 * symbolRate;
-		break;
-	case DRX_CONSTELLATION_QAM256:
-		fecBitsDesired = 8 * symbolRate;
-		break;
-	default:
-		status = -EINVAL;
-	}
-	if (status < 0)
-		goto error;
-
-	fecBitsDesired /= 1000;	/* symbolRate [Hz] -> symbolRate [kHz]  */
-	fecBitsDesired *= 500;	/* meas. period [ms] */
-
-	/* Annex A/C: bits/RsPeriod = 204 * 8 = 1632 */
-	/* fecRsPeriodTotal = fecBitsDesired / 1632 */
-	fecRsPeriodTotal = (fecBitsDesired / 1632UL) + 1;	/* roughly ceil */
-
-	/* fecRsPeriodTotal =  fecRsPrescale * fecRsPeriod  */
-	fecRsPrescale = 1 + (u16) (fecRsPeriodTotal >> 16);
-	if (fecRsPrescale == 0) {
-		/* Divide by zero (though impossible) */
-		status = -EINVAL;
-		if (status < 0)
-			goto error;
-	}
-	fecRsPeriod =
-		((u16) fecRsPeriodTotal +
-		(fecRsPrescale >> 1)) / fecRsPrescale;
-
-	/* write corresponding registers */
-	status = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, fecRsPeriod);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, fecRsPrescale);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_OC_SNC_FAIL_PERIOD__A, fecRsPeriod);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SetQAM16(struct drxk_state *state)
-{
-	int status = 0;
-
-	dprintk(1, "\n");
-	/* QAM Equalizer Setup */
-	/* Equalizer */
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13517);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 13517);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 13517);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13517);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13517);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 13517);
-	if (status < 0)
-		goto error;
-	/* Decision Feedback Equalizer */
-	status = write16(state, QAM_DQ_QUAL_FUN0__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN1__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN2__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN3__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN4__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, QAM_SY_SYNC_HWM__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_AWM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
-	if (status < 0)
-		goto error;
-
-	/* QAM Slicer Settings */
-	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM16);
-	if (status < 0)
-		goto error;
-
-	/* QAM Loop Controller Coeficients */
-	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 32);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM State Machine (FSM) Thresholds */
-
-	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 140);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 95);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 120);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 230);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 105);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 24);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM FSM Tracking Parameters */
-
-	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 220);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 25);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -65);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -127);
-	if (status < 0)
-		goto error;
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief QAM32 specific setup
-* \param demod instance of demod.
-* \return DRXStatus_t.
-*/
-static int SetQAM32(struct drxk_state *state)
-{
-	int status = 0;
-
-	dprintk(1, "\n");
-
-	/* QAM Equalizer Setup */
-	/* Equalizer */
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6707);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6707);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6707);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6707);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6707);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 6707);
-	if (status < 0)
-		goto error;
-
-	/* Decision Feedback Equalizer */
-	status = write16(state, QAM_DQ_QUAL_FUN0__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN1__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN2__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN3__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN4__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, QAM_SY_SYNC_HWM__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_AWM__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
-	if (status < 0)
-		goto error;
-
-	/* QAM Slicer Settings */
-
-	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM32);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM Loop Controller Coeficients */
-
-	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM State Machine (FSM) Thresholds */
-
-	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 90);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 170);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 10);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM FSM Tracking Parameters */
-
-	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 140);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) -8);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) -16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -26);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -56);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -86);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief QAM64 specific setup
-* \param demod instance of demod.
-* \return DRXStatus_t.
-*/
-static int SetQAM64(struct drxk_state *state)
-{
-	int status = 0;
-
-	dprintk(1, "\n");
-	/* QAM Equalizer Setup */
-	/* Equalizer */
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13336);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12618);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 11988);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13809);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13809);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15609);
-	if (status < 0)
-		goto error;
-
-	/* Decision Feedback Equalizer */
-	status = write16(state, QAM_DQ_QUAL_FUN0__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN1__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN2__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN3__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN4__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, QAM_SY_SYNC_HWM__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_AWM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
-	if (status < 0)
-		goto error;
-
-	/* QAM Slicer Settings */
-	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM64);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM Loop Controller Coeficients */
-
-	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 30);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 100);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 30);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM State Machine (FSM) Thresholds */
-
-	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 100);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 110);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 200);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 95);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 15);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM FSM Tracking Parameters */
-
-	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 141);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 7);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -15);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -45);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -80);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief QAM128 specific setup
-* \param demod: instance of demod.
-* \return DRXStatus_t.
-*/
-static int SetQAM128(struct drxk_state *state)
-{
-	int status = 0;
-
-	dprintk(1, "\n");
-	/* QAM Equalizer Setup */
-	/* Equalizer */
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6564);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6598);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6394);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6409);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6656);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 7238);
-	if (status < 0)
-		goto error;
-
-	/* Decision Feedback Equalizer */
-	status = write16(state, QAM_DQ_QUAL_FUN0__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN1__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN2__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN3__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN4__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, QAM_SY_SYNC_HWM__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_AWM__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM Slicer Settings */
-
-	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM128);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM Loop Controller Coeficients */
-
-	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 120);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 60);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 64);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM State Machine (FSM) Thresholds */
-
-	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 140);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 5);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);
-	if (status < 0)
-		goto error;
-
-	/* QAM FSM Tracking Parameters */
-
-	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 65);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -1);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -23);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief QAM256 specific setup
-* \param demod: instance of demod.
-* \return DRXStatus_t.
-*/
-static int SetQAM256(struct drxk_state *state)
-{
-	int status = 0;
-
-	dprintk(1, "\n");
-	/* QAM Equalizer Setup */
-	/* Equalizer */
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 11502);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12084);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 12543);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 12931);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13629);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15385);
-	if (status < 0)
-		goto error;
-
-	/* Decision Feedback Equalizer */
-	status = write16(state, QAM_DQ_QUAL_FUN0__A, 8);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN1__A, 8);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN2__A, 8);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN3__A, 8);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN4__A, 6);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, QAM_SY_SYNC_HWM__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_AWM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
-	if (status < 0)
-		goto error;
-
-	/* QAM Slicer Settings */
-
-	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM256);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM Loop Controller Coeficients */
-
-	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 250);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 125);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM State Machine (FSM) Thresholds */
-
-	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 150);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 110);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);
-	if (status < 0)
-		goto error;
-
-
-	/* QAM FSM Tracking Parameters */
-
-	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 74);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 18);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 13);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) 7);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -8);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-
-/*============================================================================*/
-/**
-* \brief Reset QAM block.
-* \param demod:   instance of demod.
-* \param channel: pointer to channel data.
-* \return DRXStatus_t.
-*/
-static int QAMResetQAM(struct drxk_state *state)
-{
-	int status;
-	u16 cmdResult;
-
-	dprintk(1, "\n");
-	/* Stop QAM comstate->m_exec */
-	status = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief Set QAM symbolrate.
-* \param demod:   instance of demod.
-* \param channel: pointer to channel data.
-* \return DRXStatus_t.
-*/
-static int QAMSetSymbolrate(struct drxk_state *state)
-{
-	u32 adcFrequency = 0;
-	u32 symbFreq = 0;
-	u32 iqmRcRate = 0;
-	u16 ratesel = 0;
-	u32 lcSymbRate = 0;
-	int status;
-
-	dprintk(1, "\n");
-	/* Select & calculate correct IQM rate */
-	adcFrequency = (state->m_sysClockFreq * 1000) / 3;
-	ratesel = 0;
-	/* printk(KERN_DEBUG "drxk: SR %d\n", state->props.symbol_rate); */
-	if (state->props.symbol_rate <= 1188750)
-		ratesel = 3;
-	else if (state->props.symbol_rate <= 2377500)
-		ratesel = 2;
-	else if (state->props.symbol_rate <= 4755000)
-		ratesel = 1;
-	status = write16(state, IQM_FD_RATESEL__A, ratesel);
-	if (status < 0)
-		goto error;
-
-	/*
-		IqmRcRate = ((Fadc / (symbolrate * (4<<ratesel))) - 1) * (1<<23)
-		*/
-	symbFreq = state->props.symbol_rate * (1 << ratesel);
-	if (symbFreq == 0) {
-		/* Divide by zero */
-		status = -EINVAL;
-		goto error;
-	}
-	iqmRcRate = (adcFrequency / symbFreq) * (1 << 21) +
-		(Frac28a((adcFrequency % symbFreq), symbFreq) >> 7) -
-		(1 << 23);
-	status = write32(state, IQM_RC_RATE_OFS_LO__A, iqmRcRate);
-	if (status < 0)
-		goto error;
-	state->m_iqmRcRate = iqmRcRate;
-	/*
-		LcSymbFreq = round (.125 *  symbolrate / adcFreq * (1<<15))
-		*/
-	symbFreq = state->props.symbol_rate;
-	if (adcFrequency == 0) {
-		/* Divide by zero */
-		status = -EINVAL;
-		goto error;
-	}
-	lcSymbRate = (symbFreq / adcFrequency) * (1 << 12) +
-		(Frac28a((symbFreq % adcFrequency), adcFrequency) >>
-		16);
-	if (lcSymbRate > 511)
-		lcSymbRate = 511;
-	status = write16(state, QAM_LC_SYMBOL_FREQ__A, (u16) lcSymbRate);
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-/*============================================================================*/
-
-/**
-* \brief Get QAM lock status.
-* \param demod:   instance of demod.
-* \param channel: pointer to channel data.
-* \return DRXStatus_t.
-*/
-
-static int GetQAMLockStatus(struct drxk_state *state, u32 *pLockStatus)
-{
-	int status;
-	u16 Result[2] = { 0, 0 };
-
-	dprintk(1, "\n");
-	*pLockStatus = NOT_LOCKED;
-	status = scu_command(state,
-			SCU_RAM_COMMAND_STANDARD_QAM |
-			SCU_RAM_COMMAND_CMD_DEMOD_GET_LOCK, 0, NULL, 2,
-			Result);
-	if (status < 0)
-		printk(KERN_ERR "drxk: %s status = %08x\n", __func__, status);
-
-	if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_DEMOD_LOCKED) {
-		/* 0x0000 NOT LOCKED */
-	} else if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_LOCKED) {
-		/* 0x4000 DEMOD LOCKED */
-		*pLockStatus = DEMOD_LOCK;
-	} else if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_NEVER_LOCK) {
-		/* 0x8000 DEMOD + FEC LOCKED (system lock) */
-		*pLockStatus = MPEG_LOCK;
-	} else {
-		/* 0xC000 NEVER LOCKED */
-		/* (system will never be able to lock to the signal) */
-		/* TODO: check this, intermediate & standard specific lock states are not
-		   taken into account here */
-		*pLockStatus = NEVER_LOCK;
-	}
-	return status;
-}
-
-#define QAM_MIRROR__M         0x03
-#define QAM_MIRROR_NORMAL     0x00
-#define QAM_MIRRORED          0x01
-#define QAM_MIRROR_AUTO_ON    0x02
-#define QAM_LOCKRANGE__M      0x10
-#define QAM_LOCKRANGE_NORMAL  0x10
-
-static int SetQAM(struct drxk_state *state, u16 IntermediateFreqkHz,
-		  s32 tunerFreqOffset)
-{
-	int status;
-	u16 setParamParameters[4] = { 0, 0, 0, 0 };
-	u16 cmdResult;
-
-	dprintk(1, "\n");
-	/*
-	 * STEP 1: reset demodulator
-	 *	resets FEC DI and FEC RS
-	 *	resets QAM block
-	 *	resets SCU variables
-	 */
-	status = write16(state, FEC_DI_COMM_EXEC__A, FEC_DI_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_RS_COMM_EXEC__A, FEC_RS_COMM_EXEC_STOP);
-	if (status < 0)
-		goto error;
-	status = QAMResetQAM(state);
-	if (status < 0)
-		goto error;
-
-	/*
-	 * STEP 2: configure demodulator
-	 *	-set params; resets IQM,QAM,FEC HW; initializes some
-	 *       SCU variables
-	 */
-	status = QAMSetSymbolrate(state);
-	if (status < 0)
-		goto error;
-
-	/* Set params */
-	switch (state->props.modulation) {
-	case QAM_256:
-		state->m_Constellation = DRX_CONSTELLATION_QAM256;
-		break;
-	case QAM_AUTO:
-	case QAM_64:
-		state->m_Constellation = DRX_CONSTELLATION_QAM64;
-		break;
-	case QAM_16:
-		state->m_Constellation = DRX_CONSTELLATION_QAM16;
-		break;
-	case QAM_32:
-		state->m_Constellation = DRX_CONSTELLATION_QAM32;
-		break;
-	case QAM_128:
-		state->m_Constellation = DRX_CONSTELLATION_QAM128;
-		break;
-	default:
-		status = -EINVAL;
-		break;
-	}
-	if (status < 0)
-		goto error;
-	setParamParameters[0] = state->m_Constellation;	/* modulation     */
-	setParamParameters[1] = DRXK_QAM_I12_J17;	/* interleave mode   */
-	if (state->m_OperationMode == OM_QAM_ITU_C)
-		setParamParameters[2] = QAM_TOP_ANNEX_C;
-	else
-		setParamParameters[2] = QAM_TOP_ANNEX_A;
-	setParamParameters[3] |= (QAM_MIRROR_AUTO_ON);
-	/* Env parameters */
-	/* check for LOCKRANGE Extented */
-	/* setParamParameters[3] |= QAM_LOCKRANGE_NORMAL; */
-
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM, 4, setParamParameters, 1, &cmdResult);
-	if (status < 0) {
-		/* Fall-back to the simpler call */
-		if (state->m_OperationMode == OM_QAM_ITU_C)
-			setParamParameters[0] = QAM_TOP_ANNEX_C;
-		else
-			setParamParameters[0] = QAM_TOP_ANNEX_A;
-		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV, 1, setParamParameters, 1, &cmdResult);
-		if (status < 0)
-			goto error;
-
-		setParamParameters[0] = state->m_Constellation; /* modulation     */
-		setParamParameters[1] = DRXK_QAM_I12_J17;       /* interleave mode   */
-		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM, 2, setParamParameters, 1, &cmdResult);
-	}
-	if (status < 0)
-		goto error;
-
-	/*
-	 * STEP 3: enable the system in a mode where the ADC provides valid
-	 * signal setup modulation independent registers
-	 */
-#if 0
-	status = SetFrequency(channel, tunerFreqOffset));
-	if (status < 0)
-		goto error;
-#endif
-	status = SetFrequencyShifter(state, IntermediateFreqkHz, tunerFreqOffset, true);
-	if (status < 0)
-		goto error;
-
-	/* Setup BER measurement */
-	status = SetQAMMeasurement(state, state->m_Constellation, state->props.symbol_rate);
-	if (status < 0)
-		goto error;
-
-	/* Reset default values */
-	status = write16(state, IQM_CF_SCALE_SH__A, IQM_CF_SCALE_SH__PRE);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_SY_TIMEOUT__A, QAM_SY_TIMEOUT__PRE);
-	if (status < 0)
-		goto error;
-
-	/* Reset default LC values */
-	status = write16(state, QAM_LC_RATE_LIMIT__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_LPF_FACTORP__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_LPF_FACTORI__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_MODE__A, 7);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, QAM_LC_QUAL_TAB0__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB1__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB2__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB3__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB4__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB5__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB6__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB8__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB9__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB10__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB12__A, 2);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB15__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB16__A, 3);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB20__A, 4);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_LC_QUAL_TAB25__A, 4);
-	if (status < 0)
-		goto error;
-
-	/* Mirroring, QAM-block starting point not inverted */
-	status = write16(state, QAM_SY_SP_INV__A, QAM_SY_SP_INV_SPECTRUM_INV_DIS);
-	if (status < 0)
-		goto error;
-
-	/* Halt SCU to enable safe non-atomic accesses */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
-	if (status < 0)
-		goto error;
-
-	/* STEP 4: modulation specific setup */
-	switch (state->props.modulation) {
-	case QAM_16:
-		status = SetQAM16(state);
-		break;
-	case QAM_32:
-		status = SetQAM32(state);
-		break;
-	case QAM_AUTO:
-	case QAM_64:
-		status = SetQAM64(state);
-		break;
-	case QAM_128:
-		status = SetQAM128(state);
-		break;
-	case QAM_256:
-		status = SetQAM256(state);
-		break;
-	default:
-		status = -EINVAL;
-		break;
-	}
-	if (status < 0)
-		goto error;
-
-	/* Activate SCU to enable SCU commands */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-
-	/* Re-configure MPEG output, requires knowledge of channel bitrate */
-	/* extAttr->currentChannel.modulation = channel->modulation; */
-	/* extAttr->currentChannel.symbolrate    = channel->symbolrate; */
-	status = MPEGTSDtoSetup(state, state->m_OperationMode);
-	if (status < 0)
-		goto error;
-
-	/* Start processes */
-	status = MPEGTSStart(state);
-	if (status < 0)
-		goto error;
-	status = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-	status = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_ACTIVE);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);
-	if (status < 0)
-		goto error;
-
-	/* STEP 5: start QAM demodulator (starts FEC, QAM and IQM HW) */
-	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_START, 0, NULL, 1, &cmdResult);
-	if (status < 0)
-		goto error;
-
-	/* update global DRXK data container */
-/*?     extAttr->qamInterleaveMode = DRXK_QAM_I12_J17; */
-
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SetQAMStandard(struct drxk_state *state,
-			  enum OperationMode oMode)
-{
-	int status;
-#ifdef DRXK_QAM_TAPS
-#define DRXK_QAMA_TAPS_SELECT
-#include "drxk_filters.h"
-#undef DRXK_QAMA_TAPS_SELECT
-#endif
-
-	dprintk(1, "\n");
-
-	/* added antenna switch */
-	SwitchAntennaToQAM(state);
-
-	/* Ensure correct power-up mode */
-	status = PowerUpQAM(state);
-	if (status < 0)
-		goto error;
-	/* Reset QAM block */
-	status = QAMResetQAM(state);
-	if (status < 0)
-		goto error;
-
-	/* Setup IQM */
-
-	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);
-	if (status < 0)
-		goto error;
-
-	/* Upload IQM Channel Filter settings by
-		boot loader from ROM table */
-	switch (oMode) {
-	case OM_QAM_ITU_A:
-		status = BLChainCmd(state, DRXK_BL_ROM_OFFSET_TAPS_ITU_A, DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
-		break;
-	case OM_QAM_ITU_C:
-		status = BLDirectCmd(state, IQM_CF_TAP_RE0__A, DRXK_BL_ROM_OFFSET_TAPS_ITU_C, DRXK_BLDC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
-		if (status < 0)
-			goto error;
-		status = BLDirectCmd(state, IQM_CF_TAP_IM0__A, DRXK_BL_ROM_OFFSET_TAPS_ITU_C, DRXK_BLDC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
-		break;
-	default:
-		status = -EINVAL;
-	}
-	if (status < 0)
-		goto error;
-
-	status = write16(state, IQM_CF_OUT_ENA__A, (1 << IQM_CF_OUT_ENA_QAM__B));
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_SYMMETRIC__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_MIDTAP__A, ((1 << IQM_CF_MIDTAP_RE__B) | (1 << IQM_CF_MIDTAP_IM__B)));
-	if (status < 0)
-		goto error;
-
-	status = write16(state, IQM_RC_STRETCH__A, 21);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_CLP_LEN__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_CLP_TH__A, 448);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_SNS_LEN__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_POW_MEAS_LEN__A, 0);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, IQM_FS_ADJ_SEL__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_RC_ADJ_SEL__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_ADJ_SEL__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_UPD_SEL__A, 0);
-	if (status < 0)
-		goto error;
-
-	/* IQM Impulse Noise Processing Unit */
-	status = write16(state, IQM_CF_CLP_VAL__A, 500);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_DATATH__A, 1000);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_BYPASSDET__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_DET_LCT__A, 0);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_WND_LEN__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_CF_PKDTH__A, 1);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_INC_BYPASS__A, 1);
-	if (status < 0)
-		goto error;
-
-	/* turn on IQMAF. Must be done before setAgc**() */
-	status = SetIqmAf(state, true);
-	if (status < 0)
-		goto error;
-	status = write16(state, IQM_AF_START_LOCK__A, 0x01);
-	if (status < 0)
-		goto error;
-
-	/* IQM will not be reset from here, sync ADC and update/init AGC */
-	status = ADCSynchronization(state);
-	if (status < 0)
-		goto error;
-
-	/* Set the FSM step period */
-	status = write16(state, SCU_RAM_QAM_FSM_STEP_PERIOD__A, 2000);
-	if (status < 0)
-		goto error;
-
-	/* Halt SCU to enable safe non-atomic accesses */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
-	if (status < 0)
-		goto error;
-
-	/* No more resets of the IQM, current standard correctly set =>
-		now AGCs can be configured. */
-
-	status = InitAGC(state, true);
-	if (status < 0)
-		goto error;
-	status = SetPreSaw(state, &(state->m_qamPreSawCfg));
-	if (status < 0)
-		goto error;
-
-	/* Configure AGC's */
-	status = SetAgcRf(state, &(state->m_qamRfAgcCfg), true);
-	if (status < 0)
-		goto error;
-	status = SetAgcIf(state, &(state->m_qamIfAgcCfg), true);
-	if (status < 0)
-		goto error;
-
-	/* Activate SCU to enable SCU commands */
-	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int WriteGPIO(struct drxk_state *state)
-{
-	int status;
-	u16 value = 0;
-
-	dprintk(1, "\n");
-	/* stop lock indicator process */
-	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
-	if (status < 0)
-		goto error;
-
-	/*  Write magic word to enable pdr reg write               */
-	status = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);
-	if (status < 0)
-		goto error;
-
-	if (state->m_hasSAWSW) {
-		if (state->UIO_mask & 0x0001) { /* UIO-1 */
-			/* write to io pad configuration register - output mode */
-			status = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);
-			if (status < 0)
-				goto error;
-
-			/* use corresponding bit in io data output registar */
-			status = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);
-			if (status < 0)
-				goto error;
-			if ((state->m_GPIO & 0x0001) == 0)
-				value &= 0x7FFF;	/* write zero to 15th bit - 1st UIO */
-			else
-				value |= 0x8000;	/* write one to 15th bit - 1st UIO */
-			/* write back to io data output register */
-			status = write16(state, SIO_PDR_UIO_OUT_LO__A, value);
-			if (status < 0)
-				goto error;
-		}
-		if (state->UIO_mask & 0x0002) { /* UIO-2 */
-			/* write to io pad configuration register - output mode */
-			status = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);
-			if (status < 0)
-				goto error;
-
-			/* use corresponding bit in io data output registar */
-			status = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);
-			if (status < 0)
-				goto error;
-			if ((state->m_GPIO & 0x0002) == 0)
-				value &= 0xBFFF;	/* write zero to 14th bit - 2st UIO */
-			else
-				value |= 0x4000;	/* write one to 14th bit - 2st UIO */
-			/* write back to io data output register */
-			status = write16(state, SIO_PDR_UIO_OUT_LO__A, value);
-			if (status < 0)
-				goto error;
-		}
-		if (state->UIO_mask & 0x0004) { /* UIO-3 */
-			/* write to io pad configuration register - output mode */
-			status = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);
-			if (status < 0)
-				goto error;
-
-			/* use corresponding bit in io data output registar */
-			status = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);
-			if (status < 0)
-				goto error;
-			if ((state->m_GPIO & 0x0004) == 0)
-				value &= 0xFFFB;            /* write zero to 2nd bit - 3rd UIO */
-			else
-				value |= 0x0004;            /* write one to 2nd bit - 3rd UIO */
-			/* write back to io data output register */
-			status = write16(state, SIO_PDR_UIO_OUT_LO__A, value);
-			if (status < 0)
-				goto error;
-		}
-	}
-	/*  Write magic word to disable pdr reg write               */
-	status = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SwitchAntennaToQAM(struct drxk_state *state)
-{
-	int status = 0;
-	bool gpio_state;
-
-	dprintk(1, "\n");
-
-	if (!state->antenna_gpio)
-		return 0;
-
-	gpio_state = state->m_GPIO & state->antenna_gpio;
-
-	if (state->antenna_dvbt ^ gpio_state) {
-		/* Antenna is on DVB-T mode. Switch */
-		if (state->antenna_dvbt)
-			state->m_GPIO &= ~state->antenna_gpio;
-		else
-			state->m_GPIO |= state->antenna_gpio;
-		status = WriteGPIO(state);
-	}
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-static int SwitchAntennaToDVBT(struct drxk_state *state)
-{
-	int status = 0;
-	bool gpio_state;
-
-	dprintk(1, "\n");
-
-	if (!state->antenna_gpio)
-		return 0;
-
-	gpio_state = state->m_GPIO & state->antenna_gpio;
-
-	if (!(state->antenna_dvbt ^ gpio_state)) {
-		/* Antenna is on DVB-C mode. Switch */
-		if (state->antenna_dvbt)
-			state->m_GPIO |= state->antenna_gpio;
-		else
-			state->m_GPIO &= ~state->antenna_gpio;
-		status = WriteGPIO(state);
-	}
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-	return status;
-}
-
-
-static int PowerDownDevice(struct drxk_state *state)
-{
-	/* Power down to requested mode */
-	/* Backup some register settings */
-	/* Set pins with possible pull-ups connected to them in input mode */
-	/* Analog power down */
-	/* ADC power down */
-	/* Power down device */
-	int status;
-
-	dprintk(1, "\n");
-	if (state->m_bPDownOpenBridge) {
-		/* Open I2C bridge before power down of DRXK */
-		status = ConfigureI2CBridge(state, true);
-		if (status < 0)
-			goto error;
-	}
-	/* driver 0.9.0 */
-	status = DVBTEnableOFDMTokenRing(state, false);
-	if (status < 0)
-		goto error;
-
-	status = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_CLOCK);
-	if (status < 0)
-		goto error;
-	status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
-	if (status < 0)
-		goto error;
-	state->m_HICfgCtrl |= SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;
-	status = HI_CfgCommand(state);
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static int load_microcode(struct drxk_state *state, const char *mc_name)
-{
-	const struct firmware *fw = NULL;
-	int err = 0;
-
-	dprintk(1, "\n");
-
-	err = request_firmware(&fw, mc_name, state->i2c->dev.parent);
-	if (err < 0) {
-		printk(KERN_ERR
-		       "drxk: Could not load firmware file %s.\n", mc_name);
-		printk(KERN_INFO
-		       "drxk: Copy %s to your hotplug directory!\n", mc_name);
-		return err;
-	}
-	err = DownloadMicrocode(state, fw->data, fw->size);
-	release_firmware(fw);
-	return err;
-}
-
-static int init_drxk(struct drxk_state *state)
-{
-	int status = 0;
-	enum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;
-	u16 driverVersion;
-
-	dprintk(1, "\n");
-	if ((state->m_DrxkState == DRXK_UNINITIALIZED)) {
-		status = PowerUpDevice(state);
-		if (status < 0)
-			goto error;
-		status = DRXX_Open(state);
-		if (status < 0)
-			goto error;
-		/* Soft reset of OFDM-, sys- and osc-clockdomain */
-		status = write16(state, SIO_CC_SOFT_RST__A, SIO_CC_SOFT_RST_OFDM__M | SIO_CC_SOFT_RST_SYS__M | SIO_CC_SOFT_RST_OSC__M);
-		if (status < 0)
-			goto error;
-		status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
-		if (status < 0)
-			goto error;
-		/* TODO is this needed, if yes how much delay in worst case scenario */
-		msleep(1);
-		state->m_DRXK_A3_PATCH_CODE = true;
-		status = GetDeviceCapabilities(state);
-		if (status < 0)
-			goto error;
-
-		/* Bridge delay, uses oscilator clock */
-		/* Delay = (delay (nano seconds) * oscclk (kHz))/ 1000 */
-		/* SDA brdige delay */
-		state->m_HICfgBridgeDelay =
-			(u16) ((state->m_oscClockFreq / 1000) *
-				HI_I2C_BRIDGE_DELAY) / 1000;
-		/* Clipping */
-		if (state->m_HICfgBridgeDelay >
-			SIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M) {
-			state->m_HICfgBridgeDelay =
-				SIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M;
-		}
-		/* SCL bridge delay, same as SDA for now */
-		state->m_HICfgBridgeDelay +=
-			state->m_HICfgBridgeDelay <<
-			SIO_HI_RA_RAM_PAR_3_CFG_DBL_SCL__B;
-
-		status = InitHI(state);
-		if (status < 0)
-			goto error;
-		/* disable various processes */
-#if NOA1ROM
-		if (!(state->m_DRXK_A1_ROM_CODE)
-			&& !(state->m_DRXK_A2_ROM_CODE))
-#endif
-		{
-			status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
-			if (status < 0)
-				goto error;
-		}
-
-		/* disable MPEG port */
-		status = MPEGTSDisable(state);
-		if (status < 0)
-			goto error;
-
-		/* Stop AUD and SCU */
-		status = write16(state, AUD_COMM_EXEC__A, AUD_COMM_EXEC_STOP);
-		if (status < 0)
-			goto error;
-		status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_STOP);
-		if (status < 0)
-			goto error;
-
-		/* enable token-ring bus through OFDM block for possible ucode upload */
-		status = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, SIO_OFDM_SH_OFDM_RING_ENABLE_ON);
-		if (status < 0)
-			goto error;
-
-		/* include boot loader section */
-		status = write16(state, SIO_BL_COMM_EXEC__A, SIO_BL_COMM_EXEC_ACTIVE);
-		if (status < 0)
-			goto error;
-		status = BLChainCmd(state, 0, 6, 100);
-		if (status < 0)
-			goto error;
-
-		if (state->microcode_name)
-			load_microcode(state, state->microcode_name);
-
-		/* disable token-ring bus through OFDM block for possible ucode upload */
-		status = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, SIO_OFDM_SH_OFDM_RING_ENABLE_OFF);
-		if (status < 0)
-			goto error;
-
-		/* Run SCU for a little while to initialize microcode version numbers */
-		status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
-		if (status < 0)
-			goto error;
-		status = DRXX_Open(state);
-		if (status < 0)
-			goto error;
-		/* added for test */
-		msleep(30);
-
-		powerMode = DRXK_POWER_DOWN_OFDM;
-		status = CtrlPowerMode(state, &powerMode);
-		if (status < 0)
-			goto error;
-
-		/* Stamp driver version number in SCU data RAM in BCD code
-			Done to enable field application engineers to retreive drxdriver version
-			via I2C from SCU RAM.
-			Not using SCU command interface for SCU register access since no
-			microcode may be present.
-			*/
-		driverVersion =
-			(((DRXK_VERSION_MAJOR / 100) % 10) << 12) +
-			(((DRXK_VERSION_MAJOR / 10) % 10) << 8) +
-			((DRXK_VERSION_MAJOR % 10) << 4) +
-			(DRXK_VERSION_MINOR % 10);
-		status = write16(state, SCU_RAM_DRIVER_VER_HI__A, driverVersion);
-		if (status < 0)
-			goto error;
-		driverVersion =
-			(((DRXK_VERSION_PATCH / 1000) % 10) << 12) +
-			(((DRXK_VERSION_PATCH / 100) % 10) << 8) +
-			(((DRXK_VERSION_PATCH / 10) % 10) << 4) +
-			(DRXK_VERSION_PATCH % 10);
-		status = write16(state, SCU_RAM_DRIVER_VER_LO__A, driverVersion);
-		if (status < 0)
-			goto error;
-
-		printk(KERN_INFO "DRXK driver version %d.%d.%d\n",
-			DRXK_VERSION_MAJOR, DRXK_VERSION_MINOR,
-			DRXK_VERSION_PATCH);
-
-		/* Dirty fix of default values for ROM/PATCH microcode
-			Dirty because this fix makes it impossible to setup suitable values
-			before calling DRX_Open. This solution requires changes to RF AGC speed
-			to be done via the CTRL function after calling DRX_Open */
-
-		/* m_dvbtRfAgcCfg.speed = 3; */
-
-		/* Reset driver debug flags to 0 */
-		status = write16(state, SCU_RAM_DRIVER_DEBUG__A, 0);
-		if (status < 0)
-			goto error;
-		/* driver 0.9.0 */
-		/* Setup FEC OC:
-			NOTE: No more full FEC resets allowed afterwards!! */
-		status = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_STOP);
-		if (status < 0)
-			goto error;
-		/* MPEGTS functions are still the same */
-		status = MPEGTSDtoInit(state);
-		if (status < 0)
-			goto error;
-		status = MPEGTSStop(state);
-		if (status < 0)
-			goto error;
-		status = MPEGTSConfigurePolarity(state);
-		if (status < 0)
-			goto error;
-		status = MPEGTSConfigurePins(state, state->m_enableMPEGOutput);
-		if (status < 0)
-			goto error;
-		/* added: configure GPIO */
-		status = WriteGPIO(state);
-		if (status < 0)
-			goto error;
-
-		state->m_DrxkState = DRXK_STOPPED;
-
-		if (state->m_bPowerDown) {
-			status = PowerDownDevice(state);
-			if (status < 0)
-				goto error;
-			state->m_DrxkState = DRXK_POWERED_DOWN;
-		} else
-			state->m_DrxkState = DRXK_STOPPED;
-	}
-error:
-	if (status < 0)
-		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
-
-	return status;
-}
-
-static void drxk_release(struct dvb_frontend *fe)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-
-	dprintk(1, "\n");
-	kfree(state);
-}
-
-static int drxk_sleep(struct dvb_frontend *fe)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-
-	dprintk(1, "\n");
-	ShutDown(state);
-	return 0;
-}
-
-static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-
-	dprintk(1, "%s\n", enable ? "enable" : "disable");
-	return ConfigureI2CBridge(state, enable ? true : false);
-}
-
-static int drxk_set_parameters(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	u32 delsys  = p->delivery_system, old_delsys;
-	struct drxk_state *state = fe->demodulator_priv;
-	u32 IF;
-
-	dprintk(1, "\n");
-
-	if (!fe->ops.tuner_ops.get_if_frequency) {
-		printk(KERN_ERR
-		       "drxk: Error: get_if_frequency() not defined at tuner. Can't work without it!\n");
-		return -EINVAL;
-	}
-
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 1);
-	if (fe->ops.tuner_ops.set_params)
-		fe->ops.tuner_ops.set_params(fe);
-	if (fe->ops.i2c_gate_ctrl)
-		fe->ops.i2c_gate_ctrl(fe, 0);
-
-	old_delsys = state->props.delivery_system;
-	state->props = *p;
-
-	if (old_delsys != delsys) {
-		ShutDown(state);
-		switch (delsys) {
-		case SYS_DVBC_ANNEX_A:
-		case SYS_DVBC_ANNEX_C:
-			if (!state->m_hasDVBC)
-				return -EINVAL;
-			state->m_itut_annex_c = (delsys == SYS_DVBC_ANNEX_C) ? true : false;
-			if (state->m_itut_annex_c)
-				SetOperationMode(state, OM_QAM_ITU_C);
-			else
-				SetOperationMode(state, OM_QAM_ITU_A);
-			break;
-		case SYS_DVBT:
-			if (!state->m_hasDVBT)
-				return -EINVAL;
-			SetOperationMode(state, OM_DVBT);
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	fe->ops.tuner_ops.get_if_frequency(fe, &IF);
-	Start(state, 0, IF);
-
-	/* printk(KERN_DEBUG "drxk: %s IF=%d done\n", __func__, IF); */
-
-	return 0;
-}
-
-static int drxk_read_status(struct dvb_frontend *fe, fe_status_t *status)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-	u32 stat;
-
-	dprintk(1, "\n");
-	*status = 0;
-	GetLockStatus(state, &stat, 0);
-	if (stat == MPEG_LOCK)
-		*status |= 0x1f;
-	if (stat == FEC_LOCK)
-		*status |= 0x0f;
-	if (stat == DEMOD_LOCK)
-		*status |= 0x07;
-	return 0;
-}
-
-static int drxk_read_ber(struct dvb_frontend *fe, u32 *ber)
-{
-	dprintk(1, "\n");
-
-	*ber = 0;
-	return 0;
-}
-
-static int drxk_read_signal_strength(struct dvb_frontend *fe,
-				     u16 *strength)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-	u32 val = 0;
-
-	dprintk(1, "\n");
-	ReadIFAgc(state, &val);
-	*strength = val & 0xffff;
-	return 0;
-}
-
-static int drxk_read_snr(struct dvb_frontend *fe, u16 *snr)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-	s32 snr2;
-
-	dprintk(1, "\n");
-	GetSignalToNoise(state, &snr2);
-	*snr = snr2 & 0xffff;
-	return 0;
-}
-
-static int drxk_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
-{
-	struct drxk_state *state = fe->demodulator_priv;
-	u16 err;
-
-	dprintk(1, "\n");
-	DVBTQAMGetAccPktErr(state, &err);
-	*ucblocks = (u32) err;
-	return 0;
-}
-
-static int drxk_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings
-				    *sets)
-{
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-
-	dprintk(1, "\n");
-	switch (p->delivery_system) {
-	case SYS_DVBC_ANNEX_A:
-	case SYS_DVBC_ANNEX_C:
-	case SYS_DVBT:
-		sets->min_delay_ms = 3000;
-		sets->max_drift = 0;
-		sets->step_size = 0;
-		return 0;
-	default:
-		return -EINVAL;
-	}
-}
-
-static struct dvb_frontend_ops drxk_ops = {
-	/* .delsys will be filled dynamically */
-	.info = {
-		.name = "DRXK",
-		.frequency_min = 47000000,
-		.frequency_max = 865000000,
-		 /* For DVB-C */
-		.symbol_rate_min = 870000,
-		.symbol_rate_max = 11700000,
-		/* For DVB-T */
-		.frequency_stepsize = 166667,
-
-		.caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
-			FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO |
-			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_MUTE_TS |
-			FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER |
-			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO
-	},
-
-	.release = drxk_release,
-	.sleep = drxk_sleep,
-	.i2c_gate_ctrl = drxk_gate_ctrl,
-
-	.set_frontend = drxk_set_parameters,
-	.get_tune_settings = drxk_get_tune_settings,
-
-	.read_status = drxk_read_status,
-	.read_ber = drxk_read_ber,
-	.read_signal_strength = drxk_read_signal_strength,
-	.read_snr = drxk_read_snr,
-	.read_ucblocks = drxk_read_ucblocks,
-};
-
-struct dvb_frontend *drxk_attach(const struct drxk_config *config,
-				 struct i2c_adapter *i2c)
-{
-	int n;
-
-	struct drxk_state *state = NULL;
-	u8 adr = config->adr;
-
-	dprintk(1, "\n");
-	state = kzalloc(sizeof(struct drxk_state), GFP_KERNEL);
-	if (!state)
-		return NULL;
-
-	state->i2c = i2c;
-	state->demod_address = adr;
-	state->single_master = config->single_master;
-	state->microcode_name = config->microcode_name;
-	state->no_i2c_bridge = config->no_i2c_bridge;
-	state->antenna_gpio = config->antenna_gpio;
-	state->antenna_dvbt = config->antenna_dvbt;
-	state->m_ChunkSize = config->chunk_size;
-	state->enable_merr_cfg = config->enable_merr_cfg;
-
-	if (config->dynamic_clk) {
-		state->m_DVBTStaticCLK = 0;
-		state->m_DVBCStaticCLK = 0;
-	} else {
-		state->m_DVBTStaticCLK = 1;
-		state->m_DVBCStaticCLK = 1;
-	}
-
-
-	if (config->mpeg_out_clk_strength)
-		state->m_TSClockkStrength = config->mpeg_out_clk_strength & 0x07;
-	else
-		state->m_TSClockkStrength = 0x06;
-
-	if (config->parallel_ts)
-		state->m_enableParallel = true;
-	else
-		state->m_enableParallel = false;
-
-	/* NOTE: as more UIO bits will be used, add them to the mask */
-	state->UIO_mask = config->antenna_gpio;
-
-	/* Default gpio to DVB-C */
-	if (!state->antenna_dvbt && state->antenna_gpio)
-		state->m_GPIO |= state->antenna_gpio;
-	else
-		state->m_GPIO &= ~state->antenna_gpio;
-
-	mutex_init(&state->mutex);
-
-	memcpy(&state->frontend.ops, &drxk_ops, sizeof(drxk_ops));
-	state->frontend.demodulator_priv = state;
-
-	init_state(state);
-	if (init_drxk(state) < 0)
-		goto error;
-
-	/* Initialize the supported delivery systems */
-	n = 0;
-	if (state->m_hasDVBC) {
-		state->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_A;
-		state->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_C;
-		strlcat(state->frontend.ops.info.name, " DVB-C",
-			sizeof(state->frontend.ops.info.name));
-	}
-	if (state->m_hasDVBT) {
-		state->frontend.ops.delsys[n++] = SYS_DVBT;
-		strlcat(state->frontend.ops.info.name, " DVB-T",
-			sizeof(state->frontend.ops.info.name));
-	}
-
-	printk(KERN_INFO "drxk: frontend initialized.\n");
-	return &state->frontend;
-
-error:
-	printk(KERN_ERR "drxk: not found\n");
-	kfree(state);
-	return NULL;
-}
-EXPORT_SYMBOL(drxk_attach);
-
-MODULE_DESCRIPTION("DRX-K driver");
-MODULE_AUTHOR("Ralph Metzler");
-MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/Kconfig media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/Kconfig
--- media_build_experimental//linux/drivers/media/dvb/frontends/Kconfig	2012-02-27 10:44:16.628908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/Kconfig	2012-01-11 05:45:32.000000000 +0100
@@ -70,24 +70,6 @@
 
 	  Say Y when you want to support this tuner.
 
-config DVB_STV0367DD
-	tristate "STV 0367 (DD)"
-	depends on DVB_CORE && I2C
-	default m if DVB_FE_CUSTOMISE
-	help
-	  STV 0367 DVB-C/T demodulator (Digital Devices driver).
-
-	  Say Y when you want to support this frontend.
-
-config DVB_TDA18212DD
-	tristate "NXP TDA18212 silicon tuner (DD)"
-	depends on DVB_CORE && I2C
-	default m if DVB_FE_CUSTOMISE
-	help
-	  NXP TDA18212 silicon tuner (Digital Devices driver).
-
-	  Say Y when you want to support this tuner.
-
 comment "DVB-S (satellite) frontends"
 	depends on DVB_CORE
 
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/Makefile media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/Makefile
--- media_build_experimental//linux/drivers/media/dvb/frontends/Makefile	2012-02-27 10:44:16.628908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/Makefile	2012-01-11 05:45:32.000000000 +0100
@@ -93,8 +93,6 @@
 obj-$(CONFIG_DVB_CXD2820R) += cxd2820r.o
 obj-$(CONFIG_DVB_DRXK) += drxk.o
 obj-$(CONFIG_DVB_TDA18271C2DD) += tda18271c2dd.o
-obj-$(CONFIG_DVB_STV0367DD) += stv0367dd.o
-obj-$(CONFIG_DVB_TDA18212DD) += tda18212dd.o
 obj-$(CONFIG_DVB_IT913X_FE) += it913x-fe.o
 obj-$(CONFIG_DVB_A8293) += a8293.o
 obj-$(CONFIG_DVB_TDA10071) += tda10071.o
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/Makefile.orig media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/Makefile.orig
--- media_build_experimental//linux/drivers/media/dvb/frontends/Makefile.orig	2012-01-11 05:45:32.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-#
-# Makefile for the kernel DVB frontend device drivers.
-#
-
-ccflags-y += -Idrivers/media/dvb/dvb-core/
-ccflags-y += -Idrivers/media/common/tuners/
-
-stb0899-objs = stb0899_drv.o stb0899_algo.o
-stv0900-objs = stv0900_core.o stv0900_sw.o
-au8522-objs = au8522_dig.o au8522_decoder.o
-drxd-objs = drxd_firm.o drxd_hard.o
-cxd2820r-objs = cxd2820r_core.o cxd2820r_c.o cxd2820r_t.o cxd2820r_t2.o
-drxk-objs := drxk_hard.o
-
-obj-$(CONFIG_DVB_PLL) += dvb-pll.o
-obj-$(CONFIG_DVB_STV0299) += stv0299.o
-obj-$(CONFIG_DVB_STB0899) += stb0899.o
-obj-$(CONFIG_DVB_STB6100) += stb6100.o
-obj-$(CONFIG_DVB_SP8870) += sp8870.o
-obj-$(CONFIG_DVB_CX22700) += cx22700.o
-obj-$(CONFIG_DVB_S5H1432) += s5h1432.o
-obj-$(CONFIG_DVB_CX24110) += cx24110.o
-obj-$(CONFIG_DVB_TDA8083) += tda8083.o
-obj-$(CONFIG_DVB_L64781) += l64781.o
-obj-$(CONFIG_DVB_DIB3000MB) += dib3000mb.o
-obj-$(CONFIG_DVB_DIB3000MC) += dib3000mc.o dibx000_common.o
-obj-$(CONFIG_DVB_DIB7000M) += dib7000m.o dibx000_common.o
-obj-$(CONFIG_DVB_DIB7000P) += dib7000p.o dibx000_common.o
-obj-$(CONFIG_DVB_DIB8000) += dib8000.o dibx000_common.o
-obj-$(CONFIG_DVB_DIB9000) += dib9000.o dibx000_common.o
-obj-$(CONFIG_DVB_MT312) += mt312.o
-obj-$(CONFIG_DVB_VES1820) += ves1820.o
-obj-$(CONFIG_DVB_VES1X93) += ves1x93.o
-obj-$(CONFIG_DVB_TDA1004X) += tda1004x.o
-obj-$(CONFIG_DVB_SP887X) += sp887x.o
-obj-$(CONFIG_DVB_NXT6000) += nxt6000.o
-obj-$(CONFIG_DVB_MT352) += mt352.o
-obj-$(CONFIG_DVB_ZL10036) += zl10036.o
-obj-$(CONFIG_DVB_ZL10039) += zl10039.o
-obj-$(CONFIG_DVB_ZL10353) += zl10353.o
-obj-$(CONFIG_DVB_CX22702) += cx22702.o
-obj-$(CONFIG_DVB_DRXD) += drxd.o
-obj-$(CONFIG_DVB_TDA10021) += tda10021.o
-obj-$(CONFIG_DVB_TDA10023) += tda10023.o
-obj-$(CONFIG_DVB_STV0297) += stv0297.o
-obj-$(CONFIG_DVB_NXT200X) += nxt200x.o
-obj-$(CONFIG_DVB_OR51211) += or51211.o
-obj-$(CONFIG_DVB_OR51132) += or51132.o
-obj-$(CONFIG_DVB_BCM3510) += bcm3510.o
-obj-$(CONFIG_DVB_S5H1420) += s5h1420.o
-obj-$(CONFIG_DVB_LGDT330X) += lgdt330x.o
-obj-$(CONFIG_DVB_LGDT3305) += lgdt3305.o
-obj-$(CONFIG_DVB_CX24123) += cx24123.o
-obj-$(CONFIG_DVB_LNBP21) += lnbp21.o
-obj-$(CONFIG_DVB_LNBP22) += lnbp22.o
-obj-$(CONFIG_DVB_ISL6405) += isl6405.o
-obj-$(CONFIG_DVB_ISL6421) += isl6421.o
-obj-$(CONFIG_DVB_TDA10086) += tda10086.o
-obj-$(CONFIG_DVB_TDA826X) += tda826x.o
-obj-$(CONFIG_DVB_TDA8261) += tda8261.o
-obj-$(CONFIG_DVB_TUNER_DIB0070) += dib0070.o
-obj-$(CONFIG_DVB_TUNER_DIB0090) += dib0090.o
-obj-$(CONFIG_DVB_TUA6100) += tua6100.o
-obj-$(CONFIG_DVB_S5H1409) += s5h1409.o
-obj-$(CONFIG_DVB_TUNER_ITD1000) += itd1000.o
-obj-$(CONFIG_DVB_AU8522) += au8522.o
-obj-$(CONFIG_DVB_TDA10048) += tda10048.o
-obj-$(CONFIG_DVB_TUNER_CX24113) += cx24113.o
-obj-$(CONFIG_DVB_S5H1411) += s5h1411.o
-obj-$(CONFIG_DVB_LGS8GL5) += lgs8gl5.o
-obj-$(CONFIG_DVB_TDA665x) += tda665x.o
-obj-$(CONFIG_DVB_LGS8GXX) += lgs8gxx.o
-obj-$(CONFIG_DVB_ATBM8830) += atbm8830.o
-obj-$(CONFIG_DVB_DUMMY_FE) += dvb_dummy_fe.o
-obj-$(CONFIG_DVB_AF9013) += af9013.o
-obj-$(CONFIG_DVB_CX24116) += cx24116.o
-obj-$(CONFIG_DVB_SI21XX) += si21xx.o
-obj-$(CONFIG_DVB_STV0288) += stv0288.o
-obj-$(CONFIG_DVB_STB6000) += stb6000.o
-obj-$(CONFIG_DVB_S921) += s921.o
-obj-$(CONFIG_DVB_STV6110) += stv6110.o
-obj-$(CONFIG_DVB_STV0900) += stv0900.o
-obj-$(CONFIG_DVB_STV090x) += stv090x.o
-obj-$(CONFIG_DVB_STV6110x) += stv6110x.o
-obj-$(CONFIG_DVB_ISL6423) += isl6423.o
-obj-$(CONFIG_DVB_EC100) += ec100.o
-obj-$(CONFIG_DVB_HD29L2) += hd29l2.o
-obj-$(CONFIG_DVB_DS3000) += ds3000.o
-obj-$(CONFIG_DVB_MB86A16) += mb86a16.o
-obj-$(CONFIG_DVB_MB86A20S) += mb86a20s.o
-obj-$(CONFIG_DVB_IX2505V) += ix2505v.o
-obj-$(CONFIG_DVB_STV0367) += stv0367.o
-obj-$(CONFIG_DVB_CXD2820R) += cxd2820r.o
-obj-$(CONFIG_DVB_DRXK) += drxk.o
-obj-$(CONFIG_DVB_TDA18271C2DD) += tda18271c2dd.o
-obj-$(CONFIG_DVB_IT913X_FE) += it913x-fe.o
-obj-$(CONFIG_DVB_A8293) += a8293.o
-obj-$(CONFIG_DVB_TDA10071) += tda10071.o
-
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c
--- media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c	2012-02-27 10:48:36.978908938 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c	2012-01-05 05:45:47.000000000 +0100
@@ -3512,7 +3512,6 @@
 	return 0;
 }
 
-#if 0
 static int stv090x_read_per(struct dvb_frontend *fe, u32 *per)
 {
 	struct stv090x_state *state = fe->demodulator_priv;
@@ -3563,27 +3562,6 @@
 	dprintk(FE_ERROR, 1, "I/O error");
 	return -1;
 }
-#endif
-
-static int stv090x_read_ber(struct dvb_frontend *fe, u32 *ber)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg, h, m, l;
-
-	/* Counter 1: S1: 0x75 BER, S2: 0x67 PER */
-	reg = STV090x_READ_DEMOD(state, ERRCNT12);
-	h = STV090x_GETFIELD_Px(reg, ERR_CNT12_FIELD);
-
-	reg = STV090x_READ_DEMOD(state, ERRCNT11);
-	m = STV090x_GETFIELD_Px(reg, ERR_CNT11_FIELD);
-
-	reg = STV090x_READ_DEMOD(state, ERRCNT10);
-	l = STV090x_GETFIELD_Px(reg, ERR_CNT10_FIELD);
-
-	*ber = ((h << 16) | (m << 8) | l);
-
-	return 0;
-}
 
 static int stv090x_table_lookup(const struct stv090x_tab *tab, int max, int val)
 {
@@ -3704,26 +3682,6 @@
 	return 0;
 }
 
-static int stv090x_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg, h, m, l;
-
-	/* Counter 2: 0xc1 TS error count */
-	reg = STV090x_READ_DEMOD(state, ERRCNT22);
-	h = STV090x_GETFIELD_Px(reg, ERR_CNT2_FIELD);
-
-	reg = STV090x_READ_DEMOD(state, ERRCNT21);
-	m = STV090x_GETFIELD_Px(reg, ERR_CNT21_FIELD);
-
-	reg = STV090x_READ_DEMOD(state, ERRCNT20);
-	l = STV090x_GETFIELD_Px(reg, ERR_CNT20_FIELD);
-
-	*ucblocks = ((h << 16) | (m << 8) | l);
-
-	return 0;
-}
-
 static int stv090x_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
 {
 	struct stv090x_state *state = fe->demodulator_priv;
@@ -4782,10 +4740,9 @@
 
 	.search				= stv090x_search,
 	.read_status			= stv090x_read_status,
-	.read_ber			= stv090x_read_ber,
+	.read_ber			= stv090x_read_per,
 	.read_signal_strength		= stv090x_read_signal_strength,
 	.read_snr			= stv090x_read_cnr,
-	.read_ucblocks			= stv090x_read_ucblocks,
 };
 
 
diff -urN media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c.orig media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c.orig
--- media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c.orig	2012-01-05 05:45:47.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/frontends/stv090x.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,4825 +0,0 @@
-/*
-	STV0900/0903 Multistandard Broadcast Frontend driver
-	Copyright (C) Manu Abraham <abraham.manu@gmail.com>
-
-	Copyright (C) ST Microelectronics
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-
-#include <linux/dvb/frontend.h>
-#include "dvb_frontend.h"
-
-#include "stv6110x.h" /* for demodulator internal modes */
-
-#include "stv090x_reg.h"
-#include "stv090x.h"
-#include "stv090x_priv.h"
-
-static unsigned int verbose;
-module_param(verbose, int, 0644);
-
-/* internal params node */
-struct stv090x_dev {
-	/* pointer for internal params, one for each pair of demods */
-	struct stv090x_internal		*internal;
-	struct stv090x_dev		*next_dev;
-};
-
-/* first internal params */
-static struct stv090x_dev *stv090x_first_dev;
-
-/* find chip by i2c adapter and i2c address */
-static struct stv090x_dev *find_dev(struct i2c_adapter *i2c_adap,
-					u8 i2c_addr)
-{
-	struct stv090x_dev *temp_dev = stv090x_first_dev;
-
-	/*
-	 Search of the last stv0900 chip or
-	 find it by i2c adapter and i2c address */
-	while ((temp_dev != NULL) &&
-		((temp_dev->internal->i2c_adap != i2c_adap) ||
-		(temp_dev->internal->i2c_addr != i2c_addr))) {
-
-		temp_dev = temp_dev->next_dev;
-	}
-
-	return temp_dev;
-}
-
-/* deallocating chip */
-static void remove_dev(struct stv090x_internal *internal)
-{
-	struct stv090x_dev *prev_dev = stv090x_first_dev;
-	struct stv090x_dev *del_dev = find_dev(internal->i2c_adap,
-						internal->i2c_addr);
-
-	if (del_dev != NULL) {
-		if (del_dev == stv090x_first_dev) {
-			stv090x_first_dev = del_dev->next_dev;
-		} else {
-			while (prev_dev->next_dev != del_dev)
-				prev_dev = prev_dev->next_dev;
-
-			prev_dev->next_dev = del_dev->next_dev;
-		}
-
-		kfree(del_dev);
-	}
-}
-
-/* allocating new chip */
-static struct stv090x_dev *append_internal(struct stv090x_internal *internal)
-{
-	struct stv090x_dev *new_dev;
-	struct stv090x_dev *temp_dev;
-
-	new_dev = kmalloc(sizeof(struct stv090x_dev), GFP_KERNEL);
-	if (new_dev != NULL) {
-		new_dev->internal = internal;
-		new_dev->next_dev = NULL;
-
-		/* append to list */
-		if (stv090x_first_dev == NULL) {
-			stv090x_first_dev = new_dev;
-		} else {
-			temp_dev = stv090x_first_dev;
-			while (temp_dev->next_dev != NULL)
-				temp_dev = temp_dev->next_dev;
-
-			temp_dev->next_dev = new_dev;
-		}
-	}
-
-	return new_dev;
-}
-
-
-/* DVBS1 and DSS C/N Lookup table */
-static const struct stv090x_tab stv090x_s1cn_tab[] = {
-	{   0, 8917 }, /*  0.0dB */
-	{   5, 8801 }, /*  0.5dB */
-	{  10, 8667 }, /*  1.0dB */
-	{  15, 8522 }, /*  1.5dB */
-	{  20, 8355 }, /*  2.0dB */
-	{  25, 8175 }, /*  2.5dB */
-	{  30, 7979 }, /*  3.0dB */
-	{  35, 7763 }, /*  3.5dB */
-	{  40, 7530 }, /*  4.0dB */
-	{  45, 7282 }, /*  4.5dB */
-	{  50, 7026 }, /*  5.0dB */
-	{  55, 6781 }, /*  5.5dB */
-	{  60, 6514 }, /*  6.0dB */
-	{  65, 6241 }, /*  6.5dB */
-	{  70, 5965 }, /*  7.0dB */
-	{  75, 5690 }, /*  7.5dB */
-	{  80, 5424 }, /*  8.0dB */
-	{  85, 5161 }, /*  8.5dB */
-	{  90, 4902 }, /*  9.0dB */
-	{  95, 4654 }, /*  9.5dB */
-	{ 100, 4417 }, /* 10.0dB */
-	{ 105, 4186 }, /* 10.5dB */
-	{ 110, 3968 }, /* 11.0dB */
-	{ 115, 3757 }, /* 11.5dB */
-	{ 120, 3558 }, /* 12.0dB */
-	{ 125, 3366 }, /* 12.5dB */
-	{ 130, 3185 }, /* 13.0dB */
-	{ 135, 3012 }, /* 13.5dB */
-	{ 140, 2850 }, /* 14.0dB */
-	{ 145, 2698 }, /* 14.5dB */
-	{ 150, 2550 }, /* 15.0dB */
-	{ 160, 2283 }, /* 16.0dB */
-	{ 170, 2042 }, /* 17.0dB */
-	{ 180, 1827 }, /* 18.0dB */
-	{ 190, 1636 }, /* 19.0dB */
-	{ 200, 1466 }, /* 20.0dB */
-	{ 210, 1315 }, /* 21.0dB */
-	{ 220, 1181 }, /* 22.0dB */
-	{ 230, 1064 }, /* 23.0dB */
-	{ 240,	960 }, /* 24.0dB */
-	{ 250,	869 }, /* 25.0dB */
-	{ 260,	792 }, /* 26.0dB */
-	{ 270,	724 }, /* 27.0dB */
-	{ 280,	665 }, /* 28.0dB */
-	{ 290,	616 }, /* 29.0dB */
-	{ 300,	573 }, /* 30.0dB */
-	{ 310,	537 }, /* 31.0dB */
-	{ 320,	507 }, /* 32.0dB */
-	{ 330,	483 }, /* 33.0dB */
-	{ 400,	398 }, /* 40.0dB */
-	{ 450,	381 }, /* 45.0dB */
-	{ 500,	377 }  /* 50.0dB */
-};
-
-/* DVBS2 C/N Lookup table */
-static const struct stv090x_tab stv090x_s2cn_tab[] = {
-	{ -30, 13348 }, /* -3.0dB */
-	{ -20, 12640 }, /* -2d.0B */
-	{ -10, 11883 }, /* -1.0dB */
-	{   0, 11101 }, /* -0.0dB */
-	{   5, 10718 }, /*  0.5dB */
-	{  10, 10339 }, /*  1.0dB */
-	{  15,  9947 }, /*  1.5dB */
-	{  20,  9552 }, /*  2.0dB */
-	{  25,  9183 }, /*  2.5dB */
-	{  30,  8799 }, /*  3.0dB */
-	{  35,  8422 }, /*  3.5dB */
-	{  40,  8062 }, /*  4.0dB */
-	{  45,  7707 }, /*  4.5dB */
-	{  50,  7353 }, /*  5.0dB */
-	{  55,  7025 }, /*  5.5dB */
-	{  60,  6684 }, /*  6.0dB */
-	{  65,  6331 }, /*  6.5dB */
-	{  70,  6036 }, /*  7.0dB */
-	{  75,  5727 }, /*  7.5dB */
-	{  80,  5437 }, /*  8.0dB */
-	{  85,  5164 }, /*  8.5dB */
-	{  90,  4902 }, /*  9.0dB */
-	{  95,  4653 }, /*  9.5dB */
-	{ 100,  4408 }, /* 10.0dB */
-	{ 105,  4187 }, /* 10.5dB */
-	{ 110,  3961 }, /* 11.0dB */
-	{ 115,  3751 }, /* 11.5dB */
-	{ 120,  3558 }, /* 12.0dB */
-	{ 125,  3368 }, /* 12.5dB */
-	{ 130,  3191 }, /* 13.0dB */
-	{ 135,  3017 }, /* 13.5dB */
-	{ 140,  2862 }, /* 14.0dB */
-	{ 145,  2710 }, /* 14.5dB */
-	{ 150,  2565 }, /* 15.0dB */
-	{ 160,  2300 }, /* 16.0dB */
-	{ 170,  2058 }, /* 17.0dB */
-	{ 180,  1849 }, /* 18.0dB */
-	{ 190,  1663 }, /* 19.0dB */
-	{ 200,  1495 }, /* 20.0dB */
-	{ 210,  1349 }, /* 21.0dB */
-	{ 220,  1222 }, /* 22.0dB */
-	{ 230,  1110 }, /* 23.0dB */
-	{ 240,  1011 }, /* 24.0dB */
-	{ 250,   925 }, /* 25.0dB */
-	{ 260,   853 }, /* 26.0dB */
-	{ 270,   789 }, /* 27.0dB */
-	{ 280,   734 }, /* 28.0dB */
-	{ 290,   690 }, /* 29.0dB */
-	{ 300,   650 }, /* 30.0dB */
-	{ 310,   619 }, /* 31.0dB */
-	{ 320,   593 }, /* 32.0dB */
-	{ 330,   571 }, /* 33.0dB */
-	{ 400,   498 }, /* 40.0dB */
-	{ 450,	 484 }, /* 45.0dB */
-	{ 500,	 481 }	/* 50.0dB */
-};
-
-/* RF level C/N lookup table */
-static const struct stv090x_tab stv090x_rf_tab[] = {
-	{  -5, 0xcaa1 }, /*  -5dBm */
-	{ -10, 0xc229 }, /* -10dBm */
-	{ -15, 0xbb08 }, /* -15dBm */
-	{ -20, 0xb4bc }, /* -20dBm */
-	{ -25, 0xad5a }, /* -25dBm */
-	{ -30, 0xa298 }, /* -30dBm */
-	{ -35, 0x98a8 }, /* -35dBm */
-	{ -40, 0x8389 }, /* -40dBm */
-	{ -45, 0x59be }, /* -45dBm */
-	{ -50, 0x3a14 }, /* -50dBm */
-	{ -55, 0x2d11 }, /* -55dBm */
-	{ -60, 0x210d }, /* -60dBm */
-	{ -65, 0xa14f }, /* -65dBm */
-	{ -70, 0x07aa }	 /* -70dBm */
-};
-
-
-static struct stv090x_reg stv0900_initval[] = {
-
-	{ STV090x_OUTCFG,		0x00 },
-	{ STV090x_MODECFG,		0xff },
-	{ STV090x_AGCRF1CFG,		0x11 },
-	{ STV090x_AGCRF2CFG,		0x13 },
-	{ STV090x_TSGENERAL1X,		0x14 },
-	{ STV090x_TSTTNR2,		0x21 },
-	{ STV090x_TSTTNR4,		0x21 },
-	{ STV090x_P2_DISTXCTL,		0x22 },
-	{ STV090x_P2_F22TX,		0xc0 },
-	{ STV090x_P2_F22RX,		0xc0 },
-	{ STV090x_P2_DISRXCTL,		0x00 },
-	{ STV090x_P2_DMDCFGMD,		0xF9 },
-	{ STV090x_P2_DEMOD,		0x08 },
-	{ STV090x_P2_DMDCFG3,		0xc4 },
-	{ STV090x_P2_CARFREQ,		0xed },
-	{ STV090x_P2_LDT,		0xd0 },
-	{ STV090x_P2_LDT2,		0xb8 },
-	{ STV090x_P2_TMGCFG,		0xd2 },
-	{ STV090x_P2_TMGTHRISE,		0x20 },
-	{ STV090x_P1_TMGCFG,		0xd2 },
-
-	{ STV090x_P2_TMGTHFALL,		0x00 },
-	{ STV090x_P2_FECSPY,		0x88 },
-	{ STV090x_P2_FSPYDATA,		0x3a },
-	{ STV090x_P2_FBERCPT4,		0x00 },
-	{ STV090x_P2_FSPYBER,		0x10 },
-	{ STV090x_P2_ERRCTRL1,		0x35 },
-	{ STV090x_P2_ERRCTRL2,		0xc1 },
-	{ STV090x_P2_CFRICFG,		0xf8 },
-	{ STV090x_P2_NOSCFG,		0x1c },
-	{ STV090x_P2_DMDTOM,		0x20 },
-	{ STV090x_P2_CORRELMANT,	0x70 },
-	{ STV090x_P2_CORRELABS,		0x88 },
-	{ STV090x_P2_AGC2O,		0x5b },
-	{ STV090x_P2_AGC2REF,		0x38 },
-	{ STV090x_P2_CARCFG,		0xe4 },
-	{ STV090x_P2_ACLC,		0x1A },
-	{ STV090x_P2_BCLC,		0x09 },
-	{ STV090x_P2_CARHDR,		0x08 },
-	{ STV090x_P2_KREFTMG,		0xc1 },
-	{ STV090x_P2_SFRUPRATIO,	0xf0 },
-	{ STV090x_P2_SFRLOWRATIO,	0x70 },
-	{ STV090x_P2_SFRSTEP,		0x58 },
-	{ STV090x_P2_TMGCFG2,		0x01 },
-	{ STV090x_P2_CAR2CFG,		0x26 },
-	{ STV090x_P2_BCLC2S2Q,		0x86 },
-	{ STV090x_P2_BCLC2S28,		0x86 },
-	{ STV090x_P2_SMAPCOEF7,		0x77 },
-	{ STV090x_P2_SMAPCOEF6,		0x85 },
-	{ STV090x_P2_SMAPCOEF5,		0x77 },
-	{ STV090x_P2_TSCFGL,		0x20 },
-	{ STV090x_P2_DMDCFG2,		0x3b },
-	{ STV090x_P2_MODCODLST0,	0xff },
-	{ STV090x_P2_MODCODLST1,	0xff },
-	{ STV090x_P2_MODCODLST2,	0xff },
-	{ STV090x_P2_MODCODLST3,	0xff },
-	{ STV090x_P2_MODCODLST4,	0xff },
-	{ STV090x_P2_MODCODLST5,	0xff },
-	{ STV090x_P2_MODCODLST6,	0xff },
-	{ STV090x_P2_MODCODLST7,	0xcc },
-	{ STV090x_P2_MODCODLST8,	0xcc },
-	{ STV090x_P2_MODCODLST9,	0xcc },
-	{ STV090x_P2_MODCODLSTA,	0xcc },
-	{ STV090x_P2_MODCODLSTB,	0xcc },
-	{ STV090x_P2_MODCODLSTC,	0xcc },
-	{ STV090x_P2_MODCODLSTD,	0xcc },
-	{ STV090x_P2_MODCODLSTE,	0xcc },
-	{ STV090x_P2_MODCODLSTF,	0xcf },
-	{ STV090x_P1_DISTXCTL,		0x22 },
-	{ STV090x_P1_F22TX,		0xc0 },
-	{ STV090x_P1_F22RX,		0xc0 },
-	{ STV090x_P1_DISRXCTL,		0x00 },
-	{ STV090x_P1_DMDCFGMD,		0xf9 },
-	{ STV090x_P1_DEMOD,		0x08 },
-	{ STV090x_P1_DMDCFG3,		0xc4 },
-	{ STV090x_P1_DMDTOM,		0x20 },
-	{ STV090x_P1_CARFREQ,		0xed },
-	{ STV090x_P1_LDT,		0xd0 },
-	{ STV090x_P1_LDT2,		0xb8 },
-	{ STV090x_P1_TMGCFG,		0xd2 },
-	{ STV090x_P1_TMGTHRISE,		0x20 },
-	{ STV090x_P1_TMGTHFALL,		0x00 },
-	{ STV090x_P1_SFRUPRATIO,	0xf0 },
-	{ STV090x_P1_SFRLOWRATIO,	0x70 },
-	{ STV090x_P1_TSCFGL,		0x20 },
-	{ STV090x_P1_FECSPY,		0x88 },
-	{ STV090x_P1_FSPYDATA,		0x3a },
-	{ STV090x_P1_FBERCPT4,		0x00 },
-	{ STV090x_P1_FSPYBER,		0x10 },
-	{ STV090x_P1_ERRCTRL1,		0x35 },
-	{ STV090x_P1_ERRCTRL2,		0xc1 },
-	{ STV090x_P1_CFRICFG,		0xf8 },
-	{ STV090x_P1_NOSCFG,		0x1c },
-	{ STV090x_P1_CORRELMANT,	0x70 },
-	{ STV090x_P1_CORRELABS,		0x88 },
-	{ STV090x_P1_AGC2O,		0x5b },
-	{ STV090x_P1_AGC2REF,		0x38 },
-	{ STV090x_P1_CARCFG,		0xe4 },
-	{ STV090x_P1_ACLC,		0x1A },
-	{ STV090x_P1_BCLC,		0x09 },
-	{ STV090x_P1_CARHDR,		0x08 },
-	{ STV090x_P1_KREFTMG,		0xc1 },
-	{ STV090x_P1_SFRSTEP,		0x58 },
-	{ STV090x_P1_TMGCFG2,		0x01 },
-	{ STV090x_P1_CAR2CFG,		0x26 },
-	{ STV090x_P1_BCLC2S2Q,		0x86 },
-	{ STV090x_P1_BCLC2S28,		0x86 },
-	{ STV090x_P1_SMAPCOEF7,		0x77 },
-	{ STV090x_P1_SMAPCOEF6,		0x85 },
-	{ STV090x_P1_SMAPCOEF5,		0x77 },
-	{ STV090x_P1_DMDCFG2,		0x3b },
-	{ STV090x_P1_MODCODLST0,	0xff },
-	{ STV090x_P1_MODCODLST1,	0xff },
-	{ STV090x_P1_MODCODLST2,	0xff },
-	{ STV090x_P1_MODCODLST3,	0xff },
-	{ STV090x_P1_MODCODLST4,	0xff },
-	{ STV090x_P1_MODCODLST5,	0xff },
-	{ STV090x_P1_MODCODLST6,	0xff },
-	{ STV090x_P1_MODCODLST7,	0xcc },
-	{ STV090x_P1_MODCODLST8,	0xcc },
-	{ STV090x_P1_MODCODLST9,	0xcc },
-	{ STV090x_P1_MODCODLSTA,	0xcc },
-	{ STV090x_P1_MODCODLSTB,	0xcc },
-	{ STV090x_P1_MODCODLSTC,	0xcc },
-	{ STV090x_P1_MODCODLSTD,	0xcc },
-	{ STV090x_P1_MODCODLSTE,	0xcc },
-	{ STV090x_P1_MODCODLSTF,	0xcf },
-	{ STV090x_GENCFG,		0x1d },
-	{ STV090x_NBITER_NF4,		0x37 },
-	{ STV090x_NBITER_NF5,		0x29 },
-	{ STV090x_NBITER_NF6,		0x37 },
-	{ STV090x_NBITER_NF7,		0x33 },
-	{ STV090x_NBITER_NF8,		0x31 },
-	{ STV090x_NBITER_NF9,		0x2f },
-	{ STV090x_NBITER_NF10,		0x39 },
-	{ STV090x_NBITER_NF11,		0x3a },
-	{ STV090x_NBITER_NF12,		0x29 },
-	{ STV090x_NBITER_NF13,		0x37 },
-	{ STV090x_NBITER_NF14,		0x33 },
-	{ STV090x_NBITER_NF15,		0x2f },
-	{ STV090x_NBITER_NF16,		0x39 },
-	{ STV090x_NBITER_NF17,		0x3a },
-	{ STV090x_NBITERNOERR,		0x04 },
-	{ STV090x_GAINLLR_NF4,		0x0C },
-	{ STV090x_GAINLLR_NF5,		0x0F },
-	{ STV090x_GAINLLR_NF6,		0x11 },
-	{ STV090x_GAINLLR_NF7,		0x14 },
-	{ STV090x_GAINLLR_NF8,		0x17 },
-	{ STV090x_GAINLLR_NF9,		0x19 },
-	{ STV090x_GAINLLR_NF10,		0x20 },
-	{ STV090x_GAINLLR_NF11,		0x21 },
-	{ STV090x_GAINLLR_NF12,		0x0D },
-	{ STV090x_GAINLLR_NF13,		0x0F },
-	{ STV090x_GAINLLR_NF14,		0x13 },
-	{ STV090x_GAINLLR_NF15,		0x1A },
-	{ STV090x_GAINLLR_NF16,		0x1F },
-	{ STV090x_GAINLLR_NF17,		0x21 },
-	{ STV090x_RCCFGH,		0x20 },
-	{ STV090x_P1_FECM,		0x01 }, /* disable DSS modes */
-	{ STV090x_P2_FECM,		0x01 }, /* disable DSS modes */
-	{ STV090x_P1_PRVIT,		0x2F }, /* disable PR 6/7 */
-	{ STV090x_P2_PRVIT,		0x2F }, /* disable PR 6/7 */
-};
-
-static struct stv090x_reg stv0903_initval[] = {
-	{ STV090x_OUTCFG,		0x00 },
-	{ STV090x_AGCRF1CFG,		0x11 },
-	{ STV090x_STOPCLK1,		0x48 },
-	{ STV090x_STOPCLK2,		0x14 },
-	{ STV090x_TSTTNR1,		0x27 },
-	{ STV090x_TSTTNR2,		0x21 },
-	{ STV090x_P1_DISTXCTL,		0x22 },
-	{ STV090x_P1_F22TX,		0xc0 },
-	{ STV090x_P1_F22RX,		0xc0 },
-	{ STV090x_P1_DISRXCTL,		0x00 },
-	{ STV090x_P1_DMDCFGMD,		0xF9 },
-	{ STV090x_P1_DEMOD,		0x08 },
-	{ STV090x_P1_DMDCFG3,		0xc4 },
-	{ STV090x_P1_CARFREQ,		0xed },
-	{ STV090x_P1_TNRCFG2,		0x82 },
-	{ STV090x_P1_LDT,		0xd0 },
-	{ STV090x_P1_LDT2,		0xb8 },
-	{ STV090x_P1_TMGCFG,		0xd2 },
-	{ STV090x_P1_TMGTHRISE,		0x20 },
-	{ STV090x_P1_TMGTHFALL,		0x00 },
-	{ STV090x_P1_SFRUPRATIO,	0xf0 },
-	{ STV090x_P1_SFRLOWRATIO,	0x70 },
-	{ STV090x_P1_TSCFGL,		0x20 },
-	{ STV090x_P1_FECSPY,		0x88 },
-	{ STV090x_P1_FSPYDATA,		0x3a },
-	{ STV090x_P1_FBERCPT4,		0x00 },
-	{ STV090x_P1_FSPYBER,		0x10 },
-	{ STV090x_P1_ERRCTRL1,		0x35 },
-	{ STV090x_P1_ERRCTRL2,		0xc1 },
-	{ STV090x_P1_CFRICFG,		0xf8 },
-	{ STV090x_P1_NOSCFG,		0x1c },
-	{ STV090x_P1_DMDTOM,		0x20 },
-	{ STV090x_P1_CORRELMANT,	0x70 },
-	{ STV090x_P1_CORRELABS,		0x88 },
-	{ STV090x_P1_AGC2O,		0x5b },
-	{ STV090x_P1_AGC2REF,		0x38 },
-	{ STV090x_P1_CARCFG,		0xe4 },
-	{ STV090x_P1_ACLC,		0x1A },
-	{ STV090x_P1_BCLC,		0x09 },
-	{ STV090x_P1_CARHDR,		0x08 },
-	{ STV090x_P1_KREFTMG,		0xc1 },
-	{ STV090x_P1_SFRSTEP,		0x58 },
-	{ STV090x_P1_TMGCFG2,		0x01 },
-	{ STV090x_P1_CAR2CFG,		0x26 },
-	{ STV090x_P1_BCLC2S2Q,		0x86 },
-	{ STV090x_P1_BCLC2S28,		0x86 },
-	{ STV090x_P1_SMAPCOEF7,		0x77 },
-	{ STV090x_P1_SMAPCOEF6,		0x85 },
-	{ STV090x_P1_SMAPCOEF5,		0x77 },
-	{ STV090x_P1_DMDCFG2,		0x3b },
-	{ STV090x_P1_MODCODLST0,	0xff },
-	{ STV090x_P1_MODCODLST1,	0xff },
-	{ STV090x_P1_MODCODLST2,	0xff },
-	{ STV090x_P1_MODCODLST3,	0xff },
-	{ STV090x_P1_MODCODLST4,	0xff },
-	{ STV090x_P1_MODCODLST5,	0xff },
-	{ STV090x_P1_MODCODLST6,	0xff },
-	{ STV090x_P1_MODCODLST7,	0xcc },
-	{ STV090x_P1_MODCODLST8,	0xcc },
-	{ STV090x_P1_MODCODLST9,	0xcc },
-	{ STV090x_P1_MODCODLSTA,	0xcc },
-	{ STV090x_P1_MODCODLSTB,	0xcc },
-	{ STV090x_P1_MODCODLSTC,	0xcc },
-	{ STV090x_P1_MODCODLSTD,	0xcc },
-	{ STV090x_P1_MODCODLSTE,	0xcc },
-	{ STV090x_P1_MODCODLSTF,	0xcf },
-	{ STV090x_GENCFG,		0x1c },
-	{ STV090x_NBITER_NF4,		0x37 },
-	{ STV090x_NBITER_NF5,		0x29 },
-	{ STV090x_NBITER_NF6,		0x37 },
-	{ STV090x_NBITER_NF7,		0x33 },
-	{ STV090x_NBITER_NF8,		0x31 },
-	{ STV090x_NBITER_NF9,		0x2f },
-	{ STV090x_NBITER_NF10,		0x39 },
-	{ STV090x_NBITER_NF11,		0x3a },
-	{ STV090x_NBITER_NF12,		0x29 },
-	{ STV090x_NBITER_NF13,		0x37 },
-	{ STV090x_NBITER_NF14,		0x33 },
-	{ STV090x_NBITER_NF15,		0x2f },
-	{ STV090x_NBITER_NF16,		0x39 },
-	{ STV090x_NBITER_NF17,		0x3a },
-	{ STV090x_NBITERNOERR,		0x04 },
-	{ STV090x_GAINLLR_NF4,		0x0C },
-	{ STV090x_GAINLLR_NF5,		0x0F },
-	{ STV090x_GAINLLR_NF6,		0x11 },
-	{ STV090x_GAINLLR_NF7,		0x14 },
-	{ STV090x_GAINLLR_NF8,		0x17 },
-	{ STV090x_GAINLLR_NF9,		0x19 },
-	{ STV090x_GAINLLR_NF10,		0x20 },
-	{ STV090x_GAINLLR_NF11,		0x21 },
-	{ STV090x_GAINLLR_NF12,		0x0D },
-	{ STV090x_GAINLLR_NF13,		0x0F },
-	{ STV090x_GAINLLR_NF14,		0x13 },
-	{ STV090x_GAINLLR_NF15,		0x1A },
-	{ STV090x_GAINLLR_NF16,		0x1F },
-	{ STV090x_GAINLLR_NF17,		0x21 },
-	{ STV090x_RCCFGH,		0x20 },
-	{ STV090x_P1_FECM,		0x01 }, /*disable the DSS mode */
-	{ STV090x_P1_PRVIT,		0x2f }  /*disable puncture rate 6/7*/
-};
-
-static struct stv090x_reg stv0900_cut20_val[] = {
-
-	{ STV090x_P2_DMDCFG3,		0xe8 },
-	{ STV090x_P2_DMDCFG4,		0x10 },
-	{ STV090x_P2_CARFREQ,		0x38 },
-	{ STV090x_P2_CARHDR,		0x20 },
-	{ STV090x_P2_KREFTMG,		0x5a },
-	{ STV090x_P2_SMAPCOEF7,		0x06 },
-	{ STV090x_P2_SMAPCOEF6,		0x00 },
-	{ STV090x_P2_SMAPCOEF5,		0x04 },
-	{ STV090x_P2_NOSCFG,		0x0c },
-	{ STV090x_P1_DMDCFG3,		0xe8 },
-	{ STV090x_P1_DMDCFG4,		0x10 },
-	{ STV090x_P1_CARFREQ,		0x38 },
-	{ STV090x_P1_CARHDR,		0x20 },
-	{ STV090x_P1_KREFTMG,		0x5a },
-	{ STV090x_P1_SMAPCOEF7,		0x06 },
-	{ STV090x_P1_SMAPCOEF6,		0x00 },
-	{ STV090x_P1_SMAPCOEF5,		0x04 },
-	{ STV090x_P1_NOSCFG,		0x0c },
-	{ STV090x_GAINLLR_NF4,		0x21 },
-	{ STV090x_GAINLLR_NF5,		0x21 },
-	{ STV090x_GAINLLR_NF6,		0x20 },
-	{ STV090x_GAINLLR_NF7,		0x1F },
-	{ STV090x_GAINLLR_NF8,		0x1E },
-	{ STV090x_GAINLLR_NF9,		0x1E },
-	{ STV090x_GAINLLR_NF10,		0x1D },
-	{ STV090x_GAINLLR_NF11,		0x1B },
-	{ STV090x_GAINLLR_NF12,		0x20 },
-	{ STV090x_GAINLLR_NF13,		0x20 },
-	{ STV090x_GAINLLR_NF14,		0x20 },
-	{ STV090x_GAINLLR_NF15,		0x20 },
-	{ STV090x_GAINLLR_NF16,		0x20 },
-	{ STV090x_GAINLLR_NF17,		0x21 },
-};
-
-static struct stv090x_reg stv0903_cut20_val[] = {
-	{ STV090x_P1_DMDCFG3,		0xe8 },
-	{ STV090x_P1_DMDCFG4,		0x10 },
-	{ STV090x_P1_CARFREQ,		0x38 },
-	{ STV090x_P1_CARHDR,		0x20 },
-	{ STV090x_P1_KREFTMG,		0x5a },
-	{ STV090x_P1_SMAPCOEF7,		0x06 },
-	{ STV090x_P1_SMAPCOEF6,		0x00 },
-	{ STV090x_P1_SMAPCOEF5,		0x04 },
-	{ STV090x_P1_NOSCFG,		0x0c },
-	{ STV090x_GAINLLR_NF4,		0x21 },
-	{ STV090x_GAINLLR_NF5,		0x21 },
-	{ STV090x_GAINLLR_NF6,		0x20 },
-	{ STV090x_GAINLLR_NF7,		0x1F },
-	{ STV090x_GAINLLR_NF8,		0x1E },
-	{ STV090x_GAINLLR_NF9,		0x1E },
-	{ STV090x_GAINLLR_NF10,		0x1D },
-	{ STV090x_GAINLLR_NF11,		0x1B },
-	{ STV090x_GAINLLR_NF12,		0x20 },
-	{ STV090x_GAINLLR_NF13,		0x20 },
-	{ STV090x_GAINLLR_NF14,		0x20 },
-	{ STV090x_GAINLLR_NF15,		0x20 },
-	{ STV090x_GAINLLR_NF16,		0x20 },
-	{ STV090x_GAINLLR_NF17,		0x21 }
-};
-
-/* Cut 2.0 Long Frame Tracking CR loop */
-static struct stv090x_long_frame_crloop stv090x_s2_crl_cut20[] = {
-	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
-	{ STV090x_QPSK_12,  0x1f, 0x3f, 0x1e, 0x3f, 0x3d, 0x1f, 0x3d, 0x3e, 0x3d, 0x1e },
-	{ STV090x_QPSK_35,  0x2f, 0x3f, 0x2e, 0x2f, 0x3d, 0x0f, 0x0e, 0x2e, 0x3d, 0x0e },
-	{ STV090x_QPSK_23,  0x2f, 0x3f, 0x2e, 0x2f, 0x0e, 0x0f, 0x0e, 0x1e, 0x3d, 0x3d },
-	{ STV090x_QPSK_34,  0x3f, 0x3f, 0x3e, 0x1f, 0x0e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
-	{ STV090x_QPSK_45,  0x3f, 0x3f, 0x3e, 0x1f, 0x0e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
-	{ STV090x_QPSK_56,  0x3f, 0x3f, 0x3e, 0x1f, 0x0e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
-	{ STV090x_QPSK_89,  0x3f, 0x3f, 0x3e, 0x1f, 0x1e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
-	{ STV090x_QPSK_910, 0x3f, 0x3f, 0x3e, 0x1f, 0x1e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
-	{ STV090x_8PSK_35,  0x3c, 0x3e, 0x1c, 0x2e, 0x0c, 0x1e, 0x2b, 0x2d, 0x1b, 0x1d },
-	{ STV090x_8PSK_23,  0x1d, 0x3e, 0x3c, 0x2e, 0x2c, 0x1e, 0x0c, 0x2d, 0x2b, 0x1d },
-	{ STV090x_8PSK_34,  0x0e, 0x3e, 0x3d, 0x2e, 0x0d, 0x1e, 0x2c, 0x2d, 0x0c, 0x1d },
-	{ STV090x_8PSK_56,  0x2e, 0x3e, 0x1e, 0x2e, 0x2d, 0x1e, 0x3c, 0x2d, 0x2c, 0x1d },
-	{ STV090x_8PSK_89,  0x3e, 0x3e, 0x1e, 0x2e, 0x3d, 0x1e, 0x0d, 0x2d, 0x3c, 0x1d },
-	{ STV090x_8PSK_910, 0x3e, 0x3e, 0x1e, 0x2e, 0x3d, 0x1e, 0x1d, 0x2d, 0x0d, 0x1d }
-};
-
-/* Cut 3.0 Long Frame Tracking CR loop */
-static	struct stv090x_long_frame_crloop stv090x_s2_crl_cut30[] = {
-	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
-	{ STV090x_QPSK_12,  0x3c, 0x2c, 0x0c, 0x2c, 0x1b, 0x2c, 0x1b, 0x1c, 0x0b, 0x3b },
-	{ STV090x_QPSK_35,  0x0d, 0x0d, 0x0c, 0x0d, 0x1b, 0x3c, 0x1b, 0x1c, 0x0b, 0x3b },
-	{ STV090x_QPSK_23,  0x1d, 0x0d, 0x0c, 0x1d, 0x2b, 0x3c, 0x1b, 0x1c, 0x0b, 0x3b },
-	{ STV090x_QPSK_34,  0x1d, 0x1d, 0x0c, 0x1d, 0x2b, 0x3c, 0x1b, 0x1c, 0x0b, 0x3b },
-	{ STV090x_QPSK_45,  0x2d, 0x1d, 0x1c, 0x1d, 0x2b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
-	{ STV090x_QPSK_56,  0x2d, 0x1d, 0x1c, 0x1d, 0x2b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
-	{ STV090x_QPSK_89,  0x3d, 0x2d, 0x1c, 0x1d, 0x3b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
-	{ STV090x_QPSK_910, 0x3d, 0x2d, 0x1c, 0x1d, 0x3b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
-	{ STV090x_8PSK_35,  0x39, 0x29, 0x39, 0x19, 0x19, 0x19, 0x19, 0x19, 0x09, 0x19 },
-	{ STV090x_8PSK_23,  0x2a, 0x39, 0x1a, 0x0a, 0x39, 0x0a, 0x29, 0x39, 0x29, 0x0a },
-	{ STV090x_8PSK_34,  0x2b, 0x3a, 0x1b, 0x1b, 0x3a, 0x1b, 0x1a, 0x0b, 0x1a, 0x3a },
-	{ STV090x_8PSK_56,  0x0c, 0x1b, 0x3b, 0x3b, 0x1b, 0x3b, 0x3a, 0x3b, 0x3a, 0x1b },
-	{ STV090x_8PSK_89,  0x0d, 0x3c, 0x2c, 0x2c, 0x2b, 0x0c, 0x0b, 0x3b, 0x0b, 0x1b },
-	{ STV090x_8PSK_910, 0x0d, 0x0d, 0x2c, 0x3c, 0x3b, 0x1c, 0x0b, 0x3b, 0x0b, 0x1b }
-};
-
-/* Cut 2.0 Long Frame Tracking CR Loop */
-static struct stv090x_long_frame_crloop stv090x_s2_apsk_crl_cut20[] = {
-	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
-	{ STV090x_16APSK_23,  0x0c, 0x0c, 0x0c, 0x0c, 0x1d, 0x0c, 0x3c, 0x0c, 0x2c, 0x0c },
-	{ STV090x_16APSK_34,  0x0c, 0x0c, 0x0c, 0x0c, 0x0e, 0x0c, 0x2d, 0x0c, 0x1d, 0x0c },
-	{ STV090x_16APSK_45,  0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x0c, 0x3d, 0x0c, 0x2d, 0x0c },
-	{ STV090x_16APSK_56,  0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x0c, 0x3d, 0x0c, 0x2d, 0x0c },
-	{ STV090x_16APSK_89,  0x0c, 0x0c, 0x0c, 0x0c, 0x2e, 0x0c, 0x0e, 0x0c, 0x3d, 0x0c },
-	{ STV090x_16APSK_910, 0x0c, 0x0c, 0x0c, 0x0c, 0x2e, 0x0c, 0x0e, 0x0c, 0x3d, 0x0c },
-	{ STV090x_32APSK_34,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
-	{ STV090x_32APSK_45,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
-	{ STV090x_32APSK_56,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
-	{ STV090x_32APSK_89,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
-	{ STV090x_32APSK_910, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c }
-};
-
-/* Cut 3.0 Long Frame Tracking CR Loop */
-static struct stv090x_long_frame_crloop	stv090x_s2_apsk_crl_cut30[] = {
-	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
-	{ STV090x_16APSK_23,  0x0a, 0x0a, 0x0a, 0x0a, 0x1a, 0x0a, 0x3a, 0x0a, 0x2a, 0x0a },
-	{ STV090x_16APSK_34,  0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0a, 0x3b, 0x0a, 0x1b, 0x0a },
-	{ STV090x_16APSK_45,  0x0a, 0x0a, 0x0a, 0x0a, 0x1b, 0x0a, 0x3b, 0x0a, 0x2b, 0x0a },
-	{ STV090x_16APSK_56,  0x0a, 0x0a, 0x0a, 0x0a, 0x1b, 0x0a, 0x3b, 0x0a, 0x2b, 0x0a },
-	{ STV090x_16APSK_89,  0x0a, 0x0a, 0x0a, 0x0a, 0x2b, 0x0a, 0x0c, 0x0a, 0x3b, 0x0a },
-	{ STV090x_16APSK_910, 0x0a, 0x0a, 0x0a, 0x0a, 0x2b, 0x0a, 0x0c, 0x0a, 0x3b, 0x0a },
-	{ STV090x_32APSK_34,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
-	{ STV090x_32APSK_45,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
-	{ STV090x_32APSK_56,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
-	{ STV090x_32APSK_89,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
-	{ STV090x_32APSK_910, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a }
-};
-
-static struct stv090x_long_frame_crloop stv090x_s2_lowqpsk_crl_cut20[] = {
-	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
-	{ STV090x_QPSK_14,  0x0f, 0x3f, 0x0e, 0x3f, 0x2d, 0x2f, 0x2d, 0x1f, 0x3d, 0x3e },
-	{ STV090x_QPSK_13,  0x0f, 0x3f, 0x0e, 0x3f, 0x2d, 0x2f, 0x3d, 0x0f, 0x3d, 0x2e },
-	{ STV090x_QPSK_25,  0x1f, 0x3f, 0x1e, 0x3f, 0x3d, 0x1f, 0x3d, 0x3e, 0x3d, 0x2e }
-};
-
-static struct stv090x_long_frame_crloop	stv090x_s2_lowqpsk_crl_cut30[] = {
-	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
-	{ STV090x_QPSK_14,  0x0c, 0x3c, 0x0b, 0x3c, 0x2a, 0x2c, 0x2a, 0x1c, 0x3a, 0x3b },
-	{ STV090x_QPSK_13,  0x0c, 0x3c, 0x0b, 0x3c, 0x2a, 0x2c, 0x3a, 0x0c, 0x3a, 0x2b },
-	{ STV090x_QPSK_25,  0x1c, 0x3c, 0x1b, 0x3c, 0x3a, 0x1c, 0x3a, 0x3b, 0x3a, 0x2b }
-};
-
-/* Cut 2.0 Short Frame Tracking CR Loop */
-static struct stv090x_short_frame_crloop stv090x_s2_short_crl_cut20[] = {
-	/* MODCOD	  2M    5M    10M   20M   30M */
-	{ STV090x_QPSK,   0x2f, 0x2e, 0x0e, 0x0e, 0x3d },
-	{ STV090x_8PSK,   0x3e, 0x0e, 0x2d, 0x0d, 0x3c },
-	{ STV090x_16APSK, 0x1e, 0x1e, 0x1e, 0x3d, 0x2d },
-	{ STV090x_32APSK, 0x1e, 0x1e, 0x1e, 0x3d, 0x2d }
-};
-
-/* Cut 3.0 Short Frame Tracking CR Loop */
-static struct stv090x_short_frame_crloop stv090x_s2_short_crl_cut30[] = {
-	/* MODCOD  	  2M	5M    10M   20M	  30M */
-	{ STV090x_QPSK,   0x2C, 0x2B, 0x0B, 0x0B, 0x3A },
-	{ STV090x_8PSK,   0x3B, 0x0B, 0x2A, 0x0A, 0x39 },
-	{ STV090x_16APSK, 0x1B, 0x1B, 0x1B, 0x3A, 0x2A },
-	{ STV090x_32APSK, 0x1B, 0x1B, 0x1B, 0x3A, 0x2A }
-};
-
-static inline s32 comp2(s32 __x, s32 __width)
-{
-	if (__width == 32)
-		return __x;
-	else
-		return (__x >= (1 << (__width - 1))) ? (__x - (1 << __width)) : __x;
-}
-
-static int stv090x_read_reg(struct stv090x_state *state, unsigned int reg)
-{
-	const struct stv090x_config *config = state->config;
-	int ret;
-
-	u8 b0[] = { reg >> 8, reg & 0xff };
-	u8 buf;
-
-	struct i2c_msg msg[] = {
-		{ .addr	= config->address, .flags	= 0, 		.buf = b0,   .len = 2 },
-		{ .addr	= config->address, .flags	= I2C_M_RD,	.buf = &buf, .len = 1 }
-	};
-
-	ret = i2c_transfer(state->i2c, msg, 2);
-	if (ret != 2) {
-		if (ret != -ERESTARTSYS)
-			dprintk(FE_ERROR, 1,
-				"Read error, Reg=[0x%02x], Status=%d",
-				reg, ret);
-
-		return ret < 0 ? ret : -EREMOTEIO;
-	}
-	if (unlikely(*state->verbose >= FE_DEBUGREG))
-		dprintk(FE_ERROR, 1, "Reg=[0x%02x], data=%02x",
-			reg, buf);
-
-	return (unsigned int) buf;
-}
-
-static int stv090x_write_regs(struct stv090x_state *state, unsigned int reg, u8 *data, u32 count)
-{
-	const struct stv090x_config *config = state->config;
-	int ret;
-	u8 buf[2 + count];
-	struct i2c_msg i2c_msg = { .addr = config->address, .flags = 0, .buf = buf, .len = 2 + count };
-
-	buf[0] = reg >> 8;
-	buf[1] = reg & 0xff;
-	memcpy(&buf[2], data, count);
-
-	if (unlikely(*state->verbose >= FE_DEBUGREG)) {
-		int i;
-
-		printk(KERN_DEBUG "%s [0x%04x]:", __func__, reg);
-		for (i = 0; i < count; i++)
-			printk(" %02x", data[i]);
-		printk("\n");
-	}
-
-	ret = i2c_transfer(state->i2c, &i2c_msg, 1);
-	if (ret != 1) {
-		if (ret != -ERESTARTSYS)
-			dprintk(FE_ERROR, 1, "Reg=[0x%04x], Data=[0x%02x ...], Count=%u, Status=%d",
-				reg, data[0], count, ret);
-		return ret < 0 ? ret : -EREMOTEIO;
-	}
-
-	return 0;
-}
-
-static int stv090x_write_reg(struct stv090x_state *state, unsigned int reg, u8 data)
-{
-	return stv090x_write_regs(state, reg, &data, 1);
-}
-
-static int stv090x_i2c_gate_ctrl(struct stv090x_state *state, int enable)
-{
-	u32 reg;
-
-	/*
-	 * NOTE! A lock is used as a FSM to control the state in which
-	 * access is serialized between two tuners on the same demod.
-	 * This has nothing to do with a lock to protect a critical section
-	 * which may in some other cases be confused with protecting I/O
-	 * access to the demodulator gate.
-	 * In case of any error, the lock is unlocked and exit within the
-	 * relevant operations themselves.
-	 */
-	if (enable) {
-		if (state->config->tuner_i2c_lock)
-			state->config->tuner_i2c_lock(&state->frontend, 1);
-		else
-			mutex_lock(&state->internal->tuner_lock);
-	}
-
-	reg = STV090x_READ_DEMOD(state, I2CRPT);
-	if (enable) {
-		dprintk(FE_DEBUG, 1, "Enable Gate");
-		STV090x_SETFIELD_Px(reg, I2CT_ON_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, I2CRPT, reg) < 0)
-			goto err;
-
-	} else {
-		dprintk(FE_DEBUG, 1, "Disable Gate");
-		STV090x_SETFIELD_Px(reg, I2CT_ON_FIELD, 0);
-		if ((STV090x_WRITE_DEMOD(state, I2CRPT, reg)) < 0)
-			goto err;
-	}
-
-	if (!enable) {
-		if (state->config->tuner_i2c_lock)
-			state->config->tuner_i2c_lock(&state->frontend, 0);
-		else
-			mutex_unlock(&state->internal->tuner_lock);
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	if (state->config->tuner_i2c_lock)
-		state->config->tuner_i2c_lock(&state->frontend, 0);
-	else
-		mutex_unlock(&state->internal->tuner_lock);
-	return -1;
-}
-
-static void stv090x_get_lock_tmg(struct stv090x_state *state)
-{
-	switch (state->algo) {
-	case STV090x_BLIND_SEARCH:
-		dprintk(FE_DEBUG, 1, "Blind Search");
-		if (state->srate <= 1500000) {  /*10Msps< SR <=15Msps*/
-			state->DemodTimeout = 1500;
-			state->FecTimeout = 400;
-		} else if (state->srate <= 5000000) {  /*10Msps< SR <=15Msps*/
-			state->DemodTimeout = 1000;
-			state->FecTimeout = 300;
-		} else {  /*SR >20Msps*/
-			state->DemodTimeout = 700;
-			state->FecTimeout = 100;
-		}
-		break;
-
-	case STV090x_COLD_SEARCH:
-	case STV090x_WARM_SEARCH:
-	default:
-		dprintk(FE_DEBUG, 1, "Normal Search");
-		if (state->srate <= 1000000) {  /*SR <=1Msps*/
-			state->DemodTimeout = 4500;
-			state->FecTimeout = 1700;
-		} else if (state->srate <= 2000000) { /*1Msps < SR <= 2Msps */
-			state->DemodTimeout = 2500;
-			state->FecTimeout = 1100;
-		} else if (state->srate <= 5000000) { /*2Msps < SR <= 5Msps */
-			state->DemodTimeout = 1000;
-			state->FecTimeout = 550;
-		} else if (state->srate <= 10000000) { /*5Msps < SR <= 10Msps */
-			state->DemodTimeout = 700;
-			state->FecTimeout = 250;
-		} else if (state->srate <= 20000000) { /*10Msps < SR <= 20Msps */
-			state->DemodTimeout = 400;
-			state->FecTimeout = 130;
-		} else {   /*SR >20Msps*/
-			state->DemodTimeout = 300;
-			state->FecTimeout = 100;
-		}
-		break;
-	}
-
-	if (state->algo == STV090x_WARM_SEARCH)
-		state->DemodTimeout /= 2;
-}
-
-static int stv090x_set_srate(struct stv090x_state *state, u32 srate)
-{
-	u32 sym;
-
-	if (srate > 60000000) {
-		sym  = (srate << 4); /* SR * 2^16 / master_clk */
-		sym /= (state->internal->mclk >> 12);
-	} else if (srate > 6000000) {
-		sym  = (srate << 6);
-		sym /= (state->internal->mclk >> 10);
-	} else {
-		sym  = (srate << 9);
-		sym /= (state->internal->mclk >> 7);
-	}
-
-	if (STV090x_WRITE_DEMOD(state, SFRINIT1, (sym >> 8) & 0x7f) < 0) /* MSB */
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRINIT0, (sym & 0xff)) < 0) /* LSB */
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_set_max_srate(struct stv090x_state *state, u32 clk, u32 srate)
-{
-	u32 sym;
-
-	srate = 105 * (srate / 100);
-	if (srate > 60000000) {
-		sym  = (srate << 4); /* SR * 2^16 / master_clk */
-		sym /= (state->internal->mclk >> 12);
-	} else if (srate > 6000000) {
-		sym  = (srate << 6);
-		sym /= (state->internal->mclk >> 10);
-	} else {
-		sym  = (srate << 9);
-		sym /= (state->internal->mclk >> 7);
-	}
-
-	if (sym < 0x7fff) {
-		if (STV090x_WRITE_DEMOD(state, SFRUP1, (sym >> 8) & 0x7f) < 0) /* MSB */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, SFRUP0, sym & 0xff) < 0) /* LSB */
-			goto err;
-	} else {
-		if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x7f) < 0) /* MSB */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, SFRUP0, 0xff) < 0) /* LSB */
-			goto err;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_set_min_srate(struct stv090x_state *state, u32 clk, u32 srate)
-{
-	u32 sym;
-
-	srate = 95 * (srate / 100);
-	if (srate > 60000000) {
-		sym  = (srate << 4); /* SR * 2^16 / master_clk */
-		sym /= (state->internal->mclk >> 12);
-	} else if (srate > 6000000) {
-		sym  = (srate << 6);
-		sym /= (state->internal->mclk >> 10);
-	} else {
-		sym  = (srate << 9);
-		sym /= (state->internal->mclk >> 7);
-	}
-
-	if (STV090x_WRITE_DEMOD(state, SFRLOW1, ((sym >> 8) & 0x7f)) < 0) /* MSB */
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRLOW0, (sym & 0xff)) < 0) /* LSB */
-		goto err;
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static u32 stv090x_car_width(u32 srate, enum stv090x_rolloff rolloff)
-{
-	u32 ro;
-
-	switch (rolloff) {
-	case STV090x_RO_20:
-		ro = 20;
-		break;
-	case STV090x_RO_25:
-		ro = 25;
-		break;
-	case STV090x_RO_35:
-	default:
-		ro = 35;
-		break;
-	}
-
-	return srate + (srate * ro) / 100;
-}
-
-static int stv090x_set_vit_thacq(struct stv090x_state *state)
-{
-	if (STV090x_WRITE_DEMOD(state, VTH12, 0x96) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH23, 0x64) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH34, 0x36) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH56, 0x23) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH67, 0x1e) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH78, 0x19) < 0)
-		goto err;
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_set_vit_thtracq(struct stv090x_state *state)
-{
-	if (STV090x_WRITE_DEMOD(state, VTH12, 0xd0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH23, 0x7d) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH34, 0x53) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH56, 0x2f) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH67, 0x24) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, VTH78, 0x1f) < 0)
-		goto err;
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_set_viterbi(struct stv090x_state *state)
-{
-	switch (state->search_mode) {
-	case STV090x_SEARCH_AUTO:
-		if (STV090x_WRITE_DEMOD(state, FECM, 0x10) < 0) /* DVB-S and DVB-S2 */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, PRVIT, 0x3f) < 0) /* all puncture rate */
-			goto err;
-		break;
-	case STV090x_SEARCH_DVBS1:
-		if (STV090x_WRITE_DEMOD(state, FECM, 0x00) < 0) /* disable DSS */
-			goto err;
-		switch (state->fec) {
-		case STV090x_PR12:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x01) < 0)
-				goto err;
-			break;
-
-		case STV090x_PR23:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x02) < 0)
-				goto err;
-			break;
-
-		case STV090x_PR34:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x04) < 0)
-				goto err;
-			break;
-
-		case STV090x_PR56:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x08) < 0)
-				goto err;
-			break;
-
-		case STV090x_PR78:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x20) < 0)
-				goto err;
-			break;
-
-		default:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x2f) < 0) /* all */
-				goto err;
-			break;
-		}
-		break;
-	case STV090x_SEARCH_DSS:
-		if (STV090x_WRITE_DEMOD(state, FECM, 0x80) < 0)
-			goto err;
-		switch (state->fec) {
-		case STV090x_PR12:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x01) < 0)
-				goto err;
-			break;
-
-		case STV090x_PR23:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x02) < 0)
-				goto err;
-			break;
-
-		case STV090x_PR67:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x10) < 0)
-				goto err;
-			break;
-
-		default:
-			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x13) < 0) /* 1/2, 2/3, 6/7 */
-				goto err;
-			break;
-		}
-		break;
-	default:
-		break;
-	}
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_stop_modcod(struct stv090x_state *state)
-{
-	if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0xff) < 0)
-		goto err;
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_activate_modcod(struct stv090x_state *state)
-{
-	if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xfc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0xcc) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0xcf) < 0)
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_activate_modcod_single(struct stv090x_state *state)
-{
-
-	if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xf0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0x0f) < 0)
-		goto err;
-
-	return 0;
-
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_vitclk_ctl(struct stv090x_state *state, int enable)
-{
-	u32 reg;
-
-	switch (state->demod) {
-	case STV090x_DEMODULATOR_0:
-		mutex_lock(&state->internal->demod_lock);
-		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
-		STV090x_SETFIELD(reg, STOP_CLKVIT1_FIELD, enable);
-		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
-			goto err;
-		mutex_unlock(&state->internal->demod_lock);
-		break;
-
-	case STV090x_DEMODULATOR_1:
-		mutex_lock(&state->internal->demod_lock);
-		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
-		STV090x_SETFIELD(reg, STOP_CLKVIT2_FIELD, enable);
-		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
-			goto err;
-		mutex_unlock(&state->internal->demod_lock);
-		break;
-
-	default:
-		dprintk(FE_ERROR, 1, "Wrong demodulator!");
-		break;
-	}
-	return 0;
-err:
-	mutex_unlock(&state->internal->demod_lock);
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_dvbs_track_crl(struct stv090x_state *state)
-{
-	if (state->internal->dev_ver >= 0x30) {
-		/* Set ACLC BCLC optimised value vs SR */
-		if (state->srate >= 15000000) {
-			if (STV090x_WRITE_DEMOD(state, ACLC, 0x2b) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, BCLC, 0x1a) < 0)
-				goto err;
-		} else if ((state->srate >= 7000000) && (15000000 > state->srate)) {
-			if (STV090x_WRITE_DEMOD(state, ACLC, 0x0c) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, BCLC, 0x1b) < 0)
-				goto err;
-		} else if (state->srate < 7000000) {
-			if (STV090x_WRITE_DEMOD(state, ACLC, 0x2c) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, BCLC, 0x1c) < 0)
-				goto err;
-		}
-
-	} else {
-		/* Cut 2.0 */
-		if (STV090x_WRITE_DEMOD(state, ACLC, 0x1a) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, BCLC, 0x09) < 0)
-			goto err;
-	}
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_delivery_search(struct stv090x_state *state)
-{
-	u32 reg;
-
-	switch (state->search_mode) {
-	case STV090x_SEARCH_DVBS1:
-	case STV090x_SEARCH_DSS:
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-
-		/* Activate Viterbi decoder in legacy search,
-		 * do not use FRESVIT1, might impact VITERBI2
-		 */
-		if (stv090x_vitclk_ctl(state, 0) < 0)
-			goto err;
-
-		if (stv090x_dvbs_track_crl(state) < 0)
-			goto err;
-
-		if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x22) < 0) /* disable DVB-S2 */
-			goto err;
-
-		if (stv090x_set_vit_thacq(state) < 0)
-			goto err;
-		if (stv090x_set_viterbi(state) < 0)
-			goto err;
-		break;
-
-	case STV090x_SEARCH_DVBS2:
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 0);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-
-		if (stv090x_vitclk_ctl(state, 1) < 0)
-			goto err;
-
-		if (STV090x_WRITE_DEMOD(state, ACLC, 0x1a) < 0) /* stop DVB-S CR loop */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, BCLC, 0x09) < 0)
-			goto err;
-
-		if (state->internal->dev_ver <= 0x20) {
-			/* enable S2 carrier loop */
-			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x26) < 0)
-				goto err;
-		} else {
-			/* > Cut 3: Stop carrier 3 */
-			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x66) < 0)
-				goto err;
-		}
-
-		if (state->demod_mode != STV090x_SINGLE) {
-			/* Cut 2: enable link during search */
-			if (stv090x_activate_modcod(state) < 0)
-				goto err;
-		} else {
-			/* Single demodulator
-			 * Authorize SHORT and LONG frames,
-			 * QPSK, 8PSK, 16APSK and 32APSK
-			 */
-			if (stv090x_activate_modcod_single(state) < 0)
-				goto err;
-		}
-
-		if (stv090x_set_vit_thtracq(state) < 0)
-			goto err;
-		break;
-
-	case STV090x_SEARCH_AUTO:
-	default:
-		/* enable DVB-S2 and DVB-S2 in Auto MODE */
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 0);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-
-		if (stv090x_vitclk_ctl(state, 0) < 0)
-			goto err;
-
-		if (stv090x_dvbs_track_crl(state) < 0)
-			goto err;
-
-		if (state->internal->dev_ver <= 0x20) {
-			/* enable S2 carrier loop */
-			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x26) < 0)
-				goto err;
-		} else {
-			/* > Cut 3: Stop carrier 3 */
-			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x66) < 0)
-				goto err;
-		}
-
-		if (state->demod_mode != STV090x_SINGLE) {
-			/* Cut 2: enable link during search */
-			if (stv090x_activate_modcod(state) < 0)
-				goto err;
-		} else {
-			/* Single demodulator
-			 * Authorize SHORT and LONG frames,
-			 * QPSK, 8PSK, 16APSK and 32APSK
-			 */
-			if (stv090x_activate_modcod_single(state) < 0)
-				goto err;
-		}
-
-		if (stv090x_set_vit_thacq(state) < 0)
-			goto err;
-
-		if (stv090x_set_viterbi(state) < 0)
-			goto err;
-		break;
-	}
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_start_search(struct stv090x_state *state)
-{
-	u32 reg, freq_abs;
-	s16 freq;
-
-	/* Reset demodulator */
-	reg = STV090x_READ_DEMOD(state, DMDISTATE);
-	STV090x_SETFIELD_Px(reg, I2C_DEMOD_MODE_FIELD, 0x1f);
-	if (STV090x_WRITE_DEMOD(state, DMDISTATE, reg) < 0)
-		goto err;
-
-	if (state->internal->dev_ver <= 0x20) {
-		if (state->srate <= 5000000) {
-			if (STV090x_WRITE_DEMOD(state, CARCFG, 0x44) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CFRUP1, 0x0f) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CFRUP0, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CFRLOW1, 0xf0) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CFRLOW0, 0x00) < 0)
-				goto err;
-
-			/*enlarge the timing bandwidth for Low SR*/
-			if (STV090x_WRITE_DEMOD(state, RTCS2, 0x68) < 0)
-				goto err;
-		} else {
-			/* If the symbol rate is >5 Msps
-			Set The carrier search up and low to auto mode */
-			if (STV090x_WRITE_DEMOD(state, CARCFG, 0xc4) < 0)
-				goto err;
-			/*reduce the timing bandwidth for high SR*/
-			if (STV090x_WRITE_DEMOD(state, RTCS2, 0x44) < 0)
-				goto err;
-		}
-	} else {
-		/* >= Cut 3 */
-		if (state->srate <= 5000000) {
-			/* enlarge the timing bandwidth for Low SR */
-			STV090x_WRITE_DEMOD(state, RTCS2, 0x68);
-		} else {
-			/* reduce timing bandwidth for high SR */
-			STV090x_WRITE_DEMOD(state, RTCS2, 0x44);
-		}
-
-		/* Set CFR min and max to manual mode */
-		STV090x_WRITE_DEMOD(state, CARCFG, 0x46);
-
-		if (state->algo == STV090x_WARM_SEARCH) {
-			/* WARM Start
-			 * CFR min = -1MHz,
-			 * CFR max = +1MHz
-			 */
-			freq_abs  = 1000 << 16;
-			freq_abs /= (state->internal->mclk / 1000);
-			freq      = (s16) freq_abs;
-		} else {
-			/* COLD Start
-			 * CFR min =- (SearchRange / 2 + 600KHz)
-			 * CFR max = +(SearchRange / 2 + 600KHz)
-			 * (600KHz for the tuner step size)
-			 */
-			freq_abs  = (state->search_range / 2000) + 600;
-			freq_abs  = freq_abs << 16;
-			freq_abs /= (state->internal->mclk / 1000);
-			freq      = (s16) freq_abs;
-		}
-
-		if (STV090x_WRITE_DEMOD(state, CFRUP1, MSB(freq)) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRUP0, LSB(freq)) < 0)
-			goto err;
-
-		freq *= -1;
-
-		if (STV090x_WRITE_DEMOD(state, CFRLOW1, MSB(freq)) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRLOW0, LSB(freq)) < 0)
-			goto err;
-
-	}
-
-	if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0) < 0)
-		goto err;
-
-	if (state->internal->dev_ver >= 0x20) {
-		if (STV090x_WRITE_DEMOD(state, EQUALCFG, 0x41) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, FFECFG, 0x41) < 0)
-			goto err;
-
-		if ((state->search_mode == STV090x_SEARCH_DVBS1)	||
-			(state->search_mode == STV090x_SEARCH_DSS)	||
-			(state->search_mode == STV090x_SEARCH_AUTO)) {
-
-			if (STV090x_WRITE_DEMOD(state, VITSCALE, 0x82) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, VAVSRVIT, 0x00) < 0)
-				goto err;
-		}
-	}
-
-	if (STV090x_WRITE_DEMOD(state, SFRSTEP, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0xe0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0xc0) < 0)
-		goto err;
-
-	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-	STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 0);
-	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-		goto err;
-	reg = STV090x_READ_DEMOD(state, DMDCFG2);
-	STV090x_SETFIELD_Px(reg, S1S2_SEQUENTIAL_FIELD, 0x0);
-	if (STV090x_WRITE_DEMOD(state, DMDCFG2, reg) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, RTC, 0x88) < 0)
-		goto err;
-
-	if (state->internal->dev_ver >= 0x20) {
-		/*Frequency offset detector setting*/
-		if (state->srate < 2000000) {
-			if (state->internal->dev_ver <= 0x20) {
-				/* Cut 2 */
-				if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x39) < 0)
-					goto err;
-			} else {
-				/* Cut 3 */
-				if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x89) < 0)
-					goto err;
-			}
-			if (STV090x_WRITE_DEMOD(state, CARHDR, 0x40) < 0)
-				goto err;
-		} else if (state->srate < 10000000) {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x4c) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CARHDR, 0x20) < 0)
-				goto err;
-		} else {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x4b) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CARHDR, 0x20) < 0)
-				goto err;
-		}
-	} else {
-		if (state->srate < 10000000) {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0xef) < 0)
-				goto err;
-		} else {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0xed) < 0)
-				goto err;
-		}
-	}
-
-	switch (state->algo) {
-	case STV090x_WARM_SEARCH:
-		/* The symbol rate and the exact
-		 * carrier Frequency are known
-		 */
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
-			goto err;
-		break;
-
-	case STV090x_COLD_SEARCH:
-		/* The symbol rate is known */
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0)
-			goto err;
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_get_agc2_min_level(struct stv090x_state *state)
-{
-	u32 agc2_min = 0xffff, agc2 = 0, freq_init, freq_step, reg;
-	s32 i, j, steps, dir;
-
-	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
-		goto err;
-	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-	STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 0);
-	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x83) < 0) /* SR = 65 Msps Max */
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRUP0, 0xc0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRLOW1, 0x82) < 0) /* SR= 400 ksps Min */
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRLOW0, 0xa0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x00) < 0) /* stop acq @ coarse carrier state */
-		goto err;
-	if (stv090x_set_srate(state, 1000000) < 0)
-		goto err;
-
-	steps  = state->search_range / 1000000;
-	if (steps <= 0)
-		steps = 1;
-
-	dir = 1;
-	freq_step = (1000000 * 256) / (state->internal->mclk / 256);
-	freq_init = 0;
-
-	for (i = 0; i < steps; i++) {
-		if (dir > 0)
-			freq_init = freq_init + (freq_step * i);
-		else
-			freq_init = freq_init - (freq_step * i);
-
-		dir *= -1;
-
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x5c) < 0) /* Demod RESET */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT1, (freq_init >> 8) & 0xff) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT0, freq_init & 0xff) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x58) < 0) /* Demod RESET */
-			goto err;
-		msleep(10);
-
-		agc2 = 0;
-		for (j = 0; j < 10; j++) {
-			agc2 += (STV090x_READ_DEMOD(state, AGC2I1) << 8) |
-				STV090x_READ_DEMOD(state, AGC2I0);
-		}
-		agc2 /= 10;
-		if (agc2 < agc2_min)
-			agc2_min = agc2;
-	}
-
-	return agc2_min;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static u32 stv090x_get_srate(struct stv090x_state *state, u32 clk)
-{
-	u8 r3, r2, r1, r0;
-	s32 srate, int_1, int_2, tmp_1, tmp_2;
-
-	r3 = STV090x_READ_DEMOD(state, SFR3);
-	r2 = STV090x_READ_DEMOD(state, SFR2);
-	r1 = STV090x_READ_DEMOD(state, SFR1);
-	r0 = STV090x_READ_DEMOD(state, SFR0);
-
-	srate = ((r3 << 24) | (r2 << 16) | (r1 <<  8) | r0);
-
-	int_1 = clk >> 16;
-	int_2 = srate >> 16;
-
-	tmp_1 = clk % 0x10000;
-	tmp_2 = srate % 0x10000;
-
-	srate = (int_1 * int_2) +
-		((int_1 * tmp_2) >> 16) +
-		((int_2 * tmp_1) >> 16);
-
-	return srate;
-}
-
-static u32 stv090x_srate_srch_coarse(struct stv090x_state *state)
-{
-	struct dvb_frontend *fe = &state->frontend;
-
-	int tmg_lock = 0, i;
-	s32 tmg_cpt = 0, dir = 1, steps, cur_step = 0, freq;
-	u32 srate_coarse = 0, agc2 = 0, car_step = 1200, reg;
-	u32 agc2th;
-
-	if (state->internal->dev_ver >= 0x30)
-		agc2th = 0x2e00;
-	else
-		agc2th = 0x1f00;
-
-	reg = STV090x_READ_DEMOD(state, DMDISTATE);
-	STV090x_SETFIELD_Px(reg, I2C_DEMOD_MODE_FIELD, 0x1f); /* Demod RESET */
-	if (STV090x_WRITE_DEMOD(state, DMDISTATE, reg) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGCFG, 0x12) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0xf0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0xe0) < 0)
-		goto err;
-	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-	STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 1);
-	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x83) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRUP0, 0xc0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRLOW1, 0x82) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, SFRLOW0, 0xa0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x50) < 0)
-		goto err;
-
-	if (state->internal->dev_ver >= 0x30) {
-		if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x99) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, SFRSTEP, 0x98) < 0)
-			goto err;
-
-	} else if (state->internal->dev_ver >= 0x20) {
-		if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x6a) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, SFRSTEP, 0x95) < 0)
-			goto err;
-	}
-
-	if (state->srate <= 2000000)
-		car_step = 1000;
-	else if (state->srate <= 5000000)
-		car_step = 2000;
-	else if (state->srate <= 12000000)
-		car_step = 3000;
-	else
-		car_step = 5000;
-
-	steps  = -1 + ((state->search_range / 1000) / car_step);
-	steps /= 2;
-	steps  = (2 * steps) + 1;
-	if (steps < 0)
-		steps = 1;
-	else if (steps > 10) {
-		steps = 11;
-		car_step = (state->search_range / 1000) / 10;
-	}
-	cur_step = 0;
-	dir = 1;
-	freq = state->frequency;
-
-	while ((!tmg_lock) && (cur_step < steps)) {
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x5f) < 0) /* Demod RESET */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0x00) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0x00) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, SFRINIT1, 0x00) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, SFRINIT0, 0x00) < 0)
-			goto err;
-		/* trigger acquisition */
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x40) < 0)
-			goto err;
-		msleep(50);
-		for (i = 0; i < 10; i++) {
-			reg = STV090x_READ_DEMOD(state, DSTATUS);
-			if (STV090x_GETFIELD_Px(reg, TMGLOCK_QUALITY_FIELD) >= 2)
-				tmg_cpt++;
-			agc2 += (STV090x_READ_DEMOD(state, AGC2I1) << 8) |
-				STV090x_READ_DEMOD(state, AGC2I0);
-		}
-		agc2 /= 10;
-		srate_coarse = stv090x_get_srate(state, state->internal->mclk);
-		cur_step++;
-		dir *= -1;
-		if ((tmg_cpt >= 5) && (agc2 < agc2th) &&
-		    (srate_coarse < 50000000) && (srate_coarse > 850000))
-			tmg_lock = 1;
-		else if (cur_step < steps) {
-			if (dir > 0)
-				freq += cur_step * car_step;
-			else
-				freq -= cur_step * car_step;
-
-			/* Setup tuner */
-			if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-				goto err;
-
-			if (state->config->tuner_set_frequency) {
-				if (state->config->tuner_set_frequency(fe, freq) < 0)
-					goto err_gateoff;
-			}
-
-			if (state->config->tuner_set_bandwidth) {
-				if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
-					goto err_gateoff;
-			}
-
-			if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-				goto err;
-
-			msleep(50);
-
-			if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-				goto err;
-
-			if (state->config->tuner_get_status) {
-				if (state->config->tuner_get_status(fe, &reg) < 0)
-					goto err_gateoff;
-			}
-
-			if (reg)
-				dprintk(FE_DEBUG, 1, "Tuner phase locked");
-			else
-				dprintk(FE_DEBUG, 1, "Tuner unlocked");
-
-			if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-				goto err;
-
-		}
-	}
-	if (!tmg_lock)
-		srate_coarse = 0;
-	else
-		srate_coarse = stv090x_get_srate(state, state->internal->mclk);
-
-	return srate_coarse;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static u32 stv090x_srate_srch_fine(struct stv090x_state *state)
-{
-	u32 srate_coarse, freq_coarse, sym, reg;
-
-	srate_coarse = stv090x_get_srate(state, state->internal->mclk);
-	freq_coarse  = STV090x_READ_DEMOD(state, CFR2) << 8;
-	freq_coarse |= STV090x_READ_DEMOD(state, CFR1);
-	sym = 13 * (srate_coarse / 10); /* SFRUP = SFR + 30% */
-
-	if (sym < state->srate)
-		srate_coarse = 0;
-	else {
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0) /* Demod RESET */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc1) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0x20) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0x00) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, TMGCFG, 0xd2) < 0)
-			goto err;
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0x00);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-
-		if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
-			goto err;
-
-		if (state->internal->dev_ver >= 0x30) {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x79) < 0)
-				goto err;
-		} else if (state->internal->dev_ver >= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x49) < 0)
-				goto err;
-		}
-
-		if (srate_coarse > 3000000) {
-			sym  = 13 * (srate_coarse / 10); /* SFRUP = SFR + 30% */
-			sym  = (sym / 1000) * 65536;
-			sym /= (state->internal->mclk / 1000);
-			if (STV090x_WRITE_DEMOD(state, SFRUP1, (sym >> 8) & 0x7f) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, SFRUP0, sym & 0xff) < 0)
-				goto err;
-			sym  = 10 * (srate_coarse / 13); /* SFRLOW = SFR - 30% */
-			sym  = (sym / 1000) * 65536;
-			sym /= (state->internal->mclk / 1000);
-			if (STV090x_WRITE_DEMOD(state, SFRLOW1, (sym >> 8) & 0x7f) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, SFRLOW0, sym & 0xff) < 0)
-				goto err;
-			sym  = (srate_coarse / 1000) * 65536;
-			sym /= (state->internal->mclk / 1000);
-			if (STV090x_WRITE_DEMOD(state, SFRINIT1, (sym >> 8) & 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, SFRINIT0, sym & 0xff) < 0)
-				goto err;
-		} else {
-			sym  = 13 * (srate_coarse / 10); /* SFRUP = SFR + 30% */
-			sym  = (sym / 100) * 65536;
-			sym /= (state->internal->mclk / 100);
-			if (STV090x_WRITE_DEMOD(state, SFRUP1, (sym >> 8) & 0x7f) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, SFRUP0, sym & 0xff) < 0)
-				goto err;
-			sym  = 10 * (srate_coarse / 14); /* SFRLOW = SFR - 30% */
-			sym  = (sym / 100) * 65536;
-			sym /= (state->internal->mclk / 100);
-			if (STV090x_WRITE_DEMOD(state, SFRLOW1, (sym >> 8) & 0x7f) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, SFRLOW0, sym & 0xff) < 0)
-				goto err;
-			sym  = (srate_coarse / 100) * 65536;
-			sym /= (state->internal->mclk / 100);
-			if (STV090x_WRITE_DEMOD(state, SFRINIT1, (sym >> 8) & 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, SFRINIT0, sym & 0xff) < 0)
-				goto err;
-		}
-		if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x20) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT1, (freq_coarse >> 8) & 0xff) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT0, freq_coarse & 0xff) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0) /* trigger acquisition */
-			goto err;
-	}
-
-	return srate_coarse;
-
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_get_dmdlock(struct stv090x_state *state, s32 timeout)
-{
-	s32 timer = 0, lock = 0;
-	u32 reg;
-	u8 stat;
-
-	while ((timer < timeout) && (!lock)) {
-		reg = STV090x_READ_DEMOD(state, DMDSTATE);
-		stat = STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD);
-
-		switch (stat) {
-		case 0: /* searching */
-		case 1: /* first PLH detected */
-		default:
-			dprintk(FE_DEBUG, 1, "Demodulator searching ..");
-			lock = 0;
-			break;
-		case 2: /* DVB-S2 mode */
-		case 3: /* DVB-S1/legacy mode */
-			reg = STV090x_READ_DEMOD(state, DSTATUS);
-			lock = STV090x_GETFIELD_Px(reg, LOCK_DEFINITIF_FIELD);
-			break;
-		}
-
-		if (!lock)
-			msleep(10);
-		else
-			dprintk(FE_DEBUG, 1, "Demodulator acquired LOCK");
-
-		timer += 10;
-	}
-	return lock;
-}
-
-static int stv090x_blind_search(struct stv090x_state *state)
-{
-	u32 agc2, reg, srate_coarse;
-	s32 cpt_fail, agc2_ovflw, i;
-	u8 k_ref, k_max, k_min;
-	int coarse_fail = 0;
-	int lock;
-
-	k_max = 110;
-	k_min = 10;
-
-	agc2 = stv090x_get_agc2_min_level(state);
-
-	if (agc2 > STV090x_SEARCH_AGC2_TH(state->internal->dev_ver)) {
-		lock = 0;
-	} else {
-
-		if (state->internal->dev_ver <= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, CARCFG, 0xc4) < 0)
-				goto err;
-		} else {
-			/* > Cut 3 */
-			if (STV090x_WRITE_DEMOD(state, CARCFG, 0x06) < 0)
-				goto err;
-		}
-
-		if (STV090x_WRITE_DEMOD(state, RTCS2, 0x44) < 0)
-			goto err;
-
-		if (state->internal->dev_ver >= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, EQUALCFG, 0x41) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, FFECFG, 0x41) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, VITSCALE, 0x82) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, VAVSRVIT, 0x00) < 0) /* set viterbi hysteresis */
-				goto err;
-		}
-
-		k_ref = k_max;
-		do {
-			if (STV090x_WRITE_DEMOD(state, KREFTMG, k_ref) < 0)
-				goto err;
-			if (stv090x_srate_srch_coarse(state) != 0) {
-				srate_coarse = stv090x_srate_srch_fine(state);
-				if (srate_coarse != 0) {
-					stv090x_get_lock_tmg(state);
-					lock = stv090x_get_dmdlock(state,
-							state->DemodTimeout);
-				} else {
-					lock = 0;
-				}
-			} else {
-				cpt_fail = 0;
-				agc2_ovflw = 0;
-				for (i = 0; i < 10; i++) {
-					agc2 += (STV090x_READ_DEMOD(state, AGC2I1) << 8) |
-						STV090x_READ_DEMOD(state, AGC2I0);
-					if (agc2 >= 0xff00)
-						agc2_ovflw++;
-					reg = STV090x_READ_DEMOD(state, DSTATUS2);
-					if ((STV090x_GETFIELD_Px(reg, CFR_OVERFLOW_FIELD) == 0x01) &&
-					    (STV090x_GETFIELD_Px(reg, DEMOD_DELOCK_FIELD) == 0x01))
-
-						cpt_fail++;
-				}
-				if ((cpt_fail > 7) || (agc2_ovflw > 7))
-					coarse_fail = 1;
-
-				lock = 0;
-			}
-			k_ref -= 20;
-		} while ((k_ref >= k_min) && (!lock) && (!coarse_fail));
-	}
-
-	return lock;
-
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_chk_tmg(struct stv090x_state *state)
-{
-	u32 reg;
-	s32 tmg_cpt = 0, i;
-	u8 freq, tmg_thh, tmg_thl;
-	int tmg_lock = 0;
-
-	freq = STV090x_READ_DEMOD(state, CARFREQ);
-	tmg_thh = STV090x_READ_DEMOD(state, TMGTHRISE);
-	tmg_thl = STV090x_READ_DEMOD(state, TMGTHFALL);
-	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0x20) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0x00) < 0)
-		goto err;
-
-	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0x00); /* stop carrier offset search */
-	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, RTC, 0x80) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, RTCS2, 0x40) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x00) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0x00) < 0) /* set car ofset to 0 */
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0x00) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x65) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0) /* trigger acquisition */
-		goto err;
-	msleep(10);
-
-	for (i = 0; i < 10; i++) {
-		reg = STV090x_READ_DEMOD(state, DSTATUS);
-		if (STV090x_GETFIELD_Px(reg, TMGLOCK_QUALITY_FIELD) >= 2)
-			tmg_cpt++;
-		msleep(1);
-	}
-	if (tmg_cpt >= 3)
-		tmg_lock = 1;
-
-	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, RTC, 0x88) < 0) /* DVB-S1 timing */
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, RTCS2, 0x68) < 0) /* DVB-S2 timing */
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, CARFREQ, freq) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, tmg_thh) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, tmg_thl) < 0)
-		goto err;
-
-	return	tmg_lock;
-
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_get_coldlock(struct stv090x_state *state, s32 timeout_dmd)
-{
-	struct dvb_frontend *fe = &state->frontend;
-
-	u32 reg;
-	s32 car_step, steps, cur_step, dir, freq, timeout_lock;
-	int lock = 0;
-
-	if (state->srate >= 10000000)
-		timeout_lock = timeout_dmd / 3;
-	else
-		timeout_lock = timeout_dmd / 2;
-
-	lock = stv090x_get_dmdlock(state, timeout_lock); /* cold start wait */
-	if (!lock) {
-		if (state->srate >= 10000000) {
-			if (stv090x_chk_tmg(state)) {
-				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0)
-					goto err;
-				lock = stv090x_get_dmdlock(state, timeout_dmd);
-			} else {
-				lock = 0;
-			}
-		} else {
-			if (state->srate <= 4000000)
-				car_step = 1000;
-			else if (state->srate <= 7000000)
-				car_step = 2000;
-			else if (state->srate <= 10000000)
-				car_step = 3000;
-			else
-				car_step = 5000;
-
-			steps  = (state->search_range / 1000) / car_step;
-			steps /= 2;
-			steps  = 2 * (steps + 1);
-			if (steps < 0)
-				steps = 2;
-			else if (steps > 12)
-				steps = 12;
-
-			cur_step = 1;
-			dir = 1;
-
-			if (!lock) {
-				freq = state->frequency;
-				state->tuner_bw = stv090x_car_width(state->srate, state->rolloff) + state->srate;
-				while ((cur_step <= steps) && (!lock)) {
-					if (dir > 0)
-						freq += cur_step * car_step;
-					else
-						freq -= cur_step * car_step;
-
-					/* Setup tuner */
-					if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-						goto err;
-
-					if (state->config->tuner_set_frequency) {
-						if (state->config->tuner_set_frequency(fe, freq) < 0)
-							goto err_gateoff;
-					}
-
-					if (state->config->tuner_set_bandwidth) {
-						if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
-							goto err_gateoff;
-					}
-
-					if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-						goto err;
-
-					msleep(50);
-
-					if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-						goto err;
-
-					if (state->config->tuner_get_status) {
-						if (state->config->tuner_get_status(fe, &reg) < 0)
-							goto err_gateoff;
-					}
-
-					if (reg)
-						dprintk(FE_DEBUG, 1, "Tuner phase locked");
-					else
-						dprintk(FE_DEBUG, 1, "Tuner unlocked");
-
-					if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-						goto err;
-
-					STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1c);
-					if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0x00) < 0)
-						goto err;
-					if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0x00) < 0)
-						goto err;
-					if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
-						goto err;
-					if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0)
-						goto err;
-					lock = stv090x_get_dmdlock(state, (timeout_dmd / 3));
-
-					dir *= -1;
-					cur_step++;
-				}
-			}
-		}
-	}
-
-	return lock;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_get_loop_params(struct stv090x_state *state, s32 *freq_inc, s32 *timeout_sw, s32 *steps)
-{
-	s32 timeout, inc, steps_max, srate, car_max;
-
-	srate = state->srate;
-	car_max = state->search_range / 1000;
-	car_max += car_max / 10;
-	car_max  = 65536 * (car_max / 2);
-	car_max /= (state->internal->mclk / 1000);
-
-	if (car_max > 0x4000)
-		car_max = 0x4000 ; /* maxcarrier should be<= +-1/4 Mclk */
-
-	inc  = srate;
-	inc /= state->internal->mclk / 1000;
-	inc *= 256;
-	inc *= 256;
-	inc /= 1000;
-
-	switch (state->search_mode) {
-	case STV090x_SEARCH_DVBS1:
-	case STV090x_SEARCH_DSS:
-		inc *= 3; /* freq step = 3% of srate */
-		timeout = 20;
-		break;
-
-	case STV090x_SEARCH_DVBS2:
-		inc *= 4;
-		timeout = 25;
-		break;
-
-	case STV090x_SEARCH_AUTO:
-	default:
-		inc *= 3;
-		timeout = 25;
-		break;
-	}
-	inc /= 100;
-	if ((inc > car_max) || (inc < 0))
-		inc = car_max / 2; /* increment <= 1/8 Mclk */
-
-	timeout *= 27500; /* 27.5 Msps reference */
-	if (srate > 0)
-		timeout /= (srate / 1000);
-
-	if ((timeout > 100) || (timeout < 0))
-		timeout = 100;
-
-	steps_max = (car_max / inc) + 1; /* min steps = 3 */
-	if ((steps_max > 100) || (steps_max < 0)) {
-		steps_max = 100; /* max steps <= 100 */
-		inc = car_max / steps_max;
-	}
-	*freq_inc = inc;
-	*timeout_sw = timeout;
-	*steps = steps_max;
-
-	return 0;
-}
-
-static int stv090x_chk_signal(struct stv090x_state *state)
-{
-	s32 offst_car, agc2, car_max;
-	int no_signal;
-
-	offst_car  = STV090x_READ_DEMOD(state, CFR2) << 8;
-	offst_car |= STV090x_READ_DEMOD(state, CFR1);
-	offst_car = comp2(offst_car, 16);
-
-	agc2  = STV090x_READ_DEMOD(state, AGC2I1) << 8;
-	agc2 |= STV090x_READ_DEMOD(state, AGC2I0);
-	car_max = state->search_range / 1000;
-
-	car_max += (car_max / 10); /* 10% margin */
-	car_max  = (65536 * car_max / 2);
-	car_max /= state->internal->mclk / 1000;
-
-	if (car_max > 0x4000)
-		car_max = 0x4000;
-
-	if ((agc2 > 0x2000) || (offst_car > 2 * car_max) || (offst_car < -2 * car_max)) {
-		no_signal = 1;
-		dprintk(FE_DEBUG, 1, "No Signal");
-	} else {
-		no_signal = 0;
-		dprintk(FE_DEBUG, 1, "Found Signal");
-	}
-
-	return no_signal;
-}
-
-static int stv090x_search_car_loop(struct stv090x_state *state, s32 inc, s32 timeout, int zigzag, s32 steps_max)
-{
-	int no_signal, lock = 0;
-	s32 cpt_step = 0, offst_freq, car_max;
-	u32 reg;
-
-	car_max  = state->search_range / 1000;
-	car_max += (car_max / 10);
-	car_max  = (65536 * car_max / 2);
-	car_max /= (state->internal->mclk / 1000);
-	if (car_max > 0x4000)
-		car_max = 0x4000;
-
-	if (zigzag)
-		offst_freq = 0;
-	else
-		offst_freq = -car_max + inc;
-
-	do {
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1c) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT1, ((offst_freq / 256) & 0xff)) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT0, offst_freq & 0xff) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
-			goto err;
-
-		reg = STV090x_READ_DEMOD(state, PDELCTRL1);
-		STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0x1); /* stop DVB-S2 packet delin */
-		if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
-			goto err;
-
-		if (zigzag) {
-			if (offst_freq >= 0)
-				offst_freq = -offst_freq - 2 * inc;
-			else
-				offst_freq = -offst_freq;
-		} else {
-			offst_freq += 2 * inc;
-		}
-
-		cpt_step++;
-
-		lock = stv090x_get_dmdlock(state, timeout);
-		no_signal = stv090x_chk_signal(state);
-
-	} while ((!lock) &&
-		 (!no_signal) &&
-		  ((offst_freq - inc) < car_max) &&
-		  ((offst_freq + inc) > -car_max) &&
-		  (cpt_step < steps_max));
-
-	reg = STV090x_READ_DEMOD(state, PDELCTRL1);
-	STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
-			goto err;
-
-	return lock;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_sw_algo(struct stv090x_state *state)
-{
-	int no_signal, zigzag, lock = 0;
-	u32 reg;
-
-	s32 dvbs2_fly_wheel;
-	s32 inc, timeout_step, trials, steps_max;
-
-	/* get params */
-	stv090x_get_loop_params(state, &inc, &timeout_step, &steps_max);
-
-	switch (state->search_mode) {
-	case STV090x_SEARCH_DVBS1:
-	case STV090x_SEARCH_DSS:
-		/* accelerate the frequency detector */
-		if (state->internal->dev_ver >= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x3B) < 0)
-				goto err;
-		}
-
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0x49) < 0)
-			goto err;
-		zigzag = 0;
-		break;
-
-	case STV090x_SEARCH_DVBS2:
-		if (state->internal->dev_ver >= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x79) < 0)
-				goto err;
-		}
-
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0x89) < 0)
-			goto err;
-		zigzag = 1;
-		break;
-
-	case STV090x_SEARCH_AUTO:
-	default:
-		/* accelerate the frequency detector */
-		if (state->internal->dev_ver >= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x3b) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x79) < 0)
-				goto err;
-		}
-
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0xc9) < 0)
-			goto err;
-		zigzag = 0;
-		break;
-	}
-
-	trials = 0;
-	do {
-		lock = stv090x_search_car_loop(state, inc, timeout_step, zigzag, steps_max);
-		no_signal = stv090x_chk_signal(state);
-		trials++;
-
-		/*run the SW search 2 times maximum*/
-		if (lock || no_signal || (trials == 2)) {
-			/*Check if the demod is not losing lock in DVBS2*/
-			if (state->internal->dev_ver >= 0x20) {
-				if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x49) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x9e) < 0)
-					goto err;
-			}
-
-			reg = STV090x_READ_DEMOD(state, DMDSTATE);
-			if ((lock) && (STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD) == STV090x_DVBS2)) {
-				/*Check if the demod is not losing lock in DVBS2*/
-				msleep(timeout_step);
-				reg = STV090x_READ_DEMOD(state, DMDFLYW);
-				dvbs2_fly_wheel = STV090x_GETFIELD_Px(reg, FLYWHEEL_CPT_FIELD);
-				if (dvbs2_fly_wheel < 0xd) {	 /*if correct frames is decrementing */
-					msleep(timeout_step);
-					reg = STV090x_READ_DEMOD(state, DMDFLYW);
-					dvbs2_fly_wheel = STV090x_GETFIELD_Px(reg, FLYWHEEL_CPT_FIELD);
-				}
-				if (dvbs2_fly_wheel < 0xd) {
-					/*FALSE lock, The demod is losing lock */
-					lock = 0;
-					if (trials < 2) {
-						if (state->internal->dev_ver >= 0x20) {
-							if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x79) < 0)
-								goto err;
-						}
-
-						if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0x89) < 0)
-							goto err;
-					}
-				}
-			}
-		}
-	} while ((!lock) && (trials < 2) && (!no_signal));
-
-	return lock;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static enum stv090x_delsys stv090x_get_std(struct stv090x_state *state)
-{
-	u32 reg;
-	enum stv090x_delsys delsys;
-
-	reg = STV090x_READ_DEMOD(state, DMDSTATE);
-	if (STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD) == 2)
-		delsys = STV090x_DVBS2;
-	else if (STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD) == 3) {
-		reg = STV090x_READ_DEMOD(state, FECM);
-		if (STV090x_GETFIELD_Px(reg, DSS_DVB_FIELD) == 1)
-			delsys = STV090x_DSS;
-		else
-			delsys = STV090x_DVBS1;
-	} else {
-		delsys = STV090x_ERROR;
-	}
-
-	return delsys;
-}
-
-/* in Hz */
-static s32 stv090x_get_car_freq(struct stv090x_state *state, u32 mclk)
-{
-	s32 derot, int_1, int_2, tmp_1, tmp_2;
-
-	derot  = STV090x_READ_DEMOD(state, CFR2) << 16;
-	derot |= STV090x_READ_DEMOD(state, CFR1) <<  8;
-	derot |= STV090x_READ_DEMOD(state, CFR0);
-
-	derot = comp2(derot, 24);
-	int_1 = mclk >> 12;
-	int_2 = derot >> 12;
-
-	/* carrier_frequency = MasterClock * Reg / 2^24 */
-	tmp_1 = mclk % 0x1000;
-	tmp_2 = derot % 0x1000;
-
-	derot = (int_1 * int_2) +
-		((int_1 * tmp_2) >> 12) +
-		((int_2 * tmp_1) >> 12);
-
-	return derot;
-}
-
-static int stv090x_get_viterbi(struct stv090x_state *state)
-{
-	u32 reg, rate;
-
-	reg = STV090x_READ_DEMOD(state, VITCURPUN);
-	rate = STV090x_GETFIELD_Px(reg, VIT_CURPUN_FIELD);
-
-	switch (rate) {
-	case 13:
-		state->fec = STV090x_PR12;
-		break;
-
-	case 18:
-		state->fec = STV090x_PR23;
-		break;
-
-	case 21:
-		state->fec = STV090x_PR34;
-		break;
-
-	case 24:
-		state->fec = STV090x_PR56;
-		break;
-
-	case 25:
-		state->fec = STV090x_PR67;
-		break;
-
-	case 26:
-		state->fec = STV090x_PR78;
-		break;
-
-	default:
-		state->fec = STV090x_PRERR;
-		break;
-	}
-
-	return 0;
-}
-
-static enum stv090x_signal_state stv090x_get_sig_params(struct stv090x_state *state)
-{
-	struct dvb_frontend *fe = &state->frontend;
-
-	u8 tmg;
-	u32 reg;
-	s32 i = 0, offst_freq;
-
-	msleep(5);
-
-	if (state->algo == STV090x_BLIND_SEARCH) {
-		tmg = STV090x_READ_DEMOD(state, TMGREG2);
-		STV090x_WRITE_DEMOD(state, SFRSTEP, 0x5c);
-		while ((i <= 50) && (tmg != 0) && (tmg != 0xff)) {
-			tmg = STV090x_READ_DEMOD(state, TMGREG2);
-			msleep(5);
-			i += 5;
-		}
-	}
-	state->delsys = stv090x_get_std(state);
-
-	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-		goto err;
-
-	if (state->config->tuner_get_frequency) {
-		if (state->config->tuner_get_frequency(fe, &state->frequency) < 0)
-			goto err_gateoff;
-	}
-
-	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-		goto err;
-
-	offst_freq = stv090x_get_car_freq(state, state->internal->mclk) / 1000;
-	state->frequency += offst_freq;
-
-	if (stv090x_get_viterbi(state) < 0)
-		goto err;
-
-	reg = STV090x_READ_DEMOD(state, DMDMODCOD);
-	state->modcod = STV090x_GETFIELD_Px(reg, DEMOD_MODCOD_FIELD);
-	state->pilots = STV090x_GETFIELD_Px(reg, DEMOD_TYPE_FIELD) & 0x01;
-	state->frame_len = STV090x_GETFIELD_Px(reg, DEMOD_TYPE_FIELD) >> 1;
-	reg = STV090x_READ_DEMOD(state, TMGOBS);
-	state->rolloff = STV090x_GETFIELD_Px(reg, ROLLOFF_STATUS_FIELD);
-	reg = STV090x_READ_DEMOD(state, FECM);
-	state->inversion = STV090x_GETFIELD_Px(reg, IQINV_FIELD);
-
-	if ((state->algo == STV090x_BLIND_SEARCH) || (state->srate < 10000000)) {
-
-		if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-			goto err;
-
-		if (state->config->tuner_get_frequency) {
-			if (state->config->tuner_get_frequency(fe, &state->frequency) < 0)
-				goto err_gateoff;
-		}
-
-		if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-			goto err;
-
-		if (abs(offst_freq) <= ((state->search_range / 2000) + 500))
-			return STV090x_RANGEOK;
-		else if (abs(offst_freq) <= (stv090x_car_width(state->srate, state->rolloff) / 2000))
-			return STV090x_RANGEOK;
-		else
-			return STV090x_OUTOFRANGE; /* Out of Range */
-	} else {
-		if (abs(offst_freq) <= ((state->search_range / 2000) + 500))
-			return STV090x_RANGEOK;
-		else
-			return STV090x_OUTOFRANGE;
-	}
-
-	return STV090x_OUTOFRANGE;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static u32 stv090x_get_tmgoffst(struct stv090x_state *state, u32 srate)
-{
-	s32 offst_tmg;
-
-	offst_tmg  = STV090x_READ_DEMOD(state, TMGREG2) << 16;
-	offst_tmg |= STV090x_READ_DEMOD(state, TMGREG1) <<  8;
-	offst_tmg |= STV090x_READ_DEMOD(state, TMGREG0);
-
-	offst_tmg = comp2(offst_tmg, 24); /* 2's complement */
-	if (!offst_tmg)
-		offst_tmg = 1;
-
-	offst_tmg  = ((s32) srate * 10) / ((s32) 0x1000000 / offst_tmg);
-	offst_tmg /= 320;
-
-	return offst_tmg;
-}
-
-static u8 stv090x_optimize_carloop(struct stv090x_state *state, enum stv090x_modcod modcod, s32 pilots)
-{
-	u8 aclc = 0x29;
-	s32 i;
-	struct stv090x_long_frame_crloop *car_loop, *car_loop_qpsk_low, *car_loop_apsk_low;
-
-	if (state->internal->dev_ver == 0x20) {
-		car_loop		= stv090x_s2_crl_cut20;
-		car_loop_qpsk_low	= stv090x_s2_lowqpsk_crl_cut20;
-		car_loop_apsk_low	= stv090x_s2_apsk_crl_cut20;
-	} else {
-		/* >= Cut 3 */
-		car_loop		= stv090x_s2_crl_cut30;
-		car_loop_qpsk_low	= stv090x_s2_lowqpsk_crl_cut30;
-		car_loop_apsk_low	= stv090x_s2_apsk_crl_cut30;
-	}
-
-	if (modcod < STV090x_QPSK_12) {
-		i = 0;
-		while ((i < 3) && (modcod != car_loop_qpsk_low[i].modcod))
-			i++;
-
-		if (i >= 3)
-			i = 2;
-
-	} else {
-		i = 0;
-		while ((i < 14) && (modcod != car_loop[i].modcod))
-			i++;
-
-		if (i >= 14) {
-			i = 0;
-			while ((i < 11) && (modcod != car_loop_apsk_low[i].modcod))
-				i++;
-
-			if (i >= 11)
-				i = 10;
-		}
-	}
-
-	if (modcod <= STV090x_QPSK_25) {
-		if (pilots) {
-			if (state->srate <= 3000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_on_2;
-			else if (state->srate <= 7000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_on_5;
-			else if (state->srate <= 15000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_on_10;
-			else if (state->srate <= 25000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_on_20;
-			else
-				aclc = car_loop_qpsk_low[i].crl_pilots_on_30;
-		} else {
-			if (state->srate <= 3000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_off_2;
-			else if (state->srate <= 7000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_off_5;
-			else if (state->srate <= 15000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_off_10;
-			else if (state->srate <= 25000000)
-				aclc = car_loop_qpsk_low[i].crl_pilots_off_20;
-			else
-				aclc = car_loop_qpsk_low[i].crl_pilots_off_30;
-		}
-
-	} else if (modcod <= STV090x_8PSK_910) {
-		if (pilots) {
-			if (state->srate <= 3000000)
-				aclc = car_loop[i].crl_pilots_on_2;
-			else if (state->srate <= 7000000)
-				aclc = car_loop[i].crl_pilots_on_5;
-			else if (state->srate <= 15000000)
-				aclc = car_loop[i].crl_pilots_on_10;
-			else if (state->srate <= 25000000)
-				aclc = car_loop[i].crl_pilots_on_20;
-			else
-				aclc = car_loop[i].crl_pilots_on_30;
-		} else {
-			if (state->srate <= 3000000)
-				aclc = car_loop[i].crl_pilots_off_2;
-			else if (state->srate <= 7000000)
-				aclc = car_loop[i].crl_pilots_off_5;
-			else if (state->srate <= 15000000)
-				aclc = car_loop[i].crl_pilots_off_10;
-			else if (state->srate <= 25000000)
-				aclc = car_loop[i].crl_pilots_off_20;
-			else
-				aclc = car_loop[i].crl_pilots_off_30;
-		}
-	} else { /* 16APSK and 32APSK */
-		if (state->srate <= 3000000)
-			aclc = car_loop_apsk_low[i].crl_pilots_on_2;
-		else if (state->srate <= 7000000)
-			aclc = car_loop_apsk_low[i].crl_pilots_on_5;
-		else if (state->srate <= 15000000)
-			aclc = car_loop_apsk_low[i].crl_pilots_on_10;
-		else if (state->srate <= 25000000)
-			aclc = car_loop_apsk_low[i].crl_pilots_on_20;
-		else
-			aclc = car_loop_apsk_low[i].crl_pilots_on_30;
-	}
-
-	return aclc;
-}
-
-static u8 stv090x_optimize_carloop_short(struct stv090x_state *state)
-{
-	struct stv090x_short_frame_crloop *short_crl = NULL;
-	s32 index = 0;
-	u8 aclc = 0x0b;
-
-	switch (state->modulation) {
-	case STV090x_QPSK:
-	default:
-		index = 0;
-		break;
-	case STV090x_8PSK:
-		index = 1;
-		break;
-	case STV090x_16APSK:
-		index = 2;
-		break;
-	case STV090x_32APSK:
-		index = 3;
-		break;
-	}
-
-	if (state->internal->dev_ver >= 0x30) {
-		/* Cut 3.0 and up */
-		short_crl = stv090x_s2_short_crl_cut30;
-	} else {
-		/* Cut 2.0 and up: we don't support cuts older than 2.0 */
-		short_crl = stv090x_s2_short_crl_cut20;
-	}
-
-	if (state->srate <= 3000000)
-		aclc = short_crl[index].crl_2;
-	else if (state->srate <= 7000000)
-		aclc = short_crl[index].crl_5;
-	else if (state->srate <= 15000000)
-		aclc = short_crl[index].crl_10;
-	else if (state->srate <= 25000000)
-		aclc = short_crl[index].crl_20;
-	else
-		aclc = short_crl[index].crl_30;
-
-	return aclc;
-}
-
-static int stv090x_optimize_track(struct stv090x_state *state)
-{
-	struct dvb_frontend *fe = &state->frontend;
-
-	enum stv090x_rolloff rolloff;
-	enum stv090x_modcod modcod;
-
-	s32 srate, pilots, aclc, f_1, f_0, i = 0, blind_tune = 0;
-	u32 reg;
-
-	srate  = stv090x_get_srate(state, state->internal->mclk);
-	srate += stv090x_get_tmgoffst(state, srate);
-
-	switch (state->delsys) {
-	case STV090x_DVBS1:
-	case STV090x_DSS:
-		if (state->search_mode == STV090x_SEARCH_AUTO) {
-			reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-			STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
-			STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
-			if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-				goto err;
-		}
-		reg = STV090x_READ_DEMOD(state, DEMOD);
-		STV090x_SETFIELD_Px(reg, ROLLOFF_CONTROL_FIELD, state->rolloff);
-		STV090x_SETFIELD_Px(reg, MANUAL_SXROLLOFF_FIELD, 0x01);
-		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
-			goto err;
-
-		if (state->internal->dev_ver >= 0x30) {
-			if (stv090x_get_viterbi(state) < 0)
-				goto err;
-
-			if (state->fec == STV090x_PR12) {
-				if (STV090x_WRITE_DEMOD(state, GAUSSR0, 0x98) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, CCIR0, 0x18) < 0)
-					goto err;
-			} else {
-				if (STV090x_WRITE_DEMOD(state, GAUSSR0, 0x18) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, CCIR0, 0x18) < 0)
-					goto err;
-			}
-		}
-
-		if (STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x75) < 0)
-			goto err;
-		break;
-
-	case STV090x_DVBS2:
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 0);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-		if (state->internal->dev_ver >= 0x30) {
-			if (STV090x_WRITE_DEMOD(state, ACLC, 0) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, BCLC, 0) < 0)
-				goto err;
-		}
-		if (state->frame_len == STV090x_LONG_FRAME) {
-			reg = STV090x_READ_DEMOD(state, DMDMODCOD);
-			modcod = STV090x_GETFIELD_Px(reg, DEMOD_MODCOD_FIELD);
-			pilots = STV090x_GETFIELD_Px(reg, DEMOD_TYPE_FIELD) & 0x01;
-			aclc = stv090x_optimize_carloop(state, modcod, pilots);
-			if (modcod <= STV090x_QPSK_910) {
-				STV090x_WRITE_DEMOD(state, ACLC2S2Q, aclc);
-			} else if (modcod <= STV090x_8PSK_910) {
-				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, ACLC2S28, aclc) < 0)
-					goto err;
-			}
-			if ((state->demod_mode == STV090x_SINGLE) && (modcod > STV090x_8PSK_910)) {
-				if (modcod <= STV090x_16APSK_910) {
-					if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
-						goto err;
-					if (STV090x_WRITE_DEMOD(state, ACLC2S216A, aclc) < 0)
-						goto err;
-				} else {
-					if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
-						goto err;
-					if (STV090x_WRITE_DEMOD(state, ACLC2S232A, aclc) < 0)
-						goto err;
-				}
-			}
-		} else {
-			/*Carrier loop setting for short frame*/
-			aclc = stv090x_optimize_carloop_short(state);
-			if (state->modulation == STV090x_QPSK) {
-				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, aclc) < 0)
-					goto err;
-			} else if (state->modulation == STV090x_8PSK) {
-				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, ACLC2S28, aclc) < 0)
-					goto err;
-			} else if (state->modulation == STV090x_16APSK) {
-				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, ACLC2S216A, aclc) < 0)
-					goto err;
-			} else if (state->modulation == STV090x_32APSK)  {
-				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, ACLC2S232A, aclc) < 0)
-					goto err;
-			}
-		}
-
-		STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x67); /* PER */
-		break;
-
-	case STV090x_ERROR:
-	default:
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
-		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-		break;
-	}
-
-	f_1 = STV090x_READ_DEMOD(state, CFR2);
-	f_0 = STV090x_READ_DEMOD(state, CFR1);
-	reg = STV090x_READ_DEMOD(state, TMGOBS);
-	rolloff = STV090x_GETFIELD_Px(reg, ROLLOFF_STATUS_FIELD);
-
-	if (state->algo == STV090x_BLIND_SEARCH) {
-		STV090x_WRITE_DEMOD(state, SFRSTEP, 0x00);
-		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
-		STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0x00);
-		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc1) < 0)
-			goto err;
-
-		if (stv090x_set_srate(state, srate) < 0)
-			goto err;
-		blind_tune = 1;
-
-		if (stv090x_dvbs_track_crl(state) < 0)
-			goto err;
-	}
-
-	if (state->internal->dev_ver >= 0x20) {
-		if ((state->search_mode == STV090x_SEARCH_DVBS1)	||
-		    (state->search_mode == STV090x_SEARCH_DSS)		||
-		    (state->search_mode == STV090x_SEARCH_AUTO)) {
-
-			if (STV090x_WRITE_DEMOD(state, VAVSRVIT, 0x0a) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, VITSCALE, 0x00) < 0)
-				goto err;
-		}
-	}
-
-	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
-		goto err;
-
-	/* AUTO tracking MODE */
-	if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x80) < 0)
-		goto err;
-	/* AUTO tracking MODE */
-	if (STV090x_WRITE_DEMOD(state, SFRLOW1, 0x80) < 0)
-		goto err;
-
-	if ((state->internal->dev_ver >= 0x20) || (blind_tune == 1) ||
-	    (state->srate < 10000000)) {
-		/* update initial carrier freq with the found freq offset */
-		if (STV090x_WRITE_DEMOD(state, CFRINIT1, f_1) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CFRINIT0, f_0) < 0)
-			goto err;
-		state->tuner_bw = stv090x_car_width(srate, state->rolloff) + 10000000;
-
-		if ((state->internal->dev_ver >= 0x20) || (blind_tune == 1)) {
-
-			if (state->algo != STV090x_WARM_SEARCH) {
-
-				if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-					goto err;
-
-				if (state->config->tuner_set_bandwidth) {
-					if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
-						goto err_gateoff;
-				}
-
-				if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-					goto err;
-
-			}
-		}
-		if ((state->algo == STV090x_BLIND_SEARCH) || (state->srate < 10000000))
-			msleep(50); /* blind search: wait 50ms for SR stabilization */
-		else
-			msleep(5);
-
-		stv090x_get_lock_tmg(state);
-
-		if (!(stv090x_get_dmdlock(state, (state->DemodTimeout / 2)))) {
-			if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CFRINIT1, f_1) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, CFRINIT0, f_0) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
-				goto err;
-
-			i = 0;
-
-			while ((!(stv090x_get_dmdlock(state, (state->DemodTimeout / 2)))) && (i <= 2)) {
-
-				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, CFRINIT1, f_1) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, CFRINIT0, f_0) < 0)
-					goto err;
-				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
-					goto err;
-				i++;
-			}
-		}
-
-	}
-
-	if (state->internal->dev_ver >= 0x20) {
-		if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x49) < 0)
-			goto err;
-	}
-
-	if ((state->delsys == STV090x_DVBS1) || (state->delsys == STV090x_DSS))
-		stv090x_set_vit_thtracq(state);
-
-	return 0;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_get_feclock(struct stv090x_state *state, s32 timeout)
-{
-	s32 timer = 0, lock = 0, stat;
-	u32 reg;
-
-	while ((timer < timeout) && (!lock)) {
-		reg = STV090x_READ_DEMOD(state, DMDSTATE);
-		stat = STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD);
-
-		switch (stat) {
-		case 0: /* searching */
-		case 1: /* first PLH detected */
-		default:
-			lock = 0;
-			break;
-
-		case 2: /* DVB-S2 mode */
-			reg = STV090x_READ_DEMOD(state, PDELSTATUS1);
-			lock = STV090x_GETFIELD_Px(reg, PKTDELIN_LOCK_FIELD);
-			break;
-
-		case 3: /* DVB-S1/legacy mode */
-			reg = STV090x_READ_DEMOD(state, VSTATUSVIT);
-			lock = STV090x_GETFIELD_Px(reg, LOCKEDVIT_FIELD);
-			break;
-		}
-		if (!lock) {
-			msleep(10);
-			timer += 10;
-		}
-	}
-	return lock;
-}
-
-static int stv090x_get_lock(struct stv090x_state *state, s32 timeout_dmd, s32 timeout_fec)
-{
-	u32 reg;
-	s32 timer = 0;
-	int lock;
-
-	lock = stv090x_get_dmdlock(state, timeout_dmd);
-	if (lock)
-		lock = stv090x_get_feclock(state, timeout_fec);
-
-	if (lock) {
-		lock = 0;
-
-		while ((timer < timeout_fec) && (!lock)) {
-			reg = STV090x_READ_DEMOD(state, TSSTATUS);
-			lock = STV090x_GETFIELD_Px(reg, TSFIFO_LINEOK_FIELD);
-			msleep(1);
-			timer++;
-		}
-	}
-
-	return lock;
-}
-
-static int stv090x_set_s2rolloff(struct stv090x_state *state)
-{
-	u32 reg;
-
-	if (state->internal->dev_ver <= 0x20) {
-		/* rolloff to auto mode if DVBS2 */
-		reg = STV090x_READ_DEMOD(state, DEMOD);
-		STV090x_SETFIELD_Px(reg, MANUAL_SXROLLOFF_FIELD, 0x00);
-		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
-			goto err;
-	} else {
-		/* DVB-S2 rolloff to auto mode if DVBS2 */
-		reg = STV090x_READ_DEMOD(state, DEMOD);
-		STV090x_SETFIELD_Px(reg, MANUAL_S2ROLLOFF_FIELD, 0x00);
-		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
-			goto err;
-	}
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-
-static enum stv090x_signal_state stv090x_algo(struct stv090x_state *state)
-{
-	struct dvb_frontend *fe = &state->frontend;
-	enum stv090x_signal_state signal_state = STV090x_NOCARRIER;
-	u32 reg;
-	s32 agc1_power, power_iq = 0, i;
-	int lock = 0, low_sr = 0, no_signal = 0;
-
-	reg = STV090x_READ_DEMOD(state, TSCFGH);
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 1); /* Stop path 1 stream merger */
-	if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
-		goto err;
-
-	if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x5c) < 0) /* Demod stop */
-		goto err;
-
-	if (state->internal->dev_ver >= 0x20) {
-		if (state->srate > 5000000) {
-			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x9e) < 0)
-				goto err;
-		} else {
-			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x82) < 0)
-				goto err;
-		}
-	}
-
-	stv090x_get_lock_tmg(state);
-
-	if (state->algo == STV090x_BLIND_SEARCH) {
-		state->tuner_bw = 2 * 36000000; /* wide bw for unknown srate */
-		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc0) < 0) /* wider srate scan */
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x70) < 0)
-			goto err;
-		if (stv090x_set_srate(state, 1000000) < 0) /* initial srate = 1Msps */
-			goto err;
-	} else {
-		/* known srate */
-		if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x20) < 0)
-			goto err;
-		if (STV090x_WRITE_DEMOD(state, TMGCFG, 0xd2) < 0)
-			goto err;
-
-		if (state->srate < 2000000) {
-			/* SR < 2MSPS */
-			if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x63) < 0)
-				goto err;
-		} else {
-			/* SR >= 2Msps */
-			if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x70) < 0)
-				goto err;
-		}
-
-		if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
-			goto err;
-
-		if (state->internal->dev_ver >= 0x20) {
-			if (STV090x_WRITE_DEMOD(state, KREFTMG, 0x5a) < 0)
-				goto err;
-			if (state->algo == STV090x_COLD_SEARCH)
-				state->tuner_bw = (15 * (stv090x_car_width(state->srate, state->rolloff) + 10000000)) / 10;
-			else if (state->algo == STV090x_WARM_SEARCH)
-				state->tuner_bw = stv090x_car_width(state->srate, state->rolloff) + 10000000;
-		}
-
-		/* if cold start or warm  (Symbolrate is known)
-		 * use a Narrow symbol rate scan range
-		 */
-		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc1) < 0) /* narrow srate scan */
-			goto err;
-
-		if (stv090x_set_srate(state, state->srate) < 0)
-			goto err;
-
-		if (stv090x_set_max_srate(state, state->internal->mclk,
-					  state->srate) < 0)
-			goto err;
-		if (stv090x_set_min_srate(state, state->internal->mclk,
-					  state->srate) < 0)
-			goto err;
-
-		if (state->srate >= 10000000)
-			low_sr = 0;
-		else
-			low_sr = 1;
-	}
-
-	/* Setup tuner */
-	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-		goto err;
-
-	if (state->config->tuner_set_bbgain) {
-		reg = state->config->tuner_bbgain;
-		if (reg == 0)
-			reg = 10; /* default: 10dB */
-		if (state->config->tuner_set_bbgain(fe, reg) < 0)
-			goto err_gateoff;
-	}
-
-	if (state->config->tuner_set_frequency) {
-		if (state->config->tuner_set_frequency(fe, state->frequency) < 0)
-			goto err_gateoff;
-	}
-
-	if (state->config->tuner_set_bandwidth) {
-		if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
-			goto err_gateoff;
-	}
-
-	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-		goto err;
-
-	msleep(50);
-
-	if (state->config->tuner_get_status) {
-		if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-			goto err;
-		if (state->config->tuner_get_status(fe, &reg) < 0)
-			goto err_gateoff;
-		if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-			goto err;
-
-		if (reg)
-			dprintk(FE_DEBUG, 1, "Tuner phase locked");
-		else {
-			dprintk(FE_DEBUG, 1, "Tuner unlocked");
-			return STV090x_NOCARRIER;
-		}
-	}
-
-	msleep(10);
-	agc1_power = MAKEWORD16(STV090x_READ_DEMOD(state, AGCIQIN1),
-				STV090x_READ_DEMOD(state, AGCIQIN0));
-
-	if (agc1_power == 0) {
-		/* If AGC1 integrator value is 0
-		 * then read POWERI, POWERQ
-		 */
-		for (i = 0; i < 5; i++) {
-			power_iq += (STV090x_READ_DEMOD(state, POWERI) +
-				     STV090x_READ_DEMOD(state, POWERQ)) >> 1;
-		}
-		power_iq /= 5;
-	}
-
-	if ((agc1_power == 0) && (power_iq < STV090x_IQPOWER_THRESHOLD)) {
-		dprintk(FE_ERROR, 1, "No Signal: POWER_IQ=0x%02x", power_iq);
-		lock = 0;
-		signal_state = STV090x_NOAGC1;
-	} else {
-		reg = STV090x_READ_DEMOD(state, DEMOD);
-		STV090x_SETFIELD_Px(reg, SPECINV_CONTROL_FIELD, state->inversion);
-
-		if (state->internal->dev_ver <= 0x20) {
-			/* rolloff to auto mode if DVBS2 */
-			STV090x_SETFIELD_Px(reg, MANUAL_SXROLLOFF_FIELD, 1);
-		} else {
-			/* DVB-S2 rolloff to auto mode if DVBS2 */
-			STV090x_SETFIELD_Px(reg, MANUAL_S2ROLLOFF_FIELD, 1);
-		}
-		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
-			goto err;
-
-		if (stv090x_delivery_search(state) < 0)
-			goto err;
-
-		if (state->algo != STV090x_BLIND_SEARCH) {
-			if (stv090x_start_search(state) < 0)
-				goto err;
-		}
-	}
-
-	if (signal_state == STV090x_NOAGC1)
-		return signal_state;
-
-	if (state->algo == STV090x_BLIND_SEARCH)
-		lock = stv090x_blind_search(state);
-
-	else if (state->algo == STV090x_COLD_SEARCH)
-		lock = stv090x_get_coldlock(state, state->DemodTimeout);
-
-	else if (state->algo == STV090x_WARM_SEARCH)
-		lock = stv090x_get_dmdlock(state, state->DemodTimeout);
-
-	if ((!lock) && (state->algo == STV090x_COLD_SEARCH)) {
-		if (!low_sr) {
-			if (stv090x_chk_tmg(state))
-				lock = stv090x_sw_algo(state);
-		}
-	}
-
-	if (lock)
-		signal_state = stv090x_get_sig_params(state);
-
-	if ((lock) && (signal_state == STV090x_RANGEOK)) { /* signal within Range */
-		stv090x_optimize_track(state);
-
-		if (state->internal->dev_ver >= 0x20) {
-			/* >= Cut 2.0 :release TS reset after
-			 * demod lock and optimized Tracking
-			 */
-			reg = STV090x_READ_DEMOD(state, TSCFGH);
-			STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0); /* release merger reset */
-			if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
-				goto err;
-
-			msleep(3);
-
-			STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 1); /* merger reset */
-			if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
-				goto err;
-
-			STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0); /* release merger reset */
-			if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
-				goto err;
-		}
-
-		lock = stv090x_get_lock(state, state->FecTimeout,
-				state->FecTimeout);
-		if (lock) {
-			if (state->delsys == STV090x_DVBS2) {
-				stv090x_set_s2rolloff(state);
-
-				reg = STV090x_READ_DEMOD(state, PDELCTRL2);
-				STV090x_SETFIELD_Px(reg, RESET_UPKO_COUNT, 1);
-				if (STV090x_WRITE_DEMOD(state, PDELCTRL2, reg) < 0)
-					goto err;
-				/* Reset DVBS2 packet delinator error counter */
-				reg = STV090x_READ_DEMOD(state, PDELCTRL2);
-				STV090x_SETFIELD_Px(reg, RESET_UPKO_COUNT, 0);
-				if (STV090x_WRITE_DEMOD(state, PDELCTRL2, reg) < 0)
-					goto err;
-
-				if (STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x67) < 0) /* PER */
-					goto err;
-			} else {
-				if (STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x75) < 0)
-					goto err;
-			}
-			/* Reset the Total packet counter */
-			if (STV090x_WRITE_DEMOD(state, FBERCPT4, 0x00) < 0)
-				goto err;
-			/* Reset the packet Error counter2 */
-			if (STV090x_WRITE_DEMOD(state, ERRCTRL2, 0xc1) < 0)
-				goto err;
-		} else {
-			signal_state = STV090x_NODATA;
-			no_signal = stv090x_chk_signal(state);
-		}
-	}
-	return signal_state;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static enum dvbfe_search stv090x_search(struct dvb_frontend *fe)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *props = &fe->dtv_property_cache;
-
-	if (props->frequency == 0)
-		return DVBFE_ALGO_SEARCH_INVALID;
-
-	state->delsys = props->delivery_system;
-	state->frequency = props->frequency;
-	state->srate = props->symbol_rate;
-	state->search_mode = STV090x_SEARCH_AUTO;
-	state->algo = STV090x_COLD_SEARCH;
-	state->fec = STV090x_PRERR;
-	if (state->srate > 10000000) {
-		dprintk(FE_DEBUG, 1, "Search range: 10 MHz");
-		state->search_range = 10000000;
-	} else {
-		dprintk(FE_DEBUG, 1, "Search range: 5 MHz");
-		state->search_range = 5000000;
-	}
-
-	if (stv090x_algo(state) == STV090x_RANGEOK) {
-		dprintk(FE_DEBUG, 1, "Search success!");
-		return DVBFE_ALGO_SEARCH_SUCCESS;
-	} else {
-		dprintk(FE_DEBUG, 1, "Search failed!");
-		return DVBFE_ALGO_SEARCH_FAILED;
-	}
-
-	return DVBFE_ALGO_SEARCH_ERROR;
-}
-
-static int stv090x_read_status(struct dvb_frontend *fe, enum fe_status *status)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg, dstatus;
-	u8 search_state;
-
-	*status = 0;
-
-	dstatus = STV090x_READ_DEMOD(state, DSTATUS);
-	if (STV090x_GETFIELD_Px(dstatus, CAR_LOCK_FIELD))
-		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;
-
-	reg = STV090x_READ_DEMOD(state, DMDSTATE);
-	search_state = STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD);
-
-	switch (search_state) {
-	case 0: /* searching */
-	case 1: /* first PLH detected */
-	default:
-		dprintk(FE_DEBUG, 1, "Status: Unlocked (Searching ..)");
-		break;
-
-	case 2: /* DVB-S2 mode */
-		dprintk(FE_DEBUG, 1, "Delivery system: DVB-S2");
-		if (STV090x_GETFIELD_Px(dstatus, LOCK_DEFINITIF_FIELD)) {
-			reg = STV090x_READ_DEMOD(state, PDELSTATUS1);
-			if (STV090x_GETFIELD_Px(reg, PKTDELIN_LOCK_FIELD)) {
-				*status |= FE_HAS_VITERBI;
-				reg = STV090x_READ_DEMOD(state, TSSTATUS);
-				if (STV090x_GETFIELD_Px(reg, TSFIFO_LINEOK_FIELD))
-					*status |= FE_HAS_SYNC | FE_HAS_LOCK;
-			}
-		}
-		break;
-
-	case 3: /* DVB-S1/legacy mode */
-		dprintk(FE_DEBUG, 1, "Delivery system: DVB-S");
-		if (STV090x_GETFIELD_Px(dstatus, LOCK_DEFINITIF_FIELD)) {
-			reg = STV090x_READ_DEMOD(state, VSTATUSVIT);
-			if (STV090x_GETFIELD_Px(reg, LOCKEDVIT_FIELD)) {
-				*status |= FE_HAS_VITERBI;
-				reg = STV090x_READ_DEMOD(state, TSSTATUS);
-				if (STV090x_GETFIELD_Px(reg, TSFIFO_LINEOK_FIELD))
-					*status |= FE_HAS_SYNC | FE_HAS_LOCK;
-			}
-		}
-		break;
-	}
-
-	return 0;
-}
-
-static int stv090x_read_per(struct dvb_frontend *fe, u32 *per)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-
-	s32 count_4, count_3, count_2, count_1, count_0, count;
-	u32 reg, h, m, l;
-	enum fe_status status;
-
-	stv090x_read_status(fe, &status);
-	if (!(status & FE_HAS_LOCK)) {
-		*per = 1 << 23; /* Max PER */
-	} else {
-		/* Counter 2 */
-		reg = STV090x_READ_DEMOD(state, ERRCNT22);
-		h = STV090x_GETFIELD_Px(reg, ERR_CNT2_FIELD);
-
-		reg = STV090x_READ_DEMOD(state, ERRCNT21);
-		m = STV090x_GETFIELD_Px(reg, ERR_CNT21_FIELD);
-
-		reg = STV090x_READ_DEMOD(state, ERRCNT20);
-		l = STV090x_GETFIELD_Px(reg, ERR_CNT20_FIELD);
-
-		*per = ((h << 16) | (m << 8) | l);
-
-		count_4 = STV090x_READ_DEMOD(state, FBERCPT4);
-		count_3 = STV090x_READ_DEMOD(state, FBERCPT3);
-		count_2 = STV090x_READ_DEMOD(state, FBERCPT2);
-		count_1 = STV090x_READ_DEMOD(state, FBERCPT1);
-		count_0 = STV090x_READ_DEMOD(state, FBERCPT0);
-
-		if ((!count_4) && (!count_3)) {
-			count  = (count_2 & 0xff) << 16;
-			count |= (count_1 & 0xff) <<  8;
-			count |=  count_0 & 0xff;
-		} else {
-			count = 1 << 24;
-		}
-		if (count == 0)
-			*per = 1;
-	}
-	if (STV090x_WRITE_DEMOD(state, FBERCPT4, 0) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, ERRCTRL2, 0xc1) < 0)
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_table_lookup(const struct stv090x_tab *tab, int max, int val)
-{
-	int res = 0;
-	int min = 0, med;
-
-	if ((val >= tab[min].read && val < tab[max].read) ||
-	    (val >= tab[max].read && val < tab[min].read)) {
-		while ((max - min) > 1) {
-			med = (max + min) / 2;
-			if ((val >= tab[min].read && val < tab[med].read) ||
-			    (val >= tab[med].read && val < tab[min].read))
-				max = med;
-			else
-				min = med;
-		}
-		res = ((val - tab[min].read) *
-		       (tab[max].real - tab[min].real) /
-		       (tab[max].read - tab[min].read)) +
-			tab[min].real;
-	} else {
-		if (tab[min].read < tab[max].read) {
-			if (val < tab[min].read)
-				res = tab[min].real;
-			else if (val >= tab[max].read)
-				res = tab[max].real;
-		} else {
-			if (val >= tab[min].read)
-				res = tab[min].real;
-			else if (val < tab[max].read)
-				res = tab[max].real;
-		}
-	}
-
-	return res;
-}
-
-static int stv090x_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg;
-	s32 agc_0, agc_1, agc;
-	s32 str;
-
-	reg = STV090x_READ_DEMOD(state, AGCIQIN1);
-	agc_1 = STV090x_GETFIELD_Px(reg, AGCIQ_VALUE_FIELD);
-	reg = STV090x_READ_DEMOD(state, AGCIQIN0);
-	agc_0 = STV090x_GETFIELD_Px(reg, AGCIQ_VALUE_FIELD);
-	agc = MAKEWORD16(agc_1, agc_0);
-
-	str = stv090x_table_lookup(stv090x_rf_tab,
-		ARRAY_SIZE(stv090x_rf_tab) - 1, agc);
-	if (agc > stv090x_rf_tab[0].read)
-		str = 0;
-	else if (agc < stv090x_rf_tab[ARRAY_SIZE(stv090x_rf_tab) - 1].read)
-		str = -100;
-	*strength = (str + 100) * 0xFFFF / 100;
-
-	return 0;
-}
-
-static int stv090x_read_cnr(struct dvb_frontend *fe, u16 *cnr)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg_0, reg_1, reg, i;
-	s32 val_0, val_1, val = 0;
-	u8 lock_f;
-	s32 div;
-	u32 last;
-
-	switch (state->delsys) {
-	case STV090x_DVBS2:
-		reg = STV090x_READ_DEMOD(state, DSTATUS);
-		lock_f = STV090x_GETFIELD_Px(reg, LOCK_DEFINITIF_FIELD);
-		if (lock_f) {
-			msleep(5);
-			for (i = 0; i < 16; i++) {
-				reg_1 = STV090x_READ_DEMOD(state, NNOSPLHT1);
-				val_1 = STV090x_GETFIELD_Px(reg_1, NOSPLHT_NORMED_FIELD);
-				reg_0 = STV090x_READ_DEMOD(state, NNOSPLHT0);
-				val_0 = STV090x_GETFIELD_Px(reg_0, NOSPLHT_NORMED_FIELD);
-				val  += MAKEWORD16(val_1, val_0);
-				msleep(1);
-			}
-			val /= 16;
-			last = ARRAY_SIZE(stv090x_s2cn_tab) - 1;
-			div = stv090x_s2cn_tab[0].read -
-			      stv090x_s2cn_tab[last].read;
-			*cnr = 0xFFFF - ((val * 0xFFFF) / div);
-		}
-		break;
-
-	case STV090x_DVBS1:
-	case STV090x_DSS:
-		reg = STV090x_READ_DEMOD(state, DSTATUS);
-		lock_f = STV090x_GETFIELD_Px(reg, LOCK_DEFINITIF_FIELD);
-		if (lock_f) {
-			msleep(5);
-			for (i = 0; i < 16; i++) {
-				reg_1 = STV090x_READ_DEMOD(state, NOSDATAT1);
-				val_1 = STV090x_GETFIELD_Px(reg_1, NOSDATAT_UNNORMED_FIELD);
-				reg_0 = STV090x_READ_DEMOD(state, NOSDATAT0);
-				val_0 = STV090x_GETFIELD_Px(reg_0, NOSDATAT_UNNORMED_FIELD);
-				val  += MAKEWORD16(val_1, val_0);
-				msleep(1);
-			}
-			val /= 16;
-			last = ARRAY_SIZE(stv090x_s1cn_tab) - 1;
-			div = stv090x_s1cn_tab[0].read -
-			      stv090x_s1cn_tab[last].read;
-			*cnr = 0xFFFF - ((val * 0xFFFF) / div);
-		}
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int stv090x_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg;
-
-	reg = STV090x_READ_DEMOD(state, DISTXCTL);
-	switch (tone) {
-	case SEC_TONE_ON:
-		STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD, 0);
-		STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-			goto err;
-		STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 0);
-		if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-			goto err;
-		break;
-
-	case SEC_TONE_OFF:
-		STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD, 0);
-		STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
-		if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-			goto err;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-
-static enum dvbfe_algo stv090x_frontend_algo(struct dvb_frontend *fe)
-{
-	return DVBFE_ALGO_CUSTOM;
-}
-
-static int stv090x_send_diseqc_msg(struct dvb_frontend *fe, struct dvb_diseqc_master_cmd *cmd)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg, idle = 0, fifo_full = 1;
-	int i;
-
-	reg = STV090x_READ_DEMOD(state, DISTXCTL);
-
-	STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD,
-		(state->config->diseqc_envelope_mode) ? 4 : 2);
-	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-
-	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 1);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-
-	for (i = 0; i < cmd->msg_len; i++) {
-
-		while (fifo_full) {
-			reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
-			fifo_full = STV090x_GETFIELD_Px(reg, FIFO_FULL_FIELD);
-		}
-
-		if (STV090x_WRITE_DEMOD(state, DISTXDATA, cmd->msg[i]) < 0)
-			goto err;
-	}
-	reg = STV090x_READ_DEMOD(state, DISTXCTL);
-	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-
-	i = 0;
-
-	while ((!idle) && (i < 10)) {
-		reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
-		idle = STV090x_GETFIELD_Px(reg, TX_IDLE_FIELD);
-		msleep(10);
-		i++;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_send_diseqc_burst(struct dvb_frontend *fe, fe_sec_mini_cmd_t burst)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg, idle = 0, fifo_full = 1;
-	u8 mode, value;
-	int i;
-
-	reg = STV090x_READ_DEMOD(state, DISTXCTL);
-
-	if (burst == SEC_MINI_A) {
-		mode = (state->config->diseqc_envelope_mode) ? 5 : 3;
-		value = 0x00;
-	} else {
-		mode = (state->config->diseqc_envelope_mode) ? 4 : 2;
-		value = 0xFF;
-	}
-
-	STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD, mode);
-	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-
-	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 1);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-
-	while (fifo_full) {
-		reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
-		fifo_full = STV090x_GETFIELD_Px(reg, FIFO_FULL_FIELD);
-	}
-
-	if (STV090x_WRITE_DEMOD(state, DISTXDATA, value) < 0)
-		goto err;
-
-	reg = STV090x_READ_DEMOD(state, DISTXCTL);
-	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 0);
-	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
-		goto err;
-
-	i = 0;
-
-	while ((!idle) && (i < 10)) {
-		reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
-		idle = STV090x_GETFIELD_Px(reg, TX_IDLE_FIELD);
-		msleep(10);
-		i++;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_recv_slave_reply(struct dvb_frontend *fe, struct dvb_diseqc_slave_reply *reply)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg = 0, i = 0, rx_end = 0;
-
-	while ((rx_end != 1) && (i < 10)) {
-		msleep(10);
-		i++;
-		reg = STV090x_READ_DEMOD(state, DISRX_ST0);
-		rx_end = STV090x_GETFIELD_Px(reg, RX_END_FIELD);
-	}
-
-	if (rx_end) {
-		reply->msg_len = STV090x_GETFIELD_Px(reg, FIFO_BYTENBR_FIELD);
-		for (i = 0; i < reply->msg_len; i++)
-			reply->msg[i] = STV090x_READ_DEMOD(state, DISRXDATA);
-	}
-
-	return 0;
-}
-
-static int stv090x_sleep(struct dvb_frontend *fe)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg;
-	u8 full_standby = 0;
-
-	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-		goto err;
-
-	if (state->config->tuner_sleep) {
-		if (state->config->tuner_sleep(fe) < 0)
-			goto err_gateoff;
-	}
-
-	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-		goto err;
-
-	dprintk(FE_DEBUG, 1, "Set %s(%d) to sleep",
-		state->device == STV0900 ? "STV0900" : "STV0903",
-		state->demod);
-
-	mutex_lock(&state->internal->demod_lock);
-
-	switch (state->demod) {
-	case STV090x_DEMODULATOR_0:
-		/* power off ADC 1 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR1);
-		STV090x_SETFIELD(reg, ADC1_PON_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_TSTTNR1, reg) < 0)
-			goto err;
-		/* power off DiSEqC 1 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR2);
-		STV090x_SETFIELD(reg, DISEQC1_PON_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_TSTTNR2, reg) < 0)
-			goto err;
-
-		/* check whether path 2 is already sleeping, that is when
-		   ADC2 is off */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR3);
-		if (STV090x_GETFIELD(reg, ADC2_PON_FIELD) == 0)
-			full_standby = 1;
-
-		/* stop clocks */
-		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
-		/* packet delineator 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKPKDT1_FIELD, 1);
-		/* ADC 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKADCI1_FIELD, 1);
-		/* FEC clock is shared between the two paths, only stop it
-		   when full standby is possible */
-		if (full_standby)
-			STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
-			goto err;
-		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
-		/* sampling 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKSAMP1_FIELD, 1);
-		/* viterbi 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKVIT1_FIELD, 1);
-		/* TS clock is shared between the two paths, only stop it
-		   when full standby is possible */
-		if (full_standby)
-			STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_DEMODULATOR_1:
-		/* power off ADC 2 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR3);
-		STV090x_SETFIELD(reg, ADC2_PON_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_TSTTNR3, reg) < 0)
-			goto err;
-		/* power off DiSEqC 2 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR4);
-		STV090x_SETFIELD(reg, DISEQC2_PON_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_TSTTNR4, reg) < 0)
-			goto err;
-
-		/* check whether path 1 is already sleeping, that is when
-		   ADC1 is off */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR1);
-		if (STV090x_GETFIELD(reg, ADC1_PON_FIELD) == 0)
-			full_standby = 1;
-
-		/* stop clocks */
-		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
-		/* packet delineator 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKPKDT2_FIELD, 1);
-		/* ADC 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKADCI2_FIELD, 1);
-		/* FEC clock is shared between the two paths, only stop it
-		   when full standby is possible */
-		if (full_standby)
-			STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
-			goto err;
-		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
-		/* sampling 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKSAMP2_FIELD, 1);
-		/* viterbi 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKVIT2_FIELD, 1);
-		/* TS clock is shared between the two paths, only stop it
-		   when full standby is possible */
-		if (full_standby)
-			STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
-			goto err;
-		break;
-
-	default:
-		dprintk(FE_ERROR, 1, "Wrong demodulator!");
-		break;
-	}
-
-	if (full_standby) {
-		/* general power off */
-		reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
-		STV090x_SETFIELD(reg, STANDBY_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_SYNTCTRL, reg) < 0)
-			goto err;
-	}
-
-	mutex_unlock(&state->internal->demod_lock);
-	return 0;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	mutex_unlock(&state->internal->demod_lock);
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_wakeup(struct dvb_frontend *fe)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u32 reg;
-
-	dprintk(FE_DEBUG, 1, "Wake %s(%d) from standby",
-		state->device == STV0900 ? "STV0900" : "STV0903",
-		state->demod);
-
-	mutex_lock(&state->internal->demod_lock);
-
-	/* general power on */
-	reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
-	STV090x_SETFIELD(reg, STANDBY_FIELD, 0x00);
-	if (stv090x_write_reg(state, STV090x_SYNTCTRL, reg) < 0)
-		goto err;
-
-	switch (state->demod) {
-	case STV090x_DEMODULATOR_0:
-		/* power on ADC 1 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR1);
-		STV090x_SETFIELD(reg, ADC1_PON_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_TSTTNR1, reg) < 0)
-			goto err;
-		/* power on DiSEqC 1 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR2);
-		STV090x_SETFIELD(reg, DISEQC1_PON_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_TSTTNR2, reg) < 0)
-			goto err;
-
-		/* activate clocks */
-		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
-		/* packet delineator 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKPKDT1_FIELD, 0);
-		/* ADC 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKADCI1_FIELD, 0);
-		/* FEC clock */
-		STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
-			goto err;
-		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
-		/* sampling 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKSAMP1_FIELD, 0);
-		/* viterbi 1 clock */
-		STV090x_SETFIELD(reg, STOP_CLKVIT1_FIELD, 0);
-		/* TS clock */
-		STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_DEMODULATOR_1:
-		/* power on ADC 2 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR3);
-		STV090x_SETFIELD(reg, ADC2_PON_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_TSTTNR3, reg) < 0)
-			goto err;
-		/* power on DiSEqC 2 */
-		reg = stv090x_read_reg(state, STV090x_TSTTNR4);
-		STV090x_SETFIELD(reg, DISEQC2_PON_FIELD, 1);
-		if (stv090x_write_reg(state, STV090x_TSTTNR4, reg) < 0)
-			goto err;
-
-		/* activate clocks */
-		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
-		/* packet delineator 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKPKDT2_FIELD, 0);
-		/* ADC 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKADCI2_FIELD, 0);
-		/* FEC clock */
-		STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
-			goto err;
-		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
-		/* sampling 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKSAMP2_FIELD, 0);
-		/* viterbi 2 clock */
-		STV090x_SETFIELD(reg, STOP_CLKVIT2_FIELD, 0);
-		/* TS clock */
-		STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 0);
-		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
-			goto err;
-		break;
-
-	default:
-		dprintk(FE_ERROR, 1, "Wrong demodulator!");
-		break;
-	}
-
-	mutex_unlock(&state->internal->demod_lock);
-	return 0;
-err:
-	mutex_unlock(&state->internal->demod_lock);
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static void stv090x_release(struct dvb_frontend *fe)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-
-	state->internal->num_used--;
-	if (state->internal->num_used <= 0) {
-
-		dprintk(FE_ERROR, 1, "Actually removing");
-
-		remove_dev(state->internal);
-		kfree(state->internal);
-	}
-
-	kfree(state);
-}
-
-static int stv090x_ldpc_mode(struct stv090x_state *state, enum stv090x_mode ldpc_mode)
-{
-	u32 reg = 0;
-
-	reg = stv090x_read_reg(state, STV090x_GENCFG);
-
-	switch (ldpc_mode) {
-	case STV090x_DUAL:
-	default:
-		if ((state->demod_mode != STV090x_DUAL) || (STV090x_GETFIELD(reg, DDEMOD_FIELD) != 1)) {
-			/* set LDPC to dual mode */
-			if (stv090x_write_reg(state, STV090x_GENCFG, 0x1d) < 0)
-				goto err;
-
-			state->demod_mode = STV090x_DUAL;
-
-			reg = stv090x_read_reg(state, STV090x_TSTRES0);
-			STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x1);
-			if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
-				goto err;
-			STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x0);
-			if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
-				goto err;
-
-			if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0xff) < 0)
-				goto err;
-
-			if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0xcc) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0xcc) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0xcc) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0xcc) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0xcc) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0xcc) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0xcc) < 0)
-				goto err;
-
-			if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0xff) < 0)
-				goto err;
-			if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0xcf) < 0)
-				goto err;
-		}
-		break;
-
-	case STV090x_SINGLE:
-		if (stv090x_stop_modcod(state) < 0)
-			goto err;
-		if (stv090x_activate_modcod_single(state) < 0)
-			goto err;
-
-		if (state->demod == STV090x_DEMODULATOR_1) {
-			if (stv090x_write_reg(state, STV090x_GENCFG, 0x06) < 0) /* path 2 */
-				goto err;
-		} else {
-			if (stv090x_write_reg(state, STV090x_GENCFG, 0x04) < 0) /* path 1 */
-				goto err;
-		}
-
-		reg = stv090x_read_reg(state, STV090x_TSTRES0);
-		STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x1);
-		if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
-			goto err;
-		STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x0);
-		if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
-			goto err;
-
-		reg = STV090x_READ_DEMOD(state, PDELCTRL1);
-		STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0x01);
-		if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
-			goto err;
-		STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0x00);
-		if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
-			goto err;
-		break;
-	}
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-/* return (Hz), clk in Hz*/
-static u32 stv090x_get_mclk(struct stv090x_state *state)
-{
-	const struct stv090x_config *config = state->config;
-	u32 div, reg;
-	u8 ratio;
-
-	div = stv090x_read_reg(state, STV090x_NCOARSE);
-	reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
-	ratio = STV090x_GETFIELD(reg, SELX1RATIO_FIELD) ? 4 : 6;
-
-	return (div + 1) * config->xtal / ratio; /* kHz */
-}
-
-static int stv090x_set_mclk(struct stv090x_state *state, u32 mclk, u32 clk)
-{
-	const struct stv090x_config *config = state->config;
-	u32 reg, div, clk_sel;
-
-	reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
-	clk_sel = ((STV090x_GETFIELD(reg, SELX1RATIO_FIELD) == 1) ? 4 : 6);
-
-	div = ((clk_sel * mclk) / config->xtal) - 1;
-
-	reg = stv090x_read_reg(state, STV090x_NCOARSE);
-	STV090x_SETFIELD(reg, M_DIV_FIELD, div);
-	if (stv090x_write_reg(state, STV090x_NCOARSE, reg) < 0)
-		goto err;
-
-	state->internal->mclk = stv090x_get_mclk(state);
-
-	/*Set the DiseqC frequency to 22KHz */
-	div = state->internal->mclk / 704000;
-	if (STV090x_WRITE_DEMOD(state, F22TX, div) < 0)
-		goto err;
-	if (STV090x_WRITE_DEMOD(state, F22RX, div) < 0)
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_set_tspath(struct stv090x_state *state)
-{
-	u32 reg;
-
-	if (state->internal->dev_ver >= 0x20) {
-		switch (state->config->ts1_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-			switch (state->config->ts2_mode) {
-			case STV090x_TSMODE_SERIAL_PUNCTURED:
-			case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			default:
-				stv090x_write_reg(state, STV090x_TSGENERAL, 0x00);
-				break;
-
-			case STV090x_TSMODE_PARALLEL_PUNCTURED:
-			case STV090x_TSMODE_DVBCI:
-				if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x06) < 0) /* Mux'd stream mode */
-					goto err;
-				reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
-				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
-				if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
-					goto err;
-				reg = stv090x_read_reg(state, STV090x_P2_TSCFGM);
-				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
-				if (stv090x_write_reg(state, STV090x_P2_TSCFGM, reg) < 0)
-					goto err;
-				if (stv090x_write_reg(state, STV090x_P1_TSSPEED, 0x14) < 0)
-					goto err;
-				if (stv090x_write_reg(state, STV090x_P2_TSSPEED, 0x28) < 0)
-					goto err;
-				break;
-			}
-			break;
-
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		default:
-			switch (state->config->ts2_mode) {
-			case STV090x_TSMODE_SERIAL_PUNCTURED:
-			case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			default:
-				if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0c) < 0)
-					goto err;
-				break;
-
-			case STV090x_TSMODE_PARALLEL_PUNCTURED:
-			case STV090x_TSMODE_DVBCI:
-				if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0a) < 0)
-					goto err;
-				break;
-			}
-			break;
-		}
-	} else {
-		switch (state->config->ts1_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-			switch (state->config->ts2_mode) {
-			case STV090x_TSMODE_SERIAL_PUNCTURED:
-			case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			default:
-				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x10);
-				break;
-
-			case STV090x_TSMODE_PARALLEL_PUNCTURED:
-			case STV090x_TSMODE_DVBCI:
-				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x16);
-				reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
-				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
-				if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
-					goto err;
-				reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
-				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 0);
-				if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
-					goto err;
-				if (stv090x_write_reg(state, STV090x_P1_TSSPEED, 0x14) < 0)
-					goto err;
-				if (stv090x_write_reg(state, STV090x_P2_TSSPEED, 0x28) < 0)
-					goto err;
-				break;
-			}
-			break;
-
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		default:
-			switch (state->config->ts2_mode) {
-			case STV090x_TSMODE_SERIAL_PUNCTURED:
-			case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			default:
-				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x14);
-				break;
-
-			case STV090x_TSMODE_PARALLEL_PUNCTURED:
-			case STV090x_TSMODE_DVBCI:
-				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x12);
-				break;
-			}
-			break;
-		}
-	}
-
-	switch (state->config->ts1_mode) {
-	case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_DVBCI:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_SERIAL_PUNCTURED:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	default:
-		break;
-	}
-
-	switch (state->config->ts2_mode) {
-	case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
-		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_DVBCI:
-		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_SERIAL_PUNCTURED:
-		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
-		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	case STV090x_TSMODE_SERIAL_CONTINUOUS:
-		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
-		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
-		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
-		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
-		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
-			goto err;
-		break;
-
-	default:
-		break;
-	}
-
-	if (state->config->ts1_clk > 0) {
-		u32 speed;
-
-		switch (state->config->ts1_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-		default:
-			speed = state->internal->mclk /
-				(state->config->ts1_clk / 4);
-			if (speed < 0x08)
-				speed = 0x08;
-			if (speed > 0xFF)
-				speed = 0xFF;
-			break;
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			speed = state->internal->mclk /
-				(state->config->ts1_clk / 32);
-			if (speed < 0x20)
-				speed = 0x20;
-			if (speed > 0xFF)
-				speed = 0xFF;
-			break;
-		}
-		reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
-		STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
-		if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
-			goto err;
-		if (stv090x_write_reg(state, STV090x_P1_TSSPEED, speed) < 0)
-			goto err;
-	}
-
-	if (state->config->ts2_clk > 0) {
-		u32 speed;
-
-		switch (state->config->ts2_mode) {
-		case STV090x_TSMODE_PARALLEL_PUNCTURED:
-		case STV090x_TSMODE_DVBCI:
-		default:
-			speed = state->internal->mclk /
-				(state->config->ts2_clk / 4);
-			if (speed < 0x08)
-				speed = 0x08;
-			if (speed > 0xFF)
-				speed = 0xFF;
-			break;
-		case STV090x_TSMODE_SERIAL_PUNCTURED:
-		case STV090x_TSMODE_SERIAL_CONTINUOUS:
-			speed = state->internal->mclk /
-				(state->config->ts2_clk / 32);
-			if (speed < 0x20)
-				speed = 0x20;
-			if (speed > 0xFF)
-				speed = 0xFF;
-			break;
-		}
-		reg = stv090x_read_reg(state, STV090x_P2_TSCFGM);
-		STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
-		if (stv090x_write_reg(state, STV090x_P2_TSCFGM, reg) < 0)
-			goto err;
-		if (stv090x_write_reg(state, STV090x_P2_TSSPEED, speed) < 0)
-			goto err;
-	}
-
-	reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x01);
-	if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
-		goto err;
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x00);
-	if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
-		goto err;
-
-	reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x01);
-	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-		goto err;
-	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x00);
-	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_init(struct dvb_frontend *fe)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	const struct stv090x_config *config = state->config;
-	u32 reg;
-
-	if (state->internal->mclk == 0) {
-		/* call tuner init to configure the tuner's clock output
-		   divider directly before setting up the master clock of
-		   the stv090x. */
-		if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-			goto err;
-
-		if (config->tuner_init) {
-			if (config->tuner_init(fe) < 0)
-				goto err_gateoff;
-		}
-
-		if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-			goto err;
-
-		stv090x_set_mclk(state, 135000000, config->xtal); /* 135 Mhz */
-		msleep(5);
-		if (stv090x_write_reg(state, STV090x_SYNTCTRL,
-				      0x20 | config->clk_mode) < 0)
-			goto err;
-		stv090x_get_mclk(state);
-	}
-
-	if (stv090x_wakeup(fe) < 0) {
-		dprintk(FE_ERROR, 1, "Error waking device");
-		goto err;
-	}
-
-	if (stv090x_ldpc_mode(state, state->demod_mode) < 0)
-		goto err;
-
-	reg = STV090x_READ_DEMOD(state, TNRCFG2);
-	STV090x_SETFIELD_Px(reg, TUN_IQSWAP_FIELD, state->inversion);
-	if (STV090x_WRITE_DEMOD(state, TNRCFG2, reg) < 0)
-		goto err;
-	reg = STV090x_READ_DEMOD(state, DEMOD);
-	STV090x_SETFIELD_Px(reg, ROLLOFF_CONTROL_FIELD, state->rolloff);
-	if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
-		goto err;
-
-	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
-		goto err;
-
-	if (config->tuner_set_mode) {
-		if (config->tuner_set_mode(fe, TUNER_WAKE) < 0)
-			goto err_gateoff;
-	}
-
-	if (config->tuner_init) {
-		if (config->tuner_init(fe) < 0)
-			goto err_gateoff;
-	}
-
-	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
-		goto err;
-
-	if (stv090x_set_tspath(state) < 0)
-		goto err;
-
-	return 0;
-
-err_gateoff:
-	stv090x_i2c_gate_ctrl(state, 0);
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-static int stv090x_setup(struct dvb_frontend *fe)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	const struct stv090x_config *config = state->config;
-	const struct stv090x_reg *stv090x_initval = NULL;
-	const struct stv090x_reg *stv090x_cut20_val = NULL;
-	unsigned long t1_size = 0, t2_size = 0;
-	u32 reg = 0;
-
-	int i;
-
-	if (state->device == STV0900) {
-		dprintk(FE_DEBUG, 1, "Initializing STV0900");
-		stv090x_initval = stv0900_initval;
-		t1_size = ARRAY_SIZE(stv0900_initval);
-		stv090x_cut20_val = stv0900_cut20_val;
-		t2_size = ARRAY_SIZE(stv0900_cut20_val);
-	} else if (state->device == STV0903) {
-		dprintk(FE_DEBUG, 1, "Initializing STV0903");
-		stv090x_initval = stv0903_initval;
-		t1_size = ARRAY_SIZE(stv0903_initval);
-		stv090x_cut20_val = stv0903_cut20_val;
-		t2_size = ARRAY_SIZE(stv0903_cut20_val);
-	}
-
-	/* STV090x init */
-
-	/* Stop Demod */
-	if (stv090x_write_reg(state, STV090x_P1_DMDISTATE, 0x5c) < 0)
-		goto err;
-	if (stv090x_write_reg(state, STV090x_P2_DMDISTATE, 0x5c) < 0)
-		goto err;
-
-	msleep(5);
-
-	/* Set No Tuner Mode */
-	if (stv090x_write_reg(state, STV090x_P1_TNRCFG, 0x6c) < 0)
-		goto err;
-	if (stv090x_write_reg(state, STV090x_P2_TNRCFG, 0x6c) < 0)
-		goto err;
-
-	/* I2C repeater OFF */
-	STV090x_SETFIELD_Px(reg, ENARPT_LEVEL_FIELD, config->repeater_level);
-	if (stv090x_write_reg(state, STV090x_P1_I2CRPT, reg) < 0)
-		goto err;
-	if (stv090x_write_reg(state, STV090x_P2_I2CRPT, reg) < 0)
-		goto err;
-
-	if (stv090x_write_reg(state, STV090x_NCOARSE, 0x13) < 0) /* set PLL divider */
-		goto err;
-	msleep(5);
-	if (stv090x_write_reg(state, STV090x_I2CCFG, 0x08) < 0) /* 1/41 oversampling */
-		goto err;
-	if (stv090x_write_reg(state, STV090x_SYNTCTRL, 0x20 | config->clk_mode) < 0) /* enable PLL */
-		goto err;
-	msleep(5);
-
-	/* write initval */
-	dprintk(FE_DEBUG, 1, "Setting up initial values");
-	for (i = 0; i < t1_size; i++) {
-		if (stv090x_write_reg(state, stv090x_initval[i].addr, stv090x_initval[i].data) < 0)
-			goto err;
-	}
-
-	state->internal->dev_ver = stv090x_read_reg(state, STV090x_MID);
-	if (state->internal->dev_ver >= 0x20) {
-		if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0c) < 0)
-			goto err;
-
-		/* write cut20_val*/
-		dprintk(FE_DEBUG, 1, "Setting up Cut 2.0 initial values");
-		for (i = 0; i < t2_size; i++) {
-			if (stv090x_write_reg(state, stv090x_cut20_val[i].addr, stv090x_cut20_val[i].data) < 0)
-				goto err;
-		}
-
-	} else if (state->internal->dev_ver < 0x20) {
-		dprintk(FE_ERROR, 1, "ERROR: Unsupported Cut: 0x%02x!",
-			state->internal->dev_ver);
-
-		goto err;
-	} else if (state->internal->dev_ver > 0x30) {
-		/* we shouldn't bail out from here */
-		dprintk(FE_ERROR, 1, "INFO: Cut: 0x%02x probably incomplete support!",
-			state->internal->dev_ver);
-	}
-
-	/* ADC1 range */
-	reg = stv090x_read_reg(state, STV090x_TSTTNR1);
-	STV090x_SETFIELD(reg, ADC1_INMODE_FIELD,
-		(config->adc1_range == STV090x_ADC_1Vpp) ? 0 : 1);
-	if (stv090x_write_reg(state, STV090x_TSTTNR1, reg) < 0)
-		goto err;
-
-	/* ADC2 range */
-	reg = stv090x_read_reg(state, STV090x_TSTTNR3);
-	STV090x_SETFIELD(reg, ADC2_INMODE_FIELD,
-		(config->adc2_range == STV090x_ADC_1Vpp) ? 0 : 1);
-	if (stv090x_write_reg(state, STV090x_TSTTNR3, reg) < 0)
-		goto err;
-
-	if (stv090x_write_reg(state, STV090x_TSTRES0, 0x80) < 0)
-		goto err;
-	if (stv090x_write_reg(state, STV090x_TSTRES0, 0x00) < 0)
-		goto err;
-
-	return 0;
-err:
-	dprintk(FE_ERROR, 1, "I/O error");
-	return -1;
-}
-
-int stv090x_set_gpio(struct dvb_frontend *fe, u8 gpio, u8 dir, u8 value,
-		u8 xor_value)
-{
-	struct stv090x_state *state = fe->demodulator_priv;
-	u8 reg = 0;
-
-	STV090x_SETFIELD(reg, GPIOx_OPD_FIELD, dir);
-	STV090x_SETFIELD(reg, GPIOx_CONFIG_FIELD, value);
-	STV090x_SETFIELD(reg, GPIOx_XOR_FIELD, xor_value);
-
-	return stv090x_write_reg(state, STV090x_GPIOxCFG(gpio), reg);
-}
-EXPORT_SYMBOL(stv090x_set_gpio);
-
-static struct dvb_frontend_ops stv090x_ops = {
-	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
-	.info = {
-		.name			= "STV090x Multistandard",
-		.frequency_min		= 950000,
-		.frequency_max 		= 2150000,
-		.frequency_stepsize	= 0,
-		.frequency_tolerance	= 0,
-		.symbol_rate_min 	= 1000000,
-		.symbol_rate_max 	= 45000000,
-		.caps			= FE_CAN_INVERSION_AUTO |
-					  FE_CAN_FEC_AUTO       |
-					  FE_CAN_QPSK           |
-					  FE_CAN_2G_MODULATION
-	},
-
-	.release			= stv090x_release,
-	.init				= stv090x_init,
-
-	.sleep				= stv090x_sleep,
-	.get_frontend_algo		= stv090x_frontend_algo,
-
-	.diseqc_send_master_cmd		= stv090x_send_diseqc_msg,
-	.diseqc_send_burst		= stv090x_send_diseqc_burst,
-	.diseqc_recv_slave_reply	= stv090x_recv_slave_reply,
-	.set_tone			= stv090x_set_tone,
-
-	.search				= stv090x_search,
-	.read_status			= stv090x_read_status,
-	.read_ber			= stv090x_read_per,
-	.read_signal_strength		= stv090x_read_signal_strength,
-	.read_snr			= stv090x_read_cnr,
-};
-
-
-struct dvb_frontend *stv090x_attach(const struct stv090x_config *config,
-				    struct i2c_adapter *i2c,
-				    enum stv090x_demodulator demod)
-{
-	struct stv090x_state *state = NULL;
-	struct stv090x_dev *temp_int;
-
-	state = kzalloc(sizeof (struct stv090x_state), GFP_KERNEL);
-	if (state == NULL)
-		goto error;
-
-	state->verbose				= &verbose;
-	state->config				= config;
-	state->i2c				= i2c;
-	state->frontend.ops			= stv090x_ops;
-	state->frontend.demodulator_priv	= state;
-	state->demod				= demod;
-	state->demod_mode 			= config->demod_mode; /* Single or Dual mode */
-	state->device				= config->device;
-	state->rolloff				= STV090x_RO_35; /* default */
-
-	temp_int = find_dev(state->i2c,
-				state->config->address);
-
-	if ((temp_int != NULL) && (state->demod_mode == STV090x_DUAL)) {
-		state->internal = temp_int->internal;
-		state->internal->num_used++;
-		dprintk(FE_INFO, 1, "Found Internal Structure!");
-	} else {
-		state->internal = kmalloc(sizeof(struct stv090x_internal),
-					  GFP_KERNEL);
-		if (!state->internal)
-			goto error;
-		temp_int = append_internal(state->internal);
-		if (!temp_int) {
-			kfree(state->internal);
-			goto error;
-		}
-		state->internal->num_used = 1;
-		state->internal->mclk = 0;
-		state->internal->dev_ver = 0;
-		state->internal->i2c_adap = state->i2c;
-		state->internal->i2c_addr = state->config->address;
-		dprintk(FE_INFO, 1, "Create New Internal Structure!");
-
-		mutex_init(&state->internal->demod_lock);
-		mutex_init(&state->internal->tuner_lock);
-
-		if (stv090x_setup(&state->frontend) < 0) {
-			dprintk(FE_ERROR, 1, "Error setting up device");
-			goto err_remove;
-		}
-	}
-
-	/* workaround for stuck DiSEqC output */
-	if (config->diseqc_envelope_mode)
-		stv090x_send_diseqc_burst(&state->frontend, SEC_MINI_A);
-
-	dprintk(FE_ERROR, 1, "Attaching %s demodulator(%d) Cut=0x%02x",
-	       state->device == STV0900 ? "STV0900" : "STV0903",
-	       demod,
-	       state->internal->dev_ver);
-
-	return &state->frontend;
-
-err_remove:
-	remove_dev(state->internal);
-	kfree(state->internal);
-error:
-	kfree(state);
-	return NULL;
-}
-EXPORT_SYMBOL(stv090x_attach);
-MODULE_PARM_DESC(verbose, "Set Verbosity level");
-MODULE_AUTHOR("Manu Abraham");
-MODULE_DESCRIPTION("STV090x Multi-Std Broadcast frontend");
-MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/dvb/ngene/Makefile media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/Makefile
--- media_build_experimental//linux/drivers/media/dvb/ngene/Makefile	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/Makefile	2011-11-02 05:45:17.000000000 +0100
@@ -2,8 +2,7 @@
 # Makefile for the nGene device driver
 #
 
-ngene-objs := ngene-core.o ngene-i2c.o ngene-cards.o ngene-av.o \
-	ngene-eeprom.o ngene-dvb.o
+ngene-objs := ngene-core.o ngene-i2c.o ngene-cards.o ngene-dvb.o
 
 obj-$(CONFIG_DVB_NGENE) += ngene.o
 
@@ -12,4 +11,4 @@
 ccflags-y += -Idrivers/media/common/tuners/
 
 # For the staging CI driver cxd2099
-ccflags-y += -Idrivers/staging/cxd2099/
+ccflags-y += -Idrivers/staging/media/cxd2099/
diff -urN media_build_experimental//linux/drivers/media/dvb/ngene/ngene-cards.c media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-cards.c
--- media_build_experimental//linux/drivers/media/dvb/ngene/ngene-cards.c	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-cards.c	2012-01-22 02:53:17.000000000 +0100
@@ -31,7 +31,6 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
-#include "compat.h"
 
 #include "ngene.h"
 
@@ -85,96 +84,6 @@
 	return 0;
 }
 
-#if 0
-static int tuner_attach_mt2060(struct ngene_channel *chan)
-{
-	struct ngene *dev = chan->dev;
-	void *tconf = dev->card_info->tuner_config[chan->number];
-	u8 drxa = dev->card_info->demoda[chan->number];
-	struct dvb_frontend *fe = chan->fe, *fe2;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-	fe->misc_priv = chan;
-#else
-	fe->sec_priv = chan;
-#endif
-	fe->ops.i2c_gate_ctrl = dev->card_info->gate_ctrl;
-
-	dev->card_info->gate_ctrl(fe, 1);
-	fe2 = mt2060_attach(fe, &chan->i2c_adapter, tconf, 1220);
-	dev->card_info->gate_ctrl(fe, 0);
-
-	i2c_write_register(&chan->i2c_adapter, drxa, 3, 4);
-	write_demod(&chan->i2c_adapter, drxa, 0x1012, 15);
-	write_demod(&chan->i2c_adapter, drxa, 0x1007, 0xc27);
-	write_demod(&chan->i2c_adapter, drxa, 0x0020, 0x003);
-
-	return fe2 ? 0 : -ENODEV;
-}
-
-static int tuner_attach_xc3028(struct ngene_channel *chan)
-{
-	struct ngene *dev = chan->dev;
-	void *tconf = dev->card_info->tuner_config[chan->number];
-	struct dvb_frontend *fe = chan->fe, *fe2;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-	fe->misc_priv = chan;
-#else
-	fe->sec_priv = chan;
-#endif
-	fe->ops.i2c_gate_ctrl = dev->card_info->gate_ctrl;
-
-	dev->card_info->gate_ctrl(fe, 1);
-	fe2 = xc3028_attach(fe, &chan->i2c_adapter, tconf);
-	dev->card_info->gate_ctrl(fe, 0);
-
-	/*chan->fe->ops.tuner_ops.set_frequency(chan->fe,231250000);*/
-
-	return fe2 ? 0 : -ENODEV;
-}
-
-static int demod_attach_drxd(struct ngene_channel *chan)
-{
-	void *feconf = chan->dev->card_info->fe_config[chan->number];
-
-	chan->fe = drxd_attach(feconf,
-			       chan, &chan->i2c_adapter,
-			       &chan->dev->pci_dev->dev);
-	return (chan->fe) ? 0 : -ENODEV;
-}
-
-static int demod_attach_drxh(struct ngene_channel *chan)
-{
-	void *feconf = chan->dev->card_info->fe_config[chan->number];
-
-	chan->fe = drxh_attach(feconf, chan,
-			       &chan->i2c_adapter, &chan->dev->pci_dev->dev);
-	return (chan->fe) ? 0 : -ENODEV;
-}
-
-static int demod_attach_stb0899(struct ngene_channel *chan)
-{
-	void *feconf = chan->dev->card_info->fe_config[chan->number];
-
-	chan->fe = stb0899_attach(feconf,
-				  chan, &chan->i2c_adapter,
-				  &chan->dev->pci_dev->dev);
-	if (chan->fe) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
-		chan->set_tone = chan->fe->ops->set_tone;
-		chan->fe->ops->set_tone = lnbh21_set_tone;
-		chan->fe->ops->set_voltage = lnbh21_set_voltage;
-#else
-		chan->set_tone = chan->fe->ops.set_tone;
-		chan->fe->ops.set_tone = lnbh21_set_tone;
-		chan->fe->ops.set_voltage = lnbh21_set_voltage;
-#endif
-	}
-
-	return (chan->fe) ? 0 : -ENODEV;
-}
-#endif
 
 static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
@@ -307,14 +216,10 @@
 	struct drxk_config config;
 
 	memset(&config, 0, sizeof(config));
-	config.adr = 0x29 + (chan->number ^ 2);
 	config.microcode_name = "drxk_a3.mc";
+	config.adr = 0x29 + (chan->number ^ 2);
 
-#ifdef USE_API3
-	chan->fe = dvb_attach(drxk_attach, &config, i2c, &chan->fe2);
-#else
 	chan->fe = dvb_attach(drxk_attach, &config, i2c);
-#endif
 	if (!chan->fe) {
 		printk(KERN_ERR "No DRXK found!\n");
 		return -ENODEV;
@@ -411,136 +316,6 @@
 /* Switch control (I2C gates, etc.) *****************************************/
 /****************************************************************************/
 
-#if 0
-static int avf_output(struct ngene_channel *chan, int state)
-{
-	if (chan->dev->card_info->avf[chan->number])
-		i2c_write_register(&chan->i2c_adapter,
-				   chan->dev->card_info->avf[chan->number],
-				   0xf2, state ? 0x89 : 0x80);
-	return 0;
-}
-
-/* Viper expander: sw11,sw12,sw21,sw22,i2csw1,i2csw2,tsen1,tsen2 */
-
-static int exp_set(struct ngene *dev)
-{
-	return i2c_write(&dev->channel[0].i2c_adapter,
-			 dev->card_info->exp, dev->exp_val);
-}
-
-static int exp_init(struct ngene *dev)
-{
-	if (!dev->card_info->exp)
-		return 0;
-	dev->exp_val = dev->card_info->exp_init;
-	return exp_set(dev);
-}
-
-static int exp_set_bit(struct ngene *dev, int bit, int val)
-{
-	if (val)
-		set_bit(bit, &dev->exp_val);
-	else
-		clear_bit(bit, &dev->exp_val);
-	return exp_set(dev);
-}
-
-static int viper_switch_ctrl(struct ngene_channel *chan, int type, int val)
-{
-	switch (type) {
-	case 0: /* I2C tuner gate on/off */
-		return exp_set_bit(chan->dev, 4 + chan->number, val);
-	case 1: /* Stream: 0=TS 1=ITU */
-		avf_output(chan, val);
-		return exp_set_bit(chan->dev, 6 + chan->number, val);
-	case 2: /* Input: 0=digital 1=analog antenna input */
-		exp_set_bit(chan->dev, 0 + chan->number * 2, val ? 0 : 1);
-		exp_set_bit(chan->dev, 1 + chan->number * 2, val ? 1 : 0);
-		break;
-	}
-	return 0;
-}
-
-static int viper_switch_ctrl2(struct ngene_channel *chan, int type, int val)
-{
-	switch (type) {
-	case 0: /* I2C tuner gate on/off */
-		return exp_set_bit(chan->dev, 4 + chan->number, val);
-	case 1: /* Stream: 0=TS 1=ITU */
-		avf_output(chan, val);
-		return exp_set_bit(chan->dev, 6 + chan->number, val);
-	case 2: /* Input: 0=digital 1=analog antenna input */
-		exp_set_bit(chan->dev, 0 + chan->number * 2, val ? 0 : 1);
-		exp_set_bit(chan->dev, 1 + chan->number * 2, 0);
-		break;
-	}
-	return 0;
-}
-
-static int viper_gate_ctrl(struct dvb_frontend *fe, int enable)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-	struct ngene_channel *chan = fe->misc_priv;
-#else /* Why is there no misc_priv available anymore !?!?! */
-	/* Well, just abuse sec :-) */
-	struct ngene_channel *chan = fe->sec_priv;
-#endif
-	struct ngene *dev = chan->dev;
-
-	return dev->card_info->switch_ctrl(chan, 0, enable);
-}
-
-static int python_switch_ctrl(struct ngene_channel *chan, int type, int val)
-{
-	switch (type) {
-	case 0: /* I2C tuner gate on/off */
-		if (chan->number > 1)
-			return -EINVAL;
-		return ngene_command_gpio_set(chan->dev, 3 + chan->number, val);
-	case 1: /* Stream: 0=TS 1=ITU */
-		avf_output(chan, val);
-		return 0;
-	}
-	return 0;
-}
-
-static int viper_reset_xc(struct dvb_frontend *fe)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-	struct ngene_channel *chan = fe->misc_priv;
-#else
-	struct ngene_channel *chan = fe->sec_priv;
-#endif
-	struct ngene *dev = chan->dev;
-
-	printk(KERN_INFO DEVICE_NAME ": Reset XC3028\n");
-
-	if (chan->number > 1)
-		return -EINVAL;
-
-	ngene_command_gpio_set(dev, 3 + chan->number, 0);
-	msleep(150);
-	ngene_command_gpio_set(dev, 3 + chan->number, 1);
-	return 0;
-}
-
-static int python_gate_ctrl(struct dvb_frontend *fe, int enable)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-	struct ngene_channel *chan = fe->misc_priv;
-#else /* Why is there no misc_priv available anymore !?!?! */
-	struct ngene_channel *chan = fe->sec_priv;
-#endif
-	struct ngene *dev = chan->dev;
-
-	if (chan->number == 0)
-		return ngene_command_gpio_set(dev, 3, enable);
-	if (chan->number == 1)
-		return ngene_command_gpio_set(dev, 4, enable);
-	return -EINVAL;
-}
-#endif
 
 static struct stv090x_config fe_cineS2 = {
 	.device         = STV0900,
@@ -690,323 +465,6 @@
 
 /****************************************************************************/
 
-#if 0
-static struct drxd_config fe_terratec_dvbt_0 = {
-	.index          = 0,
-	.demod_address  = 0x70,
-	.demod_revision = 0xa2,
-	.demoda_address = 0x00,
-	.pll_address    = 0x60,
-	.pll_type       = DRXD_PLL_DTT7520X,
-	.clock          = 20000,
-	.pll_set        = ngene_pll_set_th_dtt7520x,
-	.osc_deviation  = osc_deviation,
-};
-
-static struct drxd_config fe_terratec_dvbt_1 = {
-	.index          = 1,
-	.demod_address  = 0x71,
-	.demod_revision = 0xa2,
-	.demoda_address = 0x00,
-	.pll_address    = 0x60,
-	.pll_type       = DRXD_PLL_DTT7520X,
-	.clock          = 20000,
-	.pll_set        = ngene_pll_set_th_dtt7520x,
-	.osc_deviation  = osc_deviation,
-};
-
-static struct ngene_info ngene_info_terratec = {
-	.type           = NGENE_TERRATEC,
-	.name           = "Terratec Integra/Cinergy2400i Dual DVB-T",
-	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
-	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
-	.fe_config      = {&fe_terratec_dvbt_0, &fe_terratec_dvbt_1},
-	.i2c_access     = 1,
-};
-
-/****************************************************************************/
-
-static struct mt2060_config tuner_python_0 = {
-	.i2c_address    = 0x60,
-	.clock_out      = 3,
-	.input          = 0
-};
-
-static struct mt2060_config tuner_python_1 = {
-	.i2c_address    = 0x61,
-	.clock_out      = 3,
-	.input          = 1
-};
-
-static struct drxd_config fe_python_0 = {
-	.index          = 0,
-	.demod_address  = 0x71,
-	.demod_revision = 0xb1,
-	.demoda_address = 0x41,
-	.clock          = 16000,
-	.osc_deviation  = osc_deviation,
-};
-
-static struct drxd_config fe_python_1 = {
-	.index          = 1,
-	.demod_address  = 0x70,
-	.demod_revision = 0xb1,
-	.demoda_address = 0x45,
-	.clock          = 16000,
-	.osc_deviation  = osc_deviation,
-};
-
-static struct ngene_info ngene_info_python = {
-	.type           = NGENE_PYTHON,
-	.name           = "Micronas MicPython/Hedgehog Dual DVB-T",
-	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_AIN, NGENE_IO_AIN},
-	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
-	.tuner_attach   = {tuner_attach_mt2060, tuner_attach_mt2060},
-	.fe_config      = {&fe_python_0, &fe_python_1},
-	.tuner_config   = {&tuner_python_0, &tuner_python_1},
-	.avf            = {0x43, 0x47},
-	.msp            = {0x40, 0x42},
-	.demoda         = {0x41, 0x45},
-	.gate_ctrl      = python_gate_ctrl,
-	.switch_ctrl    = python_switch_ctrl,
-};
-
-/****************************************************************************/
-
-static struct drxd_config fe_appb_dvbt_0 = {
-	.index          = 0,
-	.demod_address  = 0x71,
-	.demod_revision = 0xa2,
-	.demoda_address = 0x41,
-	.pll_address    = 0x63,
-	.pll_type       = DRXD_PLL_MT3X0823,
-	.clock          = 20000,
-	.pll_set        = ngene_pll_set_mt_3x0823,
-	.osc_deviation  = osc_deviation,
-};
-
-static struct drxd_config fe_appb_dvbt_1 = {
-	.index          = 1,
-	.demod_address  = 0x70,
-	.demod_revision = 0xa2,
-	.demoda_address = 0x45,
-	.pll_address    = 0x60,
-	.pll_type       = DRXD_PLL_MT3X0823,
-	.clock          = 20000,
-	.pll_set        = ngene_pll_set_mt_3x0823,
-	.osc_deviation  = osc_deviation,
-};
-
-static struct ngene_info ngene_info_appboard = {
-	.type           = NGENE_APP,
-	.name           = "Micronas Application Board Dual DVB-T",
-	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
-	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
-	.fe_config      = {&fe_appb_dvbt_0, &fe_appb_dvbt_1},
-	.avf            = {0x43, 0x47},
-};
-
-static struct ngene_info ngene_info_appboard_ntsc = {
-	.type           = NGENE_APP,
-	.name           = "Micronas Application Board Dual DVB-T",
-	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
-	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
-	.fe_config      = {&fe_appb_dvbt_0, &fe_appb_dvbt_1},
-	.avf            = {0x43, 0x47},
-	.ntsc           = 1,
-};
-
-/****************************************************************************/
-
-static struct stb0899_config fe_sidewinder_0 = {
-	.demod_address  = 0x68,
-	.pll_address    = 0x63,
-};
-
-static struct stb0899_config fe_sidewinder_1 = {
-	.demod_address  = 0x6b,
-	.pll_address    = 0x60,
-};
-
-static struct ngene_info ngene_info_sidewinder = {
-	.type           = NGENE_SIDEWINDER,
-	.name           = "Micronas MicSquirrel/Sidewinder Dual DVB-S2",
-	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
-	.demod_attach   = {demod_attach_stb0899, demod_attach_stb0899},
-	.fe_config      = {&fe_sidewinder_0, &fe_sidewinder_1},
-	.lnb            = {0x0b, 0x08},
-};
-
-/****************************************************************************/
-/* Yet unnamed S2 card with dual DVB-S2 demod                               */
-/****************************************************************************/
-
-static struct stv0900_config fe_s2_0 = {
-	.addr           = 0x68,
-	.pll            = 0x63,
-	.pll_type       = 0,
-	.nr             = 0,
-};
-
-static struct stv0900_config fe_s2_1 = {
-	.addr           = 0x68,
-	.pll            = 0x60,
-	.pll_type       = 0,
-	.nr             = 1,
-};
-
-static struct ngene_info ngene_info_s2 = {
-	.type           = NGENE_SIDEWINDER,
-	.name           = "S2",
-	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN,
-			   NGENE_IO_TSIN, NGENE_IO_TSIN},
-	.demod_attach   = {demod_attach_stv0900, demod_attach_stv0900},
-	.fe_config      = {&fe_s2_0, &fe_s2_1},
-	.lnb            = {0x0b, 0x08},
-	.tsf            = {3, 3},
-	.fw_version     = 15,
-};
-
-static struct stv0900_config fe_s2b_0 = {
-	.addr           = 0x68,
-	.pll            = 0x60,
-	.pll_type       = 0x10,
-	.nr             = 0,
-};
-
-static struct stv0900_config fe_s2b_1 = {
-	.addr           = 0x68,
-	.pll            = 0x63,
-	.pll_type       = 0x10,
-	.nr             = 1,
-};
-
-static struct ngene_info ngene_info_s2_b = {
-	.type           = NGENE_SIDEWINDER,
-	.name           = "S2 V2",
-	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN,
-			   NGENE_IO_TSIN, NGENE_IO_TSIN},
-	.demod_attach   = {demod_attach_stv0900, demod_attach_stv0900},
-	.fe_config      = {&fe_s2b_0, &fe_s2b_1},
-	.lnb            = {0x0b, 0x08},
-	.tsf            = {3, 3},
-	.fw_version     = 17,
-};
-
-/****************************************************************************/
-
-static struct xc3028_config tuner_viper_0 = {
-	.adr            = 0x61,
-	.reset          = viper_reset_xc
-};
-
-static struct xc3028_config tuner_viper_1 = {
-	.adr            = 0x64,
-	.reset          = viper_reset_xc
-};
-
-static struct drxh_config fe_viper_h_0 = {.adr = 0x2b};
-
-static struct drxh_config fe_viper_h_1 = {.adr = 0x29};
-
-static struct drxh_config fe_viper_l_0 = {.adr = 0x2b, .type = 3931};
-
-static struct drxh_config fe_viper_l_1 = {.adr = 0x29, .type = 3931};
-
-static struct ngene_info ngene_info_viper_v1 = {
-	.type           = NGENE_VIPER,
-	.name           = "Micronas MicViper Dual ATSC DRXH",
-	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_AIN, NGENE_IO_AIN},
-	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
-	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
-	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
-	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
-	.avf            = {0x43, 0x47},
-	.msp            = {0x40, 0x42},
-	.exp            = 0x20,
-	.exp_init       = 0xf5,
-	.gate_ctrl      = viper_gate_ctrl,
-	.switch_ctrl    = viper_switch_ctrl,
-	.tsf            = {2, 2},
-};
-
-static struct ngene_info ngene_info_viper_v2 = {
-	.type           = NGENE_VIPER,
-	.name           = "Micronas MicViper Dual ATSC DRXL",
-	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_AIN, NGENE_IO_AIN},
-	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
-	.fe_config      = {&fe_viper_l_0, &fe_viper_l_1},
-	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
-	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
-	.avf            = {0x43, 0x47},
-	.msp            = {0x40, 0x42},
-	.exp            = 0x38,
-	.exp_init       = 0xf5,
-	.gate_ctrl      = viper_gate_ctrl,
-	.switch_ctrl    = viper_switch_ctrl,
-	.tsf            = {2, 2},
-};
-
-/****************************************************************************/
-
-static struct ngene_info ngene_info_vbox_v1 = {
-	.type           = NGENE_VBOX_V1,
-	.name           = "VBox Cat's Eye 164E",
-	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_AIN, NGENE_IO_AIN},
-	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
-	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
-	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
-	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
-	.avf            = {0x43, 0x47},
-	.msp            = {0x40, 0x42},
-	.exp            = 0x20,
-	.exp_init       = 0xf5,
-	.gate_ctrl      = viper_gate_ctrl,
-	.switch_ctrl    = viper_switch_ctrl,
-	.tsf            = {2, 2},
-};
-
-/****************************************************************************/
-
-static struct ngene_info ngene_info_vbox_v2 = {
-	.type           = NGENE_VBOX_V2,
-	.name           = "VBox Cat's Eye 164E",
-	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_TSIN | NGENE_IO_TV,
-			   NGENE_IO_AIN, NGENE_IO_AIN},
-	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
-	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
-	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
-	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
-	.avf            = {0x43, 0x47},
-	.msp            = {0x40, 0x42},
-	.exp            = 0x20,
-	.exp_init       = 0xf5,
-	.gate_ctrl      = viper_gate_ctrl,
-	.switch_ctrl    = viper_switch_ctrl2,
-	.tsf            = {2, 2},
-};
-
-/****************************************************************************/
-
-static struct ngene_info ngene_info_racer = {
-	.type           = NGENE_RACER,
-	.name           = "Micronas MicRacer HDTV Decoder Card",
-	.io_type        = {NGENE_IO_HDTV, NGENE_IO_NONE,
-			   NGENE_IO_AIN, NGENE_IO_NONE,
-			   NGENE_IO_TSOUT},
-	.i2s            = {0, 0, 1, 0},
-	.fw_version     = 17,
-};
-#endif
 
 
 /****************************************************************************/
@@ -1021,8 +479,6 @@
 /****************************************************************************/
 
 static const struct pci_device_id ngene_id_tbl[] __devinitdata = {
-	NGENE_ID(0x18c3, 0xab04, ngene_info_cineS2),
-	NGENE_ID(0x18c3, 0xab05, ngene_info_cineS2v5),
 	NGENE_ID(0x18c3, 0xabc3, ngene_info_cineS2),
 	NGENE_ID(0x18c3, 0xabc4, ngene_info_cineS2),
 	NGENE_ID(0x18c3, 0xdb01, ngene_info_satixS2),
@@ -1031,32 +487,6 @@
 	NGENE_ID(0x18c3, 0xdd10, ngene_info_duoFlex),
 	NGENE_ID(0x18c3, 0xdd20, ngene_info_duoFlex),
 	NGENE_ID(0x1461, 0x062e, ngene_info_m780),
-#if 0 /* not (yet?) supported */
-	NGENE_ID(0x18c3, 0x0000, ngene_info_appboard),
-	NGENE_ID(0x18c3, 0x0004, ngene_info_appboard),
-	NGENE_ID(0x18c3, 0x8011, ngene_info_appboard),
-	NGENE_ID(0x18c3, 0x8015, ngene_info_appboard_ntsc),
-	NGENE_ID(0x153b, 0x1167, ngene_info_terratec),
-	NGENE_ID(0x18c3, 0x0030, ngene_info_python),
-	NGENE_ID(0x18c3, 0x0052, ngene_info_sidewinder),
-	NGENE_ID(0x18c3, 0x8f00, ngene_info_racer),
-	NGENE_ID(0x18c3, 0x0041, ngene_info_viper_v1),
-	NGENE_ID(0x18c3, 0x0042, ngene_info_viper_v2),
-	NGENE_ID(0x14f3, 0x0041, ngene_info_vbox_v1),
-	NGENE_ID(0x14f3, 0x0043, ngene_info_vbox_v2),
-	NGENE_ID(0x18c3, 0xabcd, ngene_info_s2),
-	NGENE_ID(0x18c3, 0xabc2, ngene_info_s2_b),
-	NGENE_ID(0x18c3, 0xabc3, ngene_info_s2_b),
-	NGENE_ID(0x18c3, 0x0001, ngene_info_appboard),
-	NGENE_ID(0x18c3, 0x0005, ngene_info_appboard),
-	NGENE_ID(0x18c3, 0x0009, ngene_info_appboard_atsc),
-	NGENE_ID(0x18c3, 0x000b, ngene_info_appboard_atsc),
-	NGENE_ID(0x18c3, 0x0010, ngene_info_shrek_50_fp),
-	NGENE_ID(0x18c3, 0x0011, ngene_info_shrek_60_fp),
-	NGENE_ID(0x18c3, 0x0012, ngene_info_shrek_50),
-	NGENE_ID(0x18c3, 0x0013, ngene_info_shrek_60),
-	NGENE_ID(0x18c3, 0x0000, ngene_info_hognose),
-#endif
 	{0}
 };
 MODULE_DEVICE_TABLE(pci, ngene_id_tbl);
diff -urN media_build_experimental//linux/drivers/media/dvb/ngene/ngene-core.c media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-core.c
--- media_build_experimental//linux/drivers/media/dvb/ngene/ngene-core.c	2012-02-27 10:44:16.618908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-core.c	2011-07-11 20:09:53.000000000 +0200
@@ -38,7 +38,6 @@
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
 #include <linux/vmalloc.h>
-#include "compat.h"
 
 #include "ngene.h"
 
@@ -87,14 +86,6 @@
 		if ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))
 			dev->RxEventNotify(dev, Event.TimeStamp,
 					   Event.RXCharacter);
-#if 0
-		if ((Event.GPIOStatus & 0x80) && (dev->Gpio2EventNotify))
-			dev->Gpio2EventNotify(dev, Event.TimeStamp,
-					      Event.GPIOStatus & 0x1f);
-		if ((Event.GPIOStatus & 0x40) && (dev->Gpio3EventNotify))
-			dev->Gpio3EventNotify(dev, Event.TimeStamp,
-					      Event.GPIOStatus & 0x1f);
-#endif
 	}
 }
 
@@ -223,13 +214,6 @@
 		u8 nextWriteIndex =
 			(dev->EventQueueWriteIndex + 1) &
 			(EVENT_QUEUE_SIZE - 1);
-#if 0
-		printk(KERN_ERR DEVICE_NAME
-		       ": Event interrupt %02x Uart = %02x Gpio = %02x\n",
-		       dev->EventBuffer->EventStatus,
-		       dev->EventBuffer->UARTStatus,
-		       dev->EventBuffer->GPIOStatus);
-#endif
 		if (nextWriteIndex != dev->EventQueueReadIndex) {
 			dev->EventQueue[dev->EventQueueWriteIndex] =
 				*(dev->EventBuffer);
@@ -338,24 +322,12 @@
 	ngwritel(1, FORCE_INT);
 
 	ret = wait_event_timeout(dev->cmd_wq, dev->cmd_done == 1, 2 * HZ);
-#if 0
-	if (ret < 0)
-		return ret;
-	if (!dev->cmd_done)
-		;
-#endif
 	if (!ret) {
 		/*ngwritel(0, FORCE_NMI);*/
 
 		printk(KERN_ERR DEVICE_NAME
 		       ": Command timeout cmd=%02x prev=%02x\n",
 		       com->cmd.hdr.Opcode, dev->prev_cmd);
-#if 0
-		printk(KERN_ERR DEVICE_NAME ": Icounts=%08x\n",
-		       ngreadl(NGENE_INT_COUNTS));
-		if (ngreadl(NGENE_INT_COUNTS) == 0xffffffff)
-			ngwritel(0, NGENE_INT_ENABLE);
-#endif
 		dump_command_io(dev);
 		return -1;
 	}
@@ -382,19 +354,6 @@
 	return result;
 }
 
-#if 0
-int ngene_command_nop(struct ngene *dev)
-{
-	struct ngene_command com;
-
-	com.cmd.hdr.Opcode = CMD_NOP;
-	com.cmd.hdr.Length = 0;
-	com.in_len = 0;
-	com.out_len = 0;
-
-	return ngene_command(dev, &com);
-}
-#endif
 
 static int ngene_command_load_firmware(struct ngene *dev,
 				       u8 *ngene_fw, u32 size)
@@ -429,83 +388,6 @@
 	return ngene_command(dev, &com);
 }
 
-#if 0
-int ngene_command_imem_read(struct ngene *dev, u8 adr, u8 *data, int type)
-{
-	struct ngene_command com;
-
-	com.cmd.hdr.Opcode = type ? CMD_SFR_READ : CMD_IRAM_READ;
-	com.cmd.hdr.Length = 1;
-	com.cmd.SfrIramRead.address = adr;
-	com.in_len = 1;
-	com.out_len = 2;
-
-	if (ngene_command(dev, &com) < 0)
-		return -EIO;
-
-	*data = com.cmd.raw8[1];
-	return 0;
-}
-
-int ngene_command_imem_write(struct ngene *dev, u8 adr, u8 data, int type)
-{
-	struct ngene_command com;
-
-	com.cmd.hdr.Opcode = type ? CMD_SFR_WRITE : CMD_IRAM_WRITE;
-	com.cmd.hdr.Length = 2;
-	com.cmd.SfrIramWrite.address = adr;
-	com.cmd.SfrIramWrite.data = data;
-	com.in_len = 2;
-	com.out_len = 1;
-
-	if (ngene_command(dev, &com) < 0)
-		return -EIO;
-
-	return 0;
-}
-
-static int ngene_command_config_uart(struct ngene *dev, u8 config,
-				     tx_cb_t *tx_cb, rx_cb_t *rx_cb)
-{
-	struct ngene_command com;
-
-	com.cmd.hdr.Opcode = CMD_CONFIGURE_UART;
-	com.cmd.hdr.Length = sizeof(struct FW_CONFIGURE_UART) - 2;
-	com.cmd.ConfigureUart.UartControl = config;
-	com.in_len = sizeof(struct FW_CONFIGURE_UART);
-	com.out_len = 0;
-
-	if (ngene_command(dev, &com) < 0)
-		return -EIO;
-
-	dev->TxEventNotify = tx_cb;
-	dev->RxEventNotify = rx_cb;
-
-	dprintk(KERN_DEBUG DEVICE_NAME ": Set UART config %02x.\n", config);
-
-	return 0;
-}
-
-static void tx_cb(struct ngene *dev, u32 ts)
-{
-	dev->tx_busy = 0;
-	wake_up_interruptible(&dev->tx_wq);
-}
-
-static void rx_cb(struct ngene *dev, u32 ts, u8 c)
-{
-	int rp = dev->uart_rp;
-	int nwp, wp = dev->uart_wp;
-
-	/* dprintk(KERN_DEBUG DEVICE_NAME ": %c\n", c); */
-	nwp = (wp + 1) % (UART_RBUF_LEN);
-	if (nwp == rp)
-		return;
-	dev->uart_rbuf[wp] = c;
-	dev->uart_wp = nwp;
-	wake_up_interruptible(&dev->rx_wq);
-}
-#endif
 
 static int ngene_command_config_buf(struct ngene *dev, u8 config)
 {
@@ -551,18 +433,6 @@
 	return ngene_command(dev, &com);
 }
 
-#if 0
-/* The reset is only wired to GPIO4 on MicRacer Revision 1.10 !
-   Also better set bootdelay to 1 in nvram or less. */
-static void ngene_reset_decypher(struct ngene *dev)
-{
-	printk(KERN_INFO DEVICE_NAME ": Resetting Decypher.\n");
-	ngene_command_gpio_set(dev, 4, 0);
-	msleep(1);
-	ngene_command_gpio_set(dev, 4, 1);
-	msleep(2000);
-}
-#endif
 
 /*
  02000640 is sample on rising edge.
@@ -648,17 +518,6 @@
 	}
 }
 
-#if 0
-static void clear_tsin(struct ngene_channel *chan)
-{
-	struct SBufferHeader *Cur = chan->nextBuffer;
-
-	do {
-		memset(&Cur->ngeneBuffer.SR, 0, sizeof(Cur->ngeneBuffer.SR));
-		Cur = Cur->Next;
-	} while (Cur != chan->nextBuffer);
-}
-#endif
 
 static void flush_buffers(struct ngene_channel *chan)
 {
@@ -879,14 +738,6 @@
 	if (dev->card_info->switch_ctrl)
 		dev->card_info->switch_ctrl(chan, 1, state ^ 1);
 
-#if 0
-	/* Disable AVF output if present. */
-	if (dev->card_info->avf[chan->number])
-		i2c_write_register(&chan->i2c_adapter,
-				   chan->dev->card_info->avf[chan->number],
-				   0xf2, state ? 0x80 : 0x89);
-
-#endif
 	if (state) {
 		spin_lock_irq(&chan->state_lock);
 
@@ -926,89 +777,6 @@
 	}
 }
 
-#if 0
-/****************************************************************************/
-/* Decypher firmware loading ************************************************/
-/****************************************************************************/
-
-#define DECYPHER_FW "decypher.fw"
-
-static int dec_ts_send(struct ngene *dev, u8 *buf, u32 len)
-{
-#if 0
-	if (wait_event_interruptible(dev->tsout_rbuf.queue,
-				     dvb_ringbuffer_free
-				     (&dev->tsout_rbuf) >= len) < 0)
-		return 0;
-#else
-	while (dvb_ringbuffer_free(&dev->tsout_rbuf) < len)
-		msleep(1);
-
-#endif
-
-	dvb_ringbuffer_write(&dev->tsout_rbuf, buf, len);
-
-	return len;
-}
-
-u8 dec_fw_fill_ts[188] = { 0x47, 0x09, 0x0e, 0x10, 0xff, 0xff, 0x00, 0x00 };
-
-int dec_fw_send(struct ngene *dev, u8 *fw, u32 size)
-{
-	struct ngene_channel *chan = &dev->channel[4];
-	u32 len = 180, cc = 0;
-	u8 buf[8] = { 0x47, 0x09, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00 };
-
-	set_transfer(chan, 1);
-	msleep(100);
-	while (size) {
-		len = 180;
-		if (len > size)
-			len = size;
-		buf[3] = 0x10 | (cc & 0x0f);
-		buf[4] = (cc >> 8);
-		buf[5] = cc & 0xff;
-		buf[6] = len;
-
-		dec_ts_send(dev, buf, 8);
-		dec_ts_send(dev, fw, len);
-		if (len < 180)
-			dec_ts_send(dev, dec_fw_fill_ts + len + 8, 180 - len);
-		cc++;
-		size -= len;
-		fw += len;
-	}
-	for (len = 0; len < 512; len++)
-		dec_ts_send(dev, dec_fw_fill_ts, 188);
-	while (dvb_ringbuffer_avail(&dev->tsout_rbuf))
-		msleep(10);
-	msleep(100);
-	set_transfer(chan, 0);
-	return 0;
-}
-
-int dec_fw_boot(struct ngene *dev)
-{
-	u32 size;
-	const struct firmware *fw = NULL;
-	u8 *dec_fw;
-
-	if (request_firmware(&fw, DECYPHER_FW, &dev->pci_dev->dev) < 0) {
-		printk(KERN_ERR DEVICE_NAME
-		       ": %s not found. Check hotplug directory.\n",
-		       DECYPHER_FW);
-		return -1;
-	}
-	printk(KERN_INFO DEVICE_NAME ": Booting decypher firmware file %s\n",
-	       DECYPHER_FW);
-
-	size = fw->size;
-	dec_fw = (u8 *)fw->data;
-	dec_fw_send(dev, dec_fw, size);
-	release_firmware(fw);
-	return 0;
-}
-#endif
 
 /****************************************************************************/
 /* nGene hardware init and release functions ********************************/
@@ -1303,85 +1071,6 @@
 	0
 };
 
-#if 0
-static int allocate_buffer(struct pci_dev *pci_dev, dma_addr_t of,
-			   struct SRingBufferDescriptor *rbuf,
-			   u32 entries, u32 size1, u32 size2)
-{
-	if (create_ring_buffer(pci_dev, rbuf, entries) < 0)
-		return -ENOMEM;
-
-	if (AllocateRingBuffers(pci_dev, of, rbuf, size1, size2) < 0)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static int channel_allocate_buffers(struct ngene_channel *chan)
-{
-	struct ngene *dev = chan->dev;
-	int type = dev->card_info->io_type[chan->number];
-	int status;
-
-	chan->State = KSSTATE_STOP;
-
-	if (type & (NGENE_IO_TV | NGENE_IO_HDTV | NGENE_IO_AIN)) {
-		status = create_ring_buffer(dev->pci_dev,
-					    &chan->RingBuffer,
-					    RingBufferSizes[chan->number]);
-		if (status < 0)
-			return -ENOMEM;
-
-		if (type & (NGENE_IO_TV | NGENE_IO_AIN)) {
-			status = AllocateRingBuffers(dev->pci_dev,
-						     dev->PAOverflowBuffer,
-						     &chan->RingBuffer,
-						     Buffer1Sizes[chan->number],
-						     Buffer2Sizes[chan->
-								  number]);
-			if (status < 0)
-				return -ENOMEM;
-		} else if (type & NGENE_IO_HDTV) {
-			status = AllocateRingBuffers(dev->pci_dev,
-						     dev->PAOverflowBuffer,
-						     &chan->RingBuffer,
-						     MAX_HDTV_BUFFER_SIZE, 0);
-			if (status < 0)
-				return -ENOMEM;
-		}
-	}
-
-	if (type & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {
-
-		status = create_ring_buffer(dev->pci_dev,
-					    &chan->TSRingBuffer, RING_SIZE_TS);
-		if (status < 0)
-			return -ENOMEM;
-
-		status = AllocateRingBuffers(dev->pci_dev,
-					     dev->PAOverflowBuffer,
-					     &chan->TSRingBuffer,
-					     MAX_TS_BUFFER_SIZE, 0);
-		if (status)
-			return -ENOMEM;
-	}
-
-	if (type & NGENE_IO_TSOUT) {
-		status = create_ring_buffer(dev->pci_dev,
-					    &chan->TSIdleBuffer, 1);
-		if (status < 0)
-			return -ENOMEM;
-		status = AllocateRingBuffers(dev->pci_dev,
-					     dev->PAOverflowBuffer,
-					     &chan->TSIdleBuffer,
-					     MAX_TS_BUFFER_SIZE, 0);
-		if (status)
-			return -ENOMEM;
-		FillTSIdleBuffer(&chan->TSIdleBuffer, &chan->TSRingBuffer);
-	}
-	return 0;
-}
-#endif
 
 static int AllocCommonBuffers(struct ngene *dev)
 {
@@ -1635,10 +1324,6 @@
 		u8 tsin12_config[6]   = { 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 };
 		u8 tsin1234_config[6] = { 0x30, 0x30, 0x00, 0x30, 0x30, 0x00 };
 		u8 tsio1235_config[6] = { 0x30, 0x30, 0x00, 0x28, 0x00, 0x38 };
-#if 0
-		u8 tsin34_config[6]   = { 0x00, 0x00, 0x00, 0x60, 0x60, 0x00 };
-		u8 tsio35_config[6]   = { 0x00, 0x00, 0x00, 0x60, 0x00, 0x60 };
-#endif
 		u8 *bconf = tsin12_config;
 
 		if (dev->card_info->io_type[2]&NGENE_IO_TSIN &&
@@ -1648,22 +1333,10 @@
 			    dev->ci.en)
 				bconf = tsio1235_config;
 		}
-#if 0
-		if (dev->card_info->io_type[0] == NGENE_IO_HDTV) {
-			bconf = hdtv_config;
-			ngene_reset_decypher(dev);
-		}
-#endif
 		stat = ngene_command_config_free_buf(dev, bconf);
 	} else {
 		int bconf = BUFFER_CONFIG_4422;
 
-#if 0
-		if (dev->card_info->io_type[0] == NGENE_IO_HDTV) {
-			bconf = BUFFER_CONFIG_8022;
-			ngene_reset_decypher(dev);
-		}
-#endif
 		if (dev->card_info->io_type[3] == NGENE_IO_TSIN)
 			bconf = BUFFER_CONFIG_3333;
 		stat = ngene_command_config_buf(dev, bconf);
@@ -2024,33 +1697,6 @@
 
 
 	dev->i2c_current_bus = -1;
-#if 0
-	exp_init(dev);
-
-	/* Disable analog TV decoder chips if present */
-	if (dev->card_info->msp[0])
-		i2c_write_msp_register(&dev->channel[0].i2c_adapter,
-				       dev->card_info->msp[0], 0x00, 0x0000);
-	if (dev->card_info->msp[1])
-		i2c_write_msp_register(&dev->channel[1].i2c_adapter,
-				       dev->card_info->msp[1], 0x00, 0x0000);
-	{
-		u16 data;
-		read_msp(&dev->channel[0].i2c_adapter,
-			 dev->card_info->msp[0], 0x00, &data);
-	}
-	if (dev->card_info->avf[0])
-		i2c_write_register(&dev->channel[0].i2c_adapter,
-				   dev->card_info->avf[0], 0xf2, 0x80);
-	if (dev->card_info->avf[1])
-		i2c_write_register(&dev->channel[1].i2c_adapter,
-				   dev->card_info->avf[1], 0xf2, 0x80);
-	if (copy_eeprom) {
-		i2c_copy_eeprom(&dev->channel[0].i2c_adapter, 0x50, 0x52);
-		i2c_dump_eeprom(&dev->channel[0].i2c_adapter, 0x52);
-	}
-	/*i2c_check_eeprom(&dev->i2c_adapter);*/
-#endif
 
 	/* Register DVB adapters and devices for both channels */
 	if (init_channels(dev) < 0)
diff -urN media_build_experimental//linux/drivers/media/dvb/ngene/ngene-dvb.c media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-dvb.c
--- media_build_experimental//linux/drivers/media/dvb/ngene/ngene-dvb.c	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-dvb.c	2011-07-11 20:09:53.000000000 +0200
@@ -39,323 +39,13 @@
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
 #include <linux/vmalloc.h>
-#include "compat.h"
 
 #include "ngene.h"
 
-#if 0
-int ngene_stream_control(struct ngene *dev, u8 stream, u8 control, u8 mode,
-			 u16 lines, u16 bpl, u16 vblines, u16 vbibpl)
-{
-	if (!(mode & SMODE_TRANSPORT_STREAM))
-		return -EINVAL;
-
-	if (lines * bpl > MAX_VIDEO_BUFFER_SIZE)
-		return -EINVAL;
-
-	if ((mode & SMODE_TRANSPORT_STREAM) && (((bpl * lines) & 0xff) != 0))
-		return -EINVAL;
-
-	if ((mode & SMODE_VIDEO_CAPTURE) && (bpl & 7) != 0)
-		return -EINVAL;
-
-	return ngene_command_stream_control(dev, stream, control, mode, 0);
-}
-#endif
 
 /****************************************************************************/
 /* COMMAND API interface ****************************************************/
 /****************************************************************************/
-#if 0
-
-static int command_do_ioctl(struct inode *inode, struct file *file,
-			    unsigned int cmd, void *parg)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ngene_channel *chan = dvbdev->priv;
-	struct ngene *dev = chan->dev;
-	int err = 0;
-
-	switch (cmd) {
-	case IOCTL_MIC_NO_OP:
-		err = ngene_command_nop(dev);
-		break;
-
-	case IOCTL_MIC_DOWNLOAD_FIRMWARE:
-		break;
-
-	case IOCTL_MIC_I2C_READ:
-	{
-		MIC_I2C_READ *msg = parg;
-
-		err = ngene_command_i2c_read(dev, msg->I2CAddress >> 1,
-					     msg->OutData, msg->OutLength,
-					     msg->OutData, msg->InLength, 1);
-		break;
-	}
-
-	case IOCTL_MIC_I2C_WRITE:
-	{
-		MIC_I2C_WRITE *msg = parg;
-
-		err = ngene_command_i2c_write(dev, msg->I2CAddress >> 1,
-					      msg->Data, msg->Length);
-		break;
-	}
-
-	case IOCTL_MIC_TEST_GETMEM:
-	{
-		MIC_MEM *m = parg;
-
-		if (m->Length > 64 * 1024 || m->Start + m->Length > 64 * 1024)
-			return -EINVAL;
-
-		/* WARNING, only use this on x86,
-		   other archs may not swallow this  */
-		err = copy_to_user(m->Data, dev->iomem + m->Start, m->Length);
-		break;
-	}
-
-	case IOCTL_MIC_TEST_SETMEM:
-	{
-		MIC_MEM *m = parg;
-
-		if (m->Length > 64 * 1024 || m->Start + m->Length > 64 * 1024)
-			return -EINVAL;
-
-		err = copy_from_user(dev->iomem + m->Start, m->Data, m->Length);
-		break;
-	}
-
-	case IOCTL_MIC_SFR_READ:
-	{
-		MIC_IMEM *m = parg;
-
-		err = ngene_command_imem_read(dev, m->Address, &m->Data, 1);
-		break;
-	}
-
-	case IOCTL_MIC_SFR_WRITE:
-	{
-		MIC_IMEM *m = parg;
-
-		err = ngene_command_imem_write(dev, m->Address, m->Data, 1);
-		break;
-	}
-
-	case IOCTL_MIC_IRAM_READ:
-	{
-		MIC_IMEM *m = parg;
-
-		err = ngene_command_imem_read(dev, m->Address, &m->Data, 0);
-		break;
-	}
-
-	case IOCTL_MIC_IRAM_WRITE:
-	{
-		MIC_IMEM *m = parg;
-
-		err = ngene_command_imem_write(dev, m->Address, m->Data, 0);
-		break;
-	}
-
-	case IOCTL_MIC_STREAM_CONTROL:
-	{
-		MIC_STREAM_CONTROL *m = parg;
-
-		err = ngene_stream_control(dev, m->Stream, m->Control, m->Mode,
-					   m->nLines, m->nBytesPerLine,
-					   m->nVBILines, m->nBytesPerVBILine);
-		break;
-	}
-
-	default:
-		err = -EINVAL;
-		break;
-	}
-	return err;
-}
-
-static int command_ioctl(struct inode *inode, struct file *file,
-			 unsigned int cmd, unsigned long arg)
-{
-	void *parg = (void *)arg, *pbuf = NULL;
-	char  buf[64];
-	int   res = -EFAULT;
-
-	if (_IOC_DIR(cmd) & _IOC_WRITE) {
-		parg = buf;
-		if (_IOC_SIZE(cmd) > sizeof(buf)) {
-			pbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
-			if (!pbuf)
-				return -ENOMEM;
-			parg = pbuf;
-		}
-		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
-			goto error;
-	}
-	res = command_do_ioctl(inode, file, cmd, parg);
-	if (res < 0)
-		goto error;
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
-			res = -EFAULT;
-error:
-	kfree(pbuf);
-	return res;
-}
-
-struct page *ngene_nopage(struct vm_area_struct *vma,
-			  unsigned long address, int *type)
-{
-	return 0;
-}
-
-static int ngene_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ngene_channel *chan = dvbdev->priv;
-	struct ngene *dev = chan->dev;
-
-	unsigned long size = vma->vm_end - vma->vm_start;
-	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long padr = pci_resource_start(dev->pci_dev, 0) + off;
-	unsigned long psize = pci_resource_len(dev->pci_dev, 0) - off;
-
-	if (size > psize)
-		return -EINVAL;
-
-	if (io_remap_pfn_range(vma, vma->vm_start, padr >> PAGE_SHIFT, size,
-			       vma->vm_page_prot))
-		return -EAGAIN;
-	return 0;
-}
-
-
-static int write_uart(struct ngene *dev, u8 *data, int len)
-{
-	struct ngene_command com;
-
-	com.cmd.hdr.Opcode = CMD_WRITE_UART;
-	com.cmd.hdr.Length = len;
-	memcpy(com.cmd.WriteUart.Data, data, len);
-	com.cmd.WriteUart.Data[len] = 0;
-	com.cmd.WriteUart.Data[len + 1] = 0;
-	com.in_len = len;
-	com.out_len = 0;
-
-	if (ngene_command(dev, &com) < 0)
-		return -EIO;
-
-	return 0;
-}
-
-static int send_cli(struct ngene *dev, char *cmd)
-{
-	/* printk(KERN_INFO DEVICE_NAME ": %s", cmd); */
-	return write_uart(dev, cmd, strlen(cmd));
-}
-
-static int send_cli_val(struct ngene *dev, char *cmd, u32 val)
-{
-	char s[32];
-
-	snprintf(s, 32, "%s %d\n", cmd, val);
-	/* printk(KERN_INFO DEVICE_NAME ": %s", s); */
-	return write_uart(dev, s, strlen(s));
-}
-
-static int ngene_command_write_uart_user(struct ngene *dev,
-					 const u8 *data, int len)
-{
-	struct ngene_command com;
-
-	dev->tx_busy = 1;
-	com.cmd.hdr.Opcode = CMD_WRITE_UART;
-	com.cmd.hdr.Length = len;
-
-	if (copy_from_user(com.cmd.WriteUart.Data, data, len))
-		return -EFAULT;
-	com.in_len = len;
-	com.out_len = 0;
-
-	if (ngene_command(dev, &com) < 0)
-		return -EIO;
-
-	return 0;
-}
-
-static ssize_t uart_write(struct file *file, const char *buf,
-			  size_t count, loff_t *ppos)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ngene_channel *chan = dvbdev->priv;
-	struct ngene *dev = chan->dev;
-	int len, ret = 0;
-	size_t left = count;
-
-	while (left) {
-		len = left;
-		if (len > 250)
-			len = 250;
-		ret = wait_event_interruptible(dev->tx_wq, dev->tx_busy == 0);
-		if (ret < 0)
-			return ret;
-		ngene_command_write_uart_user(dev, buf, len);
-		left -= len;
-		buf += len;
-	}
-	return count;
-}
-
-static ssize_t uart_read(struct file *file, char *buf,
-			 size_t count, loff_t *ppos)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ngene_channel *chan = dvbdev->priv;
-	struct ngene *dev = chan->dev;
-	int left;
-	int wp, rp, avail, len;
-
-	if (!dev->uart_rbuf)
-		return -EINVAL;
-	if (count > 128)
-		count = 128;
-	left = count;
-	while (left) {
-		if (wait_event_interruptible(dev->rx_wq,
-					     dev->uart_wp != dev->uart_rp) < 0)
-			return -EAGAIN;
-		wp = dev->uart_wp;
-		rp = dev->uart_rp;
-		avail = (wp - rp);
-
-		if (avail < 0)
-			avail += UART_RBUF_LEN;
-		if (avail > left)
-			avail = left;
-		if (wp < rp) {
-			len = UART_RBUF_LEN - rp;
-			if (len > avail)
-				len = avail;
-			if (copy_to_user(buf, dev->uart_rbuf + rp, len))
-				return -EFAULT;
-			if (len < avail)
-				if (copy_to_user(buf + len, dev->uart_rbuf,
-						 avail - len))
-					return -EFAULT;
-		} else {
-			if (copy_to_user(buf, dev->uart_rbuf + rp, avail))
-				return -EFAULT;
-		}
-		dev->uart_rp = (rp + avail) % UART_RBUF_LEN;
-		left -= avail;
-		buf += avail;
-	}
-	return count;
-}
-
-#endif
 
 static ssize_t ts_write(struct file *file, const char *buf,
 			size_t count, loff_t *ppos)
@@ -443,11 +133,6 @@
 	struct ngene_channel *chan = priv;
 	struct ngene *dev = chan->dev;
 
-#if 0
-	printk(KERN_INFO DEVICE_NAME ": tsin %08x %02x %02x %02x %02x\n",
-	       len, ((u8 *) buf)[512 * 188], ((u8 *) buf)[0],
-	       ((u8 *) buf)[1], ((u8 *) buf)[2]);
-#endif
 
 	if (flags & DF_SWAP32)
 		swap_buffer(buf, len);
@@ -506,49 +191,12 @@
 	return buf;
 }
 
-#if 0
-static void set_dto(struct ngene_channel *chan, u32 rate)
-{
-	u64 val = rate * 0x89705f41ULL; /* times val for 2^26 Hz */
-
-	val = ((val >> 25) + 1) >> 1;
-	chan->AudioDTOValue = (u32) val;
-	/* chan->AudioDTOUpdated=1; */
-	/* printk(KERN_INFO DEVICE_NAME ": Setting DTO to %08x\n", val); */
-}
-#endif
 
 
 int ngene_start_feed(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ngene_channel *chan = dvbdmx->priv;
-#if 0
-	struct ngene *dev = chan->dev;
-
-	if (dev->card_info->io_type[chan->number] & NGENE_IO_TSOUT) {
-		switch (dvbdmxfeed->pes_type) {
-		case DMX_TS_PES_VIDEO:
-			send_cli_val(dev, "vpid", dvbdmxfeed->pid);
-			send_cli(dev, "res 1080i50\n");
-			/* send_cli(dev, "vdec mpeg2\n"); */
-			break;
-
-		case DMX_TS_PES_AUDIO:
-			send_cli_val(dev, "apid", dvbdmxfeed->pid);
-			send_cli(dev, "start\n");
-			break;
-
-		case DMX_TS_PES_PCR:
-			send_cli_val(dev, "pcrpid", dvbdmxfeed->pid);
-			break;
-
-		default:
-			break;
-		}
-
-	}
-#endif
 
 	if (chan->users == 0) {
 		if (!chan->dev->cmd_timeout_workaround || !chan->running)
@@ -562,27 +210,6 @@
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ngene_channel *chan = dvbdmx->priv;
-#if 0
-	struct ngene *dev = chan->dev;
-
-	if (dev->card_info->io_type[chan->number] & NGENE_IO_TSOUT) {
-		switch (dvbdmxfeed->pes_type) {
-		case DMX_TS_PES_VIDEO:
-			send_cli(dev, "stop\n");
-			break;
-
-		case DMX_TS_PES_AUDIO:
-			break;
-
-		case DMX_TS_PES_PCR:
-			break;
-
-		default:
-			break;
-		}
-
-	}
-#endif
 
 	if (--chan->users)
 		return chan->users;
diff -urN media_build_experimental//linux/drivers/media/dvb/ngene/ngene.h media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene.h
--- media_build_experimental//linux/drivers/media/dvb/ngene/ngene.h	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene.h	2011-07-11 20:09:53.000000000 +0200
@@ -653,11 +653,6 @@
 	struct dmx_frontend   mem_frontend;
 	int                   users;
 	struct video_device  *v4l_dev;
-#if 0
-	struct dvb_device    *command_dev;
-	struct dvb_device    *audio_dev;
-	struct dvb_device    *video_dev;
-#endif
 	struct dvb_device    *ci_dev;
 	struct tasklet_struct demux_tasklet;
 
@@ -696,9 +691,6 @@
 	struct mychip        *mychip;
 	struct snd_card      *soundcard;
 	u8                   *evenbuffer;
-#if 0
-	u8                   *soundbuffer;
-#endif
 	u8                    dma_on;
 	int                   soundstreamon;
 	int                   audiomute;
@@ -857,10 +849,6 @@
 	u8    lnb[4];
 	int   i2c_access;
 	u8    ntsc;
-#if 0
-	u8    exp;
-	u8    exp_init;
-#endif
 	u8    tsf[4];
 	u8    i2s[4];
 
@@ -897,25 +885,6 @@
 };
 #endif
 
-#if 0
-int ngene_command_stream_control(struct ngene *dev,
-				 u8 stream, u8 control, u8 mode, u8 flags);
-int ngene_command_nop(struct ngene *dev);
-int ngene_command_i2c_read(struct ngene *dev, u8 adr,
-			   u8 *out, u8 outlen, u8 *in, u8 inlen, int flag);
-int ngene_command_i2c_write(struct ngene *dev, u8 adr, u8 *out, u8 outlen);
-int ngene_command_imem_read(struct ngene *dev, u8 adr, u8 *data, int type);
-int ngene_command_imem_write(struct ngene *dev, u8 adr, u8 data, int type);
-int ngene_stream_control(struct ngene *dev, u8 stream, u8 control, u8 mode,
-			 u16 lines, u16 bpl, u16 vblines, u16 vbibpl);
-
-int ngene_v4l2_init(struct ngene_channel *chan);
-void ngene_v4l2_remove(struct ngene_channel *chan);
-int ngene_snd_exit(struct ngene_channel *chan);
-int ngene_snd_init(struct ngene_channel *chan);
-
-struct i2c_client *avf4910a_attach(struct i2c_adapter *adap, int addr);
-#endif
 
 /* Provided by ngene-core.c */
 int __devinit ngene_probe(struct pci_dev *pci_dev,
@@ -946,15 +915,6 @@
 			       struct dmx_frontend *mem_frontend,
 			       struct dvb_adapter *dvb_adapter);
 
-/* Provided by ngene-eeprom.c */
-#if 0
-int i2c_copy_eeprom(struct i2c_adapter *adapter, u8 adr, u8 adr2);
-int i2c_dump_eeprom(struct i2c_adapter *adapter, u8 adr);
-int i2c_check_eeprom(struct i2c_adapter *adapter);
-int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data);
-int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data);
-#endif
-
 #endif
 
 /*  LocalWords:  Endif
diff -urN media_build_experimental//linux/drivers/media/dvb/ngene/ngene-i2c.c media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-i2c.c
--- media_build_experimental//linux/drivers/media/dvb/ngene/ngene-i2c.c	2012-02-27 10:44:16.608908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/dvb/ngene/ngene-i2c.c	2011-01-10 16:23:56.000000000 +0100
@@ -41,7 +41,6 @@
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
 #include <linux/vmalloc.h>
-#include "compat.h"
 
 #include "ngene.h"
 
@@ -78,11 +77,6 @@
 {
 	struct ngene_command com;
 
-#if 0
-	/* Probing by writing 0 bytes does not work */
-	if (!outlen)
-		outlen++;
-#endif
 
 	com.cmd.hdr.Opcode = CMD_I2C_WRITE;
 	com.cmd.hdr.Length = outlen + 1;
@@ -154,39 +148,6 @@
 	return num;
 }
 
-#if 0
-static int ngene_i2c_algo_control(struct i2c_adapter *adap,
-				  unsigned int cmd, unsigned long arg)
-{
-	struct ngene_channel *chan =
-		(struct ngene_channel *)i2c_get_adapdata(adap);
-
-	switch (cmd) {
-	case IOCTL_MIC_TUN_RDY:
-		chan->tun_rdy = 1;
-		if (chan->dec_rdy == 1)
-			chan->tun_dec_rdy = 1;
-		break;
-
-	case IOCTL_MIC_DEC_RDY:
-		chan->dec_rdy = 1;
-		if (chan->tun_rdy == 1)
-			chan->tun_dec_rdy = 1;
-		break;
-
-	case IOCTL_MIC_TUN_DETECT:
-		{
-			int *palorbtsc = (int *)arg;
-			*palorbtsc = chan->dev->card_info->ntsc;
-			break;
-		}
-
-	default:
-		break;
-	}
-	return 0;
-}
-#endif
 
 static u32 ngene_i2c_functionality(struct i2c_adapter *adap)
 {
@@ -213,78 +174,3 @@
 	return i2c_add_adapter(adap);
 }
 
-#if 0
-int i2c_write(struct i2c_adapter *adapter, u8 adr, u8 data)
-{
-	u8 m[1] = {data};
-	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 1};
-
-	if (i2c_transfer(adapter, &msg, 1) != 1) {
-		printk(KERN_ERR DEVICE_NAME
-		       ": Failed to write to I2C adr %02x!\n", adr);
-		return -1;
-	}
-	return 0;
-}
-
-static int i2c_write_register(struct i2c_adapter *adapter,
-			      u8 adr, u8 reg, u8 data)
-{
-	u8 m[2] = {reg, data};
-	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 2};
-
-	if (i2c_transfer(adapter, &msg, 1) != 1) {
-		printk(KERN_ERR DEVICE_NAME
-		       ": Failed to write to I2C register %02x@%02x!\n",
-		       reg, adr);
-		return -1;
-	}
-	return 0;
-}
-
-static int i2c_write_read(struct i2c_adapter *adapter,
-			  u8 adr, u8 *w, u8 wlen, u8 *r, u8 rlen)
-{
-	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
-				   .buf = w, .len = wlen},
-				  {.addr = adr, .flags = I2C_M_RD,
-				   .buf = r, .len = rlen} };
-
-	if (i2c_transfer(adapter, msgs, 2) != 2) {
-		printk(KERN_ERR DEVICE_NAME ": error in i2c_write_read\n");
-		return -1;
-	}
-	return 0;
-}
-
-static int test_dec_i2c(struct i2c_adapter *adapter, int reg)
-{
-	u8 data[256] = { reg, 0x00, 0x93, 0x78, 0x43, 0x45 };
-	u8 data2[256];
-	int i;
-
-	memset(data2, 0, 256);
-	i2c_write_read(adapter, 0x66, data, 2, data2, 4);
-	for (i = 0; i < 4; i++)
-		printk(KERN_DEBUG "%02x ", data2[i]);
-	printk(KERN_DEBUG "\n");
-
-	return 0;
-}
-
-static int i2c_write_msp_register(struct i2c_adapter *adapter,
-				  u8 adr, u8 reg, u16 data)
-{
-	u8 m[3] = {reg, (data >> 8) & 0xff, data & 0xff};
-	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 3 };
-
-	if (i2c_transfer(adapter, &msg, 1) != 1) {
-		printk(KERN_ERR DEVICE_NAME
-		       ": Failed to write to I2C register %02x@%02x!\n",
-		       reg, adr);
-		return -1;
-	}
-	return 0;
-}
-
-#endif
diff -urN media_build_experimental//linux/drivers/media/Kconfig media-experimental-media_build_experimental//linux/drivers/media/Kconfig
--- media_build_experimental//linux/drivers/media/Kconfig	2012-02-27 10:48:36.968908938 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/Kconfig	2011-06-22 05:45:32.000000000 +0200
@@ -126,6 +126,4 @@
 
 source "drivers/media/dvb/Kconfig"
 
-source "drivers/media/common/saa716x/Kconfig"
-
 endif # MEDIA_SUPPORT
diff -urN media_build_experimental//linux/drivers/media/Kconfig.orig media-experimental-media_build_experimental//linux/drivers/media/Kconfig.orig
--- media_build_experimental//linux/drivers/media/Kconfig.orig	2011-06-22 05:45:32.000000000 +0200
+++ media-experimental-media_build_experimental//linux/drivers/media/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,129 +0,0 @@
-#
-# Multimedia device configuration
-#
-
-menuconfig MEDIA_SUPPORT
-	tristate "Multimedia support"
-	depends on HAS_IOMEM
-	help
-	  If you want to use Video for Linux, DVB for Linux, or DAB adapters,
-	  enable this option and other options below.
-
-if MEDIA_SUPPORT
-
-comment "Multimedia core support"
-
-#
-# Media controller
-#
-
-config MEDIA_CONTROLLER
-	bool "Media Controller API (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	---help---
-	  Enable the media controller API used to query media devices internal
-	  topology and configure it dynamically.
-
-	  This API is mostly used by camera interfaces in embedded platforms.
-
-#
-# V4L core and enabled API's
-#
-
-config VIDEO_DEV
-	tristate "Video For Linux"
-	---help---
-	  V4L core support for video capture and overlay devices, webcams and
-	  AM/FM radio cards.
-
-	  This kernel includes support for the new Video for Linux Two API,
-	  (V4L2).
-
-	  Additional info and docs are available on the web at
-	  <http://linuxtv.org>
-
-	  Documentation for V4L2 is also available on the web at
-	  <http://bytesex.org/v4l/>.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called videodev.
-
-config VIDEO_V4L2_COMMON
-	tristate
-	depends on (I2C || I2C=n) && VIDEO_DEV
-	default (I2C || I2C=n) && VIDEO_DEV
-
-config VIDEO_V4L2_SUBDEV_API
-	bool "V4L2 sub-device userspace API (EXPERIMENTAL)"
-	depends on VIDEO_DEV && MEDIA_CONTROLLER && EXPERIMENTAL
-	---help---
-	  Enables the V4L2 sub-device pad-level userspace API used to configure
-	  video format, size and frame rate between hardware blocks.
-
-	  This API is mostly used by camera interfaces in embedded platforms.
-
-#
-# DVB Core
-#
-
-config DVB_CORE
-	tristate "DVB for Linux"
-	select CRC32
-	help
-	  DVB core utility functions for device handling, software fallbacks etc.
-
-	  Enable this if you own a DVB/ATSC adapter and want to use it or if
-	  you compile Linux for a digital SetTopBox.
-
-	  Say Y when you have a DVB or an ATSC card and want to use it.
-
-	  API specs and user tools are available from <http://www.linuxtv.org/>.
-
-	  Please report problems regarding this support to the LinuxDVB
-	  mailing list.
-
-	  If unsure say N.
-
-config DVB_NET
-	bool "DVB Network Support"
-	default (NET && INET)
-	depends on NET && INET && DVB_CORE
-	help
-	  This option enables DVB Network Support which is a part of the DVB
-	  standard. It is used, for example, by automatic firmware updates used
-	  on Set-Top-Boxes. It can also be used to access the Internet via the
-	  DVB card, if the network provider supports it.
-
-	  You may want to disable the network support on embedded devices. If
-	  unsure say Y.
-
-config VIDEO_MEDIA
-	tristate
-	default (DVB_CORE && (VIDEO_DEV = n)) || (VIDEO_DEV && (DVB_CORE = n)) || (DVB_CORE && VIDEO_DEV)
-
-comment "Multimedia drivers"
-
-source "drivers/media/common/Kconfig"
-source "drivers/media/rc/Kconfig"
-
-#
-# Tuner drivers for DVB and V4L
-#
-
-source "drivers/media/common/tuners/Kconfig"
-
-#
-# Video/Radio/Hybrid adapters
-#
-
-source "drivers/media/video/Kconfig"
-
-source "drivers/media/radio/Kconfig"
-
-#
-# DVB adapters
-#
-
-source "drivers/media/dvb/Kconfig"
-
-endif # MEDIA_SUPPORT
diff -urN media_build_experimental//linux/drivers/media/rc/rc-main.c~ media-experimental-media_build_experimental//linux/drivers/media/rc/rc-main.c~
--- media_build_experimental//linux/drivers/media/rc/rc-main.c~	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/rc/rc-main.c~	2012-02-27 00:02:35.738915017 +0100
@@ -0,0 +1,1200 @@
+/* rc-main.c - Remote Controller core module
+ *
+ * Copyright (C) 2009-2010 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include <media/rc-core.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include "rc-core-priv.h"
+
+/* Sizes are in bytes, 256 bytes allows for 32 entries on x64 */
+#define IR_TAB_MIN_SIZE	256
+#define IR_TAB_MAX_SIZE	8192
+
+/* FIXME: IR_KEYPRESS_TIMEOUT should be protocol specific */
+#define IR_KEYPRESS_TIMEOUT 250
+
+/* Used to keep track of known keymaps */
+static LIST_HEAD(rc_map_list);
+static DEFINE_SPINLOCK(rc_map_lock);
+
+static struct rc_map_list *seek_rc_map(const char *name)
+{
+	struct rc_map_list *map = NULL;
+
+	spin_lock(&rc_map_lock);
+	list_for_each_entry(map, &rc_map_list, list) {
+		if (!strcmp(name, map->map.name)) {
+			spin_unlock(&rc_map_lock);
+			return map;
+		}
+	}
+	spin_unlock(&rc_map_lock);
+
+	return NULL;
+}
+
+struct rc_map *rc_map_get(const char *name)
+{
+
+	struct rc_map_list *map;
+
+	map = seek_rc_map(name);
+#ifdef MODULE
+	if (!map) {
+		int rc = request_module(name);
+		if (rc < 0) {
+			printk(KERN_ERR "Couldn't load IR keymap %s\n", name);
+			return NULL;
+		}
+		msleep(20);	/* Give some time for IR to register */
+
+		map = seek_rc_map(name);
+	}
+#endif
+	if (!map) {
+		printk(KERN_ERR "IR keymap %s not found\n", name);
+		return NULL;
+	}
+
+	printk(KERN_INFO "Registered IR keymap %s\n", map->map.name);
+
+	return &map->map;
+}
+EXPORT_SYMBOL_GPL(rc_map_get);
+
+int rc_map_register(struct rc_map_list *map)
+{
+	spin_lock(&rc_map_lock);
+	list_add_tail(&map->list, &rc_map_list);
+	spin_unlock(&rc_map_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rc_map_register);
+
+void rc_map_unregister(struct rc_map_list *map)
+{
+	spin_lock(&rc_map_lock);
+	list_del(&map->list);
+	spin_unlock(&rc_map_lock);
+}
+EXPORT_SYMBOL_GPL(rc_map_unregister);
+
+
+static struct rc_map_table empty[] = {
+	{ 0x2a, KEY_COFFEE },
+};
+
+static struct rc_map_list empty_map = {
+	.map = {
+		.scan    = empty,
+		.size    = ARRAY_SIZE(empty),
+		.rc_type = RC_TYPE_UNKNOWN,	/* Legacy IR type */
+		.name    = RC_MAP_EMPTY,
+	}
+};
+
+/**
+ * ir_create_table() - initializes a scancode table
+ * @rc_map:	the rc_map to initialize
+ * @name:	name to assign to the table
+ * @rc_type:	ir type to assign to the new table
+ * @size:	initial size of the table
+ * @return:	zero on success or a negative error code
+ *
+ * This routine will initialize the rc_map and will allocate
+ * memory to hold at least the specified number of elements.
+ */
+static int ir_create_table(struct rc_map *rc_map,
+			   const char *name, u64 rc_type, size_t size)
+{
+	rc_map->name = name;
+	rc_map->rc_type = rc_type;
+	rc_map->alloc = roundup_pow_of_two(size * sizeof(struct rc_map_table));
+	rc_map->size = rc_map->alloc / sizeof(struct rc_map_table);
+	rc_map->scan = kmalloc(rc_map->alloc, GFP_KERNEL);
+	if (!rc_map->scan)
+		return -ENOMEM;
+
+	IR_dprintk(1, "Allocated space for %u keycode entries (%u bytes)\n",
+		   rc_map->size, rc_map->alloc);
+	return 0;
+}
+
+/**
+ * ir_free_table() - frees memory allocated by a scancode table
+ * @rc_map:	the table whose mappings need to be freed
+ *
+ * This routine will free memory alloctaed for key mappings used by given
+ * scancode table.
+ */
+static void ir_free_table(struct rc_map *rc_map)
+{
+	rc_map->size = 0;
+	kfree(rc_map->scan);
+	rc_map->scan = NULL;
+}
+
+/**
+ * ir_resize_table() - resizes a scancode table if necessary
+ * @rc_map:	the rc_map to resize
+ * @gfp_flags:	gfp flags to use when allocating memory
+ * @return:	zero on success or a negative error code
+ *
+ * This routine will shrink the rc_map if it has lots of
+ * unused entries and grow it if it is full.
+ */
+static int ir_resize_table(struct rc_map *rc_map, gfp_t gfp_flags)
+{
+	unsigned int oldalloc = rc_map->alloc;
+	unsigned int newalloc = oldalloc;
+	struct rc_map_table *oldscan = rc_map->scan;
+	struct rc_map_table *newscan;
+
+	if (rc_map->size == rc_map->len) {
+		/* All entries in use -> grow keytable */
+		if (rc_map->alloc >= IR_TAB_MAX_SIZE)
+			return -ENOMEM;
+
+		newalloc *= 2;
+		IR_dprintk(1, "Growing table to %u bytes\n", newalloc);
+	}
+
+	if ((rc_map->len * 3 < rc_map->size) && (oldalloc > IR_TAB_MIN_SIZE)) {
+		/* Less than 1/3 of entries in use -> shrink keytable */
+		newalloc /= 2;
+		IR_dprintk(1, "Shrinking table to %u bytes\n", newalloc);
+	}
+
+	if (newalloc == oldalloc)
+		return 0;
+
+	newscan = kmalloc(newalloc, gfp_flags);
+	if (!newscan) {
+		IR_dprintk(1, "Failed to kmalloc %u bytes\n", newalloc);
+		return -ENOMEM;
+	}
+
+	memcpy(newscan, rc_map->scan, rc_map->len * sizeof(struct rc_map_table));
+	rc_map->scan = newscan;
+	rc_map->alloc = newalloc;
+	rc_map->size = rc_map->alloc / sizeof(struct rc_map_table);
+	kfree(oldscan);
+	return 0;
+}
+
+/**
+ * ir_update_mapping() - set a keycode in the scancode->keycode table
+ * @dev:	the struct rc_dev device descriptor
+ * @rc_map:	scancode table to be adjusted
+ * @index:	index of the mapping that needs to be updated
+ * @keycode:	the desired keycode
+ * @return:	previous keycode assigned to the mapping
+ *
+ * This routine is used to update scancode->keycode mapping at given
+ * position.
+ */
+static unsigned int ir_update_mapping(struct rc_dev *dev,
+				      struct rc_map *rc_map,
+				      unsigned int index,
+				      unsigned int new_keycode)
+{
+	int old_keycode = rc_map->scan[index].keycode;
+	int i;
+
+	/* Did the user wish to remove the mapping? */
+	if (new_keycode == KEY_RESERVED || new_keycode == KEY_UNKNOWN) {
+		IR_dprintk(1, "#%d: Deleting scan 0x%04x\n",
+			   index, rc_map->scan[index].scancode);
+		rc_map->len--;
+		memmove(&rc_map->scan[index], &rc_map->scan[index+ 1],
+			(rc_map->len - index) * sizeof(struct rc_map_table));
+	} else {
+		IR_dprintk(1, "#%d: %s scan 0x%04x with key 0x%04x\n",
+			   index,
+			   old_keycode == KEY_RESERVED ? "New" : "Replacing",
+			   rc_map->scan[index].scancode, new_keycode);
+		rc_map->scan[index].keycode = new_keycode;
+		__set_bit(new_keycode, dev->input_dev->keybit);
+	}
+
+	if (old_keycode != KEY_RESERVED) {
+		/* A previous mapping was updated... */
+		__clear_bit(old_keycode, dev->input_dev->keybit);
+		/* ... but another scancode might use the same keycode */
+		for (i = 0; i < rc_map->len; i++) {
+			if (rc_map->scan[i].keycode == old_keycode) {
+				__set_bit(old_keycode, dev->input_dev->keybit);
+				break;
+			}
+		}
+
+		/* Possibly shrink the keytable, failure is not a problem */
+		ir_resize_table(rc_map, GFP_ATOMIC);
+	}
+
+	return old_keycode;
+}
+
+/**
+ * ir_establish_scancode() - set a keycode in the scancode->keycode table
+ * @dev:	the struct rc_dev device descriptor
+ * @rc_map:	scancode table to be searched
+ * @scancode:	the desired scancode
+ * @resize:	controls whether we allowed to resize the table to
+ *		accommodate not yet present scancodes
+ * @return:	index of the mapping containing scancode in question
+ *		or -1U in case of failure.
+ *
+ * This routine is used to locate given scancode in rc_map.
+ * If scancode is not yet present the routine will allocate a new slot
+ * for it.
+ */
+static unsigned int ir_establish_scancode(struct rc_dev *dev,
+					  struct rc_map *rc_map,
+					  unsigned int scancode,
+					  bool resize)
+{
+	unsigned int i;
+
+	/*
+	 * Unfortunately, some hardware-based IR decoders don't provide
+	 * all bits for the complete IR code. In general, they provide only
+	 * the command part of the IR code. Yet, as it is possible to replace
+	 * the provided IR with another one, it is needed to allow loading
+	 * IR tables from other remotes. So, we support specifying a mask to
+	 * indicate the valid bits of the scancodes.
+	 */
+	if (dev->scanmask)
+		scancode &= dev->scanmask;
+
+	/* First check if we already have a mapping for this ir command */
+	for (i = 0; i < rc_map->len; i++) {
+		if (rc_map->scan[i].scancode == scancode)
+			return i;
+
+		/* Keytable is sorted from lowest to highest scancode */
+		if (rc_map->scan[i].scancode >= scancode)
+			break;
+	}
+
+	/* No previous mapping found, we might need to grow the table */
+	if (rc_map->size == rc_map->len) {
+		if (!resize || ir_resize_table(rc_map, GFP_ATOMIC))
+			return -1U;
+	}
+
+	/* i is the proper index to insert our new keycode */
+	if (i < rc_map->len)
+		memmove(&rc_map->scan[i + 1], &rc_map->scan[i],
+			(rc_map->len - i) * sizeof(struct rc_map_table));
+	rc_map->scan[i].scancode = scancode;
+	rc_map->scan[i].keycode = KEY_RESERVED;
+	rc_map->len++;
+
+	return i;
+}
+
+/**
+ * ir_setkeycode() - set a keycode in the scancode->keycode table
+ * @idev:	the struct input_dev device descriptor
+ * @scancode:	the desired scancode
+ * @keycode:	result
+ * @return:	-EINVAL if the keycode could not be inserted, otherwise zero.
+ *
+ * This routine is used to handle evdev EVIOCSKEY ioctl.
+ */
+static int ir_setkeycode(struct input_dev *idev,
+			 const struct input_keymap_entry *ke,
+			 unsigned int *old_keycode)
+{
+	struct rc_dev *rdev = input_get_drvdata(idev);
+	struct rc_map *rc_map = &rdev->rc_map;
+	unsigned int index;
+	unsigned int scancode;
+	int retval = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rc_map->lock, flags);
+
+	if (ke->flags & INPUT_KEYMAP_BY_INDEX) {
+		index = ke->index;
+		if (index >= rc_map->len) {
+			retval = -EINVAL;
+			goto out;
+		}
+	} else {
+		retval = input_scancode_to_scalar(ke, &scancode);
+		if (retval)
+			goto out;
+
+		index = ir_establish_scancode(rdev, rc_map, scancode, true);
+		if (index >= rc_map->len) {
+			retval = -ENOMEM;
+			goto out;
+		}
+	}
+
+	*old_keycode = ir_update_mapping(rdev, rc_map, index, ke->keycode);
+
+out:
+	spin_unlock_irqrestore(&rc_map->lock, flags);
+	return retval;
+}
+
+/**
+ * ir_setkeytable() - sets several entries in the scancode->keycode table
+ * @dev:	the struct rc_dev device descriptor
+ * @to:		the struct rc_map to copy entries to
+ * @from:	the struct rc_map to copy entries from
+ * @return:	-ENOMEM if all keycodes could not be inserted, otherwise zero.
+ *
+ * This routine is used to handle table initialization.
+ */
+static int ir_setkeytable(struct rc_dev *dev,
+			  const struct rc_map *from)
+{
+	struct rc_map *rc_map = &dev->rc_map;
+	unsigned int i, index;
+	int rc;
+
+	rc = ir_create_table(rc_map, from->name,
+			     from->rc_type, from->size);
+	if (rc)
+		return rc;
+
+	IR_dprintk(1, "Allocated space for %u keycode entries (%u bytes)\n",
+		   rc_map->size, rc_map->alloc);
+
+	for (i = 0; i < from->size; i++) {
+		index = ir_establish_scancode(dev, rc_map,
+					      from->scan[i].scancode, false);
+		if (index >= rc_map->len) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		ir_update_mapping(dev, rc_map, index,
+				  from->scan[i].keycode);
+	}
+
+	if (rc)
+		ir_free_table(rc_map);
+
+	return rc;
+}
+
+/**
+ * ir_lookup_by_scancode() - locate mapping by scancode
+ * @rc_map:	the struct rc_map to search
+ * @scancode:	scancode to look for in the table
+ * @return:	index in the table, -1U if not found
+ *
+ * This routine performs binary search in RC keykeymap table for
+ * given scancode.
+ */
+static unsigned int ir_lookup_by_scancode(const struct rc_map *rc_map,
+					  unsigned int scancode)
+{
+	int start = 0;
+	int end = rc_map->len - 1;
+	int mid;
+
+	while (start <= end) {
+		mid = (start + end) / 2;
+		if (rc_map->scan[mid].scancode < scancode)
+			start = mid + 1;
+		else if (rc_map->scan[mid].scancode > scancode)
+			end = mid - 1;
+		else
+			return mid;
+	}
+
+	return -1U;
+}
+
+/**
+ * ir_getkeycode() - get a keycode from the scancode->keycode table
+ * @idev:	the struct input_dev device descriptor
+ * @scancode:	the desired scancode
+ * @keycode:	used to return the keycode, if found, or KEY_RESERVED
+ * @return:	always returns zero.
+ *
+ * This routine is used to handle evdev EVIOCGKEY ioctl.
+ */
+static int ir_getkeycode(struct input_dev *idev,
+			 struct input_keymap_entry *ke)
+{
+	struct rc_dev *rdev = input_get_drvdata(idev);
+	struct rc_map *rc_map = &rdev->rc_map;
+	struct rc_map_table *entry;
+	unsigned long flags;
+	unsigned int index;
+	unsigned int scancode;
+	int retval;
+
+	spin_lock_irqsave(&rc_map->lock, flags);
+
+	if (ke->flags & INPUT_KEYMAP_BY_INDEX) {
+		index = ke->index;
+	} else {
+		retval = input_scancode_to_scalar(ke, &scancode);
+		if (retval)
+			goto out;
+
+		index = ir_lookup_by_scancode(rc_map, scancode);
+	}
+
+	if (index < rc_map->len) {
+		entry = &rc_map->scan[index];
+
+		ke->index = index;
+		ke->keycode = entry->keycode;
+		ke->len = sizeof(entry->scancode);
+		memcpy(ke->scancode, &entry->scancode, sizeof(entry->scancode));
+
+	} else if (!(ke->flags & INPUT_KEYMAP_BY_INDEX)) {
+		/*
+		 * We do not really know the valid range of scancodes
+		 * so let's respond with KEY_RESERVED to anything we
+		 * do not have mapping for [yet].
+		 */
+		ke->index = index;
+		ke->keycode = KEY_RESERVED;
+	} else {
+		retval = -EINVAL;
+		goto out;
+	}
+
+	retval = 0;
+
+out:
+	spin_unlock_irqrestore(&rc_map->lock, flags);
+	return retval;
+}
+
+/**
+ * rc_g_keycode_from_table() - gets the keycode that corresponds to a scancode
+ * @dev:	the struct rc_dev descriptor of the device
+ * @scancode:	the scancode to look for
+ * @return:	the corresponding keycode, or KEY_RESERVED
+ *
+ * This routine is used by drivers which need to convert a scancode to a
+ * keycode. Normally it should not be used since drivers should have no
+ * interest in keycodes.
+ */
+u32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode)
+{
+	struct rc_map *rc_map = &dev->rc_map;
+	unsigned int keycode;
+	unsigned int index;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rc_map->lock, flags);
+
+	index = ir_lookup_by_scancode(rc_map, scancode);
+	keycode = index < rc_map->len ?
+			rc_map->scan[index].keycode : KEY_RESERVED;
+
+	spin_unlock_irqrestore(&rc_map->lock, flags);
+
+	if (keycode != KEY_RESERVED)
+		IR_dprintk(1, "%s: scancode 0x%04x keycode 0x%02x\n",
+			   dev->input_name, scancode, keycode);
+
+	return keycode;
+}
+EXPORT_SYMBOL_GPL(rc_g_keycode_from_table);
+
+/**
+ * ir_do_keyup() - internal function to signal the release of a keypress
+ * @dev:	the struct rc_dev descriptor of the device
+ * @sync:	whether or not to call input_sync
+ *
+ * This function is used internally to release a keypress, it must be
+ * called with keylock held.
+ */
+static void ir_do_keyup(struct rc_dev *dev, bool sync)
+{
+	if (!dev->keypressed)
+		return;
+
+	IR_dprintk(1, "keyup key 0x%04x\n", dev->last_keycode);
+	input_report_key(dev->input_dev, dev->last_keycode, 0);
+	if (sync)
+		input_sync(dev->input_dev);
+	dev->keypressed = false;
+}
+
+/**
+ * rc_keyup() - signals the release of a keypress
+ * @dev:	the struct rc_dev descriptor of the device
+ *
+ * This routine is used to signal that a key has been released on the
+ * remote control.
+ */
+void rc_keyup(struct rc_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->keylock, flags);
+	ir_do_keyup(dev, true);
+	spin_unlock_irqrestore(&dev->keylock, flags);
+}
+EXPORT_SYMBOL_GPL(rc_keyup);
+
+/**
+ * ir_timer_keyup() - generates a keyup event after a timeout
+ * @cookie:	a pointer to the struct rc_dev for the device
+ *
+ * This routine will generate a keyup event some time after a keydown event
+ * is generated when no further activity has been detected.
+ */
+static void ir_timer_keyup(unsigned long cookie)
+{
+	struct rc_dev *dev = (struct rc_dev *)cookie;
+	unsigned long flags;
+
+	/*
+	 * ir->keyup_jiffies is used to prevent a race condition if a
+	 * hardware interrupt occurs at this point and the keyup timer
+	 * event is moved further into the future as a result.
+	 *
+	 * The timer will then be reactivated and this function called
+	 * again in the future. We need to exit gracefully in that case
+	 * to allow the input subsystem to do its auto-repeat magic or
+	 * a keyup event might follow immediately after the keydown.
+	 */
+	spin_lock_irqsave(&dev->keylock, flags);
+	if (time_is_before_eq_jiffies(dev->keyup_jiffies))
+		ir_do_keyup(dev, true);
+	spin_unlock_irqrestore(&dev->keylock, flags);
+}
+
+/**
+ * rc_repeat() - signals that a key is still pressed
+ * @dev:	the struct rc_dev descriptor of the device
+ *
+ * This routine is used by IR decoders when a repeat message which does
+ * not include the necessary bits to reproduce the scancode has been
+ * received.
+ */
+void rc_repeat(struct rc_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->keylock, flags);
+
+	input_event(dev->input_dev, EV_MSC, MSC_SCAN, dev->last_scancode);
+	input_sync(dev->input_dev);
+
+	if (!dev->keypressed)
+		goto out;
+
+	dev->keyup_jiffies = jiffies + msecs_to_jiffies(IR_KEYPRESS_TIMEOUT);
+	mod_timer(&dev->timer_keyup, dev->keyup_jiffies);
+
+out:
+	spin_unlock_irqrestore(&dev->keylock, flags);
+}
+EXPORT_SYMBOL_GPL(rc_repeat);
+
+/**
+ * ir_do_keydown() - internal function to process a keypress
+ * @dev:	the struct rc_dev descriptor of the device
+ * @scancode:   the scancode of the keypress
+ * @keycode:    the keycode of the keypress
+ * @toggle:     the toggle value of the keypress
+ *
+ * This function is used internally to register a keypress, it must be
+ * called with keylock held.
+ */
+static void ir_do_keydown(struct rc_dev *dev, int scancode,
+			  u32 keycode, u8 toggle)
+{
+	bool new_event = !dev->keypressed ||
+			 dev->last_scancode != scancode ||
+			 dev->last_toggle != toggle;
+
+	if (new_event && dev->keypressed)
+		ir_do_keyup(dev, false);
+
+	input_event(dev->input_dev, EV_MSC, MSC_SCAN, scancode);
+
+	if (new_event && keycode != KEY_RESERVED) {
+		/* Register a keypress */
+		dev->keypressed = true;
+		dev->last_scancode = scancode;
+		dev->last_toggle = toggle;
+		dev->last_keycode = keycode;
+
+		IR_dprintk(1, "%s: key down event, "
+			   "key 0x%04x, scancode 0x%04x\n",
+			   dev->input_name, keycode, scancode);
+		input_report_key(dev->input_dev, keycode, 1);
+	}
+
+	input_sync(dev->input_dev);
+}
+
+/**
+ * rc_keydown() - generates input event for a key press
+ * @dev:	the struct rc_dev descriptor of the device
+ * @scancode:   the scancode that we're seeking
+ * @toggle:     the toggle value (protocol dependent, if the protocol doesn't
+ *              support toggle values, this should be set to zero)
+ *
+ * This routine is used to signal that a key has been pressed on the
+ * remote control.
+ */
+void rc_keydown(struct rc_dev *dev, int scancode, u8 toggle)
+{
+	unsigned long flags;
+	u32 keycode = rc_g_keycode_from_table(dev, scancode);
+
+	spin_lock_irqsave(&dev->keylock, flags);
+	ir_do_keydown(dev, scancode, keycode, toggle);
+
+	if (dev->keypressed) {
+		dev->keyup_jiffies = jiffies + msecs_to_jiffies(IR_KEYPRESS_TIMEOUT);
+		mod_timer(&dev->timer_keyup, dev->keyup_jiffies);
+	}
+	spin_unlock_irqrestore(&dev->keylock, flags);
+}
+EXPORT_SYMBOL_GPL(rc_keydown);
+
+/**
+ * rc_keydown_notimeout() - generates input event for a key press without
+ *                          an automatic keyup event at a later time
+ * @dev:	the struct rc_dev descriptor of the device
+ * @scancode:   the scancode that we're seeking
+ * @toggle:     the toggle value (protocol dependent, if the protocol doesn't
+ *              support toggle values, this should be set to zero)
+ *
+ * This routine is used to signal that a key has been pressed on the
+ * remote control. The driver must manually call rc_keyup() at a later stage.
+ */
+void rc_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle)
+{
+	unsigned long flags;
+	u32 keycode = rc_g_keycode_from_table(dev, scancode);
+
+	spin_lock_irqsave(&dev->keylock, flags);
+	ir_do_keydown(dev, scancode, keycode, toggle);
+	spin_unlock_irqrestore(&dev->keylock, flags);
+}
+EXPORT_SYMBOL_GPL(rc_keydown_notimeout);
+
+static int ir_open(struct input_dev *idev)
+{
+	struct rc_dev *rdev = input_get_drvdata(idev);
+
+	return rdev->open(rdev);
+}
+
+static void ir_close(struct input_dev *idev)
+{
+	struct rc_dev *rdev = input_get_drvdata(idev);
+
+	 if (rdev)
+		rdev->close(rdev);
+}
+
+/* class for /sys/class/rc */
+static char *ir_devnode(struct device *dev, umode_t *mode)
+{
+	return kasprintf(GFP_KERNEL, "rc/%s", dev_name(dev));
+}
+
+static struct class ir_input_class = {
+	.name		= "rc",
+	.devnode	= ir_devnode,
+};
+
+static struct {
+	u64	type;
+	char	*name;
+} proto_names[] = {
+	{ RC_TYPE_UNKNOWN,	"unknown"	},
+	{ RC_TYPE_RC5,		"rc-5"		},
+	{ RC_TYPE_NEC,		"nec"		},
+	{ RC_TYPE_RC6,		"rc-6"		},
+	{ RC_TYPE_JVC,		"jvc"		},
+	{ RC_TYPE_SONY,		"sony"		},
+	{ RC_TYPE_RC5_SZ,	"rc-5-sz"	},
+	{ RC_TYPE_SANYO,	"sanyo"		},
+	{ RC_TYPE_MCE_KBD,	"mce_kbd"	},
+	{ RC_TYPE_LIRC,		"lirc"		},
+	{ RC_TYPE_OTHER,	"other"		},
+};
+
+#define PROTO_NONE	"none"
+
+/**
+ * show_protocols() - shows the current IR protocol(s)
+ * @device:	the device descriptor
+ * @mattr:	the device attribute struct (unused)
+ * @buf:	a pointer to the output buffer
+ *
+ * This routine is a callback routine for input read the IR protocol type(s).
+ * it is trigged by reading /sys/class/rc/rc?/protocols.
+ * It returns the protocol names of supported protocols.
+ * Enabled protocols are printed in brackets.
+ *
+ * dev->lock is taken to guard against races between device
+ * registration, store_protocols and show_protocols.
+ */
+static ssize_t show_protocols(struct device *device,
+			      struct device_attribute *mattr, char *buf)
+{
+	struct rc_dev *dev = to_rc_dev(device);
+	u64 allowed, enabled;
+	char *tmp = buf;
+	int i;
+
+	/* Device is being removed */
+	if (!dev)
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+
+	if (dev->driver_type == RC_DRIVER_SCANCODE) {
+		enabled = dev->rc_map.rc_type;
+		allowed = dev->allowed_protos;
+	} else {
+		enabled = dev->raw->enabled_protocols;
+		allowed = ir_raw_get_allowed_protocols();
+	}
+
+	IR_dprintk(1, "allowed - 0x%llx, enabled - 0x%llx\n",
+		   (long long)allowed,
+		   (long long)enabled);
+
+	for (i = 0; i < ARRAY_SIZE(proto_names); i++) {
+		if (allowed & enabled & proto_names[i].type)
+			tmp += sprintf(tmp, "[%s] ", proto_names[i].name);
+		else if (allowed & proto_names[i].type)
+			tmp += sprintf(tmp, "%s ", proto_names[i].name);
+	}
+
+	if (tmp != buf)
+		tmp--;
+	*tmp = '\n';
+
+	mutex_unlock(&dev->lock);
+
+	return tmp + 1 - buf;
+}
+
+/**
+ * store_protocols() - changes the current IR protocol(s)
+ * @device:	the device descriptor
+ * @mattr:	the device attribute struct (unused)
+ * @buf:	a pointer to the input buffer
+ * @len:	length of the input buffer
+ *
+ * This routine is for changing the IR protocol type.
+ * It is trigged by writing to /sys/class/rc/rc?/protocols.
+ * Writing "+proto" will add a protocol to the list of enabled protocols.
+ * Writing "-proto" will remove a protocol from the list of enabled protocols.
+ * Writing "proto" will enable only "proto".
+ * Writing "none" will disable all protocols.
+ * Returns -EINVAL if an invalid protocol combination or unknown protocol name
+ * is used, otherwise @len.
+ *
+ * dev->lock is taken to guard against races between device
+ * registration, store_protocols and show_protocols.
+ */
+static ssize_t store_protocols(struct device *device,
+			       struct device_attribute *mattr,
+			       const char *data,
+			       size_t len)
+{
+	struct rc_dev *dev = to_rc_dev(device);
+	bool enable, disable;
+	const char *tmp;
+	u64 type;
+	u64 mask;
+	int rc, i, count = 0;
+	unsigned long flags;
+	ssize_t ret;
+
+	/* Device is being removed */
+	if (!dev)
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+
+	if (dev->driver_type == RC_DRIVER_SCANCODE)
+		type = dev->rc_map.rc_type;
+	else if (dev->raw)
+		type = dev->raw->enabled_protocols;
+	else {
+		IR_dprintk(1, "Protocol switching not supported\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	while ((tmp = strsep((char **) &data, " \n")) != NULL) {
+		if (!*tmp)
+			break;
+
+		if (*tmp == '+') {
+			enable = true;
+			disable = false;
+			tmp++;
+		} else if (*tmp == '-') {
+			enable = false;
+			disable = true;
+			tmp++;
+		} else {
+			enable = false;
+			disable = false;
+		}
+
+		if (!enable && !disable && !strncasecmp(tmp, PROTO_NONE, sizeof(PROTO_NONE))) {
+			tmp += sizeof(PROTO_NONE);
+			mask = 0;
+			count++;
+		} else {
+			for (i = 0; i < ARRAY_SIZE(proto_names); i++) {
+				if (!strcasecmp(tmp, proto_names[i].name)) {
+					tmp += strlen(proto_names[i].name);
+					mask = proto_names[i].type;
+					break;
+				}
+			}
+			if (i == ARRAY_SIZE(proto_names)) {
+				IR_dprintk(1, "Unknown protocol: '%s'\n", tmp);
+				ret = -EINVAL;
+				goto out;
+			}
+			count++;
+		}
+
+		if (enable)
+			type |= mask;
+		else if (disable)
+			type &= ~mask;
+		else
+			type = mask;
+	}
+
+	if (!count) {
+		IR_dprintk(1, "Protocol not specified\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (dev->change_protocol) {
+		rc = dev->change_protocol(dev, type);
+		if (rc < 0) {
+			IR_dprintk(1, "Error setting protocols to 0x%llx\n",
+				   (long long)type);
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	if (dev->driver_type == RC_DRIVER_SCANCODE) {
+		spin_lock_irqsave(&dev->rc_map.lock, flags);
+		dev->rc_map.rc_type = type;
+		spin_unlock_irqrestore(&dev->rc_map.lock, flags);
+	} else {
+		dev->raw->enabled_protocols = type;
+	}
+
+	IR_dprintk(1, "Current protocol(s): 0x%llx\n",
+		   (long long)type);
+
+	ret = len;
+
+out:
+	mutex_unlock(&dev->lock);
+	return ret;
+}
+
+static void rc_dev_release(struct device *device)
+{
+}
+
+#define ADD_HOTPLUG_VAR(fmt, val...)					\
+	do {								\
+		int err = add_uevent_var(env, fmt, val);		\
+		if (err)						\
+			return err;					\
+	} while (0)
+
+static int rc_dev_uevent(struct device *device, struct kobj_uevent_env *env)
+{
+	struct rc_dev *dev = to_rc_dev(device);
+
+	if (!dev || !dev->input_dev)
+		return -ENODEV;
+
+	if (dev->rc_map.name)
+		ADD_HOTPLUG_VAR("NAME=%s", dev->rc_map.name);
+	if (dev->driver_name)
+		ADD_HOTPLUG_VAR("DRV_NAME=%s", dev->driver_name);
+
+	return 0;
+}
+
+/*
+ * Static device attribute struct with the sysfs attributes for IR's
+ */
+static DEVICE_ATTR(protocols, S_IRUGO | S_IWUSR,
+		   show_protocols, store_protocols);
+
+static struct attribute *rc_dev_attrs[] = {
+	&dev_attr_protocols.attr,
+	NULL,
+};
+
+static struct attribute_group rc_dev_attr_grp = {
+	.attrs	= rc_dev_attrs,
+};
+
+static const struct attribute_group *rc_dev_attr_groups[] = {
+	&rc_dev_attr_grp,
+	NULL
+};
+
+static struct device_type rc_dev_type = {
+	.groups		= rc_dev_attr_groups,
+	.release	= rc_dev_release,
+	.uevent		= rc_dev_uevent,
+};
+
+struct rc_dev *rc_allocate_device(void)
+{
+	struct rc_dev *dev;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->input_dev = input_allocate_device();
+	if (!dev->input_dev) {
+		kfree(dev);
+		return NULL;
+	}
+
+	dev->input_dev->getkeycode = ir_getkeycode;
+	dev->input_dev->setkeycode = ir_setkeycode;
+	input_set_drvdata(dev->input_dev, dev);
+
+	spin_lock_init(&dev->rc_map.lock);
+	spin_lock_init(&dev->keylock);
+	mutex_init(&dev->lock);
+	setup_timer(&dev->timer_keyup, ir_timer_keyup, (unsigned long)dev);
+
+	dev->dev.type = &rc_dev_type;
+	dev->dev.class = &ir_input_class;
+	device_initialize(&dev->dev);
+
+	__module_get(THIS_MODULE);
+	return dev;
+}
+EXPORT_SYMBOL_GPL(rc_allocate_device);
+
+void rc_free_device(struct rc_dev *dev)
+{
+	if (!dev)
+		return;
+
+	if (dev->input_dev)
+		input_free_device(dev->input_dev);
+
+	put_device(&dev->dev);
+
+	kfree(dev);
+	module_put(THIS_MODULE);
+}
+EXPORT_SYMBOL_GPL(rc_free_device);
+
+int rc_register_device(struct rc_dev *dev)
+{
+	static atomic_t devno = ATOMIC_INIT(0);
+	struct rc_map *rc_map;
+	const char *path;
+	int rc;
+
+	if (!dev || !dev->map_name)
+		return -EINVAL;
+
+	rc_map = rc_map_get(dev->map_name);
+	if (!rc_map)
+		rc_map = rc_map_get(RC_MAP_EMPTY);
+	if (!rc_map || !rc_map->scan || rc_map->size == 0)
+		return -EINVAL;
+
+	set_bit(EV_KEY, dev->input_dev->evbit);
+	set_bit(EV_REP, dev->input_dev->evbit);
+	set_bit(EV_MSC, dev->input_dev->evbit);
+	set_bit(MSC_SCAN, dev->input_dev->mscbit);
+	if (dev->open)
+		dev->input_dev->open = ir_open;
+	if (dev->close)
+		dev->input_dev->close = ir_close;
+
+	/*
+	 * Take the lock here, as the device sysfs node will appear
+	 * when device_add() is called, which may trigger an ir-keytable udev
+	 * rule, which will in turn call show_protocols and access either
+	 * dev->rc_map.rc_type or dev->raw->enabled_protocols before it has
+	 * been initialized.
+	 */
+	mutex_lock(&dev->lock);
+
+	dev->devno = (unsigned long)(atomic_inc_return(&devno) - 1);
+	dev_set_name(&dev->dev, "rc%ld", dev->devno);
+	dev_set_drvdata(&dev->dev, dev);
+	rc = device_add(&dev->dev);
+	if (rc)
+		goto out_unlock;
+
+	rc = ir_setkeytable(dev, rc_map);
+	if (rc)
+		goto out_dev;
+
+	dev->input_dev->dev.parent = &dev->dev;
+	memcpy(&dev->input_dev->id, &dev->input_id, sizeof(dev->input_id));
+	dev->input_dev->phys = dev->input_phys;
+	dev->input_dev->name = dev->input_name;
+	rc = input_register_device(dev->input_dev);
+	if (rc)
+		goto out_table;
+
+	/*
+	 * Default delay of 250ms is too short for some protocols, especially
+	 * since the timeout is currently set to 250ms. Increase it to 500ms,
+	 * to avoid wrong repetition of the keycodes. Note that this must be
+	 * set after the call to input_register_device().
+	 */
+	dev->input_dev->rep[REP_DELAY] = 500;
+
+	/*
+	 * As a repeat event on protocols like RC-5 and NEC take as long as
+	 * 110/114ms, using 33ms as a repeat period is not the right thing
+	 * to do.
+	 */
+	dev->input_dev->rep[REP_PERIOD] = 125;
+
+	path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);
+	printk(KERN_INFO "%s: %s as %s\n",
+		dev_name(&dev->dev),
+		dev->input_name ? dev->input_name : "Unspecified device",
+		path ? path : "N/A");
+	kfree(path);
+
+	if (dev->driver_type == RC_DRIVER_IR_RAW) {
+		rc = ir_raw_event_register(dev);
+		if (rc < 0)
+			goto out_input;
+	}
+
+	if (dev->change_protocol) {
+		rc = dev->change_protocol(dev, rc_map->rc_type);
+		if (rc < 0)
+			goto out_raw;
+	}
+
+	mutex_unlock(&dev->lock);
+
+	IR_dprintk(1, "Registered rc%ld (driver: %s, remote: %s, mode %s)\n",
+		   dev->devno,
+		   dev->driver_name ? dev->driver_name : "unknown",
+		   rc_map->name ? rc_map->name : "unknown",
+		   dev->driver_type == RC_DRIVER_IR_RAW ? "raw" : "cooked");
+
+	return 0;
+
+out_raw:
+	if (dev->driver_type == RC_DRIVER_IR_RAW)
+		ir_raw_event_unregister(dev);
+out_input:
+	input_unregister_device(dev->input_dev);
+	dev->input_dev = NULL;
+out_table:
+	ir_free_table(&dev->rc_map);
+out_dev:
+	device_del(&dev->dev);
+out_unlock:
+	mutex_unlock(&dev->lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(rc_register_device);
+
+void rc_unregister_device(struct rc_dev *dev)
+{
+	if (!dev)
+		return;
+
+	del_timer_sync(&dev->timer_keyup);
+
+	if (dev->driver_type == RC_DRIVER_IR_RAW)
+		ir_raw_event_unregister(dev);
+
+	/* Freeing the table should also call the stop callback */
+	ir_free_table(&dev->rc_map);
+	IR_dprintk(1, "Freed keycode table\n");
+
+	input_unregister_device(dev->input_dev);
+	dev->input_dev = NULL;
+
+	device_del(&dev->dev);
+
+	rc_free_device(dev);
+}
+
+EXPORT_SYMBOL_GPL(rc_unregister_device);
+
+/*
+ * Init/exit code for the module. Basically, creates/removes /sys/class/rc
+ */
+
+static int __init rc_core_init(void)
+{
+	int rc = class_register(&ir_input_class);
+	if (rc) {
+		printk(KERN_ERR "rc_core: unable to register rc class\n");
+		return rc;
+	}
+
+	/* Initialize/load the decoders/keymap code that will be used */
+	ir_raw_init();
+	rc_map_register(&empty_map);
+
+	return 0;
+}
+
+static void __exit rc_core_exit(void)
+{
+	class_unregister(&ir_input_class);
+	rc_map_unregister(&empty_map);
+}
+
+module_init(rc_core_init);
+module_exit(rc_core_exit);
+
+int rc_core_debug;    /* ir_debug level (0,1,2) */
+EXPORT_SYMBOL_GPL(rc_core_debug);
+module_param_named(debug, rc_core_debug, int, 0644);
+
+MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental//linux/drivers/media/video/v4l2-dev.c~ media-experimental-media_build_experimental//linux/drivers/media/video/v4l2-dev.c~
--- media_build_experimental//linux/drivers/media/video/v4l2-dev.c~	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/drivers/media/video/v4l2-dev.c~	2012-02-27 00:02:33.148915018 +0100
@@ -0,0 +1,804 @@
+/*
+ * Video capture interface for Linux version 2
+ *
+ *	A generic video device interface for the LINUX operating system
+ *	using a set of device structures/vectors for low level operations.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Alan Cox, <alan@lxorguk.ukuu.org.uk> (version 1)
+ *              Mauro Carvalho Chehab <mchehab@infradead.org> (version 2)
+ *
+ * Fixes:	20000516  Claudio Matsuoka <claudio@conectiva.com>
+ *		- Added procfs support
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+#define VIDEO_NUM_DEVICES	256
+#define VIDEO_NAME              "video4linux"
+
+/*
+ *	sysfs stuff
+ */
+
+static ssize_t show_index(struct device *cd,
+			 struct device_attribute *attr, char *buf)
+{
+	struct video_device *vdev = to_video_device(cd);
+
+	return sprintf(buf, "%i\n", vdev->index);
+}
+
+static ssize_t show_name(struct device *cd,
+			 struct device_attribute *attr, char *buf)
+{
+	struct video_device *vdev = to_video_device(cd);
+
+	return sprintf(buf, "%.*s\n", (int)sizeof(vdev->name), vdev->name);
+}
+
+static struct device_attribute video_device_attrs[] = {
+	__ATTR(name, S_IRUGO, show_name, NULL),
+	__ATTR(index, S_IRUGO, show_index, NULL),
+	__ATTR_NULL
+};
+
+/*
+ *	Active devices
+ */
+static struct video_device *video_device[VIDEO_NUM_DEVICES];
+static DEFINE_MUTEX(videodev_lock);
+static DECLARE_BITMAP(devnode_nums[VFL_TYPE_MAX], VIDEO_NUM_DEVICES);
+
+/* Device node utility functions */
+
+/* Note: these utility functions all assume that vfl_type is in the range
+   [0, VFL_TYPE_MAX-1]. */
+
+#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES
+/* Return the bitmap corresponding to vfl_type. */
+static inline unsigned long *devnode_bits(int vfl_type)
+{
+	/* Any types not assigned to fixed minor ranges must be mapped to
+	   one single bitmap for the purposes of finding a free node number
+	   since all those unassigned types use the same minor range. */
+	int idx = (vfl_type > VFL_TYPE_RADIO) ? VFL_TYPE_MAX - 1 : vfl_type;
+
+	return devnode_nums[idx];
+}
+#else
+/* Return the bitmap corresponding to vfl_type. */
+static inline unsigned long *devnode_bits(int vfl_type)
+{
+	return devnode_nums[vfl_type];
+}
+#endif
+
+/* Mark device node number vdev->num as used */
+static inline void devnode_set(struct video_device *vdev)
+{
+	set_bit(vdev->num, devnode_bits(vdev->vfl_type));
+}
+
+/* Mark device node number vdev->num as unused */
+static inline void devnode_clear(struct video_device *vdev)
+{
+	clear_bit(vdev->num, devnode_bits(vdev->vfl_type));
+}
+
+/* Try to find a free device node number in the range [from, to> */
+static inline int devnode_find(struct video_device *vdev, int from, int to)
+{
+	return find_next_zero_bit(devnode_bits(vdev->vfl_type), to, from);
+}
+
+struct video_device *video_device_alloc(void)
+{
+	return kzalloc(sizeof(struct video_device), GFP_KERNEL);
+}
+EXPORT_SYMBOL(video_device_alloc);
+
+void video_device_release(struct video_device *vdev)
+{
+	kfree(vdev);
+}
+EXPORT_SYMBOL(video_device_release);
+
+void video_device_release_empty(struct video_device *vdev)
+{
+	/* Do nothing */
+	/* Only valid when the video_device struct is a static. */
+}
+EXPORT_SYMBOL(video_device_release_empty);
+
+static inline void video_get(struct video_device *vdev)
+{
+	get_device(&vdev->dev);
+}
+
+static inline void video_put(struct video_device *vdev)
+{
+	put_device(&vdev->dev);
+}
+
+/* Called when the last user of the video device exits. */
+static void v4l2_device_release(struct device *cd)
+{
+	struct video_device *vdev = to_video_device(cd);
+	struct v4l2_device *v4l2_dev = vdev->v4l2_dev;
+
+	mutex_lock(&videodev_lock);
+	if (WARN_ON(video_device[vdev->minor] != vdev)) {
+		/* should not happen */
+		mutex_unlock(&videodev_lock);
+		return;
+	}
+
+	/* Free up this device for reuse */
+	video_device[vdev->minor] = NULL;
+
+	/* Delete the cdev on this minor as well */
+	cdev_del(vdev->cdev);
+	/* Just in case some driver tries to access this from
+	   the release() callback. */
+	vdev->cdev = NULL;
+
+	/* Mark device node number as free */
+	devnode_clear(vdev);
+
+	mutex_unlock(&videodev_lock);
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	if (v4l2_dev && v4l2_dev->mdev &&
+	    vdev->vfl_type != VFL_TYPE_SUBDEV)
+		media_device_unregister_entity(&vdev->entity);
+#endif
+
+	/* Do not call v4l2_device_put if there is no release callback set.
+	 * Drivers that have no v4l2_device release callback might free the
+	 * v4l2_dev instance in the video_device release callback below, so we
+	 * must perform this check here.
+	 *
+	 * TODO: In the long run all drivers that use v4l2_device should use the
+	 * v4l2_device release callback. This check will then be unnecessary.
+	 */
+	if (v4l2_dev && v4l2_dev->release == NULL)
+		v4l2_dev = NULL;
+
+	/* Release video_device and perform other
+	   cleanups as needed. */
+	vdev->release(vdev);
+
+	/* Decrease v4l2_device refcount */
+	if (v4l2_dev)
+		v4l2_device_put(v4l2_dev);
+}
+
+static struct class video_class = {
+	.name = VIDEO_NAME,
+	.dev_attrs = video_device_attrs,
+};
+
+struct video_device *video_devdata(struct file *file)
+{
+	return video_device[iminor(file->f_path.dentry->d_inode)];
+}
+EXPORT_SYMBOL(video_devdata);
+
+
+/* Priority handling */
+
+static inline bool prio_is_valid(enum v4l2_priority prio)
+{
+	return prio == V4L2_PRIORITY_BACKGROUND ||
+	       prio == V4L2_PRIORITY_INTERACTIVE ||
+	       prio == V4L2_PRIORITY_RECORD;
+}
+
+void v4l2_prio_init(struct v4l2_prio_state *global)
+{
+	memset(global, 0, sizeof(*global));
+}
+EXPORT_SYMBOL(v4l2_prio_init);
+
+int v4l2_prio_change(struct v4l2_prio_state *global, enum v4l2_priority *local,
+		     enum v4l2_priority new)
+{
+	if (!prio_is_valid(new))
+		return -EINVAL;
+	if (*local == new)
+		return 0;
+
+	atomic_inc(&global->prios[new]);
+	if (prio_is_valid(*local))
+		atomic_dec(&global->prios[*local]);
+	*local = new;
+	return 0;
+}
+EXPORT_SYMBOL(v4l2_prio_change);
+
+void v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local)
+{
+	v4l2_prio_change(global, local, V4L2_PRIORITY_DEFAULT);
+}
+EXPORT_SYMBOL(v4l2_prio_open);
+
+void v4l2_prio_close(struct v4l2_prio_state *global, enum v4l2_priority local)
+{
+	if (prio_is_valid(local))
+		atomic_dec(&global->prios[local]);
+}
+EXPORT_SYMBOL(v4l2_prio_close);
+
+enum v4l2_priority v4l2_prio_max(struct v4l2_prio_state *global)
+{
+	if (atomic_read(&global->prios[V4L2_PRIORITY_RECORD]) > 0)
+		return V4L2_PRIORITY_RECORD;
+	if (atomic_read(&global->prios[V4L2_PRIORITY_INTERACTIVE]) > 0)
+		return V4L2_PRIORITY_INTERACTIVE;
+	if (atomic_read(&global->prios[V4L2_PRIORITY_BACKGROUND]) > 0)
+		return V4L2_PRIORITY_BACKGROUND;
+	return V4L2_PRIORITY_UNSET;
+}
+EXPORT_SYMBOL(v4l2_prio_max);
+
+int v4l2_prio_check(struct v4l2_prio_state *global, enum v4l2_priority local)
+{
+	return (local < v4l2_prio_max(global)) ? -EBUSY : 0;
+}
+EXPORT_SYMBOL(v4l2_prio_check);
+
+
+static ssize_t v4l2_read(struct file *filp, char __user *buf,
+		size_t sz, loff_t *off)
+{
+	struct video_device *vdev = video_devdata(filp);
+	int ret = -ENODEV;
+
+	if (!vdev->fops->read)
+		return -EINVAL;
+	if (vdev->lock && mutex_lock_interruptible(vdev->lock))
+		return -ERESTARTSYS;
+	if (video_is_registered(vdev))
+		ret = vdev->fops->read(filp, buf, sz, off);
+	if (vdev->lock)
+		mutex_unlock(vdev->lock);
+	return ret;
+}
+
+static ssize_t v4l2_write(struct file *filp, const char __user *buf,
+		size_t sz, loff_t *off)
+{
+	struct video_device *vdev = video_devdata(filp);
+	int ret = -ENODEV;
+
+	if (!vdev->fops->write)
+		return -EINVAL;
+	if (vdev->lock && mutex_lock_interruptible(vdev->lock))
+		return -ERESTARTSYS;
+	if (video_is_registered(vdev))
+		ret = vdev->fops->write(filp, buf, sz, off);
+	if (vdev->lock)
+		mutex_unlock(vdev->lock);
+	return ret;
+}
+
+static unsigned int v4l2_poll(struct file *filp, struct poll_table_struct *poll)
+{
+	struct video_device *vdev = video_devdata(filp);
+	int ret = POLLERR | POLLHUP;
+
+	if (!vdev->fops->poll)
+		return DEFAULT_POLLMASK;
+	if (vdev->lock)
+		mutex_lock(vdev->lock);
+	if (video_is_registered(vdev))
+		ret = vdev->fops->poll(filp, poll);
+	if (vdev->lock)
+		mutex_unlock(vdev->lock);
+	return ret;
+}
+
+static long v4l2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct video_device *vdev = video_devdata(filp);
+	int ret = -ENODEV;
+
+	if (vdev->fops->unlocked_ioctl) {
+		if (vdev->lock && mutex_lock_interruptible(vdev->lock))
+			return -ERESTARTSYS;
+		if (video_is_registered(vdev))
+			ret = vdev->fops->unlocked_ioctl(filp, cmd, arg);
+		if (vdev->lock)
+			mutex_unlock(vdev->lock);
+	} else if (vdev->fops->ioctl) {
+		/* This code path is a replacement for the BKL. It is a major
+		 * hack but it will have to do for those drivers that are not
+		 * yet converted to use unlocked_ioctl.
+		 *
+		 * There are two options: if the driver implements struct
+		 * v4l2_device, then the lock defined there is used to
+		 * serialize the ioctls. Otherwise the v4l2 core lock defined
+		 * below is used. This lock is really bad since it serializes
+		 * completely independent devices.
+		 *
+		 * Both variants suffer from the same problem: if the driver
+		 * sleeps, then it blocks all ioctls since the lock is still
+		 * held. This is very common for VIDIOC_DQBUF since that
+		 * normally waits for a frame to arrive. As a result any other
+		 * ioctl calls will proceed very, very slowly since each call
+		 * will have to wait for the VIDIOC_QBUF to finish. Things that
+		 * should take 0.01s may now take 10-20 seconds.
+		 *
+		 * The workaround is to *not* take the lock for VIDIOC_DQBUF.
+		 * This actually works OK for videobuf-based drivers, since
+		 * videobuf will take its own internal lock.
+		 */
+		static DEFINE_MUTEX(v4l2_ioctl_mutex);
+		struct mutex *m = vdev->v4l2_dev ?
+			&vdev->v4l2_dev->ioctl_lock : &v4l2_ioctl_mutex;
+
+		if (cmd != VIDIOC_DQBUF && mutex_lock_interruptible(m))
+			return -ERESTARTSYS;
+		if (video_is_registered(vdev))
+			ret = vdev->fops->ioctl(filp, cmd, arg);
+		if (cmd != VIDIOC_DQBUF)
+			mutex_unlock(m);
+	} else
+		ret = -ENOTTY;
+
+	return ret;
+}
+
+#ifdef CONFIG_MMU
+#define v4l2_get_unmapped_area NULL
+#else
+static unsigned long v4l2_get_unmapped_area(struct file *filp,
+		unsigned long addr, unsigned long len, unsigned long pgoff,
+		unsigned long flags)
+{
+	struct video_device *vdev = video_devdata(filp);
+
+	if (!vdev->fops->get_unmapped_area)
+		return -ENOSYS;
+	if (!video_is_registered(vdev))
+		return -ENODEV;
+	return vdev->fops->get_unmapped_area(filp, addr, len, pgoff, flags);
+}
+#endif
+
+static int v4l2_mmap(struct file *filp, struct vm_area_struct *vm)
+{
+	struct video_device *vdev = video_devdata(filp);
+	int ret = -ENODEV;
+
+	if (!vdev->fops->mmap)
+		return ret;
+	if (vdev->lock && mutex_lock_interruptible(vdev->lock))
+		return -ERESTARTSYS;
+	if (video_is_registered(vdev))
+		ret = vdev->fops->mmap(filp, vm);
+	if (vdev->lock)
+		mutex_unlock(vdev->lock);
+	return ret;
+}
+
+/* Override for the open function */
+static int v4l2_open(struct inode *inode, struct file *filp)
+{
+	struct video_device *vdev;
+	int ret = 0;
+
+	/* Check if the video device is available */
+	mutex_lock(&videodev_lock);
+	vdev = video_devdata(filp);
+	/* return ENODEV if the video device has already been removed. */
+	if (vdev == NULL || !video_is_registered(vdev)) {
+		mutex_unlock(&videodev_lock);
+		return -ENODEV;
+	}
+	/* and increase the device refcount */
+	video_get(vdev);
+	mutex_unlock(&videodev_lock);
+	if (vdev->fops->open) {
+		if (vdev->lock && mutex_lock_interruptible(vdev->lock)) {
+			ret = -ERESTARTSYS;
+			goto err;
+		}
+		if (video_is_registered(vdev))
+			ret = vdev->fops->open(filp);
+		else
+			ret = -ENODEV;
+		if (vdev->lock)
+			mutex_unlock(vdev->lock);
+	}
+
+err:
+	/* decrease the refcount in case of an error */
+	if (ret)
+		video_put(vdev);
+	return ret;
+}
+
+/* Override for the release function */
+static int v4l2_release(struct inode *inode, struct file *filp)
+{
+	struct video_device *vdev = video_devdata(filp);
+	int ret = 0;
+
+	if (vdev->fops->release) {
+		if (vdev->lock)
+			mutex_lock(vdev->lock);
+		vdev->fops->release(filp);
+		if (vdev->lock)
+			mutex_unlock(vdev->lock);
+	}
+	/* decrease the refcount unconditionally since the release()
+	   return value is ignored. */
+	video_put(vdev);
+	return ret;
+}
+
+static const struct file_operations v4l2_fops = {
+	.owner = THIS_MODULE,
+	.read = v4l2_read,
+	.write = v4l2_write,
+	.open = v4l2_open,
+	.get_unmapped_area = v4l2_get_unmapped_area,
+	.mmap = v4l2_mmap,
+	.unlocked_ioctl = v4l2_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = v4l2_compat_ioctl32,
+#endif
+	.release = v4l2_release,
+	.poll = v4l2_poll,
+	.llseek = no_llseek,
+};
+
+/**
+ * get_index - assign stream index number based on parent device
+ * @vdev: video_device to assign index number to, vdev->parent should be assigned
+ *
+ * Note that when this is called the new device has not yet been registered
+ * in the video_device array, but it was able to obtain a minor number.
+ *
+ * This means that we can always obtain a free stream index number since
+ * the worst case scenario is that there are VIDEO_NUM_DEVICES - 1 slots in
+ * use of the video_device array.
+ *
+ * Returns a free index number.
+ */
+static int get_index(struct video_device *vdev)
+{
+	/* This can be static since this function is called with the global
+	   videodev_lock held. */
+	static DECLARE_BITMAP(used, VIDEO_NUM_DEVICES);
+	int i;
+
+	/* Some drivers do not set the parent. In that case always return 0. */
+	if (vdev->parent == NULL)
+		return 0;
+
+	bitmap_zero(used, VIDEO_NUM_DEVICES);
+
+	for (i = 0; i < VIDEO_NUM_DEVICES; i++) {
+		if (video_device[i] != NULL &&
+		    video_device[i]->parent == vdev->parent) {
+			set_bit(video_device[i]->index, used);
+		}
+	}
+
+	return find_first_zero_bit(used, VIDEO_NUM_DEVICES);
+}
+
+/**
+ *	__video_register_device - register video4linux devices
+ *	@vdev: video device structure we want to register
+ *	@type: type of device to register
+ *	@nr:   which device node number (0 == /dev/video0, 1 == /dev/video1, ...
+ *             -1 == first free)
+ *	@warn_if_nr_in_use: warn if the desired device node number
+ *	       was already in use and another number was chosen instead.
+ *	@owner: module that owns the video device node
+ *
+ *	The registration code assigns minor numbers and device node numbers
+ *	based on the requested type and registers the new device node with
+ *	the kernel.
+ *
+ *	This function assumes that struct video_device was zeroed when it
+ *	was allocated and does not contain any stale date.
+ *
+ *	An error is returned if no free minor or device node number could be
+ *	found, or if the registration of the device node failed.
+ *
+ *	Zero is returned on success.
+ *
+ *	Valid types are
+ *
+ *	%VFL_TYPE_GRABBER - A frame grabber
+ *
+ *	%VFL_TYPE_VBI - Vertical blank data (undecoded)
+ *
+ *	%VFL_TYPE_RADIO - A radio card
+ *
+ *	%VFL_TYPE_SUBDEV - A subdevice
+ */
+int __video_register_device(struct video_device *vdev, int type, int nr,
+		int warn_if_nr_in_use, struct module *owner)
+{
+	int i = 0;
+	int ret;
+	int minor_offset = 0;
+	int minor_cnt = VIDEO_NUM_DEVICES;
+	const char *name_base;
+
+	/* A minor value of -1 marks this video device as never
+	   having been registered */
+	vdev->minor = -1;
+
+	/* the release callback MUST be present */
+	if (WARN_ON(!vdev->release))
+		return -EINVAL;
+
+	/* v4l2_fh support */
+	spin_lock_init(&vdev->fh_lock);
+	INIT_LIST_HEAD(&vdev->fh_list);
+
+	/* Part 1: check device type */
+	switch (type) {
+	case VFL_TYPE_GRABBER:
+		name_base = "video";
+		break;
+	case VFL_TYPE_VBI:
+		name_base = "vbi";
+		break;
+	case VFL_TYPE_RADIO:
+		name_base = "radio";
+		break;
+	case VFL_TYPE_SUBDEV:
+		name_base = "v4l-subdev";
+		break;
+	default:
+		printk(KERN_ERR "%s called with unknown type: %d\n",
+		       __func__, type);
+		return -EINVAL;
+	}
+
+	vdev->vfl_type = type;
+	vdev->cdev = NULL;
+	if (vdev->v4l2_dev) {
+		if (vdev->v4l2_dev->dev)
+			vdev->parent = vdev->v4l2_dev->dev;
+		if (vdev->ctrl_handler == NULL)
+			vdev->ctrl_handler = vdev->v4l2_dev->ctrl_handler;
+		/* If the prio state pointer is NULL, then use the v4l2_device
+		   prio state. */
+		if (vdev->prio == NULL)
+			vdev->prio = &vdev->v4l2_dev->prio;
+	}
+
+	/* Part 2: find a free minor, device node number and device index. */
+#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES
+	/* Keep the ranges for the first four types for historical
+	 * reasons.
+	 * Newer devices (not yet in place) should use the range
+	 * of 128-191 and just pick the first free minor there
+	 * (new style). */
+	switch (type) {
+	case VFL_TYPE_GRABBER:
+		minor_offset = 0;
+		minor_cnt = 64;
+		break;
+	case VFL_TYPE_RADIO:
+		minor_offset = 64;
+		minor_cnt = 64;
+		break;
+	case VFL_TYPE_VBI:
+		minor_offset = 224;
+		minor_cnt = 32;
+		break;
+	default:
+		minor_offset = 128;
+		minor_cnt = 64;
+		break;
+	}
+#endif
+
+	/* Pick a device node number */
+	mutex_lock(&videodev_lock);
+	nr = devnode_find(vdev, nr == -1 ? 0 : nr, minor_cnt);
+	if (nr == minor_cnt)
+		nr = devnode_find(vdev, 0, minor_cnt);
+	if (nr == minor_cnt) {
+		printk(KERN_ERR "could not get a free device node number\n");
+		mutex_unlock(&videodev_lock);
+		return -ENFILE;
+	}
+#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES
+	/* 1-on-1 mapping of device node number to minor number */
+	i = nr;
+#else
+	/* The device node number and minor numbers are independent, so
+	   we just find the first free minor number. */
+	for (i = 0; i < VIDEO_NUM_DEVICES; i++)
+		if (video_device[i] == NULL)
+			break;
+	if (i == VIDEO_NUM_DEVICES) {
+		mutex_unlock(&videodev_lock);
+		printk(KERN_ERR "could not get a free minor\n");
+		return -ENFILE;
+	}
+#endif
+	vdev->minor = i + minor_offset;
+	vdev->num = nr;
+	devnode_set(vdev);
+
+	/* Should not happen since we thought this minor was free */
+	WARN_ON(video_device[vdev->minor] != NULL);
+	vdev->index = get_index(vdev);
+	mutex_unlock(&videodev_lock);
+
+	/* Part 3: Initialize the character device */
+	vdev->cdev = cdev_alloc();
+	if (vdev->cdev == NULL) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+	vdev->cdev->ops = &v4l2_fops;
+	vdev->cdev->owner = owner;
+	ret = cdev_add(vdev->cdev, MKDEV(VIDEO_MAJOR, vdev->minor), 1);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: cdev_add failed\n", __func__);
+		kfree(vdev->cdev);
+		vdev->cdev = NULL;
+		goto cleanup;
+	}
+
+	/* Part 4: register the device with sysfs */
+	vdev->dev.class = &video_class;
+	vdev->dev.devt = MKDEV(VIDEO_MAJOR, vdev->minor);
+	if (vdev->parent)
+		vdev->dev.parent = vdev->parent;
+	dev_set_name(&vdev->dev, "%s%d", name_base, vdev->num);
+	ret = device_register(&vdev->dev);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: device_register failed\n", __func__);
+		goto cleanup;
+	}
+	/* Register the release callback that will be called when the last
+	   reference to the device goes away. */
+	vdev->dev.release = v4l2_device_release;
+
+	if (nr != -1 && nr != vdev->num && warn_if_nr_in_use)
+		printk(KERN_WARNING "%s: requested %s%d, got %s\n", __func__,
+			name_base, nr, video_device_node_name(vdev));
+
+	/* Increase v4l2_device refcount */
+	if (vdev->v4l2_dev)
+		v4l2_device_get(vdev->v4l2_dev);
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	/* Part 5: Register the entity. */
+	if (vdev->v4l2_dev && vdev->v4l2_dev->mdev &&
+	    vdev->vfl_type != VFL_TYPE_SUBDEV) {
+		vdev->entity.type = MEDIA_ENT_T_DEVNODE_V4L;
+		vdev->entity.name = vdev->name;
+		vdev->entity.info.v4l.major = VIDEO_MAJOR;
+		vdev->entity.info.v4l.minor = vdev->minor;
+		ret = media_device_register_entity(vdev->v4l2_dev->mdev,
+			&vdev->entity);
+		if (ret < 0)
+			printk(KERN_WARNING
+			       "%s: media_device_register_entity failed\n",
+			       __func__);
+	}
+#endif
+	/* Part 6: Activate this minor. The char device can now be used. */
+	set_bit(V4L2_FL_REGISTERED, &vdev->flags);
+	mutex_lock(&videodev_lock);
+	video_device[vdev->minor] = vdev;
+	mutex_unlock(&videodev_lock);
+
+	return 0;
+
+cleanup:
+	mutex_lock(&videodev_lock);
+	if (vdev->cdev)
+		cdev_del(vdev->cdev);
+	devnode_clear(vdev);
+	mutex_unlock(&videodev_lock);
+	/* Mark this video device as never having been registered. */
+	vdev->minor = -1;
+	return ret;
+}
+EXPORT_SYMBOL(__video_register_device);
+
+/**
+ *	video_unregister_device - unregister a video4linux device
+ *	@vdev: the device to unregister
+ *
+ *	This unregisters the passed device. Future open calls will
+ *	be met with errors.
+ */
+void video_unregister_device(struct video_device *vdev)
+{
+	/* Check if vdev was ever registered at all */
+	if (!vdev || !video_is_registered(vdev))
+		return;
+
+	mutex_lock(&videodev_lock);
+	/* This must be in a critical section to prevent a race with v4l2_open.
+	 * Once this bit has been cleared video_get may never be called again.
+	 */
+	clear_bit(V4L2_FL_REGISTERED, &vdev->flags);
+	mutex_unlock(&videodev_lock);
+	device_unregister(&vdev->dev);
+}
+EXPORT_SYMBOL(video_unregister_device);
+
+/*
+ *	Initialise video for linux
+ */
+static int __init videodev_init(void)
+{
+	dev_t dev = MKDEV(VIDEO_MAJOR, 0);
+	int ret;
+
+	printk(KERN_INFO "Linux video capture interface: v2.00\n");
+	ret = register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);
+	if (ret < 0) {
+		printk(KERN_WARNING "videodev: unable to get major %d\n",
+				VIDEO_MAJOR);
+		return ret;
+	}
+
+	ret = class_register(&video_class);
+	if (ret < 0) {
+		unregister_chrdev_region(dev, VIDEO_NUM_DEVICES);
+		printk(KERN_WARNING "video_dev: class_register failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void __exit videodev_exit(void)
+{
+	dev_t dev = MKDEV(VIDEO_MAJOR, 0);
+
+	class_unregister(&video_class);
+	unregister_chrdev_region(dev, VIDEO_NUM_DEVICES);
+}
+
+module_init(videodev_init)
+module_exit(videodev_exit)
+
+MODULE_AUTHOR("Alan Cox, Mauro Carvalho Chehab <mchehab@infradead.org>");
+MODULE_DESCRIPTION("Device registrar for Video4Linux drivers v2");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(VIDEO_MAJOR);
+
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN media_build_experimental//linux/drivers/staging/media/cxd2099/cxd2099.c media-experimental-media_build_experimental//linux/drivers/staging/media/cxd2099/cxd2099.c
--- media_build_experimental//linux/drivers/staging/media/cxd2099/cxd2099.c	2012-02-27 10:44:16.618908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/staging/media/cxd2099/cxd2099.c	2011-11-02 05:45:17.000000000 +0100
@@ -117,10 +117,9 @@
 
 static int read_block(struct cxd *ci, u8 adr, u8 *data, u8 n)
 {
-	int status = 0;
+	int status;
 
-	if (ci->lastaddress != adr)
-		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
+	status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
 	if (!status) {
 		ci->lastaddress = adr;
 		status = i2c_read(ci->i2c, ci->cfg.adr, 1, data, n);
diff -urN media_build_experimental//linux/drivers/staging/media/cxd2099/Makefile media-experimental-media_build_experimental//linux/drivers/staging/media/cxd2099/Makefile
--- media_build_experimental//linux/drivers/staging/media/cxd2099/Makefile	2012-02-27 10:44:16.618908978 +0100
+++ media-experimental-media_build_experimental//linux/drivers/staging/media/cxd2099/Makefile	2011-11-07 12:48:02.000000000 +0100
@@ -1,5 +1,5 @@
 obj-$(CONFIG_DVB_CXD2099) += cxd2099.o
 
-EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core/
-EXTRA_CFLAGS += -Idrivers/media/dvb/frontends/
-EXTRA_CFLAGS += -Idrivers/media/common/tuners/
+ccflags-y += -Idrivers/media/dvb/dvb-core/
+ccflags-y += -Idrivers/media/dvb/frontends/
+ccflags-y += -Idrivers/media/common/tuners/
diff -urN media_build_experimental//linux/.git_log.md5 media-experimental-media_build_experimental//linux/.git_log.md5
--- media_build_experimental//linux/.git_log.md5	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/.git_log.md5	2012-02-27 00:02:30.088915018 +0100
@@ -0,0 +1 @@
+bd6e72aa905bf1b3d3e2aabe18b9fa46  git_log
diff -urN media_build_experimental//linux/include/linux/dvb/osd.h media-experimental-media_build_experimental//linux/include/linux/dvb/osd.h
--- media_build_experimental//linux/include/linux/dvb/osd.h	2012-02-27 10:48:36.968908938 +0100
+++ media-experimental-media_build_experimental//linux/include/linux/dvb/osd.h	2010-07-03 23:22:13.000000000 +0200
@@ -141,20 +141,4 @@
 #define OSD_SEND_CMD            _IOW('o', 160, osd_cmd_t)
 #define OSD_GET_CAPABILITY      _IOR('o', 161, osd_cap_t)
 
-typedef struct osd_raw_cmd_s {
-	const void __user *cmd_data;
-	int cmd_len;
-	void __user *result_data;
-	int result_len;
-} osd_raw_cmd_t;
-
-typedef struct osd_raw_data_s {
-	const void __user *data_buffer;
-	int data_length;
-	int data_handle;
-} osd_raw_data_t;
-
-#define OSD_RAW_CMD            _IOWR('o', 162, osd_raw_cmd_t)
-#define OSD_RAW_DATA           _IOWR('o', 163, osd_raw_data_t)
-
 #endif
diff -urN media_build_experimental//linux/.patches_applied media-experimental-media_build_experimental//linux/.patches_applied
--- media_build_experimental//linux/.patches_applied	1970-01-01 01:00:00.000000000 +0100
+++ media-experimental-media_build_experimental//linux/.patches_applied	2012-02-27 00:02:30.088915018 +0100
@@ -0,0 +1,2 @@
+#3.2.6
+api_version.patch
