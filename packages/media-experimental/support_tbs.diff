diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/Kconfig media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/Kconfig
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/Kconfig	2012-04-10 05:45:26.000000000 +0200
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/Kconfig	2012-04-16 23:21:58.131661111 +0200
@@ -212,6 +212,66 @@
 	select MEDIA_TUNER_MT2060 if !MEDIA_TUNER_CUSTOMISE
 	help
 	  Say Y here to support the Hauppauge WinTV-NOVA-T usb2 DVB-T USB2.0 receiver.
+	  
+config DVB_USB_TBSQBOX
+	tristate "TurboSight QBOX DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	select DVB_STV0299 if !DVB_FE_CUSTOMISE
+	select DVB_STV0288 if !DVB_FE_CUSTOMISE
+	select DVB_STB6000 if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight QBOX DVB-S USB2.0 receivers
+
+config DVB_USB_TBSQBOX2
+	tristate "TurboSight QBOX2 DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_STV090x if !DVB_FE_CUSTOMISE
+	select DVB_STB6100 if !DVB_FE_CUSTOMISE
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight QBOX2 DVB-S USB2.0 receivers
+
+config DVB_USB_TBSQBOX2CI
+	tristate "TurboSight QBOX2 CI DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_STV090x if !DVB_FE_CUSTOMISE
+	select DVB_STB6100 if !DVB_FE_CUSTOMISE
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight QBOX2 CI DVB-S USB2.0 receivers
+
+config DVB_USB_TBSQBOXS2
+	tristate "TurboSight QBOX2 DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_CX24116 if !DVB_FE_CUSTOMISE
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight QBOX2 DVB-S USB2.0 receivers
+	  
+config DVB_USB_TBSQBOXS3
+	tristate "TurboSight QBOX3 DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_TBS5921FE if !DVB_FE_CUSTOMISE
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight QBOX3 DVB-S USB2.0 receivers
+
+config DVB_USB_TBSQBOX22
+	tristate "TurboSight QBOX22 DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_TBS5922FE if !DVB_FE_CUSTOMISE
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight QBOX22 DVB-S USB2.0 receivers
+
+config DVB_USB_TBS5880
+	tristate "TurboSight TBS5880 DVB-S2 USB2.0 support"
+	depends on DVB_USB
+	select DVB_TBS5880FE if !DVB_FE_CUSTOMISE
+	select DVB_PLL if !DVB_FE_CUSTOMISE
+	help
+	  Say Y here to support the TurboSight TBS5880 DVB-S USB2.0 receivers
 
 config DVB_USB_TTUSB2
 	tristate "Pinnacle 400e DVB-S USB2.0 support"
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/Makefile media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/Makefile
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/Makefile	2012-04-10 05:45:26.000000000 +0200
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/Makefile	2012-04-16 23:21:58.131661111 +0200
@@ -45,6 +45,27 @@
 dvb-usb-cxusb-objs = cxusb.o
 obj-$(CONFIG_DVB_USB_CXUSB) += dvb-usb-cxusb.o
 
+dvb-usb-tbsqbox-objs = tbs-qbox.o
+obj-$(CONFIG_DVB_USB_TBSQBOX) += dvb-usb-tbsqbox.o
+
+dvb-usb-tbsqbox2-objs = tbs-qbox2.o
+obj-$(CONFIG_DVB_USB_TBSQBOX2) += dvb-usb-tbsqbox2.o
+
+dvb-usb-tbsqbox2ci-objs = tbs-qbox2ci.o
+obj-$(CONFIG_DVB_USB_TBSQBOX2CI) += dvb-usb-tbsqbox2ci.o
+
+dvb-usb-tbsqboxs2-objs = tbs-qboxs2.o
+obj-$(CONFIG_DVB_USB_TBSQBOXS2) += dvb-usb-tbsqboxs2.o
+
+dvb-usb-tbsqboxs3-objs = tbs-qboxs3.o tbs5921ctrl.o
+obj-$(CONFIG_DVB_USB_TBSQBOXS3) += dvb-usb-tbsqboxs3.o
+
+dvb-usb-tbsqbox22-objs = tbs-qbox22.o tbs5922ctrl.o
+obj-$(CONFIG_DVB_USB_TBSQBOX22) += dvb-usb-tbsqbox22.o
+
+dvb-usb-tbs5880-objs = tbs5880.o tbs5880ctrl.o
+obj-$(CONFIG_DVB_USB_TBS5880) += dvb-usb-tbs5880.o
+
 dvb-usb-ttusb2-objs = ttusb2.o
 obj-$(CONFIG_DVB_USB_TTUSB2) += dvb-usb-ttusb2.o
 
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5880.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5880.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5880.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5880.c	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,751 @@
+/*
+ * TurboSight TBS 5880 CI driver
+ *
+ * Copyright (c) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/version.h>
+#include "tbs5880.h"
+#include "tbs5880fe.h"
+#include "tbs5880ctrl.h"
+
+#include "dvb_ca_en50221.h"
+
+#ifndef USB_PID_TBS5880
+#define USB_PID_TBS5880 0x5880
+#endif
+
+#define TBS5880_READ_MSG 0
+#define TBS5880_WRITE_MSG 1
+
+#define TBS5880_RC_QUERY (0x1a00)
+
+struct tbs5880_state {
+	struct dvb_ca_en50221 ca;
+	struct mutex ca_mutex;
+
+	u32 last_key_pressed;
+};
+
+/*struct tbs5880_rc_keys {
+	u32 keycode;
+	u32 event;
+};*/
+
+/* debug */
+static int dvb_usb_tbs5880_debug;
+module_param_named(debug, dvb_usb_tbs5880_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." 
+							DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbs5880_op_rw(struct usb_device *dev, u8 request, u16 value,
+				u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBS5880_READ_MSG) ?
+			usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBS5880_READ_MSG) ? USB_DIR_IN : 
+								USB_DIR_OUT;
+
+	if (flags == TBS5880_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | 
+			USB_TYPE_VENDOR, value, index , u8buf, len, 2000);
+
+	if (flags == TBS5880_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+static int tbs5880_read_attribute_mem(struct dvb_ca_en50221 *ca,
+                                                	int slot, int address)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[4], rbuf[3];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 0;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+
+	//msleep(10);
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbs5880_op_rw(d->udev, 0xa4, 0, 0,
+						buf, 4, TBS5880_WRITE_MSG);
+
+	//msleep(1);
+
+	ret = tbs5880_op_rw(d->udev, 0xa5, 0, 0,
+						rbuf, 1, TBS5880_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return rbuf[0];
+}
+
+static int tbs5880_write_attribute_mem(struct dvb_ca_en50221 *ca,
+						int slot, int address, u8 value)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[5];//, rbuf[1];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 0;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+	buf[4] = value;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbs5880_op_rw(d->udev, 0xa2, 0, 0,
+						buf, 5, TBS5880_WRITE_MSG);
+
+	//msleep(1);
+
+	//ret = tbs5880_op_rw(d->udev, 0xa5, 0, 0,
+	//					rbuf, 1, TBS5880_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tbs5880_read_cam_control(struct dvb_ca_en50221 *ca, int slot, 
+								u8 address)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[4], rbuf[1];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 1;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbs5880_op_rw(d->udev, 0xa4, 0, 0,
+						buf, 4, TBS5880_WRITE_MSG);
+
+	//msleep(10);
+
+	ret = tbs5880_op_rw(d->udev, 0xa5, 0, 0,
+						rbuf, 1, TBS5880_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return rbuf[0];
+}
+
+static int tbs5880_write_cam_control(struct dvb_ca_en50221 *ca, int slot, 
+							u8 address, u8 value)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[5];//, rbuf[1];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 1;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+	buf[4] = value;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbs5880_op_rw(d->udev, 0xa2, 0, 0,
+						buf, 5, TBS5880_WRITE_MSG);
+
+	//msleep(1);
+
+	//ret = tbs5880_op_rw(d->udev, 0xa5, 0, 0,
+	//					rbuf, 1, TBS5880_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tbs5880_set_video_port(struct dvb_ca_en50221 *ca, 
+							int slot, int enable)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[2];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 2;
+	buf[1] = enable;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbs5880_op_rw(d->udev, 0xa6, 0, 0,
+						buf, 2, TBS5880_WRITE_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	if (enable != buf[1]) {
+		err("CI not %sabled.", enable ? "en" : "dis");
+		return -EIO;
+	}
+
+	info("CI %sabled.", enable ? "en" : "dis");
+	return 0;
+}
+
+static int tbs5880_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
+{
+	return tbs5880_set_video_port(ca, slot, /* enable */ 0);
+}
+
+static int tbs5880_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
+{
+	return tbs5880_set_video_port(ca, slot, /* enable */ 1);
+}
+
+static int tbs5880_slot_reset(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[2];
+	int ret;
+
+	if (0 != slot) {
+		return -EINVAL;
+	}
+
+	buf[0] = 1;
+	buf[1] = 0;
+
+	mutex_lock (&state->ca_mutex);
+
+	ret = tbs5880_op_rw(d->udev, 0xa6, 0, 0,
+						buf, 2, TBS5880_WRITE_MSG);
+
+	msleep (400);
+
+	buf[1] = 1;
+
+	ret = tbs5880_op_rw(d->udev, 0xa6, 0, 0,
+						buf, 2, TBS5880_WRITE_MSG);
+
+	msleep (1200);
+
+	mutex_unlock (&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tbs5880_poll_slot_status(struct dvb_ca_en50221 *ca,
+							int slot, int open)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	u8 buf[3];
+
+	if (0 != slot)
+		return -EINVAL;
+
+	mutex_lock(&state->ca_mutex);
+
+	tbs5880_op_rw(d->udev, 0xa8, 0, 0,
+					buf, 3, TBS5880_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if ((1 == buf[2]) && (1 == buf[1]) && (0xa9 == buf[0])) {
+				return (DVB_CA_EN50221_POLL_CAM_PRESENT |
+						DVB_CA_EN50221_POLL_CAM_READY);
+	} else {
+		return 0;
+	}
+}
+
+static void tbs5880_uninit(struct dvb_usb_device *d)
+{
+	struct tbs5880_state *state;
+
+	if (NULL == d)
+		return;
+
+	state = (struct tbs5880_state *)d->priv;
+	if (NULL == state)
+		return;
+
+	if (NULL == state->ca.data)
+		return;
+
+	/* Error ignored. */
+	tbs5880_set_video_port(&state->ca, /* slot */ 0, /* enable */ 0);
+
+	dvb_ca_en50221_release(&state->ca);
+
+	memset(&state->ca, 0, sizeof(state->ca));
+}
+
+static int tbs5880_init(struct dvb_usb_adapter *a)
+{
+
+	struct dvb_usb_device *d = a->dev;
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	int ret;
+
+	state->ca.owner = THIS_MODULE;
+	state->ca.read_attribute_mem = tbs5880_read_attribute_mem;
+	state->ca.write_attribute_mem = tbs5880_write_attribute_mem;
+	state->ca.read_cam_control = tbs5880_read_cam_control;
+	state->ca.write_cam_control = tbs5880_write_cam_control;
+	state->ca.slot_reset = tbs5880_slot_reset;
+	state->ca.slot_shutdown = tbs5880_slot_shutdown;
+	state->ca.slot_ts_enable = tbs5880_slot_ts_enable;
+	state->ca.poll_slot_status = tbs5880_poll_slot_status;
+	state->ca.data = d;
+
+	ret = dvb_ca_en50221_init (&a->dvb_adap, &state->ca,
+						/* flags */ 0, /* n_slots */ 1);
+
+	if (0 != ret) {
+		err ("Cannot initialize CI: Error %d.", ret);
+		memset (&state->ca, 0, sizeof (state->ca));
+		return ret;
+	}
+
+	info ("CI initialized.");
+
+	ret = tbs5880_poll_slot_status(&state->ca, 0, 0);
+	if (0 == ret)
+		tbs5880_set_video_port(&state->ca, /* slot */ 0, /* enable */ 0);
+
+	return 0;
+}
+
+/* I2C */
+static int tbs5880_i2c_transfer(struct i2c_adapter *adap, 
+					struct i2c_msg msg[], int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	struct tbs5880_state *state = (struct tbs5880_state *)d->priv;
+	int i = 0;
+	u8 buf6[20];
+	u8 inbuf[20];
+
+	if (!d)
+		return -ENODEV;
+
+	mutex_lock(&state->ca_mutex);
+
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2:
+		buf6[0]=msg[1].len;//lenth
+		buf6[1]=msg[0].addr<<1;//demod addr
+		//register
+		buf6[2] = msg[0].buf[0];
+
+		tbs5880_op_rw(d->udev, 0x90, 0, 0,
+					buf6, 3, TBS5880_WRITE_MSG);
+		//msleep(5);
+		tbs5880_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, 1, TBS5880_READ_MSG);
+		memcpy(msg[1].buf, inbuf, msg[1].len);
+		break;
+	case 1:
+		switch (msg[0].addr) {
+		case 0x6c:
+		case 0x6e:
+		case 0x61:
+		case 0x60:
+			if (msg[0].flags == 0) {
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//addr
+				for(i=0;i<msg[0].len;i++) {
+					buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbs5880_op_rw(d->udev, 0x80, 0, 0,
+					buf6, msg[0].len+2, TBS5880_WRITE_MSG);
+			} else {
+				buf6[0] = msg[0].len;//length
+				buf6[1] = msg[0].addr<<1;//addr
+				buf6[2] = 0x00;
+				tbs5880_op_rw(d->udev, 0x90, 0, 0,
+						buf6, 3, TBS5880_WRITE_MSG);
+				//msleep(5);
+				tbs5880_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, buf6[0], TBS5880_READ_MSG);
+				memcpy(msg[0].buf, inbuf, msg[0].len);
+			}
+			//msleep(3);
+			break;
+		case (TBS5880_RC_QUERY):
+			tbs5880_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBS5880_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			//msleep(3);
+			//info("TBS5880_RC_QUERY %x %x %x %x\n",
+			//		buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	mutex_unlock(&state->ca_mutex);
+	return num;
+}
+
+static u32 tbs5880_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct tbs5880fe_config tbs5880fe_config = {
+	.tbs5880fe_address = 0x6c,
+
+	.tbs5880_ctrl = tbs5880ctrl,
+};
+
+static struct i2c_algorithm tbs5880_i2c_algo = {
+	.master_xfer = tbs5880_i2c_transfer,
+	.functionality = tbs5880_i2c_func,
+};
+
+static int tbs5880_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbs5880_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBS5880_WRITE_MSG);
+		ret = tbs5880_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBS5880_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed.");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static struct dvb_usb_device_properties tbs5880_properties;
+
+static int tbs5880_frontend_attach(struct dvb_usb_adapter *d)
+{
+	struct dvb_usb_device *u = d->dev;
+	struct tbs5880_state *state = (struct tbs5880_state *)u->priv;
+	u8 buf[20];
+
+	mutex_init(&state->ca_mutex);
+
+	if (tbs5880_properties.adapter[0].fe[0].tuner_attach == NULL) {
+		d->fe_adap[0].fe = dvb_attach(tbs5880fe_attach, &tbs5880fe_config,
+			&d->dev->i2c_adap);
+		if (d->fe_adap[0].fe != NULL) {
+			info("Attached TBS5880FE!\n");
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbs5880_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBS5880_WRITE_MSG);
+
+			tbs5880_init(d);
+			return 0;
+		}
+	}
+
+	return -EIO;
+}
+
+static void tbs58802_usb_disconnect (struct usb_interface * intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata (intf);
+	
+	tbs5880_uninit (d);
+	dvb_usb_device_exit (intf);
+}
+
+static struct rc_map_table tbs5880_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },
+	{ 0xff94, KEY_MUTE },
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },
+	{ 0xff91, KEY_CHANNELDOWN },
+	{ 0xff93, KEY_VOLUMEUP },
+	{ 0xff8c, KEY_VOLUMEDOWN },
+	{ 0xff83, KEY_RECORD },
+	{ 0xff98, KEY_PAUSE  },
+	{ 0xff99, KEY_OK },
+	{ 0xff9a, KEY_SHUFFLE },
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9b, KEY_MODE }
+};
+
+static int tbs5880_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+
+	struct tbs5880_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBS5880_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbs5880_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbs5880_table[] = {
+	{USB_DEVICE(0x734c, 0x5880)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbs5880_table);
+
+static int tbs5880_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id5880.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x5880:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBS5880 CI firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbs5880_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBS5880_WRITE_MSG);
+	tbs5880_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBS5880_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbs5880_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBS5880_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbs5880_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBS5880_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbs5880_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBS5880_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbs5880_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5880.fw",
+	.size_of_priv = sizeof(struct tbs5880_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbs5880_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbs5880_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbs5880_rc_keys),
+		.rc_interval = 450,
+		.rc_query = tbs5880_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbs5880_load_firmware,
+	.read_mac_address = tbs5880_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbs5880_frontend_attach,
+				.streaming_ctrl = NULL,
+				.tuner_attach = NULL,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS 5880 CI USB2.0",
+			{&tbs5880_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbs5880_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbs5880_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbs5880_driver = {
+	.name = "tbs5880",
+	.probe = tbs5880_probe,
+	.disconnect = tbs58802_usb_disconnect,
+	.id_table = tbs5880_table,
+};
+
+static int __init tbs5880_module_init(void)
+{
+	int ret =  usb_register(&tbs5880_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbs5880_module_exit(void)
+{
+	usb_deregister(&tbs5880_driver);
+}
+
+module_init(tbs5880_module_init);
+module_exit(tbs5880_module_exit);
+
+MODULE_AUTHOR("Konstantin Dimitrov <kosio.dimitrov@gmail.com>");
+MODULE_DESCRIPTION("TurboSight TBS 5880 CI driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5880ctrl.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5880ctrl.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5880ctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5880ctrl.h	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,13 @@
+/*
+    TurboSight TBS 5880 DVB-T/T2/C controls
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS5880CTRL_H
+#define TBS5880CTRL_H
+
+extern int tbs5880ctrl(struct usb_device *dev, u8 *a);
+
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5880.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5880.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5880.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5880.h	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBS5880_H_
+#define _TBS5880_H_
+
+#define DVB_USB_LOG_PREFIX "tbs5880"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbs5880_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5921ctrl.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5921ctrl.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5921ctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5921ctrl.h	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,13 @@
+/*
+    TurboSight TBS 5921 DVB-S/S2 controls
+    Copyright (C) 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2010 TurboSight.com
+*/
+
+#ifndef TBS5921CTRL_H
+#define TBS5921CTRL_H
+
+extern int tbs5921ctrl(struct usb_device *dev, u8 *a);
+
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5922ctrl.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5922ctrl.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs5922ctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs5922ctrl.h	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,13 @@
+/*
+    TurboSight TBS 5922 DVB-S/S2 controls
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS5922CTRL_H
+#define TBS5922CTRL_H
+
+extern int tbs5922ctrl(struct usb_device *dev, u8 *a);
+
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox22.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox22.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox22.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox22.c	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,456 @@
+/* DVB USB framework compliant Linux driver for the
+*	TBS QBOX
+*
+* Copyright (C) 2008 Bob Liu (Bob@Turbosight.com)
+* Igor M. Liplianin (liplianin@me.by)
+*
+*	This program is free software; you can redistribute it and/or modify it
+*	under the terms of the GNU General Public License as published by the
+*	Free Software Foundation, version 2.
+*
+* see Documentation/dvb/README.dvb-usb for more information
+*/
+
+/* 
+* History:
+*
+* December 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+* remove QBOXS3 support
+* add QBOX22 support
+*/
+
+#include <linux/version.h>
+#include "tbs-qbox22.h"
+#include "tbs5922fe.h"
+#include "tbs5922ctrl.h"
+#include "tbsfe.h"
+
+#ifndef USB_PID_TBSQBOX_1
+#define USB_PID_TBSQBOX_1 0x5922
+#endif
+
+#define TBSQBOX_READ_MSG 0
+#define TBSQBOX_WRITE_MSG 1
+
+/* on my own*/
+#define TBSQBOX_VOLTAGE_CTRL (0x1800)
+#define TBSQBOX_RC_QUERY (0x1a00)
+
+struct tbsqbox22_state {
+	u32 last_key_pressed;
+};
+struct tbsqbox22_rc_keys {
+	u32 keycode;
+	u32 event;
+};
+
+/* debug */
+static int dvb_usb_tbsqbox22_debug;
+module_param_named(debug, dvb_usb_tbsqbox22_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbsqbox22_op_rw(struct usb_device *dev, u8 request, u16 value,
+			u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBSQBOX_READ_MSG) ?
+				usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBSQBOX_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+
+	if (flags == TBSQBOX_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index, u8buf, len, 2000);
+
+	if (flags == TBSQBOX_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+/* I2C */
+static int tbsqbox22_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+		int num)
+{
+struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0;
+	u8 ibuf[1], obuf[3];
+	u8 buf6[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2: {
+		/* read */
+		obuf[0] = msg[0].len;
+		obuf[1] = msg[0].addr<<1;
+		obuf[2] = msg[0].buf[0];
+
+		tbsqbox22_op_rw(d->udev, 0x90, 0, 0,
+					obuf, 3, TBSQBOX_WRITE_MSG);
+		msleep(5);
+		tbsqbox22_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+		memcpy(msg[1].buf, ibuf, msg[1].len);
+		break;
+	}
+	case 1:
+		switch (msg[0].addr) {
+		case 0x68: {
+				/* write to register */
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//demod addr
+				for(i=0;i<msg[0].len;i++) {
+				buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbsqbox22_op_rw(d->udev, 0x80, 0, 0,
+							buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+				//msleep(3);
+			break;
+		}
+		case 0x63: {
+			/* write to register */
+			buf6[0] = msg[0].len+1;//lenth
+			buf6[1] = msg[0].addr<<1;//demod addr
+			for(i=0;i<msg[0].len;i++) {
+				buf6[2+i] = msg[0].buf[i];//register
+			}
+			tbsqbox22_op_rw(d->udev, 0x80, 0, 0,
+						buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			msleep(3);
+
+			break;
+		}
+		case (TBSQBOX_RC_QUERY): {
+			tbsqbox22_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBSQBOX_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			msleep(3);
+			//info("TBSQBOX_RC_QUERY %x %x %x %x\n",buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		}
+		case (TBSQBOX_VOLTAGE_CTRL): {
+			break;
+		}
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbsqbox22_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+
+
+static struct i2c_algorithm tbsqbox22_i2c_algo = {
+	.master_xfer = tbsqbox22_i2c_transfer,
+	.functionality = tbsqbox22_i2c_func,
+};
+
+static struct tbs5922fe_config tbs5922_fe_config = {
+	.tbs5922fe_address = 0x68,
+
+	.tbs5922_ctrl = tbs5922ctrl,
+};
+
+static int tbsqbox22_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbsqbox22_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBSQBOX_WRITE_MSG);
+		ret = tbsqbox22_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static struct dvb_usb_device_properties tbsqbox22_properties;
+
+static int tbsqbox22_frontend_attach(struct dvb_usb_adapter *d)
+{
+	u8 buf[20];
+	
+        if ((d->fe_adap[0].fe = dvb_attach(tbs5922fe_attach, &tbs5922_fe_config,
+                                        &d->dev->i2c_adap)) != NULL) {
+			printk("QBOX22: TBS5922FE attached.\n");
+			dvb_attach(tbsfe_attach, d->fe_adap[0].fe);
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbsqbox22_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			buf[0] = 1;
+			buf[1] = 1;
+			tbsqbox22_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			buf[0] = 6;     
+			buf[1] = 1;
+			tbsqbox22_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			return 0;
+	}
+
+	return -EIO;
+}
+
+
+
+static struct rc_map_table tbsqbox22_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },		/*power*/
+	{ 0xff94, KEY_MUTE },		/*mute*/
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },	/*ch+*/
+	{ 0xff91, KEY_CHANNELDOWN },	/*ch-*/
+	{ 0xff93, KEY_VOLUMEUP },		/*vol+*/
+	{ 0xff8c, KEY_VOLUMEDOWN },		/*vol-*/
+	{ 0xff83, KEY_RECORD },		/*rec*/
+	{ 0xff98, KEY_PAUSE  },		/*pause*/
+	{ 0xff99, KEY_OK },	/*ok*/
+	{ 0xff9a, KEY_SHUFFLE },		  /* snapshot */
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9b, KEY_MODE }
+
+
+};
+
+
+
+static int tbsqbox22_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+	
+	struct tbsqbox22_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbsqbox22_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbsqbox22_table[] = {
+	{USB_DEVICE(0x734c, 0x5922)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX_1)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbsqbox22_table);
+
+static int tbsqbox22_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id5922.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x5922:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBSQBOX firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbsqbox22_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+	tbsqbox22_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbsqbox22_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBSQBOX_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbsqbox22_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbsqbox22_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbsqbox22_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5922.fw",
+	.size_of_priv = sizeof(struct tbsqbox22_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbsqbox22_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbsqbox22_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbsqbox22_rc_keys),
+		.rc_interval = 150,
+		.rc_query = tbsqbox22_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbsqbox22_load_firmware,
+	.read_mac_address = tbsqbox22_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbsqbox22_frontend_attach,
+				.streaming_ctrl = NULL,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS QBOX22 DVBS2 USB2.0",
+			{&tbsqbox22_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbsqbox22_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbsqbox22_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbsqbox22_driver = {
+	.name = "tbsqbox22",
+	.probe = tbsqbox22_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table = tbsqbox22_table,
+};
+
+static int __init tbsqbox22_module_init(void)
+{
+	int ret =  usb_register(&tbsqbox22_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbsqbox22_module_exit(void)
+{
+	usb_deregister(&tbsqbox22_driver);
+}
+
+module_init(tbsqbox22_module_init);
+module_exit(tbsqbox22_module_exit);
+
+MODULE_AUTHOR("Bob Liu <Bob@turbosight.com>");
+MODULE_DESCRIPTION("Driver for TBS QBOX22");
+MODULE_VERSION("0.2");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox22.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox22.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox22.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox22.h	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBSQBOX22_H_
+#define _TBSQBOX22_H_
+
+#define DVB_USB_LOG_PREFIX "tbsqbox22"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbsqbox22_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2.c	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,506 @@
+/* DVB USB framework compliant Linux driver for the
+*	TBS QBOX
+*
+* Copyright (C) 2008 Bob Liu (Bob@Turbosight.com)
+* Igor M. Liplianin (liplianin@me.by)
+*
+* Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+* 	August 2009
+* 	Add QBOX II STV0903 support
+*
+*	This program is free software; you can redistribute it and/or modify it
+*	under the terms of the GNU General Public License as published by the
+*	Free Software Foundation, version 2.
+*
+* see Documentation/dvb/README.dvb-usb for more information
+*/
+#include <linux/version.h>
+#include "tbs-qbox2.h"
+#include "stv6110x.h"
+#include "stv090x.h"
+#include "stb6100.h"
+#include "stb6100_cfg.h"
+
+
+#ifndef USB_PID_TBSQBOX
+#define USB_PID_TBSQBOX 0x2601
+#endif
+
+#ifndef USB_PID_TBSQBOX_1
+#define USB_PID_TBSQBOX_1 0x5920
+#endif
+
+#define TBSQBOX_READ_MSG 0
+#define TBSQBOX_WRITE_MSG 1
+
+/* on my own*/
+#define TBSQBOX_VOLTAGE_CTRL (0x1800)
+#define TBSQBOX_RC_QUERY (0x1a00)
+
+struct tbsqbox2_state {
+	u32 last_key_pressed;
+};
+struct tbsqbox2_rc_keys {
+	u32 keycode;
+	u32 event;
+};
+
+/* debug */
+static int dvb_usb_tbsqbox2_debug;
+module_param_named(debug, dvb_usb_tbsqbox2_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbsqbox2_op_rw(struct usb_device *dev, u8 request, u16 value,
+			u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBSQBOX_READ_MSG) ?
+				usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBSQBOX_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+
+	if (flags == TBSQBOX_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index , u8buf, len, 2000);
+
+	if (flags == TBSQBOX_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+/* I2C */
+static int tbsqbox2_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+		int num)
+{
+struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0;
+	u8 buf6[20];
+	u8 inbuf[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2:
+		buf6[0]=msg[1].len;//lenth
+		buf6[1]=msg[0].addr<<1;//demod addr
+		//register
+		buf6[2] = msg[0].buf[0];
+		buf6[3] = msg[0].buf[1];
+
+		tbsqbox2_op_rw(d->udev, 0x92, 0, 0,
+					buf6, 4, TBSQBOX_WRITE_MSG);
+		//msleep(5);
+		tbsqbox2_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, 1, TBSQBOX_READ_MSG);
+		memcpy(msg[1].buf, inbuf, msg[1].len);
+		break;
+	case 1:
+		switch (msg[0].addr) {
+		case 0x6a:
+		case 0x61:
+		case 0x60:
+			if (msg[0].flags == 0) {
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//addr
+				for(i=0;i<msg[0].len;i++) {
+					buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbsqbox2_op_rw(d->udev, 0x80, 0, 0,
+							buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			} else {
+				buf6[0] = msg[0].len;//length
+				buf6[1] = msg[0].addr<<1;//addr
+				buf6[2] = 0x00;
+				tbsqbox2_op_rw(d->udev, 0x90, 0, 0,
+							buf6, 3, TBSQBOX_WRITE_MSG);
+				//msleep(5);
+				tbsqbox2_op_rw(d->udev, 0x91, 0, 0,
+							inbuf, buf6[0], TBSQBOX_READ_MSG);
+				memcpy(msg[0].buf, inbuf, msg[0].len);
+			}
+			//msleep(3);
+			break;
+		case (TBSQBOX_RC_QUERY):
+			tbsqbox2_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBSQBOX_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			msleep(3);
+			//info("TBSQBOX_RC_QUERY %x %x %x %x\n",buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		case (TBSQBOX_VOLTAGE_CTRL):
+			buf6[0] = 3;
+			buf6[1] = msg[0].buf[0];
+			tbsqbox2_op_rw(d->udev, 0x8a, 0, 0,
+					buf6, 2, TBSQBOX_WRITE_MSG);
+			
+			break;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbsqbox2_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct stv090x_config earda_config = {
+	.device         = STV0903,
+	.demod_mode     = STV090x_SINGLE,
+	.clk_mode       = STV090x_CLK_EXT,
+
+	.xtal           = 27000000,
+	.address        = 0x6a,
+
+	.ts1_mode       = STV090x_TSMODE_DVBCI,
+	.ts2_mode       = STV090x_TSMODE_DVBCI,
+	
+	.repeater_level         = STV090x_RPTLEVEL_16,
+
+	.tuner_get_frequency    = stb6100_get_frequency,
+	.tuner_set_frequency    = stb6100_set_frequency,
+	.tuner_set_bandwidth    = stb6100_set_bandwidth,
+	.tuner_get_bandwidth    = stb6100_get_bandwidth,
+};
+
+static struct stb6100_config qbox2_stb6100_config = {
+	.tuner_address  = 0x60,
+	.refclock       = 27000000,
+};
+
+static struct i2c_algorithm tbsqbox2_i2c_algo = {
+	.master_xfer = tbsqbox2_i2c_transfer,
+	.functionality = tbsqbox2_i2c_func,
+};
+
+static int tbsqbox2_earda_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	dvb_attach(stb6100_attach, adap->fe_adap[0].fe, &qbox2_stb6100_config,
+		&adap->dev->i2c_adap);
+
+	return 0;
+}
+static int tbsqbox2_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbsqbox2_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBSQBOX_WRITE_MSG);
+		ret = tbsqbox2_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed.");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static int tbsqbox2_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	static u8 command_13v[1] = {0x00};
+	static u8 command_18v[1] = {0x01};
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_VOLTAGE_CTRL, .flags = 0,
+			.buf = command_13v, .len = 1},
+	};
+	
+	struct dvb_usb_adapter *udev_adap =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	if (voltage == SEC_VOLTAGE_18)
+		msg[0].buf = command_18v;
+	//info("tbsqbox2_set_voltage %d",voltage);
+	i2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);
+	return 0;
+}
+
+static struct dvb_usb_device_properties tbsqbox2_properties;
+
+static int tbsqbox2_frontend_attach(struct dvb_usb_adapter *d)
+{
+	u8 buf[20];
+
+	if (tbsqbox2_properties.adapter[0].fe[0].tuner_attach == &tbsqbox2_earda_tuner_attach) {
+		d->fe_adap[0].fe = dvb_attach(stv090x_attach, &earda_config,
+					&d->dev->i2c_adap, STV090x_DEMODULATOR_0);
+		if (d->fe_adap[0].fe != NULL) {
+			d->fe_adap[0].fe->ops.set_voltage = tbsqbox2_set_voltage;
+			info("Attached stv0903!\n");
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbsqbox2_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			return 0;
+		}
+	}
+
+	return -EIO;
+}
+
+
+
+static struct rc_map_table tbsqbox2_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },		/*power*/
+	{ 0xff94, KEY_MUTE },		/*mute*/
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },	/*ch+*/
+	{ 0xff91, KEY_CHANNELDOWN },	/*ch-*/
+	{ 0xff93, KEY_VOLUMEUP },		/*vol+*/
+	{ 0xff8c, KEY_VOLUMEDOWN },		/*vol-*/
+	{ 0xff83, KEY_RECORD },		/*rec*/
+	{ 0xff98, KEY_PAUSE  },		/*pause*/
+	{ 0xff99, KEY_OK },	/*ok*/
+	{ 0xff9a, KEY_SHUFFLE },		  /* snapshot */
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9b, KEY_MODE }
+
+
+};
+
+
+
+static int tbsqbox2_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+	
+	struct tbsqbox2_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbsqbox2_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbsqbox2_table[] = {
+	{USB_DEVICE(0x734c, 0x2601)},
+	{USB_DEVICE(0x734c, 0x5920)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX_1)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbsqbox2_table);
+
+static int tbsqbox2_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id2601.fw";
+	const char *filename1 = "dvb-usb-tbsqbox-id5920.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x2601:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	case 0x5920:
+		ret = request_firmware(&fw, filename1, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename1);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBSQBOX2 firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbsqbox2_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+	tbsqbox2_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbsqbox2_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBSQBOX_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbsqbox2_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbsqbox2_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbsqbox2_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5920.fw",
+	.size_of_priv = sizeof(struct tbsqbox2_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbsqbox2_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbsqbox2_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbsqbox2_rc_keys),
+		.rc_interval = 150,
+		.rc_query = tbsqbox2_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbsqbox2_load_firmware,
+	.read_mac_address = tbsqbox2_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbsqbox2_frontend_attach,
+				.streaming_ctrl = NULL,
+				.tuner_attach = tbsqbox2_earda_tuner_attach,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS QBOX2 DVBS USB2.0",
+			{&tbsqbox2_table[1], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbsqbox2_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbsqbox2_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbsqbox2_driver = {
+	.name = "tbsqbox2",
+	.probe = tbsqbox2_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table = tbsqbox2_table,
+};
+
+static int __init tbsqbox2_module_init(void)
+{
+	int ret =  usb_register(&tbsqbox2_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbsqbox2_module_exit(void)
+{
+	usb_deregister(&tbsqbox2_driver);
+}
+
+module_init(tbsqbox2_module_init);
+module_exit(tbsqbox2_module_exit);
+
+MODULE_AUTHOR("Bob Liu <Bob@turbosight.com>");
+MODULE_DESCRIPTION("Driver for TBS QBOX2 STV0903");
+MODULE_VERSION("0.3");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.c	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,818 @@
+/*
+ * TurboSight (TBS) Qbox DVB-S2 CI driver
+ *
+ * Copyright (c) 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/version.h>
+#include "tbs-qbox2ci.h"
+#include "stv6110x.h"
+#include "stv090x.h"
+#include "stb6100.h"
+#include "stb6100_cfg.h"
+
+#include "dvb_ca_en50221.h"
+
+#ifndef USB_PID_TBSQBOX
+#define USB_PID_TBSQBOX 0x5980
+#endif
+
+#define TBSQBOX_READ_MSG 0
+#define TBSQBOX_WRITE_MSG 1
+
+/* on my own*/
+#define TBSQBOX_VOLTAGE_CTRL (0x1800)
+#define TBSQBOX_RC_QUERY (0x1a00)
+
+struct tbsqbox2ci_state {
+	struct dvb_ca_en50221 ca;
+	struct mutex ca_mutex;
+
+	u32 last_key_pressed;
+};
+
+/*struct tbsqbox2ci_rc_keys {
+	u32 keycode;
+	u32 event;
+};*/
+
+/* debug */
+static int dvb_usb_tbsqbox2ci_debug;
+module_param_named(debug, dvb_usb_tbsqbox2ci_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." 
+							DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbsqbox2ci_op_rw(struct usb_device *dev, u8 request, u16 value,
+				u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBSQBOX_READ_MSG) ?
+			usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBSQBOX_READ_MSG) ? USB_DIR_IN : 
+								USB_DIR_OUT;
+
+	if (flags == TBSQBOX_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | 
+			USB_TYPE_VENDOR, value, index , u8buf, len, 2000);
+
+	if (flags == TBSQBOX_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+static int tbsqbox2ci_read_attribute_mem(struct dvb_ca_en50221 *ca,
+                                                	int slot, int address)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[4], rbuf[3];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 0;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+
+	//msleep(10);
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa4, 0, 0,
+						buf, 4, TBSQBOX_WRITE_MSG);
+
+	//msleep(1);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa5, 0, 0,
+						rbuf, 1, TBSQBOX_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return rbuf[0];
+}
+
+static int tbsqbox2ci_write_attribute_mem(struct dvb_ca_en50221 *ca,
+						int slot, int address, u8 value)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[5];//, rbuf[1];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 0;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+	buf[4] = value;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa2, 0, 0,
+						buf, 5, TBSQBOX_WRITE_MSG);
+
+	//msleep(1);
+
+	//ret = tbsqbox2ci_op_rw(d->udev, 0xa5, 0, 0,
+	//					rbuf, 1, TBSQBOX_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tbsqbox2ci_read_cam_control(struct dvb_ca_en50221 *ca, int slot, 
+								u8 address)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[4], rbuf[1];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 1;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa4, 0, 0,
+						buf, 4, TBSQBOX_WRITE_MSG);
+
+	//msleep(10);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa5, 0, 0,
+						rbuf, 1, TBSQBOX_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return rbuf[0];
+}
+
+static int tbsqbox2ci_write_cam_control(struct dvb_ca_en50221 *ca, int slot, 
+							u8 address, u8 value)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[5];//, rbuf[1];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 1;
+	buf[1] = 1;
+	buf[2] = (address >> 8) & 0x0f;
+	buf[3] = address;
+	buf[4] = value;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa2, 0, 0,
+						buf, 5, TBSQBOX_WRITE_MSG);
+
+	//msleep(1);
+
+	//ret = tbsqbox2ci_op_rw(d->udev, 0xa5, 0, 0,
+	//					rbuf, 1, TBSQBOX_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tbsqbox2ci_set_video_port(struct dvb_ca_en50221 *ca, 
+							int slot, int enable)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[2];
+	int ret;
+
+	if (0 != slot)
+		return -EINVAL;
+
+	buf[0] = 2;
+	buf[1] = enable;
+
+	mutex_lock(&state->ca_mutex);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa6, 0, 0,
+						buf, 2, TBSQBOX_WRITE_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	if (enable != buf[1]) {
+		err("CI not %sabled.", enable ? "en" : "dis");
+		return -EIO;
+	}
+
+	info("CI %sabled.", enable ? "en" : "dis");
+	return 0;
+}
+
+static int tbsqbox2ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
+{
+	return tbsqbox2ci_set_video_port(ca, slot, /* enable */ 0);
+}
+
+static int tbsqbox2ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
+{
+	return tbsqbox2ci_set_video_port(ca, slot, /* enable */ 1);
+}
+
+static int tbsqbox2ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[2];
+	int ret;
+
+	if (0 != slot) {
+		return -EINVAL;
+	}
+
+	buf[0] = 1;
+	buf[1] = 0;
+
+	mutex_lock (&state->ca_mutex);
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa6, 0, 0,
+						buf, 2, TBSQBOX_WRITE_MSG);
+
+	msleep (400);
+
+	buf[1] = 1;
+
+	ret = tbsqbox2ci_op_rw(d->udev, 0xa6, 0, 0,
+						buf, 2, TBSQBOX_WRITE_MSG);
+
+	msleep (900);
+
+	mutex_unlock (&state->ca_mutex);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tbsqbox2ci_poll_slot_status(struct dvb_ca_en50221 *ca,
+							int slot, int open)
+{
+	struct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	u8 buf[3];
+
+	if (0 != slot)
+		return -EINVAL;
+
+	mutex_lock(&state->ca_mutex);
+
+	tbsqbox2ci_op_rw(d->udev, 0xa8, 0, 0,
+					buf, 3, TBSQBOX_READ_MSG);
+
+	mutex_unlock(&state->ca_mutex);
+
+	if ((1 == buf[2]) && (1 == buf[1]) && (0xa9 == buf[0])) {
+				return (DVB_CA_EN50221_POLL_CAM_PRESENT |
+						DVB_CA_EN50221_POLL_CAM_READY);
+	} else {
+		return 0;
+	}
+}
+
+static void tbsqbox2ci_uninit(struct dvb_usb_device *d)
+{
+	struct tbsqbox2ci_state *state;
+
+	if (NULL == d)
+		return;
+
+	state = (struct tbsqbox2ci_state *)d->priv;
+	if (NULL == state)
+		return;
+
+	if (NULL == state->ca.data)
+		return;
+
+	/* Error ignored. */
+	tbsqbox2ci_set_video_port(&state->ca, /* slot */ 0, /* enable */ 0);
+
+	dvb_ca_en50221_release(&state->ca);
+
+	memset(&state->ca, 0, sizeof(state->ca));
+}
+
+static int tbsqbox2ci_init(struct dvb_usb_adapter *a)
+{
+
+	struct dvb_usb_device *d = a->dev;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	int ret;
+
+	state->ca.owner = THIS_MODULE;
+	state->ca.read_attribute_mem = tbsqbox2ci_read_attribute_mem;
+	state->ca.write_attribute_mem = tbsqbox2ci_write_attribute_mem;
+	state->ca.read_cam_control = tbsqbox2ci_read_cam_control;
+	state->ca.write_cam_control = tbsqbox2ci_write_cam_control;
+	state->ca.slot_reset = tbsqbox2ci_slot_reset;
+	state->ca.slot_shutdown = tbsqbox2ci_slot_shutdown;
+	state->ca.slot_ts_enable = tbsqbox2ci_slot_ts_enable;
+	state->ca.poll_slot_status = tbsqbox2ci_poll_slot_status;
+	state->ca.data = d;
+
+	ret = dvb_ca_en50221_init (&a->dvb_adap, &state->ca,
+						/* flags */ 0, /* n_slots */ 1);
+
+	if (0 != ret) {
+		err ("Cannot initialize CI: Error %d.", ret);
+		memset (&state->ca, 0, sizeof (state->ca));
+		return ret;
+	}
+
+	info ("CI initialized.");
+
+	ret = tbsqbox2ci_poll_slot_status(&state->ca, 0, 0);
+	if (0 == ret)
+		tbsqbox2ci_set_video_port(&state->ca, /* slot */ 0, /* enable */ 0);
+
+	return 0;
+}
+
+/* I2C */
+static int tbsqbox2ci_i2c_transfer(struct i2c_adapter *adap, 
+					struct i2c_msg msg[], int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)d->priv;
+	int i = 0;
+	u8 buf6[20];
+	u8 inbuf[20];
+
+	if (!d)
+		return -ENODEV;
+
+	mutex_lock(&state->ca_mutex);
+
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2:
+		buf6[0]=msg[1].len;//lenth
+		buf6[1]=msg[0].addr<<1;//demod addr
+		//register
+		buf6[2] = msg[0].buf[0];
+		buf6[3] = msg[0].buf[1];
+
+		tbsqbox2ci_op_rw(d->udev, 0x92, 0, 0,
+					buf6, 4, TBSQBOX_WRITE_MSG);
+		//msleep(5);
+		tbsqbox2ci_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, 1, TBSQBOX_READ_MSG);
+		memcpy(msg[1].buf, inbuf, msg[1].len);
+		break;
+	case 1:
+		switch (msg[0].addr) {
+		case 0x6a:
+		case 0x61:
+		case 0x60:
+			if (msg[0].flags == 0) {
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//addr
+				for(i=0;i<msg[0].len;i++) {
+					buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbsqbox2ci_op_rw(d->udev, 0x80, 0, 0,
+					buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			} else {
+				buf6[0] = msg[0].len;//length
+				buf6[1] = msg[0].addr<<1;//addr
+				buf6[2] = 0x00;
+				tbsqbox2ci_op_rw(d->udev, 0x90, 0, 0,
+						buf6, 3, TBSQBOX_WRITE_MSG);
+				//msleep(5);
+				tbsqbox2ci_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, buf6[0], TBSQBOX_READ_MSG);
+				memcpy(msg[0].buf, inbuf, msg[0].len);
+			}
+			//msleep(3);
+			break;
+		case (TBSQBOX_RC_QUERY):
+			tbsqbox2ci_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBSQBOX_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			//msleep(3);
+			//info("TBSQBOX_RC_QUERY %x %x %x %x\n",
+			//		buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		case (TBSQBOX_VOLTAGE_CTRL):
+			buf6[0] = 3;
+			buf6[1] = msg[0].buf[0];
+			tbsqbox2ci_op_rw(d->udev, 0x8a, 0, 0,
+					buf6, 2, TBSQBOX_WRITE_MSG);
+			
+			break;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	mutex_unlock(&state->ca_mutex);
+	return num;
+}
+
+static u32 tbsqbox2ci_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct stv090x_config earda_config = {
+	.device         = STV0903,
+	.demod_mode     = STV090x_SINGLE,
+	.clk_mode       = STV090x_CLK_EXT,
+
+	.xtal           = 27000000,
+	.address        = 0x6a,
+
+	.ts1_mode       = STV090x_TSMODE_DVBCI,
+	.ts2_mode       = STV090x_TSMODE_SERIAL_CONTINUOUS,
+	
+	.repeater_level         = STV090x_RPTLEVEL_16,
+
+	.tuner_get_frequency    = stb6100_get_frequency,
+	.tuner_set_frequency    = stb6100_set_frequency,
+	.tuner_set_bandwidth    = stb6100_set_bandwidth,
+	.tuner_get_bandwidth    = stb6100_get_bandwidth,
+};
+
+static struct stb6100_config qbox2_stb6100_config = {
+	.tuner_address  = 0x60,
+	.refclock       = 27000000,
+};
+
+static struct i2c_algorithm tbsqbox2ci_i2c_algo = {
+	.master_xfer = tbsqbox2ci_i2c_transfer,
+	.functionality = tbsqbox2ci_i2c_func,
+};
+
+static int tbsqbox2ci_earda_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	dvb_attach(stb6100_attach, adap->fe_adap[0].fe, &qbox2_stb6100_config,
+		&adap->dev->i2c_adap);
+
+	return 0;
+}
+static int tbsqbox2ci_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbsqbox2ci_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBSQBOX_WRITE_MSG);
+		ret = tbsqbox2ci_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed.");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static int tbsqbox2ci_set_voltage(struct dvb_frontend *fe, 
+						fe_sec_voltage_t voltage)
+{
+	static u8 command_13v[1] = {0x00};
+	static u8 command_18v[1] = {0x01};
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_VOLTAGE_CTRL, .flags = 0,
+			.buf = command_13v, .len = 1},
+	};
+	
+	struct dvb_usb_adapter *udev_adap =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	if (voltage == SEC_VOLTAGE_18)
+		msg[0].buf = command_18v;
+	//info("tbsqbox2ci_set_voltage %d",voltage);
+	i2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);
+	return 0;
+}
+
+static struct dvb_usb_device_properties tbsqbox2ci_properties;
+
+static int tbsqbox2ci_frontend_attach(struct dvb_usb_adapter *d)
+{
+	struct dvb_usb_device *u = d->dev;
+	struct tbsqbox2ci_state *state = (struct tbsqbox2ci_state *)u->priv;
+	u8 buf[20];
+
+	mutex_init(&state->ca_mutex);
+
+	if (tbsqbox2ci_properties.adapter[0].fe[0].tuner_attach == \
+				&tbsqbox2ci_earda_tuner_attach) {
+		d->fe_adap[0].fe = dvb_attach(stv090x_attach, &earda_config,
+				&d->dev->i2c_adap, STV090x_DEMODULATOR_0);
+		if (d->fe_adap[0].fe != NULL) {
+			d->fe_adap[0].fe->ops.set_voltage = tbsqbox2ci_set_voltage;
+			info("Attached stv0903!\n");
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbsqbox2ci_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			buf[0] = 1;
+			buf[1] = 1;
+			tbsqbox2ci_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+			
+			buf[0] = 6;
+			buf[1] = 1;
+			tbsqbox2ci_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			tbsqbox2ci_init(d);
+			return 0;
+		}
+	}
+
+	return -EIO;
+}
+
+static void tbsqbox2ci2_usb_disconnect (struct usb_interface * intf)
+{
+	struct dvb_usb_device *d = usb_get_intfdata (intf);
+	
+	tbsqbox2ci_uninit (d);
+	dvb_usb_device_exit (intf);
+}
+
+static struct rc_map_table tbsqbox2ci_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },
+	{ 0xff94, KEY_MUTE },
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },
+	{ 0xff91, KEY_CHANNELDOWN },
+	{ 0xff93, KEY_VOLUMEUP },
+	{ 0xff8c, KEY_VOLUMEDOWN },
+	{ 0xff83, KEY_RECORD },
+	{ 0xff98, KEY_PAUSE  },
+	{ 0xff99, KEY_OK },
+	{ 0xff9a, KEY_SHUFFLE },
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9b, KEY_MODE }
+};
+
+static int tbsqbox2ci_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+
+	struct tbsqbox2ci_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbsqbox2ci_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbsqbox2ci_table[] = {
+	{USB_DEVICE(0x734c, 0x5980)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbsqbox2ci_table);
+
+static int tbsqbox2ci_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id5980.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x5980:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBSQBOX2CI firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbsqbox2ci_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+	tbsqbox2ci_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbsqbox2ci_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBSQBOX_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbsqbox2ci_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbsqbox2ci_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbsqbox2ci_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5980.fw",
+	.size_of_priv = sizeof(struct tbsqbox2ci_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbsqbox2ci_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbsqbox2ci_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbsqbox2ci_rc_keys),
+		.rc_interval = 450,
+		.rc_query = tbsqbox2ci_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbsqbox2ci_load_firmware,
+	.read_mac_address = tbsqbox2ci_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbsqbox2ci_frontend_attach,
+				.streaming_ctrl = NULL,
+				.tuner_attach = tbsqbox2ci_earda_tuner_attach,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS Qbox DVB-S2 CI USB2.0",
+			{&tbsqbox2ci_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbsqbox2ci_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbsqbox2ci_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbsqbox2ci_driver = {
+	.name = "tbsqbox2ci",
+	.probe = tbsqbox2ci_probe,
+	.disconnect = tbsqbox2ci2_usb_disconnect,
+	.id_table = tbsqbox2ci_table,
+};
+
+static int __init tbsqbox2ci_module_init(void)
+{
+	int ret =  usb_register(&tbsqbox2ci_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbsqbox2ci_module_exit(void)
+{
+	usb_deregister(&tbsqbox2ci_driver);
+}
+
+module_init(tbsqbox2ci_module_init);
+module_exit(tbsqbox2ci_module_exit);
+
+MODULE_AUTHOR("Konstantin Dimitrov <kosio.dimitrov@gmail.com>");
+MODULE_DESCRIPTION("TurboSight (TBS) Qbox DVB-S2 CI driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2ci.h	2012-04-16 23:21:58.135661111 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBSQBOX2CI_H_
+#define _TBSQBOX2CI_H_
+
+#define DVB_USB_LOG_PREFIX "tbsqbox2ci"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbsqbox2ci_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox2.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox2.h	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBSQBOX2_H_
+#define _TBSQBOX2_H_
+
+#define DVB_USB_LOG_PREFIX "tbsqbox2"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbsqbox2_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox.c	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,487 @@
+/* DVB USB framework compliant Linux driver for the
+*	TBS QBOX
+*
+* Copyright (C) 2008 Bob Liu (Bob@Turbosight.com)
+* Igor M. Liplianin (liplianin@me.by)
+*
+* Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+* 	June 2009
+* 	Some fixes and improvements.
+*
+*	This program is free software; you can redistribute it and/or modify it
+*	under the terms of the GNU General Public License as published by the
+*	Free Software Foundation, version 2.
+*
+* see Documentation/dvb/README.dvb-usb for more information
+*/
+#include <linux/version.h>
+#include "tbs-qbox.h"
+#include "stv0299.h"
+#include "stv0288.h"
+#include "stb6000.h"
+
+
+#ifndef USB_PID_TBSQBOX
+#define USB_PID_TBSQBOX 0x2601
+#endif
+
+#ifndef USB_PID_TBSQBOX_1
+#define USB_PID_TBSQBOX_1 0x5910
+#endif
+
+#define TBSQBOX_READ_MSG 0
+#define TBSQBOX_WRITE_MSG 1
+
+/* on my own*/
+#define TBSQBOX_VOLTAGE_CTRL (0x1800)
+#define TBSQBOX_RC_QUERY (0x1a00)
+
+struct tbsqboxs1_state {
+	u32 last_key_pressed;
+};
+struct tbsqboxs1_rc_keys {
+	u32 keycode;
+	u32 event;
+};
+
+/* debug */
+static int dvb_usb_tbsqboxs1_debug;
+module_param_named(debug, dvb_usb_tbsqboxs1_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbsqboxs1_op_rw(struct usb_device *dev, u8 request, u16 value,
+			u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBSQBOX_READ_MSG) ?
+				usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBSQBOX_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+
+	if (flags == TBSQBOX_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index , u8buf, len, 2000);
+
+	if (flags == TBSQBOX_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+/* I2C */
+static int tbsqboxs1_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+		int num)
+{
+struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0;
+	u8 buf6[20];
+	u8 inbuf[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2:
+		
+		buf6[0]=msg[1].len;//lenth
+		buf6[1]=msg[0].addr<<1;//demod addr
+		buf6[2]=msg[0].buf[0];//register
+		
+		tbsqboxs1_op_rw(d->udev, 0x90, 0, 0,
+					buf6, 3, TBSQBOX_WRITE_MSG);
+		msleep(5);
+		tbsqboxs1_op_rw(d->udev, 0x91, 0, 0,
+					inbuf, 1, TBSQBOX_READ_MSG);
+		memcpy(msg[1].buf, inbuf, msg[1].len);
+		break;
+	case 1:
+		switch (msg[0].addr) {
+		case 0x68:
+			/* write to stv0299 register */
+			buf6[0] = msg[0].len+1;//lenth
+			buf6[1] = msg[0].addr<<1;//demod addr
+			for(i=0;i<msg[0].len;i++)
+				{
+				buf6[2+i] = msg[0].buf[i];//register
+				}
+			tbsqboxs1_op_rw(d->udev, 0x80, 0, 0,
+					buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			msleep(3);
+			break;
+		case 0x61:
+		case 0x60:
+			if (msg[0].flags == 0) {
+			/* write to tuner pll */
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//tuner addr
+				for(i=0;i<msg[0].len;i++)
+				{
+				buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbsqboxs1_op_rw(d->udev, 0x80, 0, 0,
+						buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			} 
+			msleep(3);
+			break;
+		case (TBSQBOX_RC_QUERY):
+			tbsqboxs1_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBSQBOX_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			msleep(3);
+			//info("TBSQBOX_RC_QUERY %x %x %x %x\n",buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		case (TBSQBOX_VOLTAGE_CTRL):
+			buf6[0] = 3;
+			buf6[1] = msg[0].buf[0];
+			tbsqboxs1_op_rw(d->udev, 0x8a, 0, 0,
+					buf6, 2, TBSQBOX_WRITE_MSG);
+			
+			break;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbsqboxs1_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct stv0288_config earda_config = {
+	.demod_address = 0x68,
+};
+
+static struct i2c_algorithm tbsqboxs1_i2c_algo = {
+	.master_xfer = tbsqboxs1_i2c_transfer,
+	.functionality = tbsqboxs1_i2c_func,
+};
+
+static int tbsqboxs1_earda_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	dvb_attach(stb6000_attach, adap->fe_adap[0].fe, 0x61,
+		&adap->dev->i2c_adap);
+
+	return 0;
+}
+static int tbsqboxs1_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbsqboxs1_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBSQBOX_WRITE_MSG);
+		ret = tbsqboxs1_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed.");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static int tbsqboxs1_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	static u8 command_13v[1] = {0x00};
+	static u8 command_18v[1] = {0x01};
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_VOLTAGE_CTRL, .flags = 0,
+			.buf = command_13v, .len = 1},
+	};
+	
+	struct dvb_usb_adapter *udev_adap =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	if (voltage == SEC_VOLTAGE_18)
+		msg[0].buf = command_18v;
+	//info("tbsqboxs1_set_voltage %d",voltage);
+	i2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);
+	return 0;
+}
+
+static struct dvb_usb_device_properties tbsqboxs1_properties;
+
+static int tbsqboxs1_frontend_attach(struct dvb_usb_adapter *d)
+{
+	u8 buf[20];
+
+	if (tbsqboxs1_properties.adapter[0].fe[0].tuner_attach == &tbsqboxs1_earda_tuner_attach) {
+		d->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,
+					&d->dev->i2c_adap);
+		if (d->fe_adap[0].fe != NULL) {
+			d->fe_adap[0].fe->ops.set_voltage = tbsqboxs1_set_voltage;
+			info("Attached stv0288!\n");
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbsqboxs1_op_rw(d->dev->udev, 0x8a, 0, 0,
+					 buf, 2, TBSQBOX_WRITE_MSG);
+
+			return 0;
+		}
+	}
+
+	return -EIO;
+}
+
+
+
+static struct rc_map_table tbsqboxs1_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },		/*power*/
+	{ 0xff94, KEY_MUTE },		/*mute*/
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },	/*ch+*/
+	{ 0xff91, KEY_CHANNELDOWN },	/*ch-*/
+	{ 0xff93, KEY_VOLUMEUP },		/*vol+*/
+	{ 0xff8c, KEY_VOLUMEDOWN },		/*vol-*/
+	{ 0xff83, KEY_RECORD },		/*rec*/
+	{ 0xff98, KEY_PAUSE  },		/*pause*/
+	{ 0xff99, KEY_OK },	/*ok*/
+	{ 0xff9a, KEY_SHUFFLE },		  /* snapshot */
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9b, KEY_MODE }
+
+
+};
+
+
+
+static int tbsqboxs1_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+	
+	struct tbsqboxs1_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbsqboxs1_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbsqboxs1_table[] = {
+	{USB_DEVICE(0x734c, 0x2601)},
+	{USB_DEVICE(0x734c, 0x5910)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX_1)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbsqboxs1_table);
+
+static int tbsqboxs1_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id2601.fw";
+	const char *filename1 = "dvb-usb-tbsqbox-id5910.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x2601:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	case 0x5910:
+		ret = request_firmware(&fw, filename1, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename1);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBSQBOX firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbsqboxs1_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+	tbsqboxs1_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbsqboxs1_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBSQBOX_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbsqboxs1_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbsqboxs1_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbsqboxs1_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5910.fw",
+	.size_of_priv = sizeof(struct tbsqboxs1_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbsqboxs1_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbsqboxs1_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbsqboxs1_rc_keys),
+		.rc_interval = 150,
+		.rc_query = tbsqboxs1_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbsqboxs1_load_firmware,
+	.read_mac_address = tbsqboxs1_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbsqboxs1_frontend_attach,
+				.streaming_ctrl = NULL,
+				.tuner_attach = tbsqboxs1_earda_tuner_attach,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS QBOX DVBS USB2.0",
+			{&tbsqboxs1_table[1], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbsqboxs1_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbsqboxs1_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbsqboxs1_driver = {
+	.name = "tbsqboxs1",
+	.probe = tbsqboxs1_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table = tbsqboxs1_table,
+};
+
+static int __init tbsqboxs1_module_init(void)
+{
+	int ret =  usb_register(&tbsqboxs1_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbsqboxs1_module_exit(void)
+{
+	usb_deregister(&tbsqboxs1_driver);
+}
+
+module_init(tbsqboxs1_module_init);
+module_exit(tbsqboxs1_module_exit);
+
+MODULE_AUTHOR("Bob Liu <Bob@turbosight.com>");
+MODULE_DESCRIPTION("Driver for TBS QBOX");
+MODULE_VERSION("0.1");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qbox.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qbox.h	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBSQBOX_H_
+#define _TBSQBOX_H_
+
+#define DVB_USB_LOG_PREFIX "tbsqboxs1"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbsqboxs1_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.c	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,485 @@
+/* DVB USB framework compliant Linux driver for the
+*	TBS QBOX
+*
+* Copyright (C) 2008 Bob Liu (Bob@Turbosight.com)
+* Igor M. Liplianin (liplianin@me.by)
+*
+*	This program is free software; you can redistribute it and/or modify it
+*	under the terms of the GNU General Public License as published by the
+*	Free Software Foundation, version 2.
+*
+* see Documentation/dvb/README.dvb-usb for more information
+*/
+
+/* 
+* History:
+*
+* July 2009 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+* remove QBOX2-DS3000 support
+* add QBOXS2-CX24116 support
+*/
+
+#include <linux/version.h>
+#include "tbs-qboxs2.h"
+#include "cx24116.h"
+
+
+#ifndef USB_PID_TBSQBOX_1
+#define USB_PID_TBSQBOX_1 0x5928
+#endif
+
+#define TBSQBOX_READ_MSG 0
+#define TBSQBOX_WRITE_MSG 1
+
+/* on my own*/
+#define TBSQBOX_VOLTAGE_CTRL (0x1800)
+#define TBSQBOX_RC_QUERY (0x1a00)
+
+struct tbsqboxs2_state {
+	u32 last_key_pressed;
+};
+struct tbsqboxs2_rc_keys {
+	u32 keycode;
+	u32 event;
+};
+
+/* debug */
+static int dvb_usb_tbsqboxs2_debug;
+module_param_named(debug, dvb_usb_tbsqboxs2_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbsqboxs2_op_rw(struct usb_device *dev, u8 request, u16 value,
+			u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBSQBOX_READ_MSG) ?
+				usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBSQBOX_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+
+	if (flags == TBSQBOX_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index, u8buf, len, 2000);
+
+	if (flags == TBSQBOX_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+/* I2C */
+static int tbsqboxs2_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+		int num)
+{
+struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0, len;
+	u8 ibuf[1], obuf[3];
+	u8 buf6[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2: {
+		/* read */
+		obuf[0] = msg[0].len;
+		obuf[1] = msg[0].addr<<1;
+		obuf[2] = msg[0].buf[0];
+
+		tbsqboxs2_op_rw(d->udev, 0x90, 0, 0,
+					obuf, 3, TBSQBOX_WRITE_MSG);
+		msleep(5);
+		tbsqboxs2_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+		memcpy(msg[1].buf, ibuf, msg[1].len);
+		break;
+	}
+	case 1:
+		switch (msg[0].addr) {
+		case 0x55: {
+			if (msg[0].buf[0] == 0xf7) {
+				/* firmware */
+				/* Write in small blocks */
+				u8 iobuf[19];
+				iobuf[0] = 0x12;
+				iobuf[1] = 0xaa;
+				iobuf[2] = 0xf7;
+				len = msg[0].len - 1;
+				i = 1;
+				do {
+					memcpy(iobuf + 3, msg[0].buf + i, (len > 16 ? 16 : len));
+					tbsqboxs2_op_rw(d->udev, 0x80, 0, 0,
+						iobuf, (len > 16 ? 16 : len) + 3, TBSQBOX_WRITE_MSG);
+					i += 16;
+					len -= 16;
+				} while (len > 0);
+			} else {
+				/* write to register */
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//demod addr
+				for(i=0;i<msg[0].len;i++) {
+				buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbsqboxs2_op_rw(d->udev, 0x80, 0, 0,
+							buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+				//msleep(3);
+			}
+			break;
+		}
+		case 0x60: {
+			/* write to register */
+			buf6[0] = msg[0].len+1;//lenth
+			buf6[1] = msg[0].addr<<1;//demod addr
+			for(i=0;i<msg[0].len;i++) {
+				buf6[2+i] = msg[0].buf[i];//register
+			}
+			tbsqboxs2_op_rw(d->udev, 0x80, 0, 0,
+						buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			msleep(3);
+
+			break;
+		}
+		case (TBSQBOX_RC_QUERY): {
+			tbsqboxs2_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBSQBOX_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			msleep(3);
+			//info("TBSQBOX_RC_QUERY %x %x %x %x\n",buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		}
+		case (TBSQBOX_VOLTAGE_CTRL): {
+			buf6[0] = 3;
+			buf6[1] = msg[0].buf[0];
+			tbsqboxs2_op_rw(d->udev, 0x8a, 0, 0,
+					buf6, 2, TBSQBOX_WRITE_MSG);
+			
+			break;
+		}
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbsqboxs2_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+
+
+static struct i2c_algorithm tbsqboxs2_i2c_algo = {
+	.master_xfer = tbsqboxs2_i2c_transfer,
+	.functionality = tbsqboxs2_i2c_func,
+};
+
+static const struct cx24116_config qbox2_cx24116_config = {
+	.demod_address = 0x55,
+	.mpg_clk_pos_pol = 0x01,
+};
+
+static int tbsqboxs2_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbsqboxs2_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBSQBOX_WRITE_MSG);
+		ret = tbsqboxs2_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static int tbsqboxs2_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	static u8 command_13v[1] = {0x00};
+	static u8 command_18v[1] = {0x01};
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_VOLTAGE_CTRL, .flags = 0,
+			.buf = command_13v, .len = 1},
+	};
+	
+	struct dvb_usb_adapter *udev_adap =
+		(struct dvb_usb_adapter *)(fe->dvb->priv);
+	if (voltage == SEC_VOLTAGE_18)
+		msg[0].buf = command_18v;
+	info("tbsqboxs2_set_voltage %d",voltage);
+	i2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);
+	return 0;
+}
+
+static struct dvb_usb_device_properties tbsqboxs2_properties;
+
+static int tbsqboxs2_frontend_attach(struct dvb_usb_adapter *d)
+{
+	u8 buf[20];
+	
+	if ((d->fe_adap[0].fe = dvb_attach(cx24116_attach, &qbox2_cx24116_config,
+					&d->dev->i2c_adap)) != NULL) {
+			d->fe_adap[0].fe->ops.set_voltage = tbsqboxs2_set_voltage;
+			printk("QBOXS2: CX24116 attached.\n");
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbsqboxs2_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			return 0;
+	}
+
+	return -EIO;
+}
+
+
+
+static struct rc_map_table tbsqboxs2_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },		/*power*/
+	{ 0xff94, KEY_MUTE },		/*mute*/
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },	/*ch+*/
+	{ 0xff91, KEY_CHANNELDOWN },	/*ch-*/
+	{ 0xff93, KEY_VOLUMEUP },		/*vol+*/
+	{ 0xff8c, KEY_VOLUMEDOWN },		/*vol-*/
+	{ 0xff83, KEY_RECORD },		/*rec*/
+	{ 0xff98, KEY_PAUSE  },		/*pause*/
+	{ 0xff99, KEY_OK },	/*ok*/
+	{ 0xff9a, KEY_SHUFFLE },		  /* snapshot */
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9d, KEY_MODE }
+
+
+};
+
+
+
+static int tbsqboxs2_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+	
+	struct tbsqboxs2_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbsqboxs2_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbsqboxs2_table[] = {
+	{USB_DEVICE(0x734c, 0x5928)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX_1)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbsqboxs2_table);
+
+static int tbsqboxs2_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id5928.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x5928:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBSQBOX firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbsqboxs2_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+	tbsqboxs2_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbsqboxs2_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBSQBOX_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbsqboxs2_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbsqboxs2_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbsqboxs2_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5928.fw",
+	.size_of_priv = sizeof(struct tbsqboxs2_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbsqboxs2_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbsqboxs2_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbsqboxs2_rc_keys),
+		.rc_interval = 150,
+		.rc_query = tbsqboxs2_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbsqboxs2_load_firmware,
+	.read_mac_address = tbsqboxs2_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbsqboxs2_frontend_attach,
+				.streaming_ctrl = NULL,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS QBOXS2 DVBS2 USB2.0",
+			{&tbsqboxs2_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbsqboxs2_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbsqboxs2_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbsqboxs2_driver = {
+	.name = "tbsqboxs2",
+	.probe = tbsqboxs2_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table = tbsqboxs2_table,
+};
+
+static int __init tbsqboxs2_module_init(void)
+{
+	int ret =  usb_register(&tbsqboxs2_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbsqboxs2_module_exit(void)
+{
+	usb_deregister(&tbsqboxs2_driver);
+}
+
+module_init(tbsqboxs2_module_init);
+module_exit(tbsqboxs2_module_exit);
+
+MODULE_AUTHOR("Bob Liu <Bob@turbosight.com>");
+MODULE_DESCRIPTION("Driver for TBS QBOXS2-CX24116");
+MODULE_VERSION("0.2");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs2.h	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBSQBOXS2_H_
+#define _TBSQBOXS2_H_
+
+#define DVB_USB_LOG_PREFIX "tbsqboxs2"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbsqboxs2_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.c media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.c
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.c	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,469 @@
+/* DVB USB framework compliant Linux driver for the
+*	TBS QBOX
+*
+* Copyright (C) 2008 Bob Liu (Bob@Turbosight.com)
+* Igor M. Liplianin (liplianin@me.by)
+*
+*	This program is free software; you can redistribute it and/or modify it
+*	under the terms of the GNU General Public License as published by the
+*	Free Software Foundation, version 2.
+*
+* see Documentation/dvb/README.dvb-usb for more information
+*/
+
+/* 
+* History:
+*
+* December 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+* remove QBOX2-CX24116 support
+* add QBOXS3 support
+*/
+
+#include <linux/version.h>
+#include "tbs-qboxs3.h"
+#include "tbs5921fe.h"
+#include "tbs5921ctrl.h"
+#include "tbsfe.h"
+
+#ifndef USB_PID_TBSQBOX_1
+#define USB_PID_TBSQBOX_1 0x5921
+#endif
+
+#define TBSQBOX_READ_MSG 0
+#define TBSQBOX_WRITE_MSG 1
+
+/* on my own*/
+#define TBSQBOX_VOLTAGE_CTRL (0x1800)
+#define TBSQBOX_RC_QUERY (0x1a00)
+
+struct tbsqboxs3_state {
+	u32 last_key_pressed;
+};
+struct tbsqboxs3_rc_keys {
+	u32 keycode;
+	u32 event;
+};
+
+/* debug */
+static int dvb_usb_tbsqboxs3_debug;
+module_param_named(debug, dvb_usb_tbsqboxs3_debug, int, 0644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info 2=xfer (or-able))." DVB_USB_DEBUG_STATUS);
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static int tbsqboxs3_op_rw(struct usb_device *dev, u8 request, u16 value,
+			u16 index, u8 * data, u16 len, int flags)
+{
+	int ret;
+	u8 u8buf[len];
+
+	unsigned int pipe = (flags == TBSQBOX_READ_MSG) ?
+				usb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);
+	u8 request_type = (flags == TBSQBOX_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;
+
+	if (flags == TBSQBOX_WRITE_MSG)
+		memcpy(u8buf, data, len);
+	ret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,
+				value, index, u8buf, len, 2000);
+
+	if (flags == TBSQBOX_READ_MSG)
+		memcpy(data, u8buf, len);
+	return ret;
+}
+
+/* I2C */
+static int tbsqboxs3_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+		int num)
+{
+struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int i = 0, len;
+	u8 ibuf[1], obuf[3];
+	u8 buf6[20];
+
+	if (!d)
+		return -ENODEV;
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	switch (num) {
+	case 2: {
+		/* read */
+		obuf[0] = msg[0].len;
+		obuf[1] = msg[0].addr<<1;
+		obuf[2] = msg[0].buf[0];
+
+		tbsqboxs3_op_rw(d->udev, 0x90, 0, 0,
+					obuf, 3, TBSQBOX_WRITE_MSG);
+		msleep(5);
+		tbsqboxs3_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+		memcpy(msg[1].buf, ibuf, msg[1].len);
+		break;
+	}
+	case 1:
+		switch (msg[0].addr) {
+		case 0x55: {
+			if (msg[0].buf[0] == 0xfa) {
+				/* firmware */
+				/* Write in small blocks */
+				u8 iobuf[19];
+				iobuf[0] = 0x12;
+				iobuf[1] = 0xaa;
+				iobuf[2] = 0xfa;
+				len = msg[0].len - 1;
+				i = 1;
+				do {
+					memcpy(iobuf + 3, msg[0].buf + i, (len > 16 ? 16 : len));
+					tbsqboxs3_op_rw(d->udev, 0x80, 0, 0,
+						iobuf, (len > 16 ? 16 : len) + 3, TBSQBOX_WRITE_MSG);
+					i += 16;
+					len -= 16;
+				} while (len > 0);
+			} else {
+				/* write to register */
+				buf6[0] = msg[0].len+1;//lenth
+				buf6[1] = msg[0].addr<<1;//demod addr
+				for(i=0;i<msg[0].len;i++) {
+				buf6[2+i] = msg[0].buf[i];//register
+				}
+				tbsqboxs3_op_rw(d->udev, 0x80, 0, 0,
+							buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+				//msleep(3);
+			}
+			break;
+		}
+		case 0x60: {
+			/* write to register */
+			buf6[0] = msg[0].len+1;//lenth
+			buf6[1] = msg[0].addr<<1;//demod addr
+			for(i=0;i<msg[0].len;i++) {
+				buf6[2+i] = msg[0].buf[i];//register
+			}
+			tbsqboxs3_op_rw(d->udev, 0x80, 0, 0,
+						buf6, msg[0].len+2, TBSQBOX_WRITE_MSG);
+			msleep(3);
+
+			break;
+		}
+		case (TBSQBOX_RC_QUERY): {
+			tbsqboxs3_op_rw(d->udev, 0xb8, 0, 0,
+					buf6, 4, TBSQBOX_READ_MSG);
+			msg[0].buf[0] = buf6[2];
+			msg[0].buf[1] = buf6[3];
+			msleep(3);
+			//info("TBSQBOX_RC_QUERY %x %x %x %x\n",buf6[0],buf6[1],buf6[2],buf6[3]);
+			break;
+		}
+		case (TBSQBOX_VOLTAGE_CTRL): {
+			break;
+		}
+		}
+
+		break;
+	}
+
+	mutex_unlock(&d->i2c_mutex);
+	return num;
+}
+
+static u32 tbsqboxs3_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+
+
+static struct i2c_algorithm tbsqboxs3_i2c_algo = {
+	.master_xfer = tbsqboxs3_i2c_transfer,
+	.functionality = tbsqboxs3_i2c_func,
+};
+
+static struct tbs5921fe_config tbs5921_fe_config = {
+        .tbs5921fe_address = 0x55,
+
+	.tbs5921_ctrl = tbs5921ctrl,
+};
+
+static int tbsqboxs3_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
+{
+	int i,ret;
+	u8 ibuf[3] = {0, 0,0};
+	u8 eeprom[256], eepromline[16];
+
+	for (i = 0; i < 256; i++) {
+		ibuf[0]=1;//lenth
+		ibuf[1]=0xa0;//eeprom addr
+		ibuf[2]=i;//register
+		ret = tbsqboxs3_op_rw(d->udev, 0x90, 0, 0,
+					ibuf, 3, TBSQBOX_WRITE_MSG);
+		ret = tbsqboxs3_op_rw(d->udev, 0x91, 0, 0,
+					ibuf, 1, TBSQBOX_READ_MSG);
+			if (ret < 0) {
+				err("read eeprom failed");
+				return -1;
+			} else {
+				eepromline[i%16] = ibuf[0];
+				eeprom[i] = ibuf[0];
+			}
+			
+			if ((i % 16) == 15) {
+				deb_xfer("%02x: ", i - 15);
+				debug_dump(eepromline, 16, deb_xfer);
+			}
+	}
+	memcpy(mac, eeprom + 16, 6);
+	return 0;
+};
+
+static struct dvb_usb_device_properties tbsqboxs3_properties;
+
+static int tbsqboxs3_frontend_attach(struct dvb_usb_adapter *d)
+{
+	u8 buf[20];
+	
+        if ((d->fe_adap[0].fe = dvb_attach(tbs5921fe_attach, &tbs5921_fe_config,
+                                        &d->dev->i2c_adap, 0)) != NULL) {
+			printk("QBOXS3: TBS5921FE attached.\n");
+			dvb_attach(tbsfe_attach, d->fe_adap[0].fe);
+
+			buf[0] = 7;
+			buf[1] = 1;
+			tbsqboxs3_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			buf[0] = 1;
+			buf[1] = 1;
+			tbsqboxs3_op_rw(d->dev->udev, 0x8a, 0, 0,
+					buf, 2, TBSQBOX_WRITE_MSG);
+
+			return 0;
+	}
+
+	return -EIO;
+}
+
+
+
+static struct rc_map_table tbsqboxs3_rc_keys[] = {
+	{ 0xff84, KEY_POWER2 },		/*power*/
+	{ 0xff94, KEY_MUTE },		/*mute*/
+	{ 0xff87, KEY_1 },
+	{ 0xff86, KEY_2 },
+	{ 0xff85, KEY_3 },
+	{ 0xff8b, KEY_4 },
+	{ 0xff8a, KEY_5 },
+	{ 0xff89, KEY_6 },
+	{ 0xff8f, KEY_7 },
+	{ 0xff8e, KEY_8 },
+	{ 0xff8d, KEY_9 },
+	{ 0xff92, KEY_0 },
+	{ 0xff96, KEY_CHANNELUP },	/*ch+*/
+	{ 0xff91, KEY_CHANNELDOWN },	/*ch-*/
+	{ 0xff93, KEY_VOLUMEUP },		/*vol+*/
+	{ 0xff8c, KEY_VOLUMEDOWN },		/*vol-*/
+	{ 0xff83, KEY_RECORD },		/*rec*/
+	{ 0xff98, KEY_PAUSE  },		/*pause*/
+	{ 0xff99, KEY_OK },	/*ok*/
+	{ 0xff9a, KEY_SHUFFLE },		  /* snapshot */
+	{ 0xff81, KEY_UP },
+	{ 0xff90, KEY_LEFT },
+	{ 0xff82, KEY_RIGHT },
+	{ 0xff88, KEY_DOWN },
+	{ 0xff95, KEY_FAVORITES },
+	{ 0xff97, KEY_SUBTITLE },
+	{ 0xff9d, KEY_ZOOM },
+	{ 0xff9f, KEY_EXIT },
+	{ 0xff9e, KEY_MENU },
+	{ 0xff9c, KEY_EPG },
+	{ 0xff80, KEY_PREVIOUS },
+	{ 0xff9b, KEY_MODE }
+
+
+};
+
+
+
+static int tbsqboxs3_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;
+	int keymap_size = d->props.rc.legacy.rc_map_size;
+	
+	struct tbsqboxs3_state *st = d->priv;
+	u8 key[2];
+	struct i2c_msg msg[] = {
+		{.addr = TBSQBOX_RC_QUERY, .flags = I2C_M_RD, .buf = key,
+		.len = 2},
+	};
+	int i;
+
+	*state = REMOTE_NO_KEY_PRESSED;
+	if (tbsqboxs3_i2c_transfer(&d->i2c_adap, msg, 1) == 1) {
+		//info("key: %x %x\n",msg[0].buf[0],msg[0].buf[1]); 
+		for (i = 0; i < keymap_size; i++) {
+			if (rc5_data(&keymap[i]) == msg[0].buf[1]) {
+				*state = REMOTE_KEY_PRESSED;
+				*event = keymap[i].keycode;
+				st->last_key_pressed =
+					keymap[i].keycode;
+				break;
+			}
+		st->last_key_pressed = 0;
+		}
+	}
+	 
+	return 0;
+}
+
+static struct usb_device_id tbsqboxs3_table[] = {
+	{USB_DEVICE(0x734c, 0x5921)},
+	{USB_DEVICE(USB_VID_CYPRESS, USB_PID_TBSQBOX_1)},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(usb, tbsqboxs3_table);
+
+static int tbsqboxs3_load_firmware(struct usb_device *dev,
+			const struct firmware *frmwr)
+{
+	u8 *b, *p;
+	int ret = 0, i;
+	u8 reset;
+	const struct firmware *fw;
+	const char *filename = "dvb-usb-tbsqbox-id5921.fw";
+	switch (dev->descriptor.idProduct) {
+	case 0x5921:
+		ret = request_firmware(&fw, filename, &dev->dev);
+		if (ret != 0) {
+			err("did not find the firmware file. (%s) "
+			"Please see linux/Documentation/dvb/ for more details "
+			"on firmware-problems.", filename);
+			return ret;
+		}
+		break;
+	default:
+		fw = frmwr;
+		break;
+	}
+	info("start downloading TBSQBOX firmware");
+	p = kmalloc(fw->size, GFP_KERNEL);
+	reset = 1;
+	/*stop the CPU*/
+	tbsqboxs3_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+	tbsqboxs3_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, TBSQBOX_WRITE_MSG);
+
+	if (p != NULL) {
+		memcpy(p, fw->data, fw->size);
+		for (i = 0; i < fw->size; i += 0x40) {
+			b = (u8 *) p + i;
+			if (tbsqboxs3_op_rw(dev, 0xa0, i, 0, b , 0x40,
+					TBSQBOX_WRITE_MSG) != 0x40) {
+				err("error while transferring firmware");
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* restart the CPU */
+		reset = 0;
+		if (ret || tbsqboxs3_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+		if (ret || tbsqboxs3_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+					TBSQBOX_WRITE_MSG) != 1) {
+			err("could not restart the USB controller CPU.");
+			ret = -EINVAL;
+		}
+
+		msleep(100);
+		kfree(p);
+	}
+	return ret;
+}
+
+static struct dvb_usb_device_properties tbsqboxs3_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+	.usb_ctrl = DEVICE_SPECIFIC,
+	.firmware = "dvb-usb-tbsqbox-id5921.fw",
+	.size_of_priv = sizeof(struct tbsqboxs3_state),
+	.no_reconnect = 1,
+
+	.i2c_algo = &tbsqboxs3_i2c_algo,
+	.rc.legacy = {
+		.rc_map_table = tbsqboxs3_rc_keys,
+		.rc_map_size = ARRAY_SIZE(tbsqboxs3_rc_keys),
+		.rc_interval = 150,
+		.rc_query = tbsqboxs3_rc_query,
+	},
+
+	.generic_bulk_ctrl_endpoint = 0x81,
+	/* parameter for the MPEG2-data transfer */
+	.num_adapters = 1,
+	.download_firmware = tbsqboxs3_load_firmware,
+	.read_mac_address = tbsqboxs3_read_mac_address,
+		.adapter = {
+		{
+			.num_frontends = 1,
+			.fe = {{
+				.frontend_attach = tbsqboxs3_frontend_attach,
+				.streaming_ctrl = NULL,
+				.stream = {
+					.type = USB_BULK,
+					.count = 8,
+					.endpoint = 0x82,
+					.u = {
+						.bulk = {
+							.buffersize = 4096,
+						}
+					}
+				},
+			}}
+		}
+	},
+	.num_device_descs = 1,
+	.devices = {
+		{"TBS QBOXS3 DVBS2 USB2.0",
+			{&tbsqboxs3_table[0], NULL},
+			{NULL},
+		}
+	}
+};
+
+static int tbsqboxs3_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	if (0 == dvb_usb_device_init(intf, &tbsqboxs3_properties,
+			THIS_MODULE, NULL, adapter_nr)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static struct usb_driver tbsqboxs3_driver = {
+	.name = "tbsqboxs3",
+	.probe = tbsqboxs3_probe,
+	.disconnect = dvb_usb_device_exit,
+	.id_table = tbsqboxs3_table,
+};
+
+static int __init tbsqboxs3_module_init(void)
+{
+	int ret =  usb_register(&tbsqboxs3_driver);
+	if (ret)
+		err("usb_register failed. Error number %d", ret);
+
+	return ret;
+}
+
+static void __exit tbsqboxs3_module_exit(void)
+{
+	usb_deregister(&tbsqboxs3_driver);
+}
+
+module_init(tbsqboxs3_module_init);
+module_exit(tbsqboxs3_module_exit);
+
+MODULE_AUTHOR("Bob Liu <Bob@turbosight.com>");
+MODULE_DESCRIPTION("Driver for TBS QBOXS3");
+MODULE_VERSION("0.2");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.h media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.h
--- media_build_experimental/linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/dvb-usb/tbs-qboxs3.h	2012-04-16 23:21:58.139661110 +0200
@@ -0,0 +1,8 @@
+#ifndef _TBSQBOXS3_H_
+#define _TBSQBOXS3_H_
+
+#define DVB_USB_LOG_PREFIX "tbsqboxs3"
+#include "dvb-usb.h"
+
+#define deb_xfer(args...) dprintk(dvb_usb_tbsqboxs3_debug, 0x02, args)
+#endif
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/Kconfig media_build_experimental_tbs//linux/drivers/media/dvb/frontends/Kconfig
--- media_build_experimental/linux/drivers/media/dvb/frontends/Kconfig	2012-04-16 23:07:58.000000000 +0200
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/Kconfig	2012-04-16 23:21:58.139661110 +0200
@@ -231,6 +231,125 @@
 	default m if DVB_FE_CUSTOMISE
 	help
 	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+	  
+config DVB_TBSFE
+	tristate "TBS FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A TurboSight TBS FE module. Say Y when you want to support this.
+
+config DVB_TBS6980FE
+	tristate "TurboSight TBS6980FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6981FE
+	tristate "TurboSight TBS6981FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6921FE
+	tristate "TurboSight TBS6921FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS8921FE
+	tristate "TurboSight TBS8921FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6925CTRL
+	tristate "TurboSight TBS6925 controls"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A TurboSight TBS6925 controls. Say Y when you want to support this.
+
+config DVB_TBS6992
+	tristate "TBS6992 based tuners"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  TurboSighti TBS6992 Silicon Tuner
+
+config DVB_TBS5921FE
+	tristate "TurboSight TBS5921FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS62X0FE
+	tristate "TurboSight TBS60x0FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T/T2/C tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6984FE
+	tristate "TurboSight TBS6984FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+	  
+config DVB_TBS6922FE
+	tristate "TurboSight TBS6922FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6928FE
+	tristate "TurboSight TBS6928FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS8922FE
+	tristate "TurboSight TBS8922FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS5922FE
+	tristate "TurboSight TBS5922FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS5880FE
+	tristate "TurboSight TBS5880FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T/T2/C tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6982FE
+	tristate "TurboSight TBS6982FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_TBS6991FE
+	tristate "TurboSight TBS6991FE based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
 
 config DVB_SI21XX
 	tristate "Silicon Labs SI21XX based"
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/Kconfig.orig media_build_experimental_tbs//linux/drivers/media/dvb/frontends/Kconfig.orig
--- media_build_experimental/linux/drivers/media/dvb/frontends/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/Kconfig.orig	2012-04-16 23:07:58.927639621 +0200
@@ -0,0 +1,744 @@
+config DVB_FE_CUSTOMISE
+	bool "Customise the frontend modules to build"
+	depends on DVB_CORE
+	default y if EXPERT
+	help
+	  This allows the user to select/deselect frontend drivers for their
+	  hardware from the build.
+
+	  Use this option with care as deselecting frontends which are in fact
+	  necessary will result in DVB devices which cannot be tuned due to lack
+	  of driver support.
+
+	  If unsure say N.
+
+menu "Customise DVB Frontends"
+	visible if DVB_FE_CUSTOMISE
+
+comment "Multistandard (satellite) frontends"
+	depends on DVB_CORE
+
+config DVB_STB0899
+	tristate "STB0899 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2/DSS Multistandard demodulator. Say Y when you want
+	  to support this demodulator based frontends
+
+config DVB_STB6100
+	tristate "STB6100 based tuners"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A Silicon tuner from ST used in conjunction with the STB0899
+	  demodulator. Say Y when you want to support this tuner.
+
+config DVB_STV090x
+	tristate "STV0900/STV0903(A/B) based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  DVB-S/S2/DSS Multistandard Professional/Broadcast demodulators.
+	  Say Y when you want to support these frontends.
+
+config DVB_STV6110x
+	tristate "STV6110/(A) based tuners"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A Silicon tuner that supports DVB-S and DVB-S2 modes
+
+comment "Multistandard (cable + terrestrial) frontends"
+	depends on DVB_CORE
+
+config DVB_DRXK
+	tristate "Micronas DRXK based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Micronas DRX-K DVB-C/T demodulator.
+
+	  Say Y when you want to support this frontend.
+
+config DVB_TDA18271C2DD
+	tristate "NXP TDA18271C2 silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  NXP TDA18271 silicon tuner.
+
+	  Say Y when you want to support this tuner.
+
+config DVB_STV0367DD
+	tristate "STV 0367 (DD)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  STV 0367 DVB-C/T demodulator (Digital Devices driver).
+
+	  Say Y when you want to support this frontend.
+
+config DVB_TDA18212DD
+	tristate "NXP TDA18212 silicon tuner (DD)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  NXP TDA18212 silicon tuner (Digital Devices driver).
+
+	  Say Y when you want to support this tuner.
+
+comment "DVB-S (satellite) frontends"
+	depends on DVB_CORE
+
+config DVB_CX24110
+	tristate "Conexant CX24110 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_CX24123
+	tristate "Conexant CX24123 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_MT312
+	tristate "Zarlink VP310/MT312/ZL10313 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_ZL10036
+	tristate "Zarlink ZL10036 silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_ZL10039
+	tristate "Zarlink ZL10039 silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_S5H1420
+	tristate "Samsung S5H1420 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_STV0288
+	tristate "ST STV0288 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_STB6000
+	tristate "ST STB6000 silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	  help
+	  A DVB-S silicon tuner module. Say Y when you want to support this tuner.
+
+config DVB_STV0299
+	tristate "ST STV0299 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_STV6110
+	tristate "ST STV6110 silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	  help
+	  A DVB-S silicon tuner module. Say Y when you want to support this tuner.
+
+config DVB_STV0900
+	tristate "ST STV0900 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 demodulator. Say Y when you want to support this frontend.
+
+config DVB_TDA8083
+	tristate "Philips TDA8083 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_TDA10086
+	tristate "Philips TDA10086 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_TDA8261
+	tristate "Philips TDA8261 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_VES1X93
+	tristate "VLSI VES1893 or VES1993 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_TUNER_ITD1000
+	tristate "Integrant ITD1000 Zero IF tuner for DVB-S/DSS"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_TUNER_CX24113
+	tristate "Conexant CX24113/CX24128 tuner for DVB-S/DSS"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+
+config DVB_TDA826X
+	tristate "Philips TDA826X silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S silicon tuner module. Say Y when you want to support this tuner.
+
+config DVB_TUA6100
+	tristate "Infineon TUA6100 PLL"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S PLL chip.
+
+config DVB_CX24116
+	tristate "Conexant CX24116 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_SI21XX
+	tristate "Silicon Labs SI21XX based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_DS3000
+	tristate "Montage Tehnology DS3000 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_MB86A16
+	tristate "Fujitsu MB86A16 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S/DSS Direct Conversion reveiver.
+	  Say Y when you want to support this frontend.
+
+config DVB_TDA10071
+	tristate "NXP TDA10071"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Say Y when you want to support this frontend.
+
+comment "DVB-T (terrestrial) frontends"
+	depends on DVB_CORE
+
+config DVB_SP8870
+	tristate "Spase sp8870 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+	  This driver needs external firmware. Please use the command
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware sp8870" to
+	  download/extract it, and then copy it to /usr/lib/hotplug/firmware
+	  or /lib/firmware (depending on configuration of firmware hotplug).
+
+config DVB_SP887X
+	tristate "Spase sp887x based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+	  This driver needs external firmware. Please use the command
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware sp887x" to
+	  download/extract it, and then copy it to /usr/lib/hotplug/firmware
+	  or /lib/firmware (depending on configuration of firmware hotplug).
+
+config DVB_CX22700
+	tristate "Conexant CX22700 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_CX22702
+	tristate "Conexant cx22702 demodulator (OFDM)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_S5H1432
+	tristate "Samsung s5h1432 demodulator (OFDM)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_DRXD
+	tristate "Micronas DRXD driver"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+	  Note: this driver was based on vendor driver reference code (released
+	  under the GPL) as opposed to the existing drx397xd driver, which
+	  was written via reverse engineering.
+
+config DVB_L64781
+	tristate "LSI L64781"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_TDA1004X
+	tristate "Philips TDA10045H/TDA10046H based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+	  This driver needs external firmware. Please use the commands
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware tda10045",
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware tda10046" to
+	  download/extract them, and then copy them to /usr/lib/hotplug/firmware
+	  or /lib/firmware (depending on configuration of firmware hotplug).
+
+config DVB_NXT6000
+	tristate "NxtWave Communications NXT6000 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_MT352
+	tristate "Zarlink MT352 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_ZL10353
+	tristate "Zarlink ZL10353 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_DIB3000MB
+	tristate "DiBcom 3000M-B"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Designed for mobile usage. Say Y when you want
+	  to support this frontend.
+
+config DVB_DIB3000MC
+	tristate "DiBcom 3000P/M-C"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Designed for mobile usage. Say Y when you want
+	  to support this frontend.
+
+config DVB_DIB7000M
+	tristate "DiBcom 7000MA/MB/PA/PB/MC"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Designed for mobile usage. Say Y when you want
+	  to support this frontend.
+
+config DVB_DIB7000P
+	tristate "DiBcom 7000PC"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Designed for mobile usage. Say Y when you want
+	  to support this frontend.
+
+config DVB_DIB9000
+	tristate "DiBcom 9000"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Designed for mobile usage. Say Y when you want
+	  to support this frontend.
+
+config DVB_TDA10048
+	tristate "Philips TDA10048HN based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+config DVB_AF9013
+	tristate "Afatech AF9013 demodulator"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Say Y when you want to support this frontend.
+
+config DVB_EC100
+	tristate "E3C EC100"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Say Y when you want to support this frontend.
+
+config DVB_HD29L2
+	tristate "HDIC HD29L2"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Say Y when you want to support this frontend.
+
+config DVB_STV0367
+	tristate "ST STV0367 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T/C tuner module. Say Y when you want to support this frontend.
+
+config DVB_CXD2820R
+	tristate "Sony CXD2820R"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Say Y when you want to support this frontend.
+
+config DVB_RTL2830
+	tristate "Realtek RTL2830 DVB-T"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Say Y when you want to support this frontend.
+
+comment "DVB-C (cable) frontends"
+	depends on DVB_CORE
+
+config DVB_VES1820
+	tristate "VLSI VES1820 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-C tuner module. Say Y when you want to support this frontend.
+
+config DVB_TDA10021
+	tristate "Philips TDA10021 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-C tuner module. Say Y when you want to support this frontend.
+
+config DVB_TDA10023
+	tristate "Philips TDA10023 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-C tuner module. Say Y when you want to support this frontend.
+
+config DVB_STV0297
+	tristate "ST STV0297 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-C tuner module. Say Y when you want to support this frontend.
+
+comment "ATSC (North American/Korean Terrestrial/Cable DTV) frontends"
+	depends on DVB_CORE
+
+config DVB_NXT200X
+	tristate "NxtWave Communications NXT2002/NXT2004 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+	  This driver needs external firmware. Please use the commands
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware nxt2002" and
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware nxt2004" to
+	  download/extract them, and then copy them to /usr/lib/hotplug/firmware
+	  or /lib/firmware (depending on configuration of firmware hotplug).
+
+config DVB_OR51211
+	tristate "Oren OR51211 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB tuner module. Say Y when you want to support this frontend.
+
+	  This driver needs external firmware. Please use the command
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware or51211" to
+	  download it, and then copy it to /usr/lib/hotplug/firmware
+	  or /lib/firmware (depending on configuration of firmware hotplug).
+
+config DVB_OR51132
+	tristate "Oren OR51132 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+	  This driver needs external firmware. Please use the commands
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware or51132_vsb" and/or
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware or51132_qam" to
+	  download firmwares for 8VSB and QAM64/256, respectively. Copy them to
+	  /usr/lib/hotplug/firmware or /lib/firmware (depending on
+	  configuration of firmware hotplug).
+
+config DVB_BCM3510
+	tristate "Broadcom BCM3510"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB/16VSB and QAM64/256 tuner module. Say Y when you want to
+	  support this frontend.
+
+config DVB_LGDT330X
+	tristate "LG Electronics LGDT3302/LGDT3303 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+config DVB_LGDT3305
+	tristate "LG Electronics LGDT3304 and LGDT3305 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+config DVB_S5H1409
+	tristate "Samsung S5H1409 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+config DVB_AU8522
+	tristate "Auvitek AU8522 based"
+	depends on DVB_CORE && I2C && VIDEO_V4L2
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+config DVB_S5H1411
+	tristate "Samsung S5H1411 based"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An ATSC 8VSB and QAM64/256 tuner module. Say Y when you want
+	  to support this frontend.
+
+comment "ISDB-T (terrestrial) frontends"
+	depends on DVB_CORE
+
+config DVB_S921
+	tristate "Sharp S921 frontend"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  AN ISDB-T DQPSK, QPSK, 16QAM and 64QAM 1seg tuner module.
+	  Say Y when you want to support this frontend.
+
+config DVB_DIB8000
+	tristate "DiBcom 8000MB/MC"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A driver for DiBcom's DiB8000 ISDB-T/ISDB-Tsb demodulator.
+	  Say Y when you want to support this frontend.
+
+config DVB_MB86A20S
+	tristate "Fujitsu mb86a20s"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A driver for Fujitsu mb86a20s ISDB-T/ISDB-Tsb demodulator.
+	  Say Y when you want to support this frontend.
+
+comment "Digital terrestrial only tuners/PLL"
+	depends on DVB_CORE
+
+config DVB_PLL
+	tristate "Generic I2C PLL based tuners"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  This module drives a number of tuners based on PLL chips with a
+	  common I2C interface. Say Y when you want to support these tuners.
+
+config DVB_TUNER_DIB0070
+	tristate "DiBcom DiB0070 silicon base-band tuner"
+	depends on I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A driver for the silicon baseband tuner DiB0070 from DiBcom.
+	  This device is only used inside a SiP called together with a
+	  demodulator for now.
+
+config DVB_TUNER_DIB0090
+	tristate "DiBcom DiB0090 silicon base-band tuner"
+	depends on I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A driver for the silicon baseband tuner DiB0090 from DiBcom.
+	  This device is only used inside a SiP called together with a
+	  demodulator for now.
+
+comment "SEC control devices for DVB-S"
+	depends on DVB_CORE
+
+config DVB_LNBP21
+	tristate "LNBP21/LNBH24 SEC controllers"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An SEC control chips.
+
+config DVB_LNBP22
+	tristate "LNBP22 SEC controllers"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  LNB power supply and control voltage
+	  regulator chip with step-up converter
+	  and I2C interface.
+	  Say Y when you want to support this chip.
+
+config DVB_ISL6405
+	tristate "ISL6405 SEC controller"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An SEC control chip.
+
+config DVB_ISL6421
+	tristate "ISL6421 SEC controller"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  An SEC control chip.
+
+config DVB_ISL6423
+	tristate "ISL6423 SEC controller"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A SEC controller chip from Intersil
+
+config DVB_A8293
+	tristate "Allegro A8293"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+
+config DVB_LGS8GL5
+	tristate "Silicon Legend LGS-8GL5 demodulator (OFDM)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DMB-TH tuner module. Say Y when you want to support this frontend.
+
+config DVB_LGS8GXX
+	tristate "Legend Silicon LGS8913/LGS8GL5/LGS8GXX DMB-TH demodulator"
+	depends on DVB_CORE && I2C
+	select FW_LOADER
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DMB-TH tuner module. Say Y when you want to support this frontend.
+
+config DVB_ATBM8830
+	tristate "AltoBeam ATBM8830/8831 DMB-TH demodulator"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DMB-TH tuner module. Say Y when you want to support this frontend.
+
+config DVB_TDA665x
+	tristate "TDA665x tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  Support for tuner modules based on Philips TDA6650/TDA6651 chips.
+	  Say Y when you want to support this chip.
+
+	  Currently supported tuners:
+	  * Panasonic ENV57H12D5 (ET-50DT)
+
+config DVB_IX2505V
+	tristate "Sharp IX2505V silicon tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+config DVB_IT913X_FE
+	tristate "it913x frontend and it9137 tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-T tuner module.
+	  Say Y when you want to support this frontend.
+
+config DVB_M88RS2000
+	tristate "M88RS2000 DVB-S demodulator and tuner"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  A DVB-S tuner module.
+	  Say Y when you want to support this frontend.
+
+config DVB_AF9033
+	tristate "Afatech AF9033 DVB-T demodulator"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+
+comment "Tools to develop new frontends"
+
+config DVB_DUMMY_FE
+	tristate "Dummy frontend driver"
+	default n
+endmenu
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/Makefile media_build_experimental_tbs//linux/drivers/media/dvb/frontends/Makefile
--- media_build_experimental/linux/drivers/media/dvb/frontends/Makefile	2012-04-16 23:07:58.000000000 +0200
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/Makefile	2012-04-16 23:21:58.143661109 +0200
@@ -74,6 +74,39 @@
 obj-$(CONFIG_DVB_DUMMY_FE) += dvb_dummy_fe.o
 obj-$(CONFIG_DVB_AF9013) += af9013.o
 obj-$(CONFIG_DVB_CX24116) += cx24116.o
+obj-$(CONFIG_DVB_TBSFE) += tbsfe.o
+obj-$(CONFIG_DVB_TBS6980FE) += tbs6980fe.o
+tbs6980fe-objs += kmem_wrap.o tbs6980fe_driver.o
+obj-$(CONFIG_DVB_TBS6981FE) += tbs6981fe.o
+tbs6981fe-objs += kmem_wrap.o tbs6981fe_driver.o
+obj-$(CONFIG_DVB_TBS6921FE) += tbs6921fe.o
+tbs6921fe-objs += kmem_wrap.o tbs6921fe_driver.o
+obj-$(CONFIG_DVB_TBS8921FE) += tbs8921fe.o
+tbs8921fe-objs += kmem_wrap.o tbs8921fe_driver.o
+obj-$(CONFIG_DVB_TBS6925CTRL) += tbs6925ctrl.o
+tbs6925ctrl-objs += kmem_wrap.o tbs6925ctrl_driver.o
+obj-$(CONFIG_DVB_TBS6992) += tbs6992.o
+tbs6992-objs += kmem_wrap.o tbs6992_driver.o
+obj-$(CONFIG_DVB_TBS5921FE) += tbs5921fe.o
+tbs5921fe-objs += kmem_wrap.o tbs5921fe_driver.o
+obj-$(CONFIG_DVB_TBS62X0FE) += tbs62x0fe.o
+tbs62x0fe-objs += kmem_wrap.o tbs62x0fe_driver.o
+obj-$(CONFIG_DVB_TBS6984FE) += tbs6984fe.o
+tbs6984fe-objs += kmem_wrap.o tbs6984fe_driver.o
+obj-$(CONFIG_DVB_TBS6922FE) += tbs6922fe.o
+tbs6922fe-objs += kmem_wrap.o tbs6922fe_driver.o
+obj-$(CONFIG_DVB_TBS6928FE) += tbs6928fe.o
+tbs6928fe-objs += kmem_wrap.o tbs6928fe_driver.o
+obj-$(CONFIG_DVB_TBS8922FE) += tbs8922fe.o
+tbs8922fe-objs += kmem_wrap.o tbs8922fe_driver.o
+obj-$(CONFIG_DVB_TBS5922FE) += tbs5922fe.o
+tbs5922fe-objs += kmem_wrap.o tbs5922fe_driver.o
+obj-$(CONFIG_DVB_TBS5880FE) += tbs5880fe.o
+tbs5880fe-objs += kmem_wrap.o tbs5880fe_driver.o
+obj-$(CONFIG_DVB_TBS6982FE) += tbs6982fe.o
+tbs6982fe-objs += kmem_wrap.o tbs6982fe_driver.o
+obj-$(CONFIG_DVB_TBS6991FE) += tbs6991fe.o
+tbs6991fe-objs += kmem_wrap.o tbs6991fe_driver.o
 obj-$(CONFIG_DVB_SI21XX) += si21xx.o
 obj-$(CONFIG_DVB_STV0288) += stv0288.o
 obj-$(CONFIG_DVB_STB6000) += stb6000.o
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs5880fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs5880fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs5880fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs5880fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,35 @@
+/*
+    TurboSight TBS 5880 DVBT/T2/C frontend driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS5880FE_H
+#define TBS5880FE_H
+
+#include <linux/dvb/frontend.h>
+#include "dvb-usb.h"
+
+struct tbs5880fe_config {
+	u8 tbs5880fe_address;
+
+	int (*tbs5880_ctrl)(struct usb_device *dev, u8 *a);
+};
+
+#if defined(CONFIG_DVB_TBS5880FE) || \
+	(defined(CONFIG_DVB_TBS5880FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs5880fe_attach(
+	const struct tbs5880fe_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs5880fe_attach(
+	const struct tbs5880fe_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS5880FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs5921fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs5921fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs5921fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs5921fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,35 @@
+/*
+    TurboSight TBS 5921 DVBS/S2 frontend driver
+    Copyright (C) 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2010 TurboSight.com
+*/
+
+#ifndef TBS5921FE_H
+#define TBS5921FE_H
+
+#include <linux/dvb/frontend.h>
+#include "dvb-usb.h"
+
+struct tbs5921fe_config {
+	u8 tbs5921fe_address;
+
+	int (*tbs5921_ctrl)(struct usb_device *dev, u8 *a);
+};
+
+#if defined(CONFIG_DVB_TBS5921FE) || \
+	(defined(CONFIG_DVB_TBS5921FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs5921fe_attach(
+	const struct tbs5921fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs5921fe_attach(
+	const struct tbs5921fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS5921FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs5922fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs5922fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs5922fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs5922fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,35 @@
+/*
+    TurboSight TBS 5922 DVBS/S2 frontend driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS5922FE_H
+#define TBS5922FE_H
+
+#include <linux/dvb/frontend.h>
+#include "dvb-usb.h"
+
+struct tbs5922fe_config {
+	u8 tbs5922fe_address;
+
+	int (*tbs5922_ctrl)(struct usb_device *dev, u8 *a);
+};
+
+#if defined(CONFIG_DVB_TBS5922FE) || \
+	(defined(CONFIG_DVB_TBS5922FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs5922fe_attach(
+	const struct tbs5922fe_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs5922fe_attach(
+	const struct tbs5922fe_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS5922FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs62x0fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs62x0fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs62x0fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs62x0fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 62x0 DVBT/T2/C frontend driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS62X0FE_H
+#define TBS62X0FE_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs62x0fe_config {
+	u8 tbs62x0fe_address;
+
+	int (*tbs62x0_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs62x0_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS62X0FE) || \
+	(defined(CONFIG_DVB_TBS62X0FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs62x0fe_attach(
+	const struct tbs62x0fe_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs62x0fe_attach(
+	const struct tbs62x0fe_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS62X0FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6921fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6921fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6921fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6921fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6921 DVBS/S2 frontend driver
+    Copyright (C) 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2010 TurboSight.com
+*/
+
+#ifndef TBS6921FE_H
+#define TBS6921FE_H
+
+#include <linux/dvb/frontend.h>
+#include "cx23885.h"
+
+struct tbs6921fe_config {
+	u8 tbs6921fe_address;
+
+	int (*tbs6921_ctrl1)(struct cx23885_dev *dev, int a);
+	int (*tbs6921_ctrl2)(struct cx23885_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6921FE) || \
+	(defined(CONFIG_DVB_TBS6921FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6921fe_attach(
+	const struct tbs6921fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs6921fe_attach(
+	const struct tbs6921fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6921FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6922fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6922fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6922fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6922fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6922 DVBS/S2 Satellite Demodulator/Tuner driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS6922FE_H
+#define TBS6922FE_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6922fe_config {
+	u8 tbs6922fe_address;
+	
+	int (*tbs6922_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6922_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6922FE) || \
+	(defined(CONFIG_DVB_TBS6922FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6922fe_attach(
+	const struct tbs6922fe_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs6922fe_attach(
+	const struct tbs6922fe_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6922FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6925ctrl.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6925ctrl.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6925ctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6925ctrl.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,42 @@
+/*
+    TurboSight TBS 6925 DVBS/S2 controls
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS6925CTRL_H
+#define TBS6925CTRL_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6925ctrl_config {
+	u8 tbs6925ctrl_address;
+
+	int (*tbs6925_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6925_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6925CTRL) || \
+	(defined(CONFIG_DVB_TBS6925CTRL_MODULE) && defined(MODULE))
+
+
+extern struct dvb_frontend *tbs6925ctrl_attach(
+	struct dvb_frontend *fe,
+	struct i2c_adapter *i2c,
+	const struct tbs6925ctrl_config *config);
+
+#else
+static inline struct dvb_frontend *tbs6925ctrl_attach(
+	struct dvb_frontend *fe,
+	struct i2c_adapter *i2c,
+	const struct tbs6925ctrl_config *config)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_TBS6925CTRL */
+
+#endif /* TBS6925CTRL_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6928fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6928fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6928fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6928fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6928 DVBS/S2 Satellite Demodulator/Tuner driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS6928FE_H
+#define TBS6928FE_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6928fe_config {
+	u8 tbs6928fe_address;
+	
+	int (*tbs6928_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6928_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6928FE) || \
+	(defined(CONFIG_DVB_TBS6928FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6928fe_attach(
+	const struct tbs6928fe_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs6928fe_attach(
+	const struct tbs6928fe_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6928FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6980fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6980fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6980fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6980fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6980 Dual DVBS/S2 frontend driver
+    Copyright (C) 2009 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2009 TurboSight.com
+*/
+
+#ifndef TBS6980FE_H
+#define TBS6980FE_H
+
+#include <linux/dvb/frontend.h>
+#include "cx23885.h"
+
+struct tbs6980fe_config {
+	u8 tbs6980fe_address;
+
+	int (*tbs6980_ctrl1)(struct cx23885_dev *dev, int a);
+	int (*tbs6980_ctrl2)(struct cx23885_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6980FE) || \
+	(defined(CONFIG_DVB_TBS6980FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6980fe_attach(
+	const struct tbs6980fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs6980fe_attach(
+	const struct tbs6980fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6980FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6981fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6981fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6981fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6981fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6981 Dual DVBS/S2 frontend driver
+    Copyright (C) 2009 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2009 TurboSight.com
+*/
+
+#ifndef TBS6981FE_H
+#define TBS6981FE_H
+
+#include <linux/dvb/frontend.h>
+#include "cx23885.h"
+
+struct tbs6981fe_config {
+	u8 tbs6981fe_address;
+
+	int (*tbs6981_ctrl1)(struct cx23885_dev *dev, int a);
+	int (*tbs6981_ctrl2)(struct cx23885_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6981FE) || \
+	(defined(CONFIG_DVB_TBS6981FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6981fe_attach(
+	const struct tbs6981fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs6981fe_attach(
+	const struct tbs6981fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6981FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6982fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6982fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6982fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6982fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6982 DVBS/S2 Satellite Demodulator/Tuner driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS6982FE_H
+#define TBS6982FE_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6982fe_config {
+	u8 tbs6982fe_address;
+	
+	int (*tbs6982_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6982_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6982FE) || \
+	(defined(CONFIG_DVB_TBS6982FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6982fe_attach(
+	const struct tbs6982fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs6982fe_attach(
+	const struct tbs6982fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6982FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6984fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6984fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6984fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6984fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6984 Dual DVBS/S2 frontend driver
+    Copyright (C) 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2010 TurboSight.com
+*/
+
+#ifndef TBS6984FE_H
+#define TBS6984FE_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6984fe_config {
+	u8 tbs6984fe_address;
+
+	int (*tbs6984_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6984_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6984FE) || \
+	(defined(CONFIG_DVB_TBS6984FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6984fe_attach(
+	const struct tbs6984fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs6984fe_attach(
+	const struct tbs6984fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6984FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6991fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6991fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6991fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6991fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 6991 DVBS/S2 Satellite Demodulator/Tuner driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS6991FE_H
+#define TBS6991FE_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6991fe_config {
+	u8 tbs6991fe_address;
+	
+	int (*tbs6991_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6991_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS6991FE) || \
+	(defined(CONFIG_DVB_TBS6991FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs6991fe_attach(
+	const struct tbs6991fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs6991fe_attach(
+	const struct tbs6991fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6991FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6992_cfg.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6992_cfg.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6992_cfg.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6992_cfg.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,21 @@
+
+static int tbs6992_set_frequency(struct dvb_frontend *fe, u32 frequency)
+{
+	struct dvb_frontend_ops	*frontend_ops = NULL;
+	struct dvb_tuner_ops *tuner_ops = NULL;
+	struct tuner_state t_state;
+	int ret = 0;
+
+	t_state.frequency = frequency;
+	if (&fe->ops)
+		frontend_ops = &fe->ops;
+	if (&frontend_ops->tuner_ops)
+		tuner_ops = &frontend_ops->tuner_ops;
+	if (tuner_ops->set_state) {
+		if ((ret = tuner_ops->set_state(fe, DVBFE_TUNER_FREQUENCY, &t_state)) < 0) {
+			printk("%s: Invalid parameter\n", __func__);
+			return ret;
+		}
+	}
+	return 0;
+}
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs6992.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6992.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs6992.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs6992.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,46 @@
+/*
+	TurboSight TBS 6992 Silicon Tuner driver
+    	Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    	Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS6992_H
+#define TBS6992_H
+
+#include <linux/dvb/frontend.h>
+#include "saa716x_priv.h"
+
+struct tbs6992_config {
+	u8 tbs6992_address;
+	
+	int (*tbs6992_ctrl1)(struct saa716x_dev *dev, int a);
+	int (*tbs6992_ctrl2)(struct saa716x_dev *dev, int a, int b);
+};
+
+struct tbs6992_state {
+	struct i2c_adapter *i2c;
+	const struct tbs6992_config *config;
+	struct dvb_frontend *frontend;
+	int status;
+};
+
+#if defined(CONFIG_DVB_TBS6992) || \
+	(defined(CONFIG_DVB_TBS6992_MODULE) && defined(MODULE))
+
+extern struct dvb_frontend *tbs6992_attach(
+	struct dvb_frontend *fe,
+	const struct tbs6992_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs6992_attach(
+	struct dvb_frontend *fe,
+	const struct tbs6992_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS6992_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs8921fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs8921fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs8921fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs8921fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 8921 DVBS/S2 frontend driver
+    Copyright (C) 2010 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2010 TurboSight.com
+*/
+
+#ifndef TBS8921FE_H
+#define TBS8921FE_H
+
+#include <linux/dvb/frontend.h>
+#include "cx88.h"
+
+struct tbs8921fe_config {
+	u8 tbs8921fe_address;
+
+	int (*tbs8921_ctrl1)(struct cx88_core *core, int a);
+	int (*tbs8921_ctrl2)(struct cx88_core *core, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS8921FE) || \
+	(defined(CONFIG_DVB_TBS8921FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs8921fe_attach(
+	const struct tbs8921fe_config *config,
+	struct i2c_adapter *i2c, int demod);
+#else
+static inline struct dvb_frontend *tbs8921fe_attach(
+	const struct tbs8921fe_config *config,
+	struct i2c_adapter *i2c, int demod)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS8921FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbs8922fe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs8922fe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbs8922fe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbs8922fe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,36 @@
+/*
+    TurboSight TBS 8922 DVBS/S2 Satellite Demodulator/Tuner driver
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBS8922FE_H
+#define TBS8922FE_H
+
+#include <linux/dvb/frontend.h>
+#include "cx88.h"
+
+struct tbs8922fe_config {
+	u8 tbs8922fe_address;
+
+	int (*tbs8922_ctrl1)(struct cx88_core *core, int a);
+	int (*tbs8922_ctrl2)(struct cx88_core *core, int a, int b);
+};
+
+#if defined(CONFIG_DVB_TBS8922FE) || \
+	(defined(CONFIG_DVB_TBS8922FE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbs8922fe_attach(
+	const struct tbs8922fe_config *config,
+	struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *tbs8922fe_attach(
+	const struct tbs8922fe_config *config,
+	struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif /* TBS8922FE_H */
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbsfe.c media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbsfe.c
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbsfe.c	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbsfe.c	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,55 @@
+/*
+    TurboSight TBS FE module
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#include "dvb_frontend.h"
+#include "tbsfe.h"
+
+/* phase poise enhancements */
+static int pne;
+module_param(pne, int, 0644);
+MODULE_PARM_DESC(pne, "Phase noise enhancements 0:Off, "\
+	"1:On (default:0)");
+
+/* define how SNR measurement is reported */
+static int esno;
+module_param(esno, int, 0644);
+MODULE_PARM_DESC(esno, "SNR is reported in 0:Percentage, "\
+	"1:(EsNo dB)*10 (default:0)");
+
+/* define how signal measurement is reported */
+static int dbm;
+module_param(dbm, int, 0644);
+MODULE_PARM_DESC(dbm, "Signal is reported in 0:Percentage, "\
+	"1:-1*dBm (default:0)");
+
+/* define how outer code correction is performed */
+static int occ = 1;
+module_param(occ, int, 0644);
+MODULE_PARM_DESC(occ, "0:outer code correction is disabled, "\
+	"1: outer code correction is enabled(default:1)");
+
+static int tbsfe_params(struct dvb_frontend *fe, long arg)
+{
+	return (occ << 3) | (pne << 2) | (esno << 1) | dbm;
+}
+
+static void tbsfe_release(struct dvb_frontend *fe)
+{
+}
+
+struct dvb_frontend *tbsfe_attach(struct dvb_frontend *fe)
+{
+	fe->ops.release_sec = tbsfe_release;
+	fe->ops.enable_high_lnb_voltage = tbsfe_params;
+
+	return fe;
+}
+EXPORT_SYMBOL(tbsfe_attach);
+
+MODULE_DESCRIPTION("TurboSight TBS FE module");
+MODULE_AUTHOR("Konstantin Dimitrov <kosio.dimitrov@gmail.com>");
+MODULE_LICENSE("GPL");
diff -urN media_build_experimental/linux/drivers/media/dvb/frontends/tbsfe.h media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbsfe.h
--- media_build_experimental/linux/drivers/media/dvb/frontends/tbsfe.h	1970-01-01 01:00:00.000000000 +0100
+++ media_build_experimental_tbs//linux/drivers/media/dvb/frontends/tbsfe.h	2012-04-16 23:21:58.143661109 +0200
@@ -0,0 +1,27 @@
+/*
+    TurboSight TBS FE module
+    Copyright (C) 2011 Konstantin Dimitrov <kosio.dimitrov@gmail.com>
+
+    Copyright (C) 2011 TurboSight.com
+*/
+
+#ifndef TBSFE_H
+#define TBSFE_H
+
+#include <linux/dvb/frontend.h>
+
+#if defined(CONFIG_DVB_TBSFE) || \
+	(defined(CONFIG_DVB_TBSFE_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tbsfe_attach(
+	struct dvb_frontend *fe);
+#else
+static inline struct dvb_frontend *tbsfe_attach(
+	struct dvb_frontend *fe)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_TBSFE */
+
+#endif /* TBSFE_H */
